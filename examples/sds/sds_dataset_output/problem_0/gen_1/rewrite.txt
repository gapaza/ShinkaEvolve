#!/usr/bin/env python3
"""
EVOLVE-BLOCK-START
New SDS solver using precedence-aware local search with transitive closure,
group/mutex-aware feasibility checks, and swap/add/remove neighborhood moves.
EVOLVE-BLOCK-END
"""
import sys
import json
import random
import contextlib

# EVOLVE-BLOCK-START
def solve_sds():
    # Read input
    input_data = json.load(sys.stdin)
    requirements = input_data.get("requirements", {})
    # catalog unused in current objective but accepted for compatibility
    catalog = input_data.get("catalog", {})

    # Parse items
    weights = list(requirements.get("weights", []))
    n = len(weights)
    # cardinality bounds: [min, max]
    card_bounds = requirements.get("cardinality_bounds", [0, n])
    min_card, max_card = card_bounds[0], card_bounds[1]

    # Parse interactions: keys like "i,j"
    raw_inter = requirements.get("interactions", {})
    interactions = {}
    for k, v in raw_inter.items():
        try:
            a_str, b_str = k.split(",")
            a = int(a_str.strip()); b = int(b_str.strip())
            if 0 <= a < n and 0 <= b < n:
                interactions[(a,b)] = float(v)
                interactions[(b,a)] = float(v)
        except Exception:
            # ignore malformed keys
            continue

    # Mutex pairs
    raw_mutex = requirements.get("mutex", [])
    mutex_pairs = set()
    for pair in raw_mutex:
        try:
            a, b = pair
            a = int(a); b = int(b)
            if 0 <= a < n and 0 <= b < n and a != b:
                mutex_pairs.add((min(a,b), max(a,b)))
        except Exception:
            continue

    # Groups: dict group_name -> list of indices OR list of lists may be given
    raw_groups = requirements.get("groups", {})
    groups = []
    if isinstance(raw_groups, dict):
        for grp in raw_groups.values():
            try:
                gl = [int(x) for x in grp]
                groups.append(set([x for x in gl if 0 <= x < n]))
            except Exception:
                continue
    elif isinstance(raw_groups, list):
        for grp in raw_groups:
            try:
                gl = [int(x) for x in grp]
                groups.append(set([x for x in gl if 0 <= x < n]))
            except Exception:
                continue

    # Precedence: list of (i,j) meaning if j selected then i must be selected.
    raw_prec = requirements.get("precedence", [])
    requires = {i: set() for i in range(n)}  # immediate requires: j -> set of i
    dependents = {i: set() for i in range(n)}  # immediate dependents: i -> set of j
    for pair in raw_prec:
        try:
            a, b = pair
            a = int(a); b = int(b)
            if 0 <= a < n and 0 <= b < n:
                requires[b].add(a)
                dependents[a].add(b)
        except Exception:
            continue

    # Compute transitive closures: ancestors (all requires) and descendants (all dependents)
    ancestors = [set() for _ in range(n)]
    descendants = [set() for _ in range(n)]

    # DFS to compute ancestors
    def compute_ancestors():
        for v in range(n):
            seen = set()
            stack = list(requires[v])
            while stack:
                u = stack.pop()
                if u in seen:
                    continue
                seen.add(u)
                for w in requires[u]:
                    if w not in seen:
                        stack.append(w)
            ancestors[v] = seen

    # DFS to compute descendants
    def compute_descendants():
        for v in range(n):
            seen = set()
            stack = list(dependents[v])
            while stack:
                u = stack.pop()
                if u in seen:
                    continue
                seen.add(u)
                for w in dependents[u]:
                    if w not in seen:
                        stack.append(w)
            descendants[v] = seen

    compute_ancestors()
    compute_descendants()

    # Utility: compute score of a set S (iterable of ints)
    def score_of_set(S):
        S_list = sorted(S)
        s = 0.0
        for i in S_list:
            s += weights[i] if i < len(weights) else 0.0
        # interactions counted once per unordered pair
        visited = set()
        for i in S_list:
            for j in S_list:
                if j <= i:
                    continue
                if (i,j) in interactions:
                    s += interactions[(i,j)]
        return s

    # Feasibility checks when trying to add a set 'add_set' to current S
    def feasible_union(S, add_set):
        # union size check
        new_size = len(S | add_set)
        if new_size > max_card:
            return False
        # Mutex: cannot have conflicting pairs within union
        # Check each mutex pair intersects union with both sides
        for a,b in mutex_pairs:
            if a in (S | add_set) and b in (S | add_set):
                return False
        # Groups: at most one per group
        for grp in groups:
            cnt = 0
            # if group contains many of add_set or existing selected
            # faster: check intersection size
            if len((S | add_set) & grp) > 1:
                return False
        return True

    # When adding item i, must also add its ancestors; return add_set or None if infeasible
    def compute_add_closure(i, S):
        # closure = ancestors[i] U {i}
        add_set = set(ancestors[i])
        add_set.add(i)
        # If any of the add_set is already excluded by group conflict with S?
        # Use feasible_union to check feasibility
        # But need to also ensure add_set doesn't internally violate group/mutex
        if not feasible_union(S, add_set):
            return None
        return add_set

    # When removing item i, must remove its descendants as well
    def compute_remove_closure(i, S):
        rem_set = set(descendants[i])
        rem_set.add(i)
        # ensure rem_set is subset of S
        rem_set = rem_set & set(S)
        return rem_set

    # Build initial solution using synergy-aware greedy
    def initial_greedy_solution(seed=None):
        if seed is not None:
            random.seed(seed)
        # compute base synergy potential for each item
        potentials = []
        for i in range(n):
            pot = weights[i] if i < len(weights) else 0.0
            # positive interactions potential with others
            for j in range(n):
                if j == i:
                    continue
                v = interactions.get((i,j), 0.0)
                if v > 0:
                    pot += 0.5 * v
            potentials.append((pot, i))
        # sort descending, but add slight random tie-breaker to diversify restarts
        random.shuffle(potentials)
        potentials.sort(key=lambda x: x[0], reverse=True)

        S = set()
        for _, i in potentials:
            if len(S) >= max_card:
                break
            add_closure = compute_add_closure(i, S)
            if add_closure is None:
                continue
            # If adding would not change S (all ancestors already present) still ok
            # But ensure after adding, we still satisfy min constraints possibly later
            S = S | add_closure
        # If below min, try to add feasible items by best marginal gain
        if len(S) < min_card:
            candidates = [i for i in range(n) if i not in S]
            # sort by marginal score heuristic
            def marginal_gain(i):
                add_closure = compute_add_closure(i, S)
                if add_closure is None:
                    return -1e9
                newS = S | add_closure
                return score_of_set(newS) - score_of_set(S)
            candidates.sort(key=lambda i: marginal_gain(i), reverse=True)
            for i in candidates:
                if len(S) >= min_card:
                    break
                add_closure = compute_add_closure(i, S)
                if add_closure is None:
                    continue
                S |= add_closure
        # Trim if somehow exceeded max (shouldn't happen due to feasibility checks)
        if len(S) > max_card:
            # remove lowest weight leaves until within bound (remove items with no dependents first)
            # simple greedy prune
            removable = [i for i in S if len(descendants[i] & S) == 0]
            removable.sort(key=lambda x: weights[x])
            while len(S) > max_card and removable:
                r = removable.pop(0)
                S.remove(r)
                # update removable
                removable = [i for i in S if len(descendants[i] & S) == 0]
                removable.sort(key=lambda x: weights[x])
        return S

    # Local search: try add, remove, and swap moves greedily until no improvement
    def local_search(initial_S, max_iters=200):
        S = set(initial_S)
        best_S = set(S)
        best_score = score_of_set(S)
        improved = True
        iters = 0
        while improved and iters < max_iters:
            iters += 1
            improved = False
            current_score = score_of_set(S)
            # 1) Try best add move (first-improvement)
            best_move = None
            best_move_score = current_score
            # consider items not in S
            for j in range(n):
                if j in S:
                    continue
                add_closure = compute_add_closure(j, S)
                if add_closure is None:
                    continue
                newS = S | add_closure
                # newS might include items that create new ancestors -- but closure already included
                sc = score_of_set(newS)
                if sc > best_move_score + 1e-9:
                    best_move_score = sc
                    best_move = ("add", j, add_closure)
                    break  # first improvement
            if best_move is not None:
                # apply
                S |= best_move[2]
                improved = True
                if best_move_score > best_score + 1e-9:
                    best_score = best_move_score
                    best_S = set(S)
                continue

            # 2) Try best swap moves: remove i (and its descendants) then add j's closure if feasible
            # We'll do a limited number of candidate swaps for efficiency
            # Build candidate lists sorted by weight to focus on promising swaps
            current_items = sorted(list(S), key=lambda x: weights[x])
            non_items = sorted([x for x in range(n) if x not in S], key=lambda x: -weights[x])
            swap_found = False
            for i in current_items:
                rem_closure = compute_remove_closure(i, S)
                S_after_rem = S - rem_closure
                # if removing would drop below min and we won't be able to add enough, skip unless swap recovers
                for j in non_items:
                    # try add j to S_after_rem
                    add_closure = compute_add_closure(j, S_after_rem)
                    if add_closure is None:
                        continue
                    newS = S_after_rem | add_closure
                    if len(newS) < min_card or len(newS) > max_card:
                        continue
                    sc = score_of_set(newS)
                    if sc > best_score + 1e-9:
                        S = newS
                        best_score = sc
                        best_S = set(S)
                        improved = True
                        swap_found = True
                        break
                    if sc > current_score + 1e-9:
                        S = newS
                        improved = True
                        swap_found = True
                        break
                if swap_found:
                    break
            if swap_found:
                continue

            # 3) Try remove moves (allow only if still >= min_card)
            for i in list(S):
                rem_closure = compute_remove_closure(i, S)
                newS = S - rem_closure
                if len(newS) < min_card:
                    continue
                # Ensure removing doesn't violate any constraints (it shouldn't)
                sc = score_of_set(newS)
                if sc > best_score + 1e-9:
                    S = newS
                    best_score = sc
                    best_S = set(S)
                    improved = True
                    break
                if sc > current_score + 1e-9:
                    S = newS
                    improved = True
                    break

        return best_S, best_score

    # Multi-start local search
    best_overall = None
    best_overall_score = -1e18
    restarts = 5
    # Use deterministic seed for reproducibility (unless randomness desired)
    base_seed = 12345
    for r in range(restarts):
        seed = base_seed + r
        init = initial_greedy_solution(seed=seed)
        # If init violates min_card (<), try to add best marginal items
        if len(init) < min_card:
            # force-augment
            candidates = [i for i in range(n) if i not in init]
            while len(init) < min_card and candidates:
                best_j = None; best_gain = -1e18
                cur_score = score_of_set(init)
                for j in candidates:
                    add_cl = compute_add_closure(j, init)
                    if add_cl is None:
                        continue
                    sc = score_of_set(init | add_cl) - cur_score
                    if sc > best_gain:
                        best_gain = sc; best_j = j
                if best_j is None:
                    break
                addc = compute_add_closure(best_j, init)
                if addc is None:
                    break
                init |= addc
                candidates = [i for i in range(n) if i not in init]
        # Ensure feasibility w.r.t groups/mutex and max_card
        if len(init) > max_card:
            # try pruning low contribution leaves
            items = list(init)
            items.sort(key=lambda x: weights[x])
            for it in items:
                if len(init) <= max_card:
                    break
                rem = compute_remove_closure(it, init)
                init = init - rem

        # Run local search
        bestS, best_score = local_search(init, max_iters=300)
        if best_score > best_overall_score + 1e-9:
            best_overall_score = best_score
            best_overall = bestS

    # Final safety: ensure precedence closure and constraints satisfied for best_overall
    if best_overall is None:
        best_overall = set()
    # close under precedence (should already be)
    closure_changed = True
    while closure_changed:
        closure_changed = False
        to_add = set()
        for v in list(best_overall):
            for a in ancestors[v]:
                if a not in best_overall:
                    to_add.add(a)
        if to_add:
            if feasible_union(best_overall, to_add):
                best_overall |= to_add
                closure_changed = True
            else:
                # cannot close; remove problematic items (those that require impossible ancestors)
                # remove any item that has ancestors not feasible
                removable = set()
                for v in list(best_overall):
                    need = set(ancestors[v]) | {v}
                    if not feasible_union(best_overall - {v}, need - {v}):
                        removable.add(v)
                if not removable:
                    # if nothing to remove, break to avoid infinite loop
                    break
                for r in removable:
                    rem_cl = compute_remove_closure(r, best_overall)
                    best_overall -= rem_cl
                    closure_changed = True

    # Enforce min_card by adding best marginal items if possible
    S = set(best_overall)
    if len(S) < min_card:
        candidates = [i for i in range(n) if i not in S]
        while len(S) < min_card and candidates:
            best_j = None; best_gain = -1e18
            cur_score = score_of_set(S)
            for j in candidates:
                add_cl = compute_add_closure(j, S)
                if add_cl is None:
                    continue
                sc = score_of_set(S | add_cl) - cur_score
                if sc > best_gain:
                    best_gain = sc; best_j = j
            if best_j is None:
                break
            addc = compute_add_closure(best_j, S)
            if addc is None:
                break
            S |= addc
            candidates = [i for i in range(n) if i not in S]

    # Final trimming if > max_card (as last resort)
    if len(S) > max_card:
        # remove low weight leaves until within bound
        leaves = [i for i in S if len(descendants[i] & S) == 0]
        leaves.sort(key=lambda x: (weights[x], x))
        while len(S) > max_card and leaves:
            r = leaves.pop(0)
            rem = compute_remove_closure(r, S)
            S -= rem
            leaves = [i for i in S if len(descendants[i] & S) == 0]
            leaves.sort(key=lambda x: (weights[x], x))

    result = {"selection": {"variables": sorted(list(S))}}
    print(json.dumps(result))

# EVOLVE-BLOCK-END

# This part remains fixed (not evolved)
def run_sds(problem_data=None):
    """
    Main function called by the evaluator.
    Can accept problem_data as parameter or read from stdin.
    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).
    """
    import sys
    import json
    import io

    if problem_data is None:
        # Read from stdin (for compatibility)
        input_data = json.load(sys.stdin)
    else:
        # Use provided problem data
        input_data = problem_data

    # Capture stdout from solve_sds
    stdout_capture = io.StringIO()
    old_stdin = sys.stdin

    try:
        # Create mock stdin
        sys.stdin = io.StringIO(json.dumps(input_data))
        with contextlib.redirect_stdout(stdout_capture):
            solve_sds()
    finally:
        sys.stdin = old_stdin

    result_str = stdout_capture.getvalue()
    return result_str


if __name__ == "__main__":
    solve_sds()