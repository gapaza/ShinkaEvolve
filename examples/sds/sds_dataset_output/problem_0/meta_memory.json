{
  "unprocessed_programs": [
    {
      "id": "639d15e8-d1f9-4fa7-b731-6db3bcbdb880",
      "code": "\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    This is a greedy baseline - evolution will improve this.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    # Simple greedy: select items with highest weights first\n    # This is a baseline - evolution will find better strategies\n    n = len(weights)\n    selected = []\n    \n    # Create score list (weight + interaction potential)\n    scores = []\n    for i in range(n):\n        score = weights[i] if i < len(weights) else 0.0\n        # Add potential interaction value\n        for k, v in interactions.items():\n            try:\n                u, w = map(int, k.split(\",\"))\n                if u == i or w == i:\n                    score += abs(v) * 0.5  # Potential value\n            except:\n                pass\n        scores.append((score, i))\n    \n    # Sort by score descending\n    scores.sort(reverse=True)\n    \n    # Greedy selection respecting constraints\n    selected_set = set()\n    for score, i in scores:\n        if len(selected_set) >= cardinality_bounds[1]:\n            break\n            \n        # Check mutex constraints\n        can_add = True\n        for a, b in mutex:\n            if (a == i and b in selected_set) or (b == i and a in selected_set):\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n            \n        # Check group constraints (at most one per group)\n        for grp_vars in groups.values():\n            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n        \n        # Check precedence (if j selected, i must be selected)\n        precedence_ok = True\n        for pred_i, pred_j in precedence:\n            if pred_j == i and pred_i not in selected_set:\n                precedence_ok = False\n                break\n        \n        if not precedence_ok:\n            continue\n        \n        # Add if we meet minimum cardinality or have room\n        if len(selected_set) < cardinality_bounds[1]:\n            selected_set.add(i)\n            selected.append(i)\n    \n    # Ensure minimum cardinality\n    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n        for i in range(n):\n            if i not in selected_set:\n                selected_set.add(i)\n                selected.append(i)\n                break\n    \n    # Output result\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n    \n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n    \n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n    \n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n    \n    result_str = stdout_capture.getvalue()\n    return result_str\n\n",
      "language": "python",
      "parent_id": null,
      "archive_inspiration_ids": [],
      "top_k_inspiration_ids": [],
      "island_idx": 0,
      "generation": 0,
      "timestamp": 1764667783.801555,
      "code_diff": null,
      "combined_score": 0.3470686777681244,
      "public_metrics": {
        "feasible": true,
        "selection_size": 10,
        "raw_score": 106.5063848215821
      },
      "private_metrics": {
        "selection": [
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          14
        ],
        "raw_score": 106.5063848215821,
        "normalized_fitness": 0.3470686777681244
      },
      "text_feedback": "",
      "correct": true,
      "children_count": 0,
      "complexity": 1.0,
      "embedding": [
        0.025548656,
        -0.00076658087,
        0.021985417,
        -0.030396597,
        0.001218803,
        0.018749416,
        0.03432343,
        0.014192351,
        -0.03514758,
        0.016349684,
        0.027802948,
        -0.06122951,
        -0.023354962,
        0.010774552,
        6.902636e-05,
        -0.03265089,
        0.03832298,
        0.013925714,
        -0.006005388,
        -0.0033147805,
        0.038880497,
        0.037304915,
        0.04435867,
        0.041352946,
        0.0134166805,
        -0.0038268443,
        0.041207507,
        0.08842646,
        0.020894632,
        -0.03749883,
        0.011410844,
        -0.016337566,
        -0.04096511,
        -0.0017331394,
        -0.003532938,
        0.028021106,
        0.0034965784,
        0.029863324,
        -0.050127722,
        -0.016252726,
        -0.010562454,
        -0.029014934,
        -0.02503962,
        0.015646733,
        -0.0043116384,
        -0.014834703,
        0.0045540356,
        -0.016192127,
        0.029063413,
        -0.026348567,
        -0.043219406,
        0.017210195,
        0.029645167,
        -0.022567172,
        -0.013319721,
        -0.03684436,
        0.013877234,
        0.024651786,
        -0.007932445,
        -0.0058751,
        0.03665044,
        -0.057738993,
        0.027221195,
        0.04455259,
        0.00839906,
        0.014374149,
        0.018773656,
        0.010023121,
        -0.03694132,
        -0.025645614,
        -0.02695456,
        -0.0043904176,
        0.0026633383,
        -0.019609926,
        0.0030057242,
        0.02443363,
        0.0076961084,
        0.03526878,
        0.0025845591,
        -0.04111055,
        -0.05361824,
        -0.019585686,
        -0.013901474,
        -0.031487383,
        -0.06908318,
        -0.059096415,
        0.0052842572,
        0.01592549,
        -0.029669406,
        -0.055605896,
        -0.018628217,
        -0.0067507597,
        -0.07979713,
        0.020761313,
        0.008665697,
        -0.04685536,
        0.03694132,
        -0.033887114,
        0.013513639,
        -0.016167887,
        -0.013610598,
        -0.023670077,
        0.008865674,
        -0.009350468,
        -0.012883406,
        0.010168559,
        0.02695456,
        0.031196509,
        0.013671197,
        -0.011392664,
        -0.040771194,
        0.020276519,
        0.015380097,
        0.05958121,
        0.03102683,
        -0.04355876,
        -0.07596725,
        -0.026590964,
        -0.0035086982,
        -0.009726184,
        -0.020421956,
        -0.0268576,
        0.0069204373,
        0.03202066,
        -0.03514758,
        0.032990247,
        0.015489175,
        -0.08672968,
        -0.031220747,
        0.0073446324,
        0.035729334,
        0.0056842123,
        0.0038965335,
        -0.050612517,
        -0.061084073,
        -0.019888682,
        -0.030687474,
        -0.023560999,
        -0.019270571,
        0.058854017,
        0.016143648,
        0.01094423,
        -0.0064295833,
        0.024821464,
        -0.047364395,
        -0.032432735,
        -0.012259234,
        0.0100716,
        -0.09002629,
        0.037547313,
        0.049036935,
        -0.025063861,
        3.6028163e-05,
        -0.008677817,
        0.046685684,
        -0.051436666,
        -0.038953215,
        -0.0042237695,
        0.05933881,
        -0.033062965,
        -0.03512334,
        0.0046661445,
        -0.013186403,
        0.003202672,
        0.03349928,
        -0.0185555,
        -0.03538998,
        0.03374168,
        -0.027293915,
        -0.013707557,
        -0.018155543,
        -0.07058604,
        -0.009174731,
        0.014761984,
        0.0017210195,
        -0.019985642,
        0.0043328484,
        -0.03272361,
        0.008708117,
        -0.041425668,
        -0.04869758,
        -0.03762003,
        -0.016931439,
        -0.059823606,
        -0.0068355985,
        -0.062393017,
        -0.023064084,
        -0.023306482,
        0.0006438673,
        0.0026284936,
        -0.019209972,
        0.0122955935,
        0.015634613,
        -0.011259345,
        0.015658854,
        -0.019840203,
        0.05473327,
        0.038274504,
        0.008496019,
        0.01592549,
        0.010156439,
        0.0149074225,
        0.026712162,
        -0.024227591,
        -0.018119184,
        -0.029960282,
        -0.08125151,
        -0.029960282,
        -0.008877794,
        -0.06132647,
        0.030905632,
        -0.015913371,
        0.0013703011,
        0.054781746,
        0.047121998,
        -0.010168559,
        -0.021488504,
        0.003945013,
        -0.012847047,
        0.011925938,
        -0.028796777,
        0.0051721483,
        0.014216591,
        0.017428352,
        -4.454994e-05,
        0.03691708,
        -0.029063413,
        -0.030057242,
        0.028699817,
        -0.035705093,
        -0.0012907647,
        5.240891e-05,
        0.016228486,
        0.03776547,
        -0.008302101,
        -0.01832522,
        -0.038056348,
        0.028142305,
        0.013574238,
        -0.0054812045,
        0.027948387,
        -0.0061477968,
        0.019585686,
        0.023051966,
        0.026372805,
        -0.012241054,
        -0.029039174,
        -0.00417529,
        0.005514534,
        -0.004272249,
        0.02010684,
        0.0034541588,
        0.03172978,
        -0.029572448,
        -0.01937965,
        -0.03177826,
        -0.028966455,
        -0.02442151,
        -0.004960051,
        0.04629785,
        -0.06636833,
        -0.000965801,
        0.014568066,
        -0.011816859,
        -0.05109731,
        0.0105685145,
        0.021088548,
        -0.008144543,
        -0.008744475,
        0.0050358,
        -0.003013299,
        0.032263055,
        -0.05274561,
        0.0117380805,
        -0.035002142,
        -0.0005078977,
        -0.005605433,
        0.044867706,
        -0.026494004,
        -0.01504074,
        -0.06981037,
        -0.0073143328,
        0.031632822,
        0.0019528117,
        0.04612817,
        0.018737298,
        -0.0045146463,
        0.013622718,
        0.00019164522,
        0.038104825,
        0.012422852,
        -0.010750311,
        0.039559208,
        -0.022700489,
        -0.030057242,
        -0.028166544,
        0.009780724,
        0.037014037,
        0.00085066236,
        0.002852711,
        0.069034696,
        0.012980365,
        -0.007720348,
        0.0014362029,
        -0.029111894,
        -0.02101583,
        0.04355876,
        -0.03524454,
        0.03958345,
        0.035826292,
        -0.018749416,
        0.01679812,
        0.027802948,
        0.010738192,
        -0.03456583,
        -0.027802948,
        0.053666722,
        -0.026178887,
        0.03008148,
        0.011616882,
        -0.031705543,
        0.0038813837,
        0.034032553,
        -0.0028299862,
        0.008168783,
        -0.05274561,
        -0.020737072,
        -0.0047176536,
        0.0031511625,
        -0.020737072,
        -0.038298745,
        0.017125355,
        0.025403216,
        0.041910462,
        0.001257435,
        -0.06287781,
        0.029160373,
        0.016604202,
        0.023633718,
        0.0077809473,
        -0.03265089,
        0.008871734,
        -0.015489175,
        -0.046273608,
        0.010604873,
        -0.014592306,
        -0.042492215,
        0.07645205,
        0.047412876,
        -0.02274897,
        0.023136804,
        -0.017295035,
        -0.0088899145,
        0.019076653,
        -0.016786,
        -0.004129841,
        -0.013840875,
        -0.01420447,
        -0.03189946,
        -0.032311536,
        0.046443287,
        0.0121077355,
        -0.009380768,
        0.013889355,
        -0.005463025,
        0.0054872646,
        -0.03538998,
        0.032844808,
        0.01431355,
        -0.035196062,
        0.05798139,
        0.018943334,
        -0.035462696,
        0.017161716,
        -0.055751335,
        -0.016979918,
        0.020676473,
        0.031341948,
        0.0042237695,
        0.06210214,
        -0.011289645,
        0.009938282,
        -0.024445748,
        -0.0074173515,
        0.017137475,
        -0.0016952648,
        -0.032287296,
        -0.030566275,
        -0.011247226,
        -0.020264398,
        0.037304915,
        -0.023791276,
        0.035026383,
        0.009641345,
        -0.0077445875,
        0.020058362,
        -0.0025406247,
        -0.0064538233,
        0.024942663,
        0.02442151,
        0.0068901377,
        0.00048252175,
        -0.003429919,
        -0.03580205,
        -0.031560104,
        -0.0009604985,
        0.028893735,
        0.028142305,
        0.0134166805,
        -0.013210642,
        0.042371016,
        0.0025800143,
        0.036868602,
        -0.021379424,
        0.008829315,
        -0.0017119296,
        -0.028893735,
        0.058950976,
        0.016676921,
        0.06724096,
        -0.0067810593,
        -0.00293755,
        0.02845742,
        -0.03626261,
        -0.004347998,
        0.02770599,
        0.03849266,
        -0.029863324,
        0.052988008,
        0.01603457,
        -0.0003516652,
        0.023379201,
        0.04952173,
        -0.002837561,
        -0.0029905743,
        0.0504186,
        0.039050173,
        0.014774104,
        0.029936044,
        -0.020870391,
        0.0053024366,
        0.024845704,
        0.02175514,
        0.008053644,
        0.0070901155,
        0.011332065,
        0.03524454,
        -0.008453599,
        0.026760641,
        0.017452592,
        0.018167663,
        -0.022312654,
        0.012222874,
        -0.014846823,
        0.0021527894,
        0.020300757,
        0.03279633,
        -0.027584791,
        0.05541198,
        -0.0105685145,
        0.04801887,
        0.06888926,
        -0.024748744,
        0.023985194,
        -0.0021770291,
        0.024797224,
        0.03177826,
        -0.004102571,
        -0.029063413,
        0.049158134,
        0.0115502225,
        -0.005202448,
        -0.062683895,
        -0.009598926,
        -0.014349909,
        -0.02251869,
        0.035899013,
        0.010774552,
        -0.024712386,
        0.0121077355,
        -0.0121077355,
        -0.017052637,
        -0.00038821413,
        0.021585463,
        0.027996866,
        0.048043106,
        -0.008229382,
        -0.032287296,
        -0.018749416,
        0.020652235,
        0.035705093,
        0.0039541028,
        0.012616769,
        -0.012077436,
        -0.018894855,
        -0.025282018,
        0.014895302,
        0.018797897,
        -0.02011896,
        -0.0148589425,
        0.037038278,
        -0.014798343,
        -0.039244093,
        0.05037012,
        0.05027316,
        -0.023015605,
        -0.003696556,
        -0.029936044,
        -0.009907982,
        -0.00032344865,
        -0.020724952,
        0.03257817,
        -0.030105721,
        0.032675132,
        0.037014037,
        -0.012150155,
        -0.035608135,
        -0.0619567,
        -0.017367752,
        0.0065932013,
        -0.018919095,
        -0.02426395,
        -0.021306707,
        0.029669406,
        -0.009089892,
        -0.029984523,
        0.0064174635,
        -0.0718465,
        -0.024894184,
        -0.017525312,
        0.005638763,
        -0.012204695,
        -0.045449458,
        0.07465831,
        -0.043122444,
        -0.0013392441,
        -0.0063326247,
        -0.019949282,
        -0.038007867,
        0.003266301,
        -0.0018588828,
        -0.022882286,
        -0.023924595,
        -0.009907982,
        0.029523969,
        -0.028675579,
        0.050806433,
        0.011774439,
        -0.0015248293,
        0.009550446,
        -0.021391544,
        -0.029039174,
        -0.012247114,
        0.009877683,
        -0.013198523,
        0.011544162,
        -0.023318602,
        -0.013962073,
        0.007938505,
        -0.042322535,
        0.0065932013,
        -0.002866346,
        0.021524863,
        0.018070705,
        -0.013089444,
        -0.0117199,
        0.048479423,
        0.034517348,
        -0.023124684,
        -0.004054092,
        0.014107511,
        -0.01937965,
        0.01510134,
        -0.022421733,
        0.040916633,
        0.016543603,
        -0.02610617,
        -0.027196955,
        -0.015016501,
        -0.009386828,
        -0.009156551,
        -0.024991142,
        0.0023860966,
        -0.011931998,
        -0.047437113,
        0.0033238705,
        -0.010095839,
        -0.012992485,
        0.025330499,
        -0.003684436,
        -0.013719676,
        -0.0014695325,
        0.043922357,
        0.0088414345,
        -0.022227814,
        0.00056811824,
        0.01593761,
        -0.012786448,
        -0.003187522,
        0.02265201,
        0.03022692,
        -0.04588577,
        0.025233539,
        0.021137029,
        -0.038832016,
        -0.022046017,
        0.058999456,
        0.029136132,
        0.018107064,
        0.027099997,
        -0.029184612,
        -0.03439615,
        0.00336023,
        -0.0017316244,
        -0.04043184,
        0.008193023,
        -0.037232198,
        0.02695456,
        0.013065204,
        -0.022252055,
        0.016555723,
        -0.017101116,
        0.00754461,
        0.010744252,
        0.047606792,
        0.009053532,
        0.0065023024,
        0.0146286655,
        -0.014386268,
        -0.0053084968,
        -0.032287296,
        -0.0006434886,
        -0.01510134,
        -7.722857e-06,
        -0.019573567,
        0.007799127,
        0.007805187,
        0.008526319,
        -0.017379873,
        0.03185098,
        0.028724058,
        0.014749864,
        0.003863204,
        -0.023379201,
        0.033329602,
        0.01095635,
        -0.026542483,
        -0.008465719,
        0.03614141,
        -0.010768492,
        -0.025718333,
        -0.002427001,
        0.0016058809,
        -0.019100891,
        0.045594897,
        0.050564036,
        -0.0111745065,
        -0.034177992,
        -0.012392553,
        0.005705422,
        0.0039692526,
        -0.037571553,
        0.042371016,
        0.03861386,
        0.023560999,
        0.015404336,
        0.02855438,
        0.03442039,
        0.0026769731,
        0.009483787,
        -0.042613413,
        -0.007471891,
        0.023767037,
        -0.0088899145,
        -0.01431355,
        -0.020203799,
        0.027075756,
        -0.0044782865,
        -0.037207957,
        0.020421956,
        -0.009683765,
        0.008998993,
        -0.0008612672,
        0.0083263405,
        0.024748744,
        -0.04755831,
        0.006211426,
        0.0097746635,
        0.016628442,
        0.010435196,
        0.0017391993,
        0.0040480318,
        -0.008132423,
        -0.019925043,
        0.035729334,
        0.025330499,
        0.01596185,
        0.041498385,
        -0.018664578,
        -0.088184066,
        -0.01007766,
        0.014931662,
        0.0065871417,
        -0.00015699,
        -0.014798343,
        -0.03677164,
        -0.016519364,
        0.0133682005,
        0.020797672,
        0.0011559313,
        -0.01088363,
        0.022567172,
        -0.022870168,
        -0.011653241,
        -0.0029769395,
        0.0059266095,
        0.022809569,
        0.017598031,
        0.03189946,
        -0.014555947,
        -0.061568867,
        -0.023161044,
        -0.019173611,
        -0.002173999,
        -0.060744718,
        -0.039147135,
        -0.0016998097,
        0.023197403,
        0.004744923,
        -0.0032390314,
        0.014422628,
        -0.0134166805,
        -0.036626205,
        0.021415785,
        0.0068477183,
        -0.020809792,
        -0.024385149,
        0.003693526,
        -0.02840894,
        0.017937386,
        -0.0038116944,
        -0.0077324677,
        0.022930767,
        0.022058137,
        -0.03017844,
        -0.0061690067,
        0.0065265424,
        0.018846376,
        -0.02434879,
        0.024251832,
        -0.03260241,
        0.008314221,
        -0.0018558529,
        -0.009059592,
        0.028118065,
        0.006405344,
        0.022033898,
        -0.0031329826,
        -0.019088773,
        0.02091887,
        -0.011047249,
        -0.027415114,
        -0.048358224,
        0.012053196,
        0.017973745,
        0.024009435,
        -0.0020694654,
        -0.022870168,
        0.028748298,
        0.026324326,
        0.017743468,
        0.018700937,
        -0.012992485,
        0.017925266,
        0.01087151,
        -0.013174283,
        -0.0035814173,
        -0.026566723,
        0.008289982,
        0.03189946,
        0.018094944,
        0.010598814,
        -0.0106594125,
        0.026518244,
        0.026227368,
        0.0042358893,
        0.0014581701,
        0.002755752,
        0.034880944,
        -0.04777647,
        -0.041765023,
        0.013186403,
        0.0024512408,
        0.031341948,
        -0.010180678,
        0.047970388,
        -0.032505453,
        -0.113344885,
        -0.021100668,
        -0.004611605,
        -0.024845704,
        0.021573342,
        0.00062568753,
        0.037111,
        0.022021778,
        -0.010671533,
        -0.002692123,
        -0.024894184,
        -0.021573342,
        0.0035450577,
        0.023536758,
        0.0100413,
        -0.017198075,
        -0.016446644,
        -0.008744475,
        0.008883854,
        -0.039850086,
        -0.017416233,
        0.008568738,
        -0.0015483116,
        -0.0058114706,
        -0.056575485,
        -0.0014975596,
        -0.00029769394,
        0.032238815,
        0.009289869,
        0.021524863,
        -0.016276967,
        0.0050691296,
        -0.023221644,
        0.055169582,
        -0.023003485,
        -0.00021493806,
        0.0061417366,
        -0.009156551,
        -0.02511234,
        0.010392776,
        0.017258674,
        -0.024021553,
        0.013756036,
        -0.06404132,
        0.016119407,
        0.008550558,
        -0.02352464,
        -0.0095868055,
        -0.0013286391,
        0.04617665,
        -0.00044578343,
        0.03172978,
        -0.019088773,
        -0.03194794,
        -0.02183998,
        0.02105219,
        0.012035017,
        0.01431355,
        -0.0013634837,
        0.018700937,
        -0.028990695,
        -0.024482109,
        0.024894184,
        -0.0028845256,
        -0.028093826,
        0.0026284936,
        -0.016083049,
        -0.028699817,
        -0.019355409,
        0.021864219,
        -0.026372805,
        0.0058448003,
        -0.023900354,
        -0.01848278,
        -0.04685536,
        0.018737298,
        0.0057751113,
        -0.013901474,
        -0.012380432,
        -0.0036571664,
        0.04363148,
        -0.0064901826,
        -0.02105219,
        0.0143014295,
        -0.0064841225,
        0.023936715,
        0.013816635,
        0.03279633,
        -0.03623837,
        0.048382465,
        -0.014362029,
        0.0044146576,
        0.011622941,
        -0.0032875107,
        -0.045110103,
        0.045425218,
        0.020034121,
        -0.035850532,
        0.0012316803,
        -0.026978798,
        0.008768716,
        0.050660998,
        -0.008047584,
        -0.0009332289,
        0.007865787,
        0.027390873,
        -0.056672443,
        0.016531482,
        -0.00504186,
        0.034856703,
        0.007883966,
        0.01679812,
        -0.03512334,
        0.020421956,
        -0.009659525,
        -0.025500176,
        0.021027949,
        0.02097947,
        0.011186627,
        0.01761015,
        -0.0110351285,
        0.030396597,
        -0.0334508,
        0.05138819,
        -0.027802948,
        0.025015382,
        0.0032814508,
        -0.010210978,
        -0.022046017,
        0.018167663,
        0.008829315,
        -0.002948155,
        -0.012665249,
        0.054248475,
        0.007629449,
        0.031414665,
        0.026203128,
        -0.012507691,
        -0.013356081,
        0.0133682005,
        0.020240158,
        0.0027481772,
        -0.014774104,
        0.0012612224,
        -0.029184612,
        0.0053206165,
        0.027245436,
        -0.024894184,
        -0.055218063,
        0.028093826,
        -0.011847159,
        -0.032190338,
        0.024312431,
        0.028263504,
        0.024191232,
        0.04014096,
        0.011774439,
        -0.028602859,
        0.0056508826,
        -0.030614754,
        0.002261868,
        0.021549104,
        0.020821912,
        -0.015549774,
        0.045788813,
        0.034105275,
        0.007914266,
        -0.023076205,
        0.0087020565,
        0.01916149,
        -0.03526878,
        -0.011865338,
        -0.04515858,
        -0.01011402,
        -0.0023830666,
        0.008180902,
        -0.009483787,
        0.016786,
        0.014495348,
        0.043098208,
        0.0025345648,
        0.042080138,
        -0.012319833,
        0.011332065,
        0.0056811823,
        -0.031487383,
        -0.027342394,
        0.00045032837,
        -0.0028860406,
        -0.018773656,
        0.009726184,
        0.018264621,
        -0.0057629915,
        0.045110103,
        0.019100891,
        0.019113012,
        -0.016555723,
        0.0115502225,
        0.04952173,
        -0.023161044,
        0.002261868,
        0.015537655,
        0.023694318,
        -0.04045608,
        0.016228486,
        0.047534075,
        0.011016949,
        0.010350357,
        -0.029087653,
        6.746404e-05,
        0.008090003,
        0.023318602,
        -0.012113796,
        -0.007986985,
        -0.017452592,
        0.02442151,
        0.033572,
        -0.005293347,
        -0.035608135,
        -0.012313773,
        -0.03541422,
        -0.030323878,
        0.02845742,
        -0.019646285,
        -0.0046631144,
        0.0112229865,
        0.020385597,
        0.0115502225,
        0.005566044,
        -0.01259253,
        0.011410844,
        0.017888907,
        -0.0035905072,
        -0.012737968,
        0.01587701,
        -0.0046570543,
        -0.0017376842,
        0.0049721706,
        0.0006824994,
        0.031511623,
        0.005514534,
        -0.017743468,
        0.011822919,
        -0.006787119,
        0.022833807,
        -0.02777871,
        0.011307825,
        -0.002273988,
        0.02345192,
        0.0034753685,
        -0.033887114,
        -0.010398836,
        0.0043389085,
        -0.036286846,
        0.05303649,
        -0.029208852,
        0.014919542,
        0.045085862,
        0.0058175307,
        -0.004760073,
        -0.010374596,
        -0.013574238,
        -0.01596185,
        -0.00754461,
        -0.029620927,
        -0.019525087,
        -0.01262889,
        0.0071628345,
        0.02168242,
        -0.0044237473,
        0.008544498,
        0.015355857,
        -0.026590964,
        -0.00843542,
        -0.007980925,
        -0.012338013,
        -0.0053206165,
        -0.018216142,
        -0.003111773,
        -0.023827637,
        -0.012919766,
        0.023039846,
        0.0068416586,
        0.042880047,
        0.016228486,
        -0.043461803,
        0.034008313,
        -0.004308609,
        0.03878354,
        -0.022942886,
        -0.013865115,
        0.014131752,
        -0.0049721706,
        -0.016846599,
        -0.020022001,
        -0.0064114034,
        0.004929751,
        -0.027584791,
        -8.13711e-06,
        -0.02695456,
        -0.019634167,
        0.031366184,
        0.006793179,
        -0.03943801,
        0.037256435,
        -0.0042237695,
        -0.056866363,
        0.0056508826,
        -0.0137439165,
        -0.028917976,
        0.020458316,
        0.0052388078,
        0.008586918,
        0.02101583,
        -0.00018009348,
        -0.0027527222,
        0.009405008,
        0.021924818,
        0.0046812943,
        0.04367996,
        0.0149074225,
        0.011319945,
        -0.0021861189,
        -0.018603979,
        -0.032190338,
        0.011132088,
        0.017731348,
        0.0048994515,
        0.009956461,
        -0.03160858,
        0.004054092,
        0.028602859,
        0.017246554,
        -0.026203128,
        -0.0285059,
        -0.014774104,
        -0.050660998,
        0.00049085415,
        0.00061584014,
        -0.013307601,
        -0.022567172,
        -0.024070034,
        -0.0042480095,
        0.0043510282,
        0.0025224448,
        0.0049964106,
        -0.018785777,
        0.009314109,
        0.00014458608,
        0.04280733,
        0.06927709,
        0.016167887,
        -0.025524415,
        0.0033390203,
        0.005111549,
        -0.0108957505,
        -0.02598497,
        0.006884078,
        0.0016770851,
        -0.04518282,
        0.02107643,
        0.011156327,
        0.010792731,
        0.028966455,
        0.021706661,
        -0.022894407,
        -0.006532602,
        0.025233539,
        0.007835487,
        -0.019488728,
        0.00057152694,
        0.010283697,
        -0.013562119,
        0.013356081,
        0.006387164,
        0.023306482,
        0.019028174,
        -0.020591635,
        0.0052115377,
        0.012968245,
        0.013234883,
        -0.009483787,
        -0.019197851,
        -0.017864667,
        -0.019949282,
        -0.004369208,
        -0.014895302,
        0.008447539,
        -0.012204695,
        -0.052454736,
        -0.017295035,
        -0.0049085417,
        -0.0334508,
        0.025330499,
        0.06452611,
        0.022155097,
        -0.022361133,
        0.016822359,
        0.013962073,
        0.008411179,
        0.009835263,
        0.011101788,
        -0.019416008,
        -0.03374168,
        -0.010332176,
        -0.027972627,
        0.0044085975,
        0.00078324566,
        0.021112788,
        0.010332176,
        -0.022094497,
        -0.025645614,
        0.02588801,
        0.05638157,
        0.0136954365,
        -0.022482332,
        0.019476607,
        0.01004736,
        -0.0152346585,
        0.04755831,
        -0.019706884,
        -0.013646957,
        -0.0017558641,
        0.0010612449,
        -0.014483227,
        0.05104883,
        0.02101583,
        0.012338013,
        0.00088474946,
        0.003923803,
        -0.022070257,
        0.007738528,
        -0.036601964,
        -0.034953665,
        -0.00672046,
        0.014034793,
        0.0009218665,
        0.02525778,
        -0.022555051,
        0.018749416,
        -0.028602859,
        -0.034880944,
        -0.023245882,
        0.014022673,
        -0.0005499385,
        -0.0136954365,
        0.0235004,
        0.017040517,
        -0.051727545,
        -0.008902034,
        -0.009641345,
        -0.007223434,
        0.023270123,
        -0.0009741334,
        -0.06462307,
        0.006005388,
        -0.044092033,
        3.3436124e-06,
        -0.006641681,
        -0.0037026159,
        0.019185731,
        0.018906975,
        -0.026663681,
        0.01670116,
        -0.011204806,
        0.028118065,
        -0.03684436,
        -0.022409612,
        -0.013295482,
        -0.025403216,
        0.011647182,
        -0.012847047,
        0.0037450353,
        -0.00420256,
        -0.012992485,
        0.01095635,
        -0.0053993957,
        -0.013319721,
        0.0064114034,
        0.015719453,
        0.010235218,
        -0.0030329938,
        0.015283138,
        0.025572896,
        0.006956797,
        -0.0234398,
        -0.0074537112,
        0.0016240607,
        -0.012968245,
        0.025233539,
        -0.02090675,
        -0.011992597,
        -0.029766366,
        0.020288639,
        -0.029839084,
        0.014713504,
        -0.01511346,
        -0.017210195,
        0.03008148,
        0.042055897,
        -0.0039541028,
        -0.024045793,
        -0.026687922,
        -0.0011635062,
        0.0045934254,
        -0.005278197,
        0.032481212,
        -0.009786784,
        -0.01005948,
        -0.012968245,
        0.0023664017,
        0.023015605,
        0.015271018,
        -0.011350244,
        0.0077506476,
        -0.0015816411,
        0.0039328933,
        0.01092605,
        0.015186179,
        0.002343677,
        -0.009532266,
        -0.019028174,
        0.03766851,
        -0.0005067615,
        -0.016470883,
        0.03665044,
        0.022482332,
        -0.030857151,
        0.011853219,
        0.017864667,
        0.0060538677,
        0.017234435,
        0.013259122,
        -0.0053387964,
        0.004360118,
        -0.01340456,
        -0.001843733,
        -0.026275847,
        0.003011784,
        -0.0042298296,
        0.009017172,
        0.0007840032,
        -0.018603979,
        -0.0005772081,
        0.023839755,
        0.02259141,
        -0.00584177,
        -0.049739886,
        -0.01847066,
        0.04787343,
        -0.014083272,
        -0.0018997873,
        0.0016922348,
        -0.002199754,
        0.016386045,
        -0.02693032,
        0.0044934363,
        0.0012680399,
        0.019634167,
        0.002261868,
        0.06476851,
        -0.018700937,
        -0.010326117,
        0.00040450017,
        -0.0028602858,
        0.020506795,
        -0.010198859,
        -0.016567843,
        0.0028996754,
        0.011301765,
        0.011392664,
        -0.049012695,
        -0.021137029,
        -0.0077567077,
        -0.050030764,
        0.023379201,
        0.02010684,
        -0.017804068,
        0.002680003,
        -0.01763439,
        0.03187522,
        0.004114691,
        -0.00011428645,
        0.009386828,
        -0.021185508,
        -0.004702504,
        -0.053278886,
        0.05473327,
        0.034032553,
        -0.030614754,
        -0.030396597,
        0.009708004,
        0.016895078,
        0.011271466,
        0.017088996,
        0.036529243,
        0.00077567075,
        0.031487383,
        0.00756279,
        -0.02267625,
        -0.014616546,
        -0.009653465,
        -0.0073446324,
        -0.03861386,
        -0.02010684,
        -0.047218956,
        -0.0036511065,
        -0.008465719,
        0.0025254749,
        0.014362029,
        -0.00589328,
        -0.0055084745,
        -0.022700489,
        0.008023344,
        0.014931662,
        -0.02511234,
        -0.030396597,
        -0.024760865,
        0.003102683,
        0.0022042987,
        0.0020528005,
        0.011204806,
        -0.043728437,
        -0.023354962,
        0.013174283,
        0.00056508824,
        0.0037995747,
        -0.021500623,
        0.007859726,
        0.009811023,
        0.050612517,
        -0.02016744,
        -0.036698923,
        0.008059704,
        0.0021240048,
        0.011422964,
        -0.021949058,
        0.017985865,
        0.02945125,
        0.0026072839,
        0.036747403,
        -0.020482555,
        0.0082839215,
        -0.01427719,
        0.007847606,
        0.010410956,
        0.04021368,
        0.0039692526,
        0.034687027,
        0.0011975932,
        -0.037886668,
        0.0009976156,
        -0.002608799,
        -0.030566275,
        -0.02106431,
        0.000563952,
        0.02188846,
        0.011659301,
        -0.023476161,
        0.0002160743,
        -0.0017679839,
        0.03858962,
        -0.02265201,
        0.0019679614,
        -0.010635173,
        0.031535864,
        0.03177826,
        0.016628442,
        -0.024469988,
        0.039268333,
        -0.027366634,
        0.016083049,
        0.020821912,
        -0.012507691,
        0.0022800479,
        -0.0070234565,
        -0.01000494,
        -0.015574015,
        0.055848293,
        0.0010673048,
        0.049036935,
        -0.013889355,
        0.013053085,
        0.025403216,
        0.039219853,
        0.0053387964,
        0.00922927,
        0.024094272,
        -0.0076052095,
        0.0059932685,
        0.014519587,
        0.016058808,
        -0.005372126,
        0.007229494,
        -0.0074961307,
        0.0148589425,
        0.006962857,
        0.00041359008,
        0.00026474308,
        0.0018300982,
        -0.016786,
        -0.017525312,
        -0.011695661,
        -0.04780071,
        -0.007865787,
        0.0028693757,
        -0.031972177,
        -0.02853014,
        -0.039947044,
        0.031220747,
        -0.025354737,
        -0.013731796,
        -0.009132311,
        0.0017952536,
        0.048067346,
        0.007974865,
        -0.0301542,
        -0.00083551253,
        0.02174302,
        -0.024106393,
        0.046612963,
        0.03185098,
        0.01674964,
        0.014216591,
        -0.006387164,
        -0.026154649,
        -0.025403216,
        -0.00840512,
        -0.009011112,
        -0.008641457,
        0.015852772,
        0.014349909,
        -0.008908094,
        -0.016676921,
        0.021403665,
        0.0036480764,
        0.005544834,
        -0.01594973,
        -0.016470883
      ],
      "embedding_pca_2d": [],
      "embedding_pca_3d": [],
      "embedding_cluster_id": null,
      "migration_history": [],
      "metadata": {
        "compute_time": 10.011558771133423,
        "api_costs": 0.0,
        "embed_cost": 1.354e-05,
        "novelty_cost": 0.0,
        "patch_type": "init",
        "patch_name": "initial_program",
        "patch_description": "Initial program from file.",
        "stdout_log": "Evaluating program: sds_dataset_output/problem_0/gen_0/main.py\nSaving results to: sds_dataset_output/problem_0/gen_0/results\nRun 1/1 completed in 0.00 seconds\nCorrectness and error status saved to sds_dataset_output/problem_0/gen_0/results/correct.json\nMetrics saved to sds_dataset_output/problem_0/gen_0/results/metrics.json\nEvaluation and Validation completed successfully.\nMetrics:\n  combined_score: 0.3470686777681244\n  public:\n    feasible: True\n    selection_size: 10\n    raw_score: 106.5063848215821\n  private:\n    selection: [2, 3, 4, 5, 6, 7, 8, 9, 10, 14]\n    raw_score: 106.5063848215821\n    normalized_fitness: 0.3470686777681244\n  execution_time_mean: 0.0007033750002847228\n  execution_time_std: 0.0\n  num_valid_runs: 1\n  num_invalid_runs: 0\n  all_validation_errors: []\n",
        "stderr_log": "",
        "code_analysis_metrics": {
          "cyclomatic_complexity": 30,
          "average_cyclomatic_complexity": 15.0,
          "halstead_volume": 483.4105501817314,
          "halstead_difficulty": 7.857142857142857,
          "halstead_effort": 3798.2257514278895,
          "lines_of_code": 145,
          "logical_lines_of_code": 84,
          "comments": 22,
          "maintainability_index": 1.4165259654789253,
          "max_nesting_depth": 5,
          "complexity_score": 1.0
        }
      },
      "in_archive": false
    },
    {
      "id": "6bc02da7-745b-45ce-8958-d40245b377e0",
      "code": "\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n    \n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n    \n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n    \n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n    \n    result_str = stdout_capture.getvalue()\n    return result_str\n\n",
      "language": "python",
      "parent_id": "639d15e8-d1f9-4fa7-b731-6db3bcbdb880",
      "archive_inspiration_ids": [],
      "top_k_inspiration_ids": [],
      "island_idx": 0,
      "generation": 1,
      "timestamp": 1764667920.5675619,
      "code_diff": "--- a/original.py\n+++ b/original.py\n@@ -1,145 +1,45 @@\n \"\"\"\n Initial solution for Synergistic Dependency Selection (SDS) problem.\n The code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n \"\"\"\n \n import json\n import sys\n import contextlib\n \n-# EVOLVE-BLOCK-START\n-def solve_sds():\n-    \"\"\"\n-    Solve the Synergistic Dependency Selection problem.\n-    \n-    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n-    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n-    \n-    This is a greedy baseline - evolution will improve this.\n-    \"\"\"\n-    # Read input\n-    input_data = json.load(sys.stdin)\n-    requirements = input_data.get(\"requirements\", {})\n-    catalog = input_data.get(\"catalog\", {})\n-    \n-    # Extract constraints\n-    weights = requirements.get(\"weights\", [])\n-    interactions = requirements.get(\"interactions\", {})\n-    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n-    mutex = requirements.get(\"mutex\", [])\n-    groups = requirements.get(\"groups\", {})\n-    precedence = requirements.get(\"precedence\", [])\n-    \n-    # Simple greedy: select items with highest weights first\n-    # This is a baseline - evolution will find better strategies\n-    n = len(weights)\n-    selected = []\n-    \n-    # Create score list (weight + interaction potential)\n-    scores = []\n-    for i in range(n):\n-        score = weights[i] if i < len(weights) else 0.0\n-        # Add potential interaction value\n-        for k, v in interactions.items():\n-            try:\n-                u, w = map(int, k.split(\",\"))\n-                if u == i or w == i:\n-                    score += abs(v) * 0.5  # Potential value\n-            except:\n-                pass\n-        scores.append((score, i))\n-    \n-    # Sort by score descending\n-    scores.sort(reverse=True)\n-    \n-    # Greedy selection respecting constraints\n-    selected_set = set()\n-    for score, i in scores:\n-        if len(selected_set) >= cardinality_bounds[1]:\n-            break\n-            \n-        # Check mutex constraints\n-        can_add = True\n-        for a, b in mutex:\n-            if (a == i and b in selected_set) or (b == i and a in selected_set):\n-                can_add = False\n-                break\n-        \n-        if not can_add:\n-            continue\n-            \n-        # Check group constraints (at most one per group)\n-        for grp_vars in groups.values():\n-            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n-                can_add = False\n-                break\n-        \n-        if not can_add:\n-            continue\n-        \n-        # Check precedence (if j selected, i must be selected)\n-        precedence_ok = True\n-        for pred_i, pred_j in precedence:\n-            if pred_j == i and pred_i not in selected_set:\n-                precedence_ok = False\n-                break\n-        \n-        if not precedence_ok:\n-            continue\n-        \n-        # Add if we meet minimum cardinality or have room\n-        if len(selected_set) < cardinality_bounds[1]:\n-            selected_set.add(i)\n-            selected.append(i)\n-    \n-    # Ensure minimum cardinality\n-    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n-        for i in range(n):\n-            if i not in selected_set:\n-                selected_set.add(i)\n-                selected.append(i)\n-                break\n-    \n-    # Output result\n-    result = {\n-        \"selection\": {\n-            \"variables\": sorted(selected)\n-        }\n-    }\n-    print(json.dumps(result))\n-# EVOLVE-BLOCK-END\n+# EVOLVE-BLOCK-START# EVOLVE-BLOCK-END\n \n \n # This part remains fixed (not evolved)\n def run_sds(problem_data=None):\n     \"\"\"\n     Main function called by the evaluator.\n     Can accept problem_data as parameter or read from stdin.\n     Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n     \"\"\"\n     import sys\n     import json\n     import io\n     \n     if problem_data is None:\n         # Read from stdin (for compatibility)\n         input_data = json.load(sys.stdin)\n     else:\n         # Use provided problem data\n         input_data = problem_data\n     \n     # Capture stdout from solve_sds\n     stdout_capture = io.StringIO()\n     old_stdin = sys.stdin\n     \n     try:\n         # Create mock stdin\n         sys.stdin = io.StringIO(json.dumps(input_data))\n         with contextlib.redirect_stdout(stdout_capture):\n             solve_sds()\n     finally:\n         sys.stdin = old_stdin\n     \n     result_str = stdout_capture.getvalue()\n     return result_str\n \n",
      "combined_score": 0.0,
      "public_metrics": {},
      "private_metrics": {},
      "text_feedback": "",
      "correct": false,
      "children_count": 0,
      "complexity": 0.296,
      "embedding": [],
      "embedding_pca_2d": [],
      "embedding_pca_3d": [],
      "embedding_cluster_id": null,
      "migration_history": [],
      "metadata": {
        "compute_time": 2.0105550289154053,
        "patch_type": "full",
        "api_costs": 0.011254249999999999,
        "num_applied": 1,
        "patch_name": "local_search_precedence_aware",
        "patch_description": "This implementation replaces the original simple greedy with a precedence-aware local search optimizer. Key differences and improvements:\n- Enforces precedence by computing transitive closures (ancestors/dependents) so any add/remove automatically respects dependency chains.\n- Builds a feasible initial solution using a synergy-aware greedy heuristic (weights + positive interaction potential).\n- Performs iterative local search (adds, removals, and swaps) with first-improvement hill-climbing to quickly escape weak local optima, evaluating moves incrementally and always respecting mutex and group constraints and cardinality bounds.\n- Tries several randomized restarts (with deterministic seed fallback) to explore multiple basins and keep the best feasible selection.\nThis approach is fundamentally different (local search with precedence closure and swap moves) and should find higher-quality solutions than the one-pass greedy baseline while still being efficient for moderate-sized instances.",
        "error_attempt": null,
        "novelty_attempt": 1,
        "resample_attempt": 1,
        "patch_attempt": 1,
        "model_name": "gpt-5-mini",
        "temperature": 1.0,
        "max_output_tokens": 8192,
        "llm_result": {
          "content": "<NAME>\nlocal_search_precedence_aware\n</NAME>\n\n<DESCRIPTION>\nThis implementation replaces the original simple greedy with a precedence-aware local search optimizer. Key differences and improvements:\n- Enforces precedence by computing transitive closures (ancestors/dependents) so any add/remove automatically respects dependency chains.\n- Builds a feasible initial solution using a synergy-aware greedy heuristic (weights + positive interaction potential).\n- Performs iterative local search (adds, removals, and swaps) with first-improvement hill-climbing to quickly escape weak local optima, evaluating moves incrementally and always respecting mutex and group constraints and cardinality bounds.\n- Tries several randomized restarts (with deterministic seed fallback) to explore multiple basins and keep the best feasible selection.\nThis approach is fundamentally different (local search with precedence closure and swap moves) and should find higher-quality solutions than the one-pass greedy baseline while still being efficient for moderate-sized instances.\n</DESCRIPTION>\n\n<CODE>\n```python\n#!/usr/bin/env python3\n\"\"\"\nEVOLVE-BLOCK-START\nNew SDS solver using precedence-aware local search with transitive closure,\ngroup/mutex-aware feasibility checks, and swap/add/remove neighborhood moves.\nEVOLVE-BLOCK-END\n\"\"\"\nimport sys\nimport json\nimport random\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    # catalog unused in current objective but accepted for compatibility\n    catalog = input_data.get(\"catalog\", {})\n\n    # Parse items\n    weights = list(requirements.get(\"weights\", []))\n    n = len(weights)\n    # cardinality bounds: [min, max]\n    card_bounds = requirements.get(\"cardinality_bounds\", [0, n])\n    min_card, max_card = card_bounds[0], card_bounds[1]\n\n    # Parse interactions: keys like \"i,j\"\n    raw_inter = requirements.get(\"interactions\", {})\n    interactions = {}\n    for k, v in raw_inter.items():\n        try:\n            a_str, b_str = k.split(\",\")\n            a = int(a_str.strip()); b = int(b_str.strip())\n            if 0 <= a < n and 0 <= b < n:\n                interactions[(a,b)] = float(v)\n                interactions[(b,a)] = float(v)\n        except Exception:\n            # ignore malformed keys\n            continue\n\n    # Mutex pairs\n    raw_mutex = requirements.get(\"mutex\", [])\n    mutex_pairs = set()\n    for pair in raw_mutex:\n        try:\n            a, b = pair\n            a = int(a); b = int(b)\n            if 0 <= a < n and 0 <= b < n and a != b:\n                mutex_pairs.add((min(a,b), max(a,b)))\n        except Exception:\n            continue\n\n    # Groups: dict group_name -> list of indices OR list of lists may be given\n    raw_groups = requirements.get(\"groups\", {})\n    groups = []\n    if isinstance(raw_groups, dict):\n        for grp in raw_groups.values():\n            try:\n                gl = [int(x) for x in grp]\n                groups.append(set([x for x in gl if 0 <= x < n]))\n            except Exception:\n                continue\n    elif isinstance(raw_groups, list):\n        for grp in raw_groups:\n            try:\n                gl = [int(x) for x in grp]\n                groups.append(set([x for x in gl if 0 <= x < n]))\n            except Exception:\n                continue\n\n    # Precedence: list of (i,j) meaning if j selected then i must be selected.\n    raw_prec = requirements.get(\"precedence\", [])\n    requires = {i: set() for i in range(n)}  # immediate requires: j -> set of i\n    dependents = {i: set() for i in range(n)}  # immediate dependents: i -> set of j\n    for pair in raw_prec:\n        try:\n            a, b = pair\n            a = int(a); b = int(b)\n            if 0 <= a < n and 0 <= b < n:\n                requires[b].add(a)\n                dependents[a].add(b)\n        except Exception:\n            continue\n\n    # Compute transitive closures: ancestors (all requires) and descendants (all dependents)\n    ancestors = [set() for _ in range(n)]\n    descendants = [set() for _ in range(n)]\n\n    # DFS to compute ancestors\n    def compute_ancestors():\n        for v in range(n):\n            seen = set()\n            stack = list(requires[v])\n            while stack:\n                u = stack.pop()\n                if u in seen:\n                    continue\n                seen.add(u)\n                for w in requires[u]:\n                    if w not in seen:\n                        stack.append(w)\n            ancestors[v] = seen\n\n    # DFS to compute descendants\n    def compute_descendants():\n        for v in range(n):\n            seen = set()\n            stack = list(dependents[v])\n            while stack:\n                u = stack.pop()\n                if u in seen:\n                    continue\n                seen.add(u)\n                for w in dependents[u]:\n                    if w not in seen:\n                        stack.append(w)\n            descendants[v] = seen\n\n    compute_ancestors()\n    compute_descendants()\n\n    # Utility: compute score of a set S (iterable of ints)\n    def score_of_set(S):\n        S_list = sorted(S)\n        s = 0.0\n        for i in S_list:\n            s += weights[i] if i < len(weights) else 0.0\n        # interactions counted once per unordered pair\n        visited = set()\n        for i in S_list:\n            for j in S_list:\n                if j <= i:\n                    continue\n                if (i,j) in interactions:\n                    s += interactions[(i,j)]\n        return s\n\n    # Feasibility checks when trying to add a set 'add_set' to current S\n    def feasible_union(S, add_set):\n        # union size check\n        new_size = len(S | add_set)\n        if new_size > max_card:\n            return False\n        # Mutex: cannot have conflicting pairs within union\n        # Check each mutex pair intersects union with both sides\n        for a,b in mutex_pairs:\n            if a in (S | add_set) and b in (S | add_set):\n                return False\n        # Groups: at most one per group\n        for grp in groups:\n            cnt = 0\n            # if group contains many of add_set or existing selected\n            # faster: check intersection size\n            if len((S | add_set) & grp) > 1:\n                return False\n        return True\n\n    # When adding item i, must also add its ancestors; return add_set or None if infeasible\n    def compute_add_closure(i, S):\n        # closure = ancestors[i] U {i}\n        add_set = set(ancestors[i])\n        add_set.add(i)\n        # If any of the add_set is already excluded by group conflict with S?\n        # Use feasible_union to check feasibility\n        # But need to also ensure add_set doesn't internally violate group/mutex\n        if not feasible_union(S, add_set):\n            return None\n        return add_set\n\n    # When removing item i, must remove its descendants as well\n    def compute_remove_closure(i, S):\n        rem_set = set(descendants[i])\n        rem_set.add(i)\n        # ensure rem_set is subset of S\n        rem_set = rem_set & set(S)\n        return rem_set\n\n    # Build initial solution using synergy-aware greedy\n    def initial_greedy_solution(seed=None):\n        if seed is not None:\n            random.seed(seed)\n        # compute base synergy potential for each item\n        potentials = []\n        for i in range(n):\n            pot = weights[i] if i < len(weights) else 0.0\n            # positive interactions potential with others\n            for j in range(n):\n                if j == i:\n                    continue\n                v = interactions.get((i,j), 0.0)\n                if v > 0:\n                    pot += 0.5 * v\n            potentials.append((pot, i))\n        # sort descending, but add slight random tie-breaker to diversify restarts\n        random.shuffle(potentials)\n        potentials.sort(key=lambda x: x[0], reverse=True)\n\n        S = set()\n        for _, i in potentials:\n            if len(S) >= max_card:\n                break\n            add_closure = compute_add_closure(i, S)\n            if add_closure is None:\n                continue\n            # If adding would not change S (all ancestors already present) still ok\n            # But ensure after adding, we still satisfy min constraints possibly later\n            S = S | add_closure\n        # If below min, try to add feasible items by best marginal gain\n        if len(S) < min_card:\n            candidates = [i for i in range(n) if i not in S]\n            # sort by marginal score heuristic\n            def marginal_gain(i):\n                add_closure = compute_add_closure(i, S)\n                if add_closure is None:\n                    return -1e9\n                newS = S | add_closure\n                return score_of_set(newS) - score_of_set(S)\n            candidates.sort(key=lambda i: marginal_gain(i), reverse=True)\n            for i in candidates:\n                if len(S) >= min_card:\n                    break\n                add_closure = compute_add_closure(i, S)\n                if add_closure is None:\n                    continue\n                S |= add_closure\n        # Trim if somehow exceeded max (shouldn't happen due to feasibility checks)\n        if len(S) > max_card:\n            # remove lowest weight leaves until within bound (remove items with no dependents first)\n            # simple greedy prune\n            removable = [i for i in S if len(descendants[i] & S) == 0]\n            removable.sort(key=lambda x: weights[x])\n            while len(S) > max_card and removable:\n                r = removable.pop(0)\n                S.remove(r)\n                # update removable\n                removable = [i for i in S if len(descendants[i] & S) == 0]\n                removable.sort(key=lambda x: weights[x])\n        return S\n\n    # Local search: try add, remove, and swap moves greedily until no improvement\n    def local_search(initial_S, max_iters=200):\n        S = set(initial_S)\n        best_S = set(S)\n        best_score = score_of_set(S)\n        improved = True\n        iters = 0\n        while improved and iters < max_iters:\n            iters += 1\n            improved = False\n            current_score = score_of_set(S)\n            # 1) Try best add move (first-improvement)\n            best_move = None\n            best_move_score = current_score\n            # consider items not in S\n            for j in range(n):\n                if j in S:\n                    continue\n                add_closure = compute_add_closure(j, S)\n                if add_closure is None:\n                    continue\n                newS = S | add_closure\n                # newS might include items that create new ancestors -- but closure already included\n                sc = score_of_set(newS)\n                if sc > best_move_score + 1e-9:\n                    best_move_score = sc\n                    best_move = (\"add\", j, add_closure)\n                    break  # first improvement\n            if best_move is not None:\n                # apply\n                S |= best_move[2]\n                improved = True\n                if best_move_score > best_score + 1e-9:\n                    best_score = best_move_score\n                    best_S = set(S)\n                continue\n\n            # 2) Try best swap moves: remove i (and its descendants) then add j's closure if feasible\n            # We'll do a limited number of candidate swaps for efficiency\n            # Build candidate lists sorted by weight to focus on promising swaps\n            current_items = sorted(list(S), key=lambda x: weights[x])\n            non_items = sorted([x for x in range(n) if x not in S], key=lambda x: -weights[x])\n            swap_found = False\n            for i in current_items:\n                rem_closure = compute_remove_closure(i, S)\n                S_after_rem = S - rem_closure\n                # if removing would drop below min and we won't be able to add enough, skip unless swap recovers\n                for j in non_items:\n                    # try add j to S_after_rem\n                    add_closure = compute_add_closure(j, S_after_rem)\n                    if add_closure is None:\n                        continue\n                    newS = S_after_rem | add_closure\n                    if len(newS) < min_card or len(newS) > max_card:\n                        continue\n                    sc = score_of_set(newS)\n                    if sc > best_score + 1e-9:\n                        S = newS\n                        best_score = sc\n                        best_S = set(S)\n                        improved = True\n                        swap_found = True\n                        break\n                    if sc > current_score + 1e-9:\n                        S = newS\n                        improved = True\n                        swap_found = True\n                        break\n                if swap_found:\n                    break\n            if swap_found:\n                continue\n\n            # 3) Try remove moves (allow only if still >= min_card)\n            for i in list(S):\n                rem_closure = compute_remove_closure(i, S)\n                newS = S - rem_closure\n                if len(newS) < min_card:\n                    continue\n                # Ensure removing doesn't violate any constraints (it shouldn't)\n                sc = score_of_set(newS)\n                if sc > best_score + 1e-9:\n                    S = newS\n                    best_score = sc\n                    best_S = set(S)\n                    improved = True\n                    break\n                if sc > current_score + 1e-9:\n                    S = newS\n                    improved = True\n                    break\n\n        return best_S, best_score\n\n    # Multi-start local search\n    best_overall = None\n    best_overall_score = -1e18\n    restarts = 5\n    # Use deterministic seed for reproducibility (unless randomness desired)\n    base_seed = 12345\n    for r in range(restarts):\n        seed = base_seed + r\n        init = initial_greedy_solution(seed=seed)\n        # If init violates min_card (<), try to add best marginal items\n        if len(init) < min_card:\n            # force-augment\n            candidates = [i for i in range(n) if i not in init]\n            while len(init) < min_card and candidates:\n                best_j = None; best_gain = -1e18\n                cur_score = score_of_set(init)\n                for j in candidates:\n                    add_cl = compute_add_closure(j, init)\n                    if add_cl is None:\n                        continue\n                    sc = score_of_set(init | add_cl) - cur_score\n                    if sc > best_gain:\n                        best_gain = sc; best_j = j\n                if best_j is None:\n                    break\n                addc = compute_add_closure(best_j, init)\n                if addc is None:\n                    break\n                init |= addc\n                candidates = [i for i in range(n) if i not in init]\n        # Ensure feasibility w.r.t groups/mutex and max_card\n        if len(init) > max_card:\n            # try pruning low contribution leaves\n            items = list(init)\n            items.sort(key=lambda x: weights[x])\n            for it in items:\n                if len(init) <= max_card:\n                    break\n                rem = compute_remove_closure(it, init)\n                init = init - rem\n\n        # Run local search\n        bestS, best_score = local_search(init, max_iters=300)\n        if best_score > best_overall_score + 1e-9:\n            best_overall_score = best_score\n            best_overall = bestS\n\n    # Final safety: ensure precedence closure and constraints satisfied for best_overall\n    if best_overall is None:\n        best_overall = set()\n    # close under precedence (should already be)\n    closure_changed = True\n    while closure_changed:\n        closure_changed = False\n        to_add = set()\n        for v in list(best_overall):\n            for a in ancestors[v]:\n                if a not in best_overall:\n                    to_add.add(a)\n        if to_add:\n            if feasible_union(best_overall, to_add):\n                best_overall |= to_add\n                closure_changed = True\n            else:\n                # cannot close; remove problematic items (those that require impossible ancestors)\n                # remove any item that has ancestors not feasible\n                removable = set()\n                for v in list(best_overall):\n                    need = set(ancestors[v]) | {v}\n                    if not feasible_union(best_overall - {v}, need - {v}):\n                        removable.add(v)\n                if not removable:\n                    # if nothing to remove, break to avoid infinite loop\n                    break\n                for r in removable:\n                    rem_cl = compute_remove_closure(r, best_overall)\n                    best_overall -= rem_cl\n                    closure_changed = True\n\n    # Enforce min_card by adding best marginal items if possible\n    S = set(best_overall)\n    if len(S) < min_card:\n        candidates = [i for i in range(n) if i not in S]\n        while len(S) < min_card and candidates:\n            best_j = None; best_gain = -1e18\n            cur_score = score_of_set(S)\n            for j in candidates:\n                add_cl = compute_add_closure(j, S)\n                if add_cl is None:\n                    continue\n                sc = score_of_set(S | add_cl) - cur_score\n                if sc > best_gain:\n                    best_gain = sc; best_j = j\n            if best_j is None:\n                break\n            addc = compute_add_closure(best_j, S)\n            if addc is None:\n                break\n            S |= addc\n            candidates = [i for i in range(n) if i not in S]\n\n    # Final trimming if > max_card (as last resort)\n    if len(S) > max_card:\n        # remove low weight leaves until within bound\n        leaves = [i for i in S if len(descendants[i] & S) == 0]\n        leaves.sort(key=lambda x: (weights[x], x))\n        while len(S) > max_card and leaves:\n            r = leaves.pop(0)\n            rem = compute_remove_closure(r, S)\n            S -= rem\n            leaves = [i for i in S if len(descendants[i] & S) == 0]\n            leaves.sort(key=lambda x: (weights[x], x))\n\n    result = {\"selection\": {\"variables\": sorted(list(S))}}\n    print(json.dumps(result))\n\n# EVOLVE-BLOCK-END\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n\n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n\n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n\n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n\n    result_str = stdout_capture.getvalue()\n    return result_str\n\n\nif __name__ == \"__main__\":\n    solve_sds()\n```",
          "msg": "\n# Current program\n\nHere is the current program we are trying to improve (you will need to \npropose a new program with the same inputs and outputs as the original \nprogram, but with improved internal implementation):\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    This is a greedy baseline - evolution will improve this.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    # Simple greedy: select items with highest weights first\n    # This is a baseline - evolution will find better strategies\n    n = len(weights)\n    selected = []\n    \n    # Create score list (weight + interaction potential)\n    scores = []\n    for i in range(n):\n        score = weights[i] if i < len(weights) else 0.0\n        # Add potential interaction value\n        for k, v in interactions.items():\n            try:\n                u, w = map(int, k.split(\",\"))\n                if u == i or w == i:\n                    score += abs(v) * 0.5  # Potential value\n            except:\n                pass\n        scores.append((score, i))\n    \n    # Sort by score descending\n    scores.sort(reverse=True)\n    \n    # Greedy selection respecting constraints\n    selected_set = set()\n    for score, i in scores:\n        if len(selected_set) >= cardinality_bounds[1]:\n            break\n            \n        # Check mutex constraints\n        can_add = True\n        for a, b in mutex:\n            if (a == i and b in selected_set) or (b == i and a in selected_set):\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n            \n        # Check group constraints (at most one per group)\n        for grp_vars in groups.values():\n            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n        \n        # Check precedence (if j selected, i must be selected)\n        precedence_ok = True\n        for pred_i, pred_j in precedence:\n            if pred_j == i and pred_i not in selected_set:\n                precedence_ok = False\n                break\n        \n        if not precedence_ok:\n            continue\n        \n        # Add if we meet minimum cardinality or have room\n        if len(selected_set) < cardinality_bounds[1]:\n            selected_set.add(i)\n            selected.append(i)\n    \n    # Ensure minimum cardinality\n    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n        for i in range(n):\n            if i not in selected_set:\n                selected_set.add(i)\n                selected.append(i)\n                break\n    \n    # Output result\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n    \n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n    \n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n    \n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n    \n    result_str = stdout_capture.getvalue()\n    return result_str\n\n\n```\n\nHere are the performance metrics of the program:\n\nCombined score to maximize: 0.35\nfeasible: True; selection_size: 10; raw_score: 106.51\n\n# Task\n\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs as the original program, but with improved internal implementation.\n",
          "system_msg": "You are an expert algorithmist specializing in combinatorial optimization, particularly the Synergistic Dependency Selection (SDS) problem.\n\nThe SDS problem requires selecting a subset of variables that:\n1. Satisfies cardinality bounds (min/max number of items)\n2. Respects mutex constraints (cannot select both items in a mutex pair)\n3. Respects group constraints (at most one item per group)\n4. Satisfies precedence constraints (if j is selected, i must be selected)\n5. Maximizes the objective: sum of selected item weights + pairwise interaction values\n\nKey strategies to explore:\n1. Greedy selection with constraint-aware ordering\n2. Dynamic programming for small instances\n3. Constraint satisfaction with backtracking\n4. Weighted scoring that accounts for interactions\n5. Precedence-aware selection ordering\n6. Group-aware selection that maximizes diversity\n\nThe code should read JSON from stdin with \"requirements\" and \"catalog\", and output JSON to stdout with \"selection\" containing \"variables\" list.\n\nBe creative and find efficient solutions that maximize the objective while respecting all constraints.\nDesign a completely different algorithm approach to solve the same problem.\nIgnore the current implementation and think of alternative algorithmic strategies that could achieve better performance.\nYou MUST respond using a short summary name, description and the full code:\n\n<NAME>\nA shortened name summarizing the code you are proposing. Lowercase, no spaces, underscores allowed.\n</NAME>\n\n<DESCRIPTION>\nExplain the completely different algorithmic approach you are taking and why it should perform better than the current implementation.\n</DESCRIPTION>\n\n<CODE>\n```{language}\n# The completely new algorithm implementation here.\n```\n</CODE>\n\n* Keep the markers \"EVOLVE-BLOCK-START\" and \"EVOLVE-BLOCK-END\" in the code.\n* Your algorithm should solve the same problem but use a fundamentally different approach.\n* Ensure the same inputs and outputs are maintained.\n* Think outside the box - consider different data structures, algorithms, or paradigms.\n* Use the <NAME>, <DESCRIPTION>, and <CODE> delimiters to structure your response. It will be parsed afterwards.",
          "new_msg_history": [
            {
              "role": "user",
              "content": "\n# Current program\n\nHere is the current program we are trying to improve (you will need to \npropose a new program with the same inputs and outputs as the original \nprogram, but with improved internal implementation):\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    This is a greedy baseline - evolution will improve this.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    # Simple greedy: select items with highest weights first\n    # This is a baseline - evolution will find better strategies\n    n = len(weights)\n    selected = []\n    \n    # Create score list (weight + interaction potential)\n    scores = []\n    for i in range(n):\n        score = weights[i] if i < len(weights) else 0.0\n        # Add potential interaction value\n        for k, v in interactions.items():\n            try:\n                u, w = map(int, k.split(\",\"))\n                if u == i or w == i:\n                    score += abs(v) * 0.5  # Potential value\n            except:\n                pass\n        scores.append((score, i))\n    \n    # Sort by score descending\n    scores.sort(reverse=True)\n    \n    # Greedy selection respecting constraints\n    selected_set = set()\n    for score, i in scores:\n        if len(selected_set) >= cardinality_bounds[1]:\n            break\n            \n        # Check mutex constraints\n        can_add = True\n        for a, b in mutex:\n            if (a == i and b in selected_set) or (b == i and a in selected_set):\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n            \n        # Check group constraints (at most one per group)\n        for grp_vars in groups.values():\n            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n        \n        # Check precedence (if j selected, i must be selected)\n        precedence_ok = True\n        for pred_i, pred_j in precedence:\n            if pred_j == i and pred_i not in selected_set:\n                precedence_ok = False\n                break\n        \n        if not precedence_ok:\n            continue\n        \n        # Add if we meet minimum cardinality or have room\n        if len(selected_set) < cardinality_bounds[1]:\n            selected_set.add(i)\n            selected.append(i)\n    \n    # Ensure minimum cardinality\n    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n        for i in range(n):\n            if i not in selected_set:\n                selected_set.add(i)\n                selected.append(i)\n                break\n    \n    # Output result\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n    \n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n    \n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n    \n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n    \n    result_str = stdout_capture.getvalue()\n    return result_str\n\n\n```\n\nHere are the performance metrics of the program:\n\nCombined score to maximize: 0.35\nfeasible: True; selection_size: 10; raw_score: 106.51\n\n# Task\n\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs as the original program, but with improved internal implementation.\n"
            },
            {
              "role": "assistant",
              "content": "<NAME>\nlocal_search_precedence_aware\n</NAME>\n\n<DESCRIPTION>\nThis implementation replaces the original simple greedy with a precedence-aware local search optimizer. Key differences and improvements:\n- Enforces precedence by computing transitive closures (ancestors/dependents) so any add/remove automatically respects dependency chains.\n- Builds a feasible initial solution using a synergy-aware greedy heuristic (weights + positive interaction potential).\n- Performs iterative local search (adds, removals, and swaps) with first-improvement hill-climbing to quickly escape weak local optima, evaluating moves incrementally and always respecting mutex and group constraints and cardinality bounds.\n- Tries several randomized restarts (with deterministic seed fallback) to explore multiple basins and keep the best feasible selection.\nThis approach is fundamentally different (local search with precedence closure and swap moves) and should find higher-quality solutions than the one-pass greedy baseline while still being efficient for moderate-sized instances.\n</DESCRIPTION>\n\n<CODE>\n```python\n#!/usr/bin/env python3\n\"\"\"\nEVOLVE-BLOCK-START\nNew SDS solver using precedence-aware local search with transitive closure,\ngroup/mutex-aware feasibility checks, and swap/add/remove neighborhood moves.\nEVOLVE-BLOCK-END\n\"\"\"\nimport sys\nimport json\nimport random\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    # catalog unused in current objective but accepted for compatibility\n    catalog = input_data.get(\"catalog\", {})\n\n    # Parse items\n    weights = list(requirements.get(\"weights\", []))\n    n = len(weights)\n    # cardinality bounds: [min, max]\n    card_bounds = requirements.get(\"cardinality_bounds\", [0, n])\n    min_card, max_card = card_bounds[0], card_bounds[1]\n\n    # Parse interactions: keys like \"i,j\"\n    raw_inter = requirements.get(\"interactions\", {})\n    interactions = {}\n    for k, v in raw_inter.items():\n        try:\n            a_str, b_str = k.split(\",\")\n            a = int(a_str.strip()); b = int(b_str.strip())\n            if 0 <= a < n and 0 <= b < n:\n                interactions[(a,b)] = float(v)\n                interactions[(b,a)] = float(v)\n        except Exception:\n            # ignore malformed keys\n            continue\n\n    # Mutex pairs\n    raw_mutex = requirements.get(\"mutex\", [])\n    mutex_pairs = set()\n    for pair in raw_mutex:\n        try:\n            a, b = pair\n            a = int(a); b = int(b)\n            if 0 <= a < n and 0 <= b < n and a != b:\n                mutex_pairs.add((min(a,b), max(a,b)))\n        except Exception:\n            continue\n\n    # Groups: dict group_name -> list of indices OR list of lists may be given\n    raw_groups = requirements.get(\"groups\", {})\n    groups = []\n    if isinstance(raw_groups, dict):\n        for grp in raw_groups.values():\n            try:\n                gl = [int(x) for x in grp]\n                groups.append(set([x for x in gl if 0 <= x < n]))\n            except Exception:\n                continue\n    elif isinstance(raw_groups, list):\n        for grp in raw_groups:\n            try:\n                gl = [int(x) for x in grp]\n                groups.append(set([x for x in gl if 0 <= x < n]))\n            except Exception:\n                continue\n\n    # Precedence: list of (i,j) meaning if j selected then i must be selected.\n    raw_prec = requirements.get(\"precedence\", [])\n    requires = {i: set() for i in range(n)}  # immediate requires: j -> set of i\n    dependents = {i: set() for i in range(n)}  # immediate dependents: i -> set of j\n    for pair in raw_prec:\n        try:\n            a, b = pair\n            a = int(a); b = int(b)\n            if 0 <= a < n and 0 <= b < n:\n                requires[b].add(a)\n                dependents[a].add(b)\n        except Exception:\n            continue\n\n    # Compute transitive closures: ancestors (all requires) and descendants (all dependents)\n    ancestors = [set() for _ in range(n)]\n    descendants = [set() for _ in range(n)]\n\n    # DFS to compute ancestors\n    def compute_ancestors():\n        for v in range(n):\n            seen = set()\n            stack = list(requires[v])\n            while stack:\n                u = stack.pop()\n                if u in seen:\n                    continue\n                seen.add(u)\n                for w in requires[u]:\n                    if w not in seen:\n                        stack.append(w)\n            ancestors[v] = seen\n\n    # DFS to compute descendants\n    def compute_descendants():\n        for v in range(n):\n            seen = set()\n            stack = list(dependents[v])\n            while stack:\n                u = stack.pop()\n                if u in seen:\n                    continue\n                seen.add(u)\n                for w in dependents[u]:\n                    if w not in seen:\n                        stack.append(w)\n            descendants[v] = seen\n\n    compute_ancestors()\n    compute_descendants()\n\n    # Utility: compute score of a set S (iterable of ints)\n    def score_of_set(S):\n        S_list = sorted(S)\n        s = 0.0\n        for i in S_list:\n            s += weights[i] if i < len(weights) else 0.0\n        # interactions counted once per unordered pair\n        visited = set()\n        for i in S_list:\n            for j in S_list:\n                if j <= i:\n                    continue\n                if (i,j) in interactions:\n                    s += interactions[(i,j)]\n        return s\n\n    # Feasibility checks when trying to add a set 'add_set' to current S\n    def feasible_union(S, add_set):\n        # union size check\n        new_size = len(S | add_set)\n        if new_size > max_card:\n            return False\n        # Mutex: cannot have conflicting pairs within union\n        # Check each mutex pair intersects union with both sides\n        for a,b in mutex_pairs:\n            if a in (S | add_set) and b in (S | add_set):\n                return False\n        # Groups: at most one per group\n        for grp in groups:\n            cnt = 0\n            # if group contains many of add_set or existing selected\n            # faster: check intersection size\n            if len((S | add_set) & grp) > 1:\n                return False\n        return True\n\n    # When adding item i, must also add its ancestors; return add_set or None if infeasible\n    def compute_add_closure(i, S):\n        # closure = ancestors[i] U {i}\n        add_set = set(ancestors[i])\n        add_set.add(i)\n        # If any of the add_set is already excluded by group conflict with S?\n        # Use feasible_union to check feasibility\n        # But need to also ensure add_set doesn't internally violate group/mutex\n        if not feasible_union(S, add_set):\n            return None\n        return add_set\n\n    # When removing item i, must remove its descendants as well\n    def compute_remove_closure(i, S):\n        rem_set = set(descendants[i])\n        rem_set.add(i)\n        # ensure rem_set is subset of S\n        rem_set = rem_set & set(S)\n        return rem_set\n\n    # Build initial solution using synergy-aware greedy\n    def initial_greedy_solution(seed=None):\n        if seed is not None:\n            random.seed(seed)\n        # compute base synergy potential for each item\n        potentials = []\n        for i in range(n):\n            pot = weights[i] if i < len(weights) else 0.0\n            # positive interactions potential with others\n            for j in range(n):\n                if j == i:\n                    continue\n                v = interactions.get((i,j), 0.0)\n                if v > 0:\n                    pot += 0.5 * v\n            potentials.append((pot, i))\n        # sort descending, but add slight random tie-breaker to diversify restarts\n        random.shuffle(potentials)\n        potentials.sort(key=lambda x: x[0], reverse=True)\n\n        S = set()\n        for _, i in potentials:\n            if len(S) >= max_card:\n                break\n            add_closure = compute_add_closure(i, S)\n            if add_closure is None:\n                continue\n            # If adding would not change S (all ancestors already present) still ok\n            # But ensure after adding, we still satisfy min constraints possibly later\n            S = S | add_closure\n        # If below min, try to add feasible items by best marginal gain\n        if len(S) < min_card:\n            candidates = [i for i in range(n) if i not in S]\n            # sort by marginal score heuristic\n            def marginal_gain(i):\n                add_closure = compute_add_closure(i, S)\n                if add_closure is None:\n                    return -1e9\n                newS = S | add_closure\n                return score_of_set(newS) - score_of_set(S)\n            candidates.sort(key=lambda i: marginal_gain(i), reverse=True)\n            for i in candidates:\n                if len(S) >= min_card:\n                    break\n                add_closure = compute_add_closure(i, S)\n                if add_closure is None:\n                    continue\n                S |= add_closure\n        # Trim if somehow exceeded max (shouldn't happen due to feasibility checks)\n        if len(S) > max_card:\n            # remove lowest weight leaves until within bound (remove items with no dependents first)\n            # simple greedy prune\n            removable = [i for i in S if len(descendants[i] & S) == 0]\n            removable.sort(key=lambda x: weights[x])\n            while len(S) > max_card and removable:\n                r = removable.pop(0)\n                S.remove(r)\n                # update removable\n                removable = [i for i in S if len(descendants[i] & S) == 0]\n                removable.sort(key=lambda x: weights[x])\n        return S\n\n    # Local search: try add, remove, and swap moves greedily until no improvement\n    def local_search(initial_S, max_iters=200):\n        S = set(initial_S)\n        best_S = set(S)\n        best_score = score_of_set(S)\n        improved = True\n        iters = 0\n        while improved and iters < max_iters:\n            iters += 1\n            improved = False\n            current_score = score_of_set(S)\n            # 1) Try best add move (first-improvement)\n            best_move = None\n            best_move_score = current_score\n            # consider items not in S\n            for j in range(n):\n                if j in S:\n                    continue\n                add_closure = compute_add_closure(j, S)\n                if add_closure is None:\n                    continue\n                newS = S | add_closure\n                # newS might include items that create new ancestors -- but closure already included\n                sc = score_of_set(newS)\n                if sc > best_move_score + 1e-9:\n                    best_move_score = sc\n                    best_move = (\"add\", j, add_closure)\n                    break  # first improvement\n            if best_move is not None:\n                # apply\n                S |= best_move[2]\n                improved = True\n                if best_move_score > best_score + 1e-9:\n                    best_score = best_move_score\n                    best_S = set(S)\n                continue\n\n            # 2) Try best swap moves: remove i (and its descendants) then add j's closure if feasible\n            # We'll do a limited number of candidate swaps for efficiency\n            # Build candidate lists sorted by weight to focus on promising swaps\n            current_items = sorted(list(S), key=lambda x: weights[x])\n            non_items = sorted([x for x in range(n) if x not in S], key=lambda x: -weights[x])\n            swap_found = False\n            for i in current_items:\n                rem_closure = compute_remove_closure(i, S)\n                S_after_rem = S - rem_closure\n                # if removing would drop below min and we won't be able to add enough, skip unless swap recovers\n                for j in non_items:\n                    # try add j to S_after_rem\n                    add_closure = compute_add_closure(j, S_after_rem)\n                    if add_closure is None:\n                        continue\n                    newS = S_after_rem | add_closure\n                    if len(newS) < min_card or len(newS) > max_card:\n                        continue\n                    sc = score_of_set(newS)\n                    if sc > best_score + 1e-9:\n                        S = newS\n                        best_score = sc\n                        best_S = set(S)\n                        improved = True\n                        swap_found = True\n                        break\n                    if sc > current_score + 1e-9:\n                        S = newS\n                        improved = True\n                        swap_found = True\n                        break\n                if swap_found:\n                    break\n            if swap_found:\n                continue\n\n            # 3) Try remove moves (allow only if still >= min_card)\n            for i in list(S):\n                rem_closure = compute_remove_closure(i, S)\n                newS = S - rem_closure\n                if len(newS) < min_card:\n                    continue\n                # Ensure removing doesn't violate any constraints (it shouldn't)\n                sc = score_of_set(newS)\n                if sc > best_score + 1e-9:\n                    S = newS\n                    best_score = sc\n                    best_S = set(S)\n                    improved = True\n                    break\n                if sc > current_score + 1e-9:\n                    S = newS\n                    improved = True\n                    break\n\n        return best_S, best_score\n\n    # Multi-start local search\n    best_overall = None\n    best_overall_score = -1e18\n    restarts = 5\n    # Use deterministic seed for reproducibility (unless randomness desired)\n    base_seed = 12345\n    for r in range(restarts):\n        seed = base_seed + r\n        init = initial_greedy_solution(seed=seed)\n        # If init violates min_card (<), try to add best marginal items\n        if len(init) < min_card:\n            # force-augment\n            candidates = [i for i in range(n) if i not in init]\n            while len(init) < min_card and candidates:\n                best_j = None; best_gain = -1e18\n                cur_score = score_of_set(init)\n                for j in candidates:\n                    add_cl = compute_add_closure(j, init)\n                    if add_cl is None:\n                        continue\n                    sc = score_of_set(init | add_cl) - cur_score\n                    if sc > best_gain:\n                        best_gain = sc; best_j = j\n                if best_j is None:\n                    break\n                addc = compute_add_closure(best_j, init)\n                if addc is None:\n                    break\n                init |= addc\n                candidates = [i for i in range(n) if i not in init]\n        # Ensure feasibility w.r.t groups/mutex and max_card\n        if len(init) > max_card:\n            # try pruning low contribution leaves\n            items = list(init)\n            items.sort(key=lambda x: weights[x])\n            for it in items:\n                if len(init) <= max_card:\n                    break\n                rem = compute_remove_closure(it, init)\n                init = init - rem\n\n        # Run local search\n        bestS, best_score = local_search(init, max_iters=300)\n        if best_score > best_overall_score + 1e-9:\n            best_overall_score = best_score\n            best_overall = bestS\n\n    # Final safety: ensure precedence closure and constraints satisfied for best_overall\n    if best_overall is None:\n        best_overall = set()\n    # close under precedence (should already be)\n    closure_changed = True\n    while closure_changed:\n        closure_changed = False\n        to_add = set()\n        for v in list(best_overall):\n            for a in ancestors[v]:\n                if a not in best_overall:\n                    to_add.add(a)\n        if to_add:\n            if feasible_union(best_overall, to_add):\n                best_overall |= to_add\n                closure_changed = True\n            else:\n                # cannot close; remove problematic items (those that require impossible ancestors)\n                # remove any item that has ancestors not feasible\n                removable = set()\n                for v in list(best_overall):\n                    need = set(ancestors[v]) | {v}\n                    if not feasible_union(best_overall - {v}, need - {v}):\n                        removable.add(v)\n                if not removable:\n                    # if nothing to remove, break to avoid infinite loop\n                    break\n                for r in removable:\n                    rem_cl = compute_remove_closure(r, best_overall)\n                    best_overall -= rem_cl\n                    closure_changed = True\n\n    # Enforce min_card by adding best marginal items if possible\n    S = set(best_overall)\n    if len(S) < min_card:\n        candidates = [i for i in range(n) if i not in S]\n        while len(S) < min_card and candidates:\n            best_j = None; best_gain = -1e18\n            cur_score = score_of_set(S)\n            for j in candidates:\n                add_cl = compute_add_closure(j, S)\n                if add_cl is None:\n                    continue\n                sc = score_of_set(S | add_cl) - cur_score\n                if sc > best_gain:\n                    best_gain = sc; best_j = j\n            if best_j is None:\n                break\n            addc = compute_add_closure(best_j, S)\n            if addc is None:\n                break\n            S |= addc\n            candidates = [i for i in range(n) if i not in S]\n\n    # Final trimming if > max_card (as last resort)\n    if len(S) > max_card:\n        # remove low weight leaves until within bound\n        leaves = [i for i in S if len(descendants[i] & S) == 0]\n        leaves.sort(key=lambda x: (weights[x], x))\n        while len(S) > max_card and leaves:\n            r = leaves.pop(0)\n            rem = compute_remove_closure(r, S)\n            S -= rem\n            leaves = [i for i in S if len(descendants[i] & S) == 0]\n            leaves.sort(key=lambda x: (weights[x], x))\n\n    result = {\"selection\": {\"variables\": sorted(list(S))}}\n    print(json.dumps(result))\n\n# EVOLVE-BLOCK-END\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n\n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n\n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n\n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n\n    result_str = stdout_capture.getvalue()\n    return result_str\n\n\nif __name__ == \"__main__\":\n    solve_sds()\n```"
            }
          ],
          "model_name": "gpt-5-mini",
          "kwargs": {
            "temperature": 1.0,
            "max_output_tokens": 8192
          },
          "input_tokens": 1505,
          "output_tokens": 5439,
          "cost": 0.011254249999999999,
          "input_cost": 0.00037624999999999996,
          "output_cost": 0.010877999999999999,
          "thought": "",
          "model_posteriors": {
            "gpt-5-mini": 1.0
          }
        },
        "diff_summary": {
          "added": 0,
          "deleted": 100,
          "modified": 1
        },
        "embed_cost": 0.0,
        "novelty_cost": 0.0,
        "stdout_log": "Evaluating program: sds_dataset_output/problem_0/gen_1/main.py\nSaving results to: sds_dataset_output/problem_0/gen_1/results\nEvaluation error: name 'solve_sds' is not defined\nCorrectness and error status saved to sds_dataset_output/problem_0/gen_1/results/correct.json\nMetrics saved to sds_dataset_output/problem_0/gen_1/results/metrics.json\nEvaluation or Validation failed: name 'solve_sds' is not defined\nMetrics:\n  combined_score: 0.0\n  execution_time_mean: 0.0\n  execution_time_std: 0.0\n  num_successful_runs: 0\n  num_valid_runs: 0\n  num_invalid_runs: 0\n  all_validation_errors: []\n",
        "stderr_log": "",
        "code_analysis_metrics": {
          "cyclomatic_complexity": 2,
          "average_cyclomatic_complexity": 2.0,
          "halstead_volume": 4.754887502163469,
          "halstead_difficulty": 0.5,
          "halstead_effort": 2.3774437510817346,
          "lines_of_code": 45,
          "logical_lines_of_code": 23,
          "comments": 6,
          "maintainability_index": 69.87504155694901,
          "max_nesting_depth": 3,
          "complexity_score": 0.296
        }
      },
      "in_archive": false
    },
    {
      "id": "831127dd-538f-4048-8e94-392255459053",
      "code": "\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n\n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n\n    Improved greedy + local search:\n    - Evaluate true marginal gains including interactions.\n    - Respect precedence by adding predecessor closures when needed.\n    - Enforce mutex and group constraints when considering additions.\n    - Perform simple 1-for-1 local-search swaps to improve objective.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n\n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    min_card, max_card = cardinality_bounds[0], cardinality_bounds[1]\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n\n    n = len(weights)\n\n    # Build interaction lookup function supporting both \"i,j\" keys and nested dicts\n    interaction_map = {}\n    # If interactions given as dict with string keys like \"i,j\"\n    for k, v in interactions.items():\n        if isinstance(k, str):\n            try:\n                i_s, j_s = k.split(\",\")\n                i, j = int(i_s), int(j_s)\n                if i > j:\n                    i, j = j, i\n                interaction_map[(i, j)] = float(v)\n            except Exception:\n                # fallback: ignore malformed keys\n                pass\n        elif isinstance(k, (list, tuple)) and len(k) == 2:\n            try:\n                i, j = int(k[0]), int(k[1])\n                if i > j:\n                    i, j = j, i\n                interaction_map[(i, j)] = float(v)\n            except Exception:\n                pass\n        else:\n            # maybe nested mapping interactions[i][j]\n            try:\n                # will handle below\n                pass\n            except Exception:\n                pass\n    # handle nested dict case: interactions may be like {i: {j: val}}\n    if not interaction_map:\n        try:\n            for i_key, row in interactions.items():\n                ii = int(i_key)\n                for j_key, v in row.items():\n                    jj = int(j_key)\n                    a, b = (ii, jj) if ii <= jj else (jj, ii)\n                    interaction_map[(a, b)] = float(v)\n        except Exception:\n            # If parsing fails, leave interaction_map empty\n            pass\n\n    def get_interaction(i, j):\n        a, b = (i, j) if i <= j else (j, i)\n        return interaction_map.get((a, b), 0.0)\n\n    # Build predecessor map for precedence constraints\n    preds = {i: set() for i in range(n)}\n    for p in precedence:\n        try:\n            pi, pj = int(p[0]), int(p[1])\n            # if pj selected then pi must be selected\n            preds[pj].add(pi)\n        except Exception:\n            pass\n    # compute transitive closure of predecessors for each node\n    pred_closure = {}\n    for i in range(n):\n        stack = list(preds.get(i, []))\n        closure = set()\n        while stack:\n            x = stack.pop()\n            if x in closure:\n                continue\n            closure.add(x)\n            for pp in preds.get(x, []):\n                if pp not in closure:\n                    stack.append(pp)\n        pred_closure[i] = closure\n\n    # Helper: check feasibility of a full candidate set S (set of indices)\n    def is_feasible_set(S):\n        # cardinality\n        if len(S) > max_card or len(S) < 0:\n            return False\n        # mutex: no pair both present\n        for a, b in mutex:\n            if a in S and b in S:\n                return False\n        # groups: at most one per group\n        for grp_vars in groups.values():\n            if len(set(grp_vars).intersection(S)) > 1:\n                return False\n        # precedence: for every j in S, all its preds must be in S\n        for j in list(S):\n            if not pred_closure.get(j):\n                # OK\n                pass\n            # direct preds\n            for pi in preds.get(j, set()):\n                if pi not in S:\n                    return False\n        return True\n\n    # Objective calculation\n    def objective(S):\n        S_list = list(S)\n        total = 0.0\n        for i in S_list:\n            total += weights[i] if i < len(weights) else 0.0\n        # pairwise interactions (count each pair once)\n        for idx in range(len(S_list)):\n            for jdx in range(idx+1, len(S_list)):\n                total += get_interaction(S_list[idx], S_list[jdx])\n        return total\n\n    # Function to compute marginal gain of adding set A (iterable) to current set S\n    def marginal_gain(S, A):\n        A = set(A) - set(S)\n        if not A:\n            return 0.0\n        gain = 0.0\n        for i in A:\n            gain += weights[i] if i < len(weights) else 0.0\n        # interactions between A and S\n        for i in A:\n            for j in S:\n                gain += get_interaction(i, j)\n        # interactions internal to A\n        A_list = list(A)\n        for ii in range(len(A_list)):\n            for jj in range(ii+1, len(A_list)):\n                gain += get_interaction(A_list[ii], A_list[jj])\n        return gain\n\n    # Helper: when trying to add item i, compute required closure (predecessors)\n    def closure_for(i, current_set):\n        # items that must be present if we include i: i plus all transitive predecessors\n        C = set([i])\n        for p in pred_closure.get(i, set()):\n            C.add(p)\n        # Some predecessors may themselves have predecessors already included by pred_closure\n        # pred_closure already transitive, so this suffices.\n        # Remove those already in current_set\n        return C - set(current_set)\n\n    # Main greedy: iteratively add the candidate (plus its preds) with best marginal gain\n    selected_set = set()\n    # We'll allow adding until no improvement or until max_card reached.\n    while len(selected_set) < max_card:\n        best_gain = None\n        best_add = None\n        # evaluate every candidate not in selected_set\n        for i in range(n):\n            if i in selected_set:\n                continue\n            # compute closure needed\n            add_set = closure_for(i, selected_set)\n            # if adding would exceed max_card, skip\n            if len(selected_set) + len(add_set) > max_card:\n                continue\n            # Check feasibility when adding\n            new_set = set(selected_set) | set(add_set)\n            if not is_feasible_set(new_set):\n                continue\n            gain = marginal_gain(selected_set, add_set)\n            if best_gain is None or gain > best_gain:\n                best_gain = gain\n                best_add = add_set\n        # Stop if nothing feasible to add\n        if best_add is None:\n            break\n        # If best_gain is negative and we've already reached min_card, stop adding further\n        if best_gain is not None and best_gain < 0 and len(selected_set) >= min_card:\n            break\n        # Otherwise add the best_add\n        selected_set |= set(best_add)\n\n    # If we haven't reached minimum cardinality, force-add best remaining items (respecting constraints)\n    if len(selected_set) < min_card:\n        # consider candidates by marginal gain ignoring negative cutoff\n        candidates = [i for i in range(n) if i not in selected_set]\n        # sort by simple heuristic gain (weight + sum positive interactions)\n        def heuristic_gain(i):\n            g = weights[i] if i < len(weights) else 0.0\n            for j in range(n):\n                if j == i:\n                    continue\n                g += abs(get_interaction(i, j)) * 0.2\n            return g\n        candidates.sort(key=heuristic_gain, reverse=True)\n        for i in candidates:\n            if len(selected_set) >= min_card:\n                break\n            add_set = closure_for(i, selected_set)\n            if len(selected_set) + len(add_set) > max_card:\n                continue\n            new_set = set(selected_set) | set(add_set)\n            if not is_feasible_set(new_set):\n                continue\n            selected_set |= set(add_set)\n\n    # Local search: try single-item swaps to improve objective (remove one, add one or add closure)\n    improved = True\n    max_iters = 500\n    it = 0\n    current_obj = objective(selected_set)\n    # Precompute all items list\n    all_items = set(range(n))\n    while improved and it < max_iters:\n        improved = False\n        it += 1\n        # iterate possible removals and additions\n        removed_item = None\n        added_items = None\n        best_obj = current_obj\n        for rem in list(selected_set):\n            # Try remove rem and try to add any outside item (with its closure w.r.t resulting set)\n            base_set = set(selected_set)\n            base_set.remove(rem)\n            # Ensure base_set is still feasible (removing may break precedence if rem was a predecessor of others)\n            if not is_feasible_set(base_set):\n                # Can't remove this item unless we also remove dependents; skip for simplicity\n                continue\n            for add in (all_items - base_set):\n                if add in base_set:\n                    continue\n                add_closure = closure_for(add, base_set)\n                candidate_set = set(base_set) | set(add_closure)\n                # respect cardinality\n                if len(candidate_set) < min_card or len(candidate_set) > max_card:\n                    continue\n                if not is_feasible_set(candidate_set):\n                    continue\n                obj = objective(candidate_set)\n                if obj > best_obj + 1e-9:\n                    best_obj = obj\n                    removed_item = rem\n                    added_items = set(add_closure)\n        if best_obj > current_obj + 1e-9 and removed_item is not None:\n            # apply improvement\n            selected_set.remove(removed_item)\n            selected_set |= set(added_items)\n            current_obj = best_obj\n            improved = True\n\n    # Final safety: ensure feasibility (if not, fall back to greedy selection by weight)\n    if not is_feasible_set(selected_set):\n        selected_set = set()\n        for i in sorted(range(n), key=lambda x: weights[x], reverse=True):\n            if len(selected_set) >= max_card:\n                break\n            add_set = closure_for(i, selected_set)\n            if len(selected_set) + len(add_set) > max_card:\n                continue\n            new_set = set(selected_set) | set(add_set)\n            if not is_feasible_set(new_set):\n                continue\n            selected_set |= set(add_set)\n        # fill up if still below min_card\n        i = 0\n        while len(selected_set) < min_card and i < n:\n            if i not in selected_set:\n                add_set = closure_for(i, selected_set)\n                if len(selected_set) + len(add_set) <= max_card:\n                    new_set = set(selected_set) | set(add_set)\n                    if is_feasible_set(new_set):\n                        selected_set |= set(add_set)\n            i += 1\n\n    result = {\n        \"selection\": {\n            \"variables\": sorted(list(selected_set))\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n\n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n\n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n\n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n\n    result_str = stdout_capture.getvalue()\n    return result_str\n",
      "language": "python",
      "parent_id": "051ec677-21ad-422b-9eff-f6fe22d20b09",
      "archive_inspiration_ids": [],
      "top_k_inspiration_ids": [],
      "island_idx": 1,
      "generation": 2,
      "timestamp": 1764668001.675686,
      "code_diff": "--- a/original.py\n+++ b/original.py\n@@ -1,144 +1,340 @@\n \"\"\"\n Initial solution for Synergistic Dependency Selection (SDS) problem.\n The code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n \"\"\"\n \n import json\n import sys\n import contextlib\n \n # EVOLVE-BLOCK-START\n def solve_sds():\n     \"\"\"\n     Solve the Synergistic Dependency Selection problem.\n \n     Reads from stdin: JSON with \"requirements\" and \"catalog\"\n     Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n \n-    This is a greedy baseline - evolution will improve this.\n+    Improved greedy + local search:\n+    - Evaluate true marginal gains including interactions.\n+    - Respect precedence by adding predecessor closures when needed.\n+    - Enforce mutex and group constraints when considering additions.\n+    - Perform simple 1-for-1 local-search swaps to improve objective.\n     \"\"\"\n     # Read input\n     input_data = json.load(sys.stdin)\n     requirements = input_data.get(\"requirements\", {})\n     catalog = input_data.get(\"catalog\", {})\n \n     # Extract constraints\n     weights = requirements.get(\"weights\", [])\n     interactions = requirements.get(\"interactions\", {})\n     cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n+    min_card, max_card = cardinality_bounds[0], cardinality_bounds[1]\n     mutex = requirements.get(\"mutex\", [])\n     groups = requirements.get(\"groups\", {})\n     precedence = requirements.get(\"precedence\", [])\n \n-    # Simple greedy: select items with highest weights first\n-    # This is a baseline - evolution will find better strategies\n     n = len(weights)\n-    selected = []\n-\n-    # Create score list (weight + interaction potential)\n-    scores = []\n+\n+    # Build interaction lookup function supporting both \"i,j\" keys and nested dicts\n+    interaction_map = {}\n+    # If interactions given as dict with string keys like \"i,j\"\n+    for k, v in interactions.items():\n+        if isinstance(k, str):\n+            try:\n+                i_s, j_s = k.split(\",\")\n+                i, j = int(i_s), int(j_s)\n+                if i > j:\n+                    i, j = j, i\n+                interaction_map[(i, j)] = float(v)\n+            except Exception:\n+                # fallback: ignore malformed keys\n+                pass\n+        elif isinstance(k, (list, tuple)) and len(k) == 2:\n+            try:\n+                i, j = int(k[0]), int(k[1])\n+                if i > j:\n+                    i, j = j, i\n+                interaction_map[(i, j)] = float(v)\n+            except Exception:\n+                pass\n+        else:\n+            # maybe nested mapping interactions[i][j]\n+            try:\n+                # will handle below\n+                pass\n+            except Exception:\n+                pass\n+    # handle nested dict case: interactions may be like {i: {j: val}}\n+    if not interaction_map:\n+        try:\n+            for i_key, row in interactions.items():\n+                ii = int(i_key)\n+                for j_key, v in row.items():\n+                    jj = int(j_key)\n+                    a, b = (ii, jj) if ii <= jj else (jj, ii)\n+                    interaction_map[(a, b)] = float(v)\n+        except Exception:\n+            # If parsing fails, leave interaction_map empty\n+            pass\n+\n+    def get_interaction(i, j):\n+        a, b = (i, j) if i <= j else (j, i)\n+        return interaction_map.get((a, b), 0.0)\n+\n+    # Build predecessor map for precedence constraints\n+    preds = {i: set() for i in range(n)}\n+    for p in precedence:\n+        try:\n+            pi, pj = int(p[0]), int(p[1])\n+            # if pj selected then pi must be selected\n+            preds[pj].add(pi)\n+        except Exception:\n+            pass\n+    # compute transitive closure of predecessors for each node\n+    pred_closure = {}\n     for i in range(n):\n-        score = weights[i] if i < len(weights) else 0.0\n-        # Add potential interaction value\n-        for k, v in interactions.items():\n-            try:\n-                u, w = map(int, k.split(\",\"))\n-                if u == i or w == i:\n-                    score += abs(v) * 0.5  # Potential value\n-            except:\n-                pass\n-        scores.append((score, i))\n-\n-    # Sort by score descending\n-    scores.sort(reverse=True)\n-\n-    # Greedy selection respecting constraints\n+        stack = list(preds.get(i, []))\n+        closure = set()\n+        while stack:\n+            x = stack.pop()\n+            if x in closure:\n+                continue\n+            closure.add(x)\n+            for pp in preds.get(x, []):\n+                if pp not in closure:\n+                    stack.append(pp)\n+        pred_closure[i] = closure\n+\n+    # Helper: check feasibility of a full candidate set S (set of indices)\n+    def is_feasible_set(S):\n+        # cardinality\n+        if len(S) > max_card or len(S) < 0:\n+            return False\n+        # mutex: no pair both present\n+        for a, b in mutex:\n+            if a in S and b in S:\n+                return False\n+        # groups: at most one per group\n+        for grp_vars in groups.values():\n+            if len(set(grp_vars).intersection(S)) > 1:\n+                return False\n+        # precedence: for every j in S, all its preds must be in S\n+        for j in list(S):\n+            if not pred_closure.get(j):\n+                # OK\n+                pass\n+            # direct preds\n+            for pi in preds.get(j, set()):\n+                if pi not in S:\n+                    return False\n+        return True\n+\n+    # Objective calculation\n+    def objective(S):\n+        S_list = list(S)\n+        total = 0.0\n+        for i in S_list:\n+            total += weights[i] if i < len(weights) else 0.0\n+        # pairwise interactions (count each pair once)\n+        for idx in range(len(S_list)):\n+            for jdx in range(idx+1, len(S_list)):\n+                total += get_interaction(S_list[idx], S_list[jdx])\n+        return total\n+\n+    # Function to compute marginal gain of adding set A (iterable) to current set S\n+    def marginal_gain(S, A):\n+        A = set(A) - set(S)\n+        if not A:\n+            return 0.0\n+        gain = 0.0\n+        for i in A:\n+            gain += weights[i] if i < len(weights) else 0.0\n+        # interactions between A and S\n+        for i in A:\n+            for j in S:\n+                gain += get_interaction(i, j)\n+        # interactions internal to A\n+        A_list = list(A)\n+        for ii in range(len(A_list)):\n+            for jj in range(ii+1, len(A_list)):\n+                gain += get_interaction(A_list[ii], A_list[jj])\n+        return gain\n+\n+    # Helper: when trying to add item i, compute required closure (predecessors)\n+    def closure_for(i, current_set):\n+        # items that must be present if we include i: i plus all transitive predecessors\n+        C = set([i])\n+        for p in pred_closure.get(i, set()):\n+            C.add(p)\n+        # Some predecessors may themselves have predecessors already included by pred_closure\n+        # pred_closure already transitive, so this suffices.\n+        # Remove those already in current_set\n+        return C - set(current_set)\n+\n+    # Main greedy: iteratively add the candidate (plus its preds) with best marginal gain\n     selected_set = set()\n-    for score, i in scores:\n-        if len(selected_set) >= cardinality_bounds[1]:\n+    # We'll allow adding until no improvement or until max_card reached.\n+    while len(selected_set) < max_card:\n+        best_gain = None\n+        best_add = None\n+        # evaluate every candidate not in selected_set\n+        for i in range(n):\n+            if i in selected_set:\n+                continue\n+            # compute closure needed\n+            add_set = closure_for(i, selected_set)\n+            # if adding would exceed max_card, skip\n+            if len(selected_set) + len(add_set) > max_card:\n+                continue\n+            # Check feasibility when adding\n+            new_set = set(selected_set) | set(add_set)\n+            if not is_feasible_set(new_set):\n+                continue\n+            gain = marginal_gain(selected_set, add_set)\n+            if best_gain is None or gain > best_gain:\n+                best_gain = gain\n+                best_add = add_set\n+        # Stop if nothing feasible to add\n+        if best_add is None:\n             break\n-\n-        # Check mutex constraints\n-        can_add = True\n-        for a, b in mutex:\n-            if (a == i and b in selected_set) or (b == i and a in selected_set):\n-                can_add = False\n+        # If best_gain is negative and we've already reached min_card, stop adding further\n+        if best_gain is not None and best_gain < 0 and len(selected_set) >= min_card:\n+            break\n+        # Otherwise add the best_add\n+        selected_set |= set(best_add)\n+\n+    # If we haven't reached minimum cardinality, force-add best remaining items (respecting constraints)\n+    if len(selected_set) < min_card:\n+        # consider candidates by marginal gain ignoring negative cutoff\n+        candidates = [i for i in range(n) if i not in selected_set]\n+        # sort by simple heuristic gain (weight + sum positive interactions)\n+        def heuristic_gain(i):\n+            g = weights[i] if i < len(weights) else 0.0\n+            for j in range(n):\n+                if j == i:\n+                    continue\n+                g += abs(get_interaction(i, j)) * 0.2\n+            return g\n+        candidates.sort(key=heuristic_gain, reverse=True)\n+        for i in candidates:\n+            if len(selected_set) >= min_card:\n                 break\n-\n-        if not can_add:\n-            continue\n-\n-        # Check group constraints (at most one per group)\n-        for grp_vars in groups.values():\n-            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n-                can_add = False\n+            add_set = closure_for(i, selected_set)\n+            if len(selected_set) + len(add_set) > max_card:\n+                continue\n+            new_set = set(selected_set) | set(add_set)\n+            if not is_feasible_set(new_set):\n+                continue\n+            selected_set |= set(add_set)\n+\n+    # Local search: try single-item swaps to improve objective (remove one, add one or add closure)\n+    improved = True\n+    max_iters = 500\n+    it = 0\n+    current_obj = objective(selected_set)\n+    # Precompute all items list\n+    all_items = set(range(n))\n+    while improved and it < max_iters:\n+        improved = False\n+        it += 1\n+        # iterate possible removals and additions\n+        removed_item = None\n+        added_items = None\n+        best_obj = current_obj\n+        for rem in list(selected_set):\n+            # Try remove rem and try to add any outside item (with its closure w.r.t resulting set)\n+            base_set = set(selected_set)\n+            base_set.remove(rem)\n+            # Ensure base_set is still feasible (removing may break precedence if rem was a predecessor of others)\n+            if not is_feasible_set(base_set):\n+                # Can't remove this item unless we also remove dependents; skip for simplicity\n+                continue\n+            for add in (all_items - base_set):\n+                if add in base_set:\n+                    continue\n+                add_closure = closure_for(add, base_set)\n+                candidate_set = set(base_set) | set(add_closure)\n+                # respect cardinality\n+                if len(candidate_set) < min_card or len(candidate_set) > max_card:\n+                    continue\n+                if not is_feasible_set(candidate_set):\n+                    continue\n+                obj = objective(candidate_set)\n+                if obj > best_obj + 1e-9:\n+                    best_obj = obj\n+                    removed_item = rem\n+                    added_items = set(add_closure)\n+        if best_obj > current_obj + 1e-9 and removed_item is not None:\n+            # apply improvement\n+            selected_set.remove(removed_item)\n+            selected_set |= set(added_items)\n+            current_obj = best_obj\n+            improved = True\n+\n+    # Final safety: ensure feasibility (if not, fall back to greedy selection by weight)\n+    if not is_feasible_set(selected_set):\n+        selected_set = set()\n+        for i in sorted(range(n), key=lambda x: weights[x], reverse=True):\n+            if len(selected_set) >= max_card:\n                 break\n-\n-        if not can_add:\n-            continue\n-\n-        # Check precedence (if j selected, i must be selected)\n-        precedence_ok = True\n-        for pred_i, pred_j in precedence:\n-            if pred_j == i and pred_i not in selected_set:\n-                precedence_ok = False\n-                break\n-\n-        if not precedence_ok:\n-            continue\n-\n-        # Add if we meet minimum cardinality or have room\n-        if len(selected_set) < cardinality_bounds[1]:\n-            selected_set.add(i)\n-            selected.append(i)\n-\n-    # Ensure minimum cardinality\n-    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n-        for i in range(n):\n+            add_set = closure_for(i, selected_set)\n+            if len(selected_set) + len(add_set) > max_card:\n+                continue\n+            new_set = set(selected_set) | set(add_set)\n+            if not is_feasible_set(new_set):\n+                continue\n+            selected_set |= set(add_set)\n+        # fill up if still below min_card\n+        i = 0\n+        while len(selected_set) < min_card and i < n:\n             if i not in selected_set:\n-                selected_set.add(i)\n-                selected.append(i)\n-                break\n-\n-    # Output result\n+                add_set = closure_for(i, selected_set)\n+                if len(selected_set) + len(add_set) <= max_card:\n+                    new_set = set(selected_set) | set(add_set)\n+                    if is_feasible_set(new_set):\n+                        selected_set |= set(add_set)\n+            i += 1\n+\n     result = {\n         \"selection\": {\n-            \"variables\": sorted(selected)\n+            \"variables\": sorted(list(selected_set))\n         }\n     }\n     print(json.dumps(result))\n # EVOLVE-BLOCK-END\n \n \n # This part remains fixed (not evolved)\n def run_sds(problem_data=None):\n     \"\"\"\n     Main function called by the evaluator.\n     Can accept problem_data as parameter or read from stdin.\n     Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n     \"\"\"\n     import sys\n     import json\n     import io\n \n     if problem_data is None:\n         # Read from stdin (for compatibility)\n         input_data = json.load(sys.stdin)\n     else:\n         # Use provided problem data\n         input_data = problem_data\n \n     # Capture stdout from solve_sds\n     stdout_capture = io.StringIO()\n     old_stdin = sys.stdin\n \n     try:\n         # Create mock stdin\n         sys.stdin = io.StringIO(json.dumps(input_data))\n         with contextlib.redirect_stdout(stdout_capture):\n             solve_sds()\n     finally:\n         sys.stdin = old_stdin\n \n     result_str = stdout_capture.getvalue()\n     return result_str\n",
      "combined_score": 0.4306669471949661,
      "public_metrics": {
        "feasible": true,
        "selection_size": 10,
        "raw_score": 132.16052771701814
      },
      "private_metrics": {
        "selection": [
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          14
        ],
        "raw_score": 132.16052771701814,
        "normalized_fitness": 0.4306669471949661
      },
      "text_feedback": "",
      "correct": true,
      "children_count": 0,
      "complexity": 1.0,
      "embedding": [
        0.020278046,
        -0.001004223,
        0.017035495,
        -0.031264003,
        0.0130428,
        0.023387508,
        0.04055609,
        0.0030898007,
        -0.024682108,
        0.0300057,
        0.039346185,
        -0.059963007,
        -0.026835743,
        0.016612027,
        0.013635655,
        -0.04162081,
        0.04527473,
        0.008112429,
        -0.0051421057,
        -0.00028319392,
        0.05168724,
        0.023060832,
        0.03627302,
        0.03225613,
        0.0044040624,
        -0.018233303,
        0.04372605,
        0.093985595,
        0.037507124,
        -0.038184673,
        0.037942693,
        -0.005964843,
        -0.03668439,
        0.00257559,
        -0.00770106,
        0.034361366,
        0.0063701617,
        0.024294939,
        -0.042443547,
        -0.009370732,
        -0.0017740265,
        -0.029207163,
        -0.02413765,
        0.008318112,
        -0.0030731645,
        -0.02036274,
        0.0009217981,
        -0.00992729,
        0.02401666,
        -0.020241749,
        -0.039249394,
        0.024367534,
        0.013200088,
        -2.830994e-05,
        -0.003929174,
        -0.029957304,
        0.013321079,
        0.014313203,
        -0.0013082123,
        0.0047609853,
        0.022770455,
        -0.041959584,
        0.042491943,
        0.01448259,
        -0.008681085,
        0.014942355,
        0.009491723,
        0.004159056,
        -0.027101923,
        -0.023496399,
        -0.047936525,
        -0.011760299,
        0.00926789,
        -0.024319137,
        0.0006582652,
        0.022334889,
        0.033393443,
        0.03736194,
        0.012274509,
        -0.03849925,
        -0.048904452,
        -0.023290716,
        -0.0005644974,
        -0.0274165,
        -0.06093093,
        -0.07941832,
        -0.008209221,
        0.024488524,
        -0.044597182,
        -0.061802063,
        -0.012800819,
        -0.011282385,
        -0.067561224,
        0.025722628,
        0.02033854,
        -0.04539572,
        0.048468888,
        -0.021693638,
        0.020157056,
        0.007555871,
        0.007229196,
        -0.037265144,
        0.009945438,
        -0.034651745,
        0.008112429,
        0.024512721,
        0.03194155,
        0.03508731,
        0.010877066,
        -0.015341625,
        -0.035547078,
        0.027852066,
        0.01592238,
        0.039491374,
        0.023520598,
        -0.053090733,
        -0.054591015,
        -0.011978082,
        0.003484533,
        -0.020810405,
        -0.012740323,
        -0.009050107,
        -0.005940645,
        0.03956397,
        -0.010374955,
        0.031312402,
        0.027053528,
        -0.076514535,
        -0.032570705,
        0.006799679,
        0.060059797,
        0.010973859,
        -0.002681457,
        -0.043677654,
        -0.06572217,
        -0.031360798,
        -0.03552288,
        -0.013635655,
        -0.022395384,
        0.03900741,
        0.024052957,
        0.0015517061,
        -0.006503252,
        0.019491607,
        -0.046896007,
        -0.018717267,
        -0.00027922392,
        0.011965983,
        -0.089097574,
        0.04580709,
        0.046581432,
        -0.026013007,
        0.0065093013,
        0.0051723537,
        0.0638831,
        -0.0600114,
        -0.040362507,
        0.010635085,
        0.06383471,
        -0.033369243,
        -0.017955024,
        0.0031608827,
        -0.0039049757,
        -0.0056442176,
        0.033877403,
        -0.024040857,
        -0.042007983,
        0.036079437,
        -0.041306235,
        -0.027658481,
        0.00068700046,
        -0.09016229,
        -0.0084149055,
        0.010580639,
        0.0034573101,
        -0.017047593,
        -0.009255791,
        -0.027803669,
        0.008148725,
        -0.03196575,
        -0.038015287,
        -0.019128634,
        -0.01761625,
        -0.053235922,
        -0.02076201,
        -0.044742372,
        -0.013563061,
        -0.006999314,
        0.009945438,
        0.0102842115,
        -0.01161511,
        0.023472201,
        0.01944321,
        -0.017120188,
        0.004446409,
        -0.018741464,
        0.05430064,
        0.0456619,
        -0.005744035,
        0.025722628,
        0.025746828,
        -0.0010503507,
        0.037676513,
        -0.033127263,
        -0.012032528,
        -0.02531126,
        -0.05386507,
        -0.016878206,
        -0.0058771246,
        -0.04476657,
        0.03119141,
        -0.02949754,
        -0.002767663,
        0.049364217,
        0.049654596,
        0.0115606645,
        -0.025625836,
        0.0007803902,
        -0.010610887,
        0.04817851,
        -0.026908338,
        0.01201438,
        -0.0039080004,
        0.013514664,
        0.007779704,
        0.04779134,
        -0.013175891,
        -0.035668068,
        0.016019173,
        -0.046823412,
        -0.0039594215,
        -0.0043163444,
        0.004748886,
        0.034942124,
        -0.008348361,
        -0.032159336,
        -0.026738951,
        0.013514664,
        0.009515921,
        -0.0068843723,
        0.031796362,
        -0.009243691,
        -0.0023336087,
        0.0035541027,
        0.014047024,
        -0.005012041,
        -0.03663599,
        -0.00215061,
        -0.0021899322,
        -0.0050453134,
        0.017713042,
        -0.0248031,
        0.029037775,
        -0.025383854,
        -0.022310691,
        -0.036998965,
        -0.018063916,
        -0.02036274,
        -0.008118478,
        0.053090733,
        -0.059963007,
        0.00087264564,
        0.015813489,
        -0.02270996,
        -0.0378459,
        0.010229766,
        0.01030236,
        -0.007059809,
        -0.0037174402,
        -0.0011138709,
        -0.0064185583,
        0.029449143,
        -0.047428366,
        0.019116536,
        -0.03501472,
        -0.0011214329,
        -0.0034936073,
        0.06819037,
        -0.024827298,
        -0.022431681,
        -0.067028865,
        0.0043677655,
        0.040168922,
        0.0033514432,
        0.053235922,
        0.004594623,
        -0.007217097,
        0.0059708925,
        0.00050853915,
        0.030949429,
        0.0007550578,
        -0.019600498,
        0.026472772,
        -0.048904452,
        -0.03068325,
        -0.025722628,
        -0.002563491,
        0.026980933,
        0.020302244,
        0.0027510268,
        0.08116058,
        0.015849786,
        0.0047882083,
        -0.014264807,
        -0.028384425,
        -0.018426888,
        0.03600684,
        -0.04321789,
        0.023980362,
        0.029981503,
        -0.01513594,
        0.0020402062,
        0.009038008,
        -0.0025892016,
        -0.031772166,
        -0.01644264,
        0.059866212,
        -0.03027188,
        0.037966892,
        0.0062552206,
        -0.025553241,
        0.0014866736,
        0.030489665,
        0.00075581396,
        0.021282269,
        -0.06083414,
        -0.016382145,
        -0.0030293055,
        0.0025287063,
        -0.02062892,
        -0.030828437,
        0.0130186025,
        0.03929779,
        0.04711379,
        -0.001129751,
        -0.0613181,
        0.021911422,
        0.009667159,
        0.019878777,
        0.0032092792,
        -0.025892016,
        -0.0014707935,
        -0.032715894,
        -0.044355202,
        0.015752994,
        -0.019806182,
        -0.038959015,
        0.07215887,
        0.05468781,
        -0.014034924,
        0.009969636,
        -0.0021218748,
        -0.014833463,
        0.043096896,
        -0.01996347,
        -0.013200088,
        -0.01853578,
        -0.013889736,
        -0.024500623,
        -0.032159336,
        0.025141874,
        -0.0021551473,
        -0.011863141,
        0.0046399944,
        -0.020072361,
        0.023556896,
        -0.03513571,
        0.022613168,
        0.006303617,
        -0.009618763,
        0.04646044,
        0.041330434,
        -0.023859372,
        0.012292658,
        -0.07303,
        -0.0061554033,
        0.004394988,
        0.032014146,
        0.027948858,
        0.048759263,
        -0.018741464,
        0.017446863,
        -0.015946578,
        -0.013829241,
        0.01500285,
        0.0005066487,
        -0.022044512,
        -0.020713612,
        -0.030973626,
        -0.01918913,
        0.033490233,
        -0.031264003,
        0.02270996,
        0.0062310225,
        -0.005795456,
        0.012462045,
        0.009697407,
        0.020653117,
        0.019999767,
        0.033248253,
        0.0068843723,
        0.004401038,
        -0.009455426,
        -0.052800354,
        -0.038692836,
        -0.006067685,
        0.03588585,
        0.035305094,
        0.014107519,
        -0.009890992,
        0.03709576,
        0.01839059,
        0.042733926,
        -0.005704713,
        0.02193562,
        -0.0053326664,
        -0.0339258,
        0.046121664,
        0.023544796,
        0.06402829,
        0.003923124,
        -0.0041832547,
        0.038402457,
        -0.0352325,
        -0.015220634,
        0.03206254,
        0.047258977,
        -0.02427074,
        0.062431216,
        0.021221774,
        -0.01422851,
        0.04135463,
        0.05492979,
        0.00081366266,
        0.0017634399,
        0.05062252,
        0.033514433,
        0.02360529,
        0.02896518,
        -0.019201228,
        -0.014397897,
        0.0091166515,
        0.033345044,
        0.0067512826,
        -0.009098503,
        0.012062776,
        0.022601068,
        -0.0024697233,
        0.034240376,
        0.026133997,
        0.0074167317,
        -0.01605547,
        0.02153635,
        -0.014676175,
        0.008433054,
        0.011185593,
        0.04803332,
        -0.026254987,
        0.054349035,
        -0.01149412,
        0.06402829,
        0.055268563,
        -0.029061973,
        0.018632572,
        0.00965506,
        0.028118245,
        0.03206254,
        0.014409996,
        -0.027464895,
        0.046896007,
        0.020907197,
        -0.0021702712,
        -0.054736204,
        -0.008499599,
        -0.021717835,
        -0.036466606,
        0.033248253,
        0.0034210128,
        0.0011509244,
        0.009884942,
        0.0008560094,
        -0.010290261,
        0.007186849,
        0.019745687,
        0.027053528,
        0.044814967,
        0.0017105064,
        -0.034022592,
        -0.021209674,
        6.758467e-05,
        0.022637365,
        0.0049515455,
        0.017253278,
        -0.012214014,
        -0.00874763,
        -0.03612783,
        -0.016224857,
        0.028553812,
        -0.024125552,
        -0.008995661,
        0.025020882,
        -0.023496399,
        -0.051251672,
        0.05115488,
        0.039491374,
        -0.013563061,
        0.006125156,
        -0.02964273,
        -0.013696151,
        0.004585549,
        -0.029037775,
        0.019491607,
        -0.034240376,
        0.031046221,
        0.0391768,
        0.0023230219,
        -0.036563396,
        -0.03849925,
        -0.013841339,
        0.014168015,
        -0.008269716,
        -0.03039287,
        -0.017301675,
        0.010399153,
        -0.0014458392,
        -0.023327012,
        0.022117104,
        -0.08135416,
        -0.033490233,
        -0.0136598535,
        0.010489896,
        -0.008892818,
        -0.049001247,
        0.07414312,
        -0.038692836,
        -0.005181428,
        -0.030078296,
        -0.02937655,
        -0.026908338,
        0.011536466,
        -0.0043375175,
        -0.015051247,
        -0.033127263,
        -0.0111553455,
        0.031264003,
        -0.026593762,
        0.06083414,
        0.0060465117,
        -0.00861454,
        -0.00026712485,
        -0.02492409,
        -0.02060472,
        -0.0120869735,
        0.0108044725,
        -0.013490466,
        0.005039264,
        -0.03276429,
        -0.014397897,
        -0.013780844,
        -0.036442406,
        0.0011168957,
        -0.0009845621,
        0.01853578,
        0.009515921,
        -0.023242319,
        -0.008306013,
        0.053235922,
        0.02179043,
        -0.018245403,
        0.011252138,
        0.007543772,
        -0.021996114,
        0.017700944,
        -0.06770641,
        0.047428366,
        0.027198715,
        -0.013393674,
        -0.031675372,
        -0.010810521,
        -0.004283072,
        -0.01370825,
        -0.018027619,
        -0.0031276103,
        -0.0133694755,
        -0.07472388,
        0.0053447653,
        -0.020132856,
        0.010387054,
        0.018826157,
        0.001307456,
        -0.001839059,
        -0.0016061519,
        0.020943495,
        0.008862571,
        -0.011717952,
        0.0007422025,
        -0.020701515,
        -0.00808218,
        -0.004343567,
        0.023508498,
        0.022419581,
        -0.042104773,
        0.019866677,
        0.018693067,
        -0.043895435,
        -0.012837117,
        0.054881394,
        0.014942355,
        0.021766232,
        0.021572648,
        -0.014313203,
        -0.030925231,
        0.014107519,
        -0.003953372,
        -0.044718172,
        0.010005933,
        -0.031409193,
        0.038426656,
        0.014712472,
        -0.01721698,
        0.01265563,
        -0.009552218,
        0.0069872146,
        0.02244378,
        0.04290331,
        -0.006031388,
        0.004255849,
        0.014361599,
        -0.009237642,
        -0.027222915,
        -0.02584362,
        -0.002008446,
        -0.012994404,
        0.0054234094,
        -0.017313773,
        -0.008015635,
        0.015305327,
        -0.0015282641,
        -0.009957537,
        0.017858231,
        0.017277475,
        0.012691927,
        0.001047326,
        -0.041596614,
        0.031530183,
        0.015813489,
        -0.025238667,
        -0.0011380691,
        0.031457588,
        -0.014240609,
        -0.023968263,
        -0.006185651,
        0.0025453425,
        -0.02164524,
        0.050477333,
        0.042830717,
        0.007374385,
        -0.023145527,
        -0.014978652,
        0.0031608827,
        -0.0060495366,
        -0.025214467,
        0.01764045,
        0.04411322,
        0.006212874,
        0.028602209,
        0.029691124,
        0.039080005,
        0.014458392,
        0.0058136047,
        -0.051493656,
        -0.0066242423,
        0.03288528,
        -0.013260584,
        -0.005949719,
        -0.023774678,
        0.025892016,
        0.0010049792,
        -0.03457915,
        0.018233303,
        -0.005414335,
        0.011639308,
        -0.018039718,
        0.0066242423,
        0.016974999,
        -0.042346757,
        0.015486813,
        0.00861454,
        0.012050676,
        0.014676175,
        0.012679828,
        0.010266064,
        -0.008263667,
        -0.019140733,
        0.037870098,
        0.029328153,
        0.011397326,
        0.032425515,
        -0.028142443,
        -0.098292865,
        0.00010775737,
        0.023399606,
        0.0052933446,
        -0.0014314716,
        -0.014506788,
        -0.02387147,
        -0.019358516,
        0.01617646,
        0.024682108,
        0.0062068244,
        -0.0023215096,
        0.02179043,
        -0.0123773515,
        -0.009884942,
        -0.011984131,
        0.00770106,
        0.035982642,
        0.017567854,
        0.023218121,
        -0.020096561,
        -0.05362309,
        -0.02896518,
        -0.017458962,
        0.0085358955,
        -0.06451226,
        -0.036708586,
        -0.023072932,
        0.035813257,
        0.0064004096,
        -0.0026572589,
        0.022552673,
        -0.006956967,
        -0.028505417,
        0.020810405,
        -0.0040108426,
        -0.019056039,
        -0.029158765,
        0.0022489151,
        -0.027561689,
        0.034482356,
        -0.005492979,
        -0.0070356107,
        0.023641588,
        0.011209791,
        -0.031989947,
        -0.008796026,
        0.0043919636,
        0.02284305,
        -0.03353863,
        0.027731076,
        -0.036031038,
        0.007991438,
        -0.008348361,
        -0.0050816108,
        0.024440126,
        0.010713729,
        0.023169724,
        -0.0033090964,
        -0.027585886,
        0.016345847,
        -0.017047593,
        -0.011149296,
        -0.046557233,
        0.00939493,
        0.013284782,
        0.02036274,
        0.008487499,
        -0.0154626155,
        0.016841909,
        0.02988471,
        0.026158195,
        0.011016206,
        0.006926719,
        0.0071989484,
        0.011203742,
        -0.012776621,
        -0.0064125084,
        -0.04529893,
        0.01252254,
        0.019769885,
        0.021778332,
        0.002693556,
        -0.010278163,
        0.026714753,
        0.018463185,
        -0.012147469,
        -0.0023018487,
        -0.0020976767,
        0.027779471,
        -0.044064824,
        -0.02833603,
        0.008989611,
        -0.0024198145,
        0.029787917,
        -0.017337972,
        0.045371525,
        -0.035619672,
        -0.119442046,
        -0.005247973,
        0.0007221634,
        -0.0152327325,
        0.012159568,
        -0.01972149,
        0.024089254,
        0.0099333385,
        -0.0120869735,
        -0.01265563,
        -0.03220773,
        -0.020399038,
        0.011590912,
        0.02047163,
        0.01226846,
        -0.0097579025,
        -0.01841479,
        0.0040501645,
        0.022177601,
        -0.03206254,
        -0.011028305,
        0.014990752,
        -0.004059239,
        0.012226113,
        -0.045492515,
        -0.0026043255,
        0.006358063,
        0.04684761,
        -0.0017664647,
        -0.00027695534,
        0.003157858,
        0.0034149634,
        -0.008965413,
        0.045056947,
        -0.026811546,
        0.004709564,
        0.010018032,
        -0.0043102945,
        -0.014264807,
        0.015438417,
        0.016152263,
        -0.014034924,
        0.027779471,
        -0.06625453,
        0.020205451,
        0.0143011045,
        -0.019612597,
        -0.0077918028,
        -0.0061614527,
        0.042080574,
        0.0006310423,
        0.025408054,
        -0.023218121,
        -0.035329293,
        -0.021149179,
        0.026013007,
        0.011990181,
        0.005547425,
        -0.008396757,
        0.021306468,
        -0.031772166,
        -0.015777191,
        0.042274162,
        -0.026472772,
        -0.023351211,
        0.007852298,
        -0.020774107,
        -0.027876263,
        -0.011227939,
        0.025722628,
        -0.005453657,
        -0.0028538688,
        -0.022129204,
        -0.008935166,
        -0.047162186,
        0.033078864,
        0.011633258,
        -0.0070114126,
        -0.0057621836,
        -0.0042497995,
        0.05009016,
        -0.010786324,
        0.008929116,
        0.022020312,
        0.0010783299,
        0.03274009,
        0.017471062,
        0.03745873,
        -0.017422665,
        0.051009692,
        -0.0130428,
        -0.010725828,
        0.01422851,
        0.002153635,
        -0.03486953,
        0.0404351,
        0.015752994,
        -0.035668068,
        0.013091197,
        -0.0037023162,
        0.012873414,
        0.058898285,
        0.0057863817,
        -0.0025029958,
        -0.00020284852,
        0.03678118,
        -0.051735636,
        0.021826727,
        -0.010877066,
        0.016115965,
        0.007858348,
        0.0124378465,
        -0.04149982,
        0.027440697,
        -0.006563747,
        -0.024875693,
        0.0037083658,
        0.011125097,
        0.010247915,
        0.024597416,
        -0.009207395,
        0.046702422,
        -0.04254034,
        0.044911757,
        -0.030320277,
        0.016128065,
        0.0049666693,
        -0.01866887,
        -0.0139502315,
        0.009903091,
        0.008923066,
        -0.005925521,
        -0.02581942,
        0.06030178,
        0.0073925336,
        0.023786778,
        0.034216177,
        -0.021887222,
        -0.028432822,
        0.021258071,
        0.017241178,
        0.0037416383,
        -0.014131717,
        0.0029672976,
        -0.018342195,
        0.008433054,
        0.042104773,
        -0.018112313,
        -0.059914608,
        0.030876834,
        -0.016793514,
        -0.035595473,
        0.016841909,
        0.026133997,
        0.011500169,
        0.036031038,
        -0.0042891214,
        -0.021971917,
        -0.002413765,
        -0.036224626,
        0.0059285457,
        0.02845702,
        0.015438417,
        -0.017120188,
        0.037991088,
        0.023520598,
        0.00037847413,
        -0.029763719,
        0.00874763,
        0.007894645,
        -0.03692637,
        -0.01448259,
        -0.03232872,
        -0.0112158405,
        -0.00075581396,
        0.005362914,
        -0.012238212,
        0.009485673,
        0.0208951,
        0.03692637,
        0.001283258,
        0.042419348,
        -0.009189246,
        -0.00025219005,
        0.023254419,
        -0.0456619,
        -0.03065905,
        0.0014685249,
        0.00033726165,
        -0.013151692,
        0.018184906,
        0.015559408,
        0.0013293857,
        0.050961293,
        0.0038596042,
        0.03015089,
        -0.00796119,
        0.003889852,
        0.049170632,
        -0.03501472,
        -0.008106379,
        0.019915074,
        0.026617961,
        -0.055655736,
        0.009183196,
        0.051300067,
        0.008051933,
        0.0054324837,
        -0.0417902,
        -0.0016454739,
        0.010120874,
        0.01148202,
        -0.029013576,
        -0.0047609853,
        -0.01840269,
        0.023786778,
        0.02637598,
        0.0019524879,
        -0.039225195,
        -0.024488524,
        -0.034893725,
        -0.02285515,
        0.028795794,
        -0.019745687,
        -0.008057983,
        0.0064004096,
        0.023581093,
        0.009618763,
        0.008045884,
        0.0010745489,
        0.0024999708,
        0.012691927,
        -0.015474714,
        -0.012776621,
        0.024718406,
        -0.017422665,
        -0.005716812,
        0.00964901,
        -0.0020507928,
        0.029739521,
        0.010774224,
        -0.01632165,
        0.006055586,
        -0.008856521,
        0.026351782,
        -0.023169724,
        0.0155836055,
        0.018487383,
        0.019358516,
        0.0010564002,
        -0.02988471,
        -0.006932769,
        0.01500285,
        -0.029473342,
        0.049291622,
        -0.027585886,
        0.023520598,
        0.04413742,
        0.0026466723,
        -0.0050483383,
        -0.0011524367,
        -0.011711903,
        -0.009080354,
        -0.014107519,
        -0.035450283,
        -0.020810405,
        -0.017325873,
        0.014954454,
        0.021838827,
        -0.004842654,
        0.008578243,
        0.019273823,
        -0.016769314,
        0.007162651,
        -0.013151692,
        -0.008493549,
        -0.0059436695,
        -0.005626069,
        0.0047882083,
        -0.036563396,
        -0.025093477,
        0.028819991,
        0.008759729,
        0.034893725,
        0.027053528,
        -0.038426656,
        0.032861084,
        -0.018777762,
        0.032449715,
        -0.019890876,
        8.3417435e-05,
        0.017918726,
        -0.013587259,
        -0.0057349605,
        -0.010889166,
        -0.013756646,
        0.0073017906,
        -0.025456449,
        0.0063701617,
        -0.019612597,
        -0.02388357,
        0.024307037,
        0.017592052,
        -0.042249963,
        0.037555523,
        -0.0016621101,
        -0.047936525,
        0.005650267,
        -0.00978815,
        -0.022274394,
        0.0013815629,
        0.0036206476,
        0.012462045,
        0.01188129,
        0.0071989484,
        -0.0020598671,
        -0.00013564195,
        0.0124378465,
        -0.0045885732,
        0.033562828,
        0.014155915,
        0.02581942,
        -0.006185651,
        -0.013538863,
        -0.027876263,
        0.008251567,
        0.016067568,
        -0.0028614306,
        0.008838372,
        -0.025166072,
        0.005816629,
        0.02035064,
        0.016418442,
        -0.016805612,
        -0.026666356,
        0.0027177543,
        -0.059914608,
        0.0030066196,
        -0.0030565283,
        -0.018063916,
        -0.02831183,
        -0.023472201,
        -0.0091771465,
        0.0021400235,
        -0.010145073,
        0.004277022,
        -0.022782555,
        0.0045280783,
        -0.00875368,
        0.02360529,
        0.07530463,
        0.0080700815,
        -0.024307037,
        0.010501996,
        0.005326617,
        0.0020371813,
        -0.010846819,
        0.0055625485,
        0.014446293,
        -0.046581432,
        0.0027117047,
        0.010798423,
        0.0063096667,
        0.028021453,
        0.035426084,
        -0.019757787,
        -0.009721605,
        0.026859941,
        0.009673209,
        -0.016890306,
        0.009890992,
        0.015281129,
        0.0068964716,
        0.022492176,
        0.010622986,
        0.012062776,
        0.019733587,
        -0.016091768,
        0.008420954,
        0.009739754,
        0.012353153,
        -0.016599927,
        -0.026133997,
        -0.0043889387,
        -0.015632002,
        0.003771886,
        -0.021415358,
        0.016103866,
        -0.01839059,
        -0.042685527,
        -0.025335459,
        -0.00072254153,
        -0.03317566,
        0.016926603,
        0.056042906,
        0.015886083,
        -0.012099073,
        0.019261723,
        0.014651977,
        0.003756762,
        0.0030610655,
        0.01943111,
        -0.018330095,
        -0.043121096,
        -0.010677432,
        -0.03053806,
        -0.0025060205,
        0.017942926,
        0.007023512,
        -0.0025529044,
        -0.022371186,
        -0.029449143,
        0.020326443,
        0.054203846,
        0.025408054,
        -0.02569843,
        0.019927174,
        -0.008493549,
        -0.02416185,
        0.049533606,
        -0.036732785,
        -0.0047428366,
        0.0036720687,
        0.01370825,
        -0.009618763,
        0.050670918,
        0.0018012495,
        0.015341625,
        -0.005181428,
        -0.007912794,
        -0.012825017,
        0.017434765,
        -0.034772735,
        -0.031554382,
        -0.0182575,
        0.00010955332,
        0.0123773515,
        0.033780612,
        -0.01972149,
        0.020653117,
        -0.03668439,
        -0.027900463,
        -0.015970776,
        0.013684051,
        0.005623044,
        -0.022419581,
        0.018281698,
        0.021330666,
        -0.048468888,
        -0.010054329,
        -0.012946008,
        -0.013163791,
        0.029182963,
        -0.0023063857,
        -0.0652866,
        0.02283095,
        -0.041983783,
        0.007023512,
        0.0020160081,
        -0.0038323812,
        0.015196435,
        0.009152949,
        -0.02360529,
        0.012250312,
        -0.020169154,
        0.023581093,
        -0.029449143,
        -0.019237526,
        -0.010998057,
        -0.031651177,
        0.020834604,
        -0.017289575,
        0.007918843,
        -0.013200088,
        -0.0029158765,
        0.020677315,
        -0.015099643,
        -0.015123841,
        -0.0055958214,
        0.022044512,
        0.013466268,
        -0.008257617,
        0.033248253,
        0.019733587,
        0.0007077958,
        -0.021596845,
        -0.009328385,
        -0.0039866446,
        -0.020205451,
        0.014893958,
        -0.025432251,
        -0.019624697,
        -0.038184673,
        0.030320277,
        -0.033853207,
        0.010713729,
        -0.014107519,
        -0.024319137,
        0.02453692,
        0.029787917,
        0.008681085,
        -0.028650604,
        -0.019527903,
        0.011566713,
        -0.0038021337,
        -0.0028659678,
        0.028287632,
        -0.010713729,
        -0.010253964,
        -0.016140163,
        0.0056169946,
        0.020374838,
        0.022395384,
        -0.019068139,
        0.009171098,
        0.0054264343,
        0.005822679,
        0.014688275,
        0.0248031,
        0.003508731,
        -0.0066544903,
        -0.035038915,
        0.023472201,
        -0.011639308,
        -0.015547309,
        0.040628687,
        0.024621613,
        -0.02964273,
        -0.013103296,
        0.015148039,
        -0.0056200195,
        0.01812441,
        0.011838943,
        -0.017809836,
        0.0104415,
        -0.013502565,
        -0.0040350407,
        -0.009975686,
        -0.0035541027,
        -0.012304757,
        0.0032002048,
        -0.019346418,
        -0.00541736,
        -0.016769314,
        0.027343905,
        0.012752423,
        -0.0019555127,
        -0.036998965,
        -0.019056039,
        0.046654023,
        -0.0016484987,
        0.0102237165,
        0.0021808578,
        -0.00066922995,
        0.0065214,
        -0.018354293,
        0.010120874,
        0.008717382,
        0.026569564,
        -0.00042989518,
        0.063253954,
        -0.016261155,
        0.005075561,
        0.0020175204,
        0.0058257035,
        0.02492409,
        -0.012449946,
        -0.0008318113,
        -0.0018330095,
        0.010580639,
        0.001578929,
        -0.04943681,
        -0.015244832,
        -0.0026421351,
        -0.046436243,
        0.0139502315,
        0.009975686,
        -0.014845562,
        0.004987843,
        -0.00965506,
        0.031772166,
        0.006430657,
        0.006503252,
        0.003378666,
        -0.0026451598,
        -0.016430542,
        -0.047404166,
        0.048614074,
        0.021729935,
        -0.014168015,
        -0.033659622,
        0.009860745,
        0.022540573,
        0.0050483383,
        0.015837686,
        0.03428877,
        0.008947264,
        0.014216411,
        -0.0024394756,
        -0.013103296,
        -0.00888072,
        -0.0013339227,
        -0.014071221,
        -0.049146432,
        -0.007737357,
        -0.042733926,
        -0.0015864909,
        -0.027852066,
        0.0059013227,
        0.01721698,
        -0.009890992,
        0.012631432,
        -0.021439558,
        0.007924893,
        0.0002869749,
        -0.017265378,
        -0.02531126,
        -0.01526903,
        -0.007936992,
        -0.015027048,
        0.002200519,
        0.010895215,
        -0.04399223,
        -0.018051816,
        0.024065057,
        0.0034875579,
        0.00756797,
        -0.030586457,
        0.013768745,
        -0.008420954,
        0.062334422,
        -0.00013989554,
        -0.0457103,
        0.0019282898,
        0.013853438,
        0.018620472,
        -0.013345277,
        0.005036239,
        0.023266517,
        0.0057591586,
        0.04058029,
        -0.017289575,
        0.008451202,
        -0.02373838,
        -0.0040380657,
        -0.0037416383,
        0.027706876,
        -0.00044539713,
        0.038838025,
        -0.0032153286,
        -0.03300627,
        0.010205568,
        0.021572648,
        -0.031481788,
        -0.011772398,
        -0.012383401,
        0.010471747,
        0.017047593,
        -0.017664647,
        0.012056726,
        -0.0053175427,
        0.019334318,
        -0.021149179,
        0.0013513152,
        -0.005483905,
        0.024549019,
        0.024996685,
        0.014119618,
        -0.03772491,
        0.045855485,
        -0.02284305,
        0.021003991,
        0.01878986,
        -0.02467001,
        -0.007846248,
        -0.0071445024,
        -0.009776051,
        -0.0123773515,
        0.055655736,
        -0.004854753,
        0.039975338,
        -0.008312063,
        0.020774107,
        0.0089412145,
        0.026545366,
        0.0063096667,
        0.007682911,
        0.03169957,
        -0.014337401,
        0.012117222,
        0.012195866,
        0.012546739,
        -0.0070356107,
        0.006642391,
        -0.007949091,
        0.031602778,
        0.007253394,
        -0.009951487,
        -0.002673895,
        0.002425864,
        -0.012093023,
        -0.02152425,
        -0.015220634,
        -0.044693977,
        -0.007023512,
        0.00339379,
        -0.021221774,
        -0.020241749,
        -0.03484533,
        0.030828437,
        -0.036103632,
        -0.0084149055,
        -0.0046914155,
        0.0019177031,
        0.033345044,
        0.017676745,
        -0.017337972,
        -0.0033090964,
        0.01265563,
        -0.026956735,
        0.03407099,
        0.0221897,
        0.015474714,
        0.01969729,
        -0.005629094,
        -0.0041560316,
        -0.019007644,
        -0.012105122,
        -0.009358633,
        -0.0049666693,
        0.0067815306,
        0.017797736,
        -0.00652745,
        -0.018233303,
        0.0115606645,
        -0.0012658655,
        -0.004449434,
        -0.015486813,
        -0.009727655
      ],
      "embedding_pca_2d": [],
      "embedding_pca_3d": [],
      "embedding_cluster_id": null,
      "migration_history": [],
      "metadata": {
        "compute_time": 2.0108509063720703,
        "patch_type": "diff",
        "api_costs": 0.0092665,
        "num_applied": 1,
        "patch_name": "greedy_marginal_with_local_search",
        "patch_description": "Replace the baseline greedy solver with a stronger, constraint-aware greedy algorithm that:\n- Computes true marginal gains including pairwise interactions.\n- Handles precedence by computing closure of predecessors when considering adding an item.\n- Enforces mutex and group constraints when evaluating candidates.\n- Greedily adds the item (and required predecessors) with the best marginal gain, respecting cardinality bounds.\n- After initial construction, performs a simple local search (1-for-1 swaps) to escape local optima and improve the objective.\n- Contains robust parsing for different interaction key formats (\"i,j\" strings or nested dicts).\n\nThese changes preserve feasibility and aim to improve the combined score by better leveraging synergies and constraints.",
        "error_attempt": null,
        "novelty_attempt": 1,
        "resample_attempt": 1,
        "patch_attempt": 1,
        "model_name": "gpt-5-mini",
        "temperature": 1.0,
        "max_output_tokens": 8192,
        "llm_result": {
          "content": "<NAME>\ngreedy_marginal_with_local_search\n</NAME>\n\n<DESCRIPTION>\nReplace the baseline greedy solver with a stronger, constraint-aware greedy algorithm that:\n- Computes true marginal gains including pairwise interactions.\n- Handles precedence by computing closure of predecessors when considering adding an item.\n- Enforces mutex and group constraints when evaluating candidates.\n- Greedily adds the item (and required predecessors) with the best marginal gain, respecting cardinality bounds.\n- After initial construction, performs a simple local search (1-for-1 swaps) to escape local optima and improve the objective.\n- Contains robust parsing for different interaction key formats (\"i,j\" strings or nested dicts).\n\nThese changes preserve feasibility and aim to improve the combined score by better leveraging synergies and constraints.\n</DESCRIPTION>\n\n<DIFF>\n<<<<<<< SEARCH\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    This is a greedy baseline - evolution will improve this.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    # Simple greedy: select items with highest weights first\n    # This is a baseline - evolution will find better strategies\n    n = len(weights)\n    selected = []\n    \n    # Create score list (weight + interaction potential)\n    scores = []\n    for i in range(n):\n        score = weights[i] if i < len(weights) else 0.0\n        # Add potential interaction value\n        for k, v in interactions.items():\n            try:\n                u, w = map(int, k.split(\",\"))\n                if u == i or w == i:\n                    score += abs(v) * 0.5  # Potential value\n            except:\n                pass\n        scores.append((score, i))\n    \n    # Sort by score descending\n    scores.sort(reverse=True)\n    \n    # Greedy selection respecting constraints\n    selected_set = set()\n    for score, i in scores:\n        if len(selected_set) >= cardinality_bounds[1]:\n            break\n            \n        # Check mutex constraints\n        can_add = True\n        for a, b in mutex:\n            if (a == i and b in selected_set) or (b == i and a in selected_set):\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n            \n        # Check group constraints (at most one per group)\n        for grp_vars in groups.values():\n            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n        \n        # Check precedence (if j selected, i must be selected)\n        precedence_ok = True\n        for pred_i, pred_j in precedence:\n            if pred_j == i and pred_i not in selected_set:\n                precedence_ok = False\n                break\n        \n        if not precedence_ok:\n            continue\n        \n        # Add if we meet minimum cardinality or have room\n        if len(selected_set) < cardinality_bounds[1]:\n            selected_set.add(i)\n            selected.append(i)\n    \n    # Ensure minimum cardinality\n    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n        for i in range(n):\n            if i not in selected_set:\n                selected_set.add(i)\n                selected.append(i)\n                break\n    \n    # Output result\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n=======\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    Improved greedy + local search:\n    - Evaluate true marginal gains including interactions.\n    - Respect precedence by adding predecessor closures when needed.\n    - Enforce mutex and group constraints when considering additions.\n    - Perform simple 1-for-1 local-search swaps to improve objective.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    min_card, max_card = cardinality_bounds[0], cardinality_bounds[1]\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    n = len(weights)\n    \n    # Build interaction lookup function supporting both \"i,j\" keys and nested dicts\n    interaction_map = {}\n    # If interactions given as dict with string keys like \"i,j\"\n    for k, v in interactions.items():\n        if isinstance(k, str):\n            try:\n                i_s, j_s = k.split(\",\")\n                i, j = int(i_s), int(j_s)\n                if i > j:\n                    i, j = j, i\n                interaction_map[(i, j)] = float(v)\n            except Exception:\n                # fallback: ignore malformed keys\n                pass\n        elif isinstance(k, (list, tuple)) and len(k) == 2:\n            try:\n                i, j = int(k[0]), int(k[1])\n                if i > j:\n                    i, j = j, i\n                interaction_map[(i, j)] = float(v)\n            except Exception:\n                pass\n        else:\n            # maybe nested mapping interactions[i][j]\n            try:\n                # will handle below\n                pass\n            except Exception:\n                pass\n    # handle nested dict case: interactions may be like {i: {j: val}}\n    if not interaction_map:\n        try:\n            for i_key, row in interactions.items():\n                ii = int(i_key)\n                for j_key, v in row.items():\n                    jj = int(j_key)\n                    a, b = (ii, jj) if ii <= jj else (jj, ii)\n                    interaction_map[(a, b)] = float(v)\n        except Exception:\n            # If parsing fails, leave interaction_map empty\n            pass\n    \n    def get_interaction(i, j):\n        a, b = (i, j) if i <= j else (j, i)\n        return interaction_map.get((a, b), 0.0)\n    \n    # Build predecessor map for precedence constraints\n    preds = {i: set() for i in range(n)}\n    for p in precedence:\n        try:\n            pi, pj = int(p[0]), int(p[1])\n            # if pj selected then pi must be selected\n            preds[pj].add(pi)\n        except Exception:\n            pass\n    # compute transitive closure of predecessors for each node\n    pred_closure = {}\n    for i in range(n):\n        stack = list(preds.get(i, []))\n        closure = set()\n        while stack:\n            x = stack.pop()\n            if x in closure:\n                continue\n            closure.add(x)\n            for pp in preds.get(x, []):\n                if pp not in closure:\n                    stack.append(pp)\n        pred_closure[i] = closure\n    \n    # Helper: check feasibility of a full candidate set S (set of indices)\n    def is_feasible_set(S):\n        # cardinality\n        if len(S) > max_card or len(S) < 0:\n            return False\n        # mutex: no pair both present\n        for a, b in mutex:\n            if a in S and b in S:\n                return False\n        # groups: at most one per group\n        for grp_vars in groups.values():\n            if len(set(grp_vars).intersection(S)) > 1:\n                return False\n        # precedence: for every j in S, all its preds must be in S\n        for j in list(S):\n            if not pred_closure.get(j):\n                # OK\n                pass\n            # direct preds\n            for pi in preds.get(j, set()):\n                if pi not in S:\n                    return False\n        return True\n    \n    # Objective calculation\n    def objective(S):\n        S_list = list(S)\n        total = 0.0\n        for i in S_list:\n            total += weights[i] if i < len(weights) else 0.0\n        # pairwise interactions (count each pair once)\n        for idx in range(len(S_list)):\n            for jdx in range(idx+1, len(S_list)):\n                total += get_interaction(S_list[idx], S_list[jdx])\n        return total\n    \n    # Function to compute marginal gain of adding set A (iterable) to current set S\n    def marginal_gain(S, A):\n        A = set(A) - set(S)\n        if not A:\n            return 0.0\n        gain = 0.0\n        for i in A:\n            gain += weights[i] if i < len(weights) else 0.0\n        # interactions between A and S\n        for i in A:\n            for j in S:\n                gain += get_interaction(i, j)\n        # interactions internal to A\n        A_list = list(A)\n        for ii in range(len(A_list)):\n            for jj in range(ii+1, len(A_list)):\n                gain += get_interaction(A_list[ii], A_list[jj])\n        return gain\n    \n    # Helper: when trying to add item i, compute required closure (predecessors)\n    def closure_for(i, current_set):\n        # items that must be present if we include i: i plus all transitive predecessors\n        C = set([i])\n        for p in pred_closure.get(i, set()):\n            C.add(p)\n        # Some predecessors may themselves have predecessors already included by pred_closure\n        # pred_closure already transitive, so this suffices.\n        # Remove those already in current_set\n        return C - set(current_set)\n    \n    # Main greedy: iteratively add the candidate (plus its preds) with best marginal gain\n    selected_set = set()\n    # We'll allow adding until no improvement or until max_card reached.\n    while len(selected_set) < max_card:\n        best_gain = None\n        best_add = None\n        # evaluate every candidate not in selected_set\n        for i in range(n):\n            if i in selected_set:\n                continue\n            # compute closure needed\n            add_set = closure_for(i, selected_set)\n            # if adding would exceed max_card, skip\n            if len(selected_set) + len(add_set) > max_card:\n                continue\n            # Check feasibility when adding\n            new_set = set(selected_set) | set(add_set)\n            if not is_feasible_set(new_set):\n                continue\n            gain = marginal_gain(selected_set, add_set)\n            if best_gain is None or gain > best_gain:\n                best_gain = gain\n                best_add = add_set\n        # Stop if nothing feasible to add\n        if best_add is None:\n            break\n        # If best_gain is negative and we've already reached min_card, stop adding further\n        if best_gain is not None and best_gain < 0 and len(selected_set) >= min_card:\n            break\n        # Otherwise add the best_add\n        selected_set |= set(best_add)\n    \n    # If we haven't reached minimum cardinality, force-add best remaining items (respecting constraints)\n    if len(selected_set) < min_card:\n        # consider candidates by marginal gain ignoring negative cutoff\n        candidates = [i for i in range(n) if i not in selected_set]\n        # sort by simple heuristic gain (weight + sum positive interactions)\n        def heuristic_gain(i):\n            g = weights[i] if i < len(weights) else 0.0\n            for j in range(n):\n                if j == i:\n                    continue\n                g += abs(get_interaction(i, j)) * 0.2\n            return g\n        candidates.sort(key=heuristic_gain, reverse=True)\n        for i in candidates:\n            if len(selected_set) >= min_card:\n                break\n            add_set = closure_for(i, selected_set)\n            if len(selected_set) + len(add_set) > max_card:\n                continue\n            new_set = set(selected_set) | set(add_set)\n            if not is_feasible_set(new_set):\n                continue\n            selected_set |= set(add_set)\n    \n    # Local search: try single-item swaps to improve objective (remove one, add one or add closure)\n    improved = True\n    max_iters = 500\n    it = 0\n    current_obj = objective(selected_set)\n    # Precompute all items list\n    all_items = set(range(n))\n    while improved and it < max_iters:\n        improved = False\n        it += 1\n        # iterate possible removals and additions\n        removed_item = None\n        added_items = None\n        best_obj = current_obj\n        for rem in list(selected_set):\n            # Try remove rem and try to add any outside item (with its closure w.r.t resulting set)\n            base_set = set(selected_set)\n            base_set.remove(rem)\n            # Ensure base_set is still feasible (removing may break precedence if rem was a predecessor of others)\n            if not is_feasible_set(base_set):\n                # Can't remove this item unless we also remove dependents; skip for simplicity\n                continue\n            for add in (all_items - base_set):\n                if add in base_set:\n                    continue\n                add_closure = closure_for(add, base_set)\n                candidate_set = set(base_set) | set(add_closure)\n                # respect cardinality\n                if len(candidate_set) < min_card or len(candidate_set) > max_card:\n                    continue\n                if not is_feasible_set(candidate_set):\n                    continue\n                obj = objective(candidate_set)\n                if obj > best_obj + 1e-9:\n                    best_obj = obj\n                    removed_item = rem\n                    added_items = set(add_closure)\n        if best_obj > current_obj + 1e-9 and removed_item is not None:\n            # apply improvement\n            selected_set.remove(removed_item)\n            selected_set |= set(added_items)\n            current_obj = best_obj\n            improved = True\n    \n    # Final safety: ensure feasibility (if not, fall back to greedy selection by weight)\n    if not is_feasible_set(selected_set):\n        selected_set = set()\n        for i in sorted(range(n), key=lambda x: weights[x], reverse=True):\n            if len(selected_set) >= max_card:\n                break\n            add_set = closure_for(i, selected_set)\n            if len(selected_set) + len(add_set) > max_card:\n                continue\n            new_set = set(selected_set) | set(add_set)\n            if not is_feasible_set(new_set):\n                continue\n            selected_set |= set(add_set)\n        # fill up if still below min_card\n        i = 0\n        while len(selected_set) < min_card and i < n:\n            if i not in selected_set:\n                add_set = closure_for(i, selected_set)\n                if len(selected_set) + len(add_set) <= max_card:\n                    new_set = set(selected_set) | set(add_set)\n                    if is_feasible_set(new_set):\n                        selected_set |= set(add_set)\n            i += 1\n    \n    result = {\n        \"selection\": {\n            \"variables\": sorted(list(selected_set))\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n>>>>>>> REPLACE\n</DIFF>",
          "msg": "\n# Current program\n\nHere is the current program we are trying to improve (you will need to propose a modification to it below):\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    This is a greedy baseline - evolution will improve this.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    # Simple greedy: select items with highest weights first\n    # This is a baseline - evolution will find better strategies\n    n = len(weights)\n    selected = []\n    \n    # Create score list (weight + interaction potential)\n    scores = []\n    for i in range(n):\n        score = weights[i] if i < len(weights) else 0.0\n        # Add potential interaction value\n        for k, v in interactions.items():\n            try:\n                u, w = map(int, k.split(\",\"))\n                if u == i or w == i:\n                    score += abs(v) * 0.5  # Potential value\n            except:\n                pass\n        scores.append((score, i))\n    \n    # Sort by score descending\n    scores.sort(reverse=True)\n    \n    # Greedy selection respecting constraints\n    selected_set = set()\n    for score, i in scores:\n        if len(selected_set) >= cardinality_bounds[1]:\n            break\n            \n        # Check mutex constraints\n        can_add = True\n        for a, b in mutex:\n            if (a == i and b in selected_set) or (b == i and a in selected_set):\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n            \n        # Check group constraints (at most one per group)\n        for grp_vars in groups.values():\n            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n        \n        # Check precedence (if j selected, i must be selected)\n        precedence_ok = True\n        for pred_i, pred_j in precedence:\n            if pred_j == i and pred_i not in selected_set:\n                precedence_ok = False\n                break\n        \n        if not precedence_ok:\n            continue\n        \n        # Add if we meet minimum cardinality or have room\n        if len(selected_set) < cardinality_bounds[1]:\n            selected_set.add(i)\n            selected.append(i)\n    \n    # Ensure minimum cardinality\n    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n        for i in range(n):\n            if i not in selected_set:\n                selected_set.add(i)\n                selected.append(i)\n                break\n    \n    # Output result\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n    \n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n    \n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n    \n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n    \n    result_str = stdout_capture.getvalue()\n    return result_str\n\n\n```\n\nHere are the performance metrics of the program:\n\nCombined score to maximize: 0.35\nfeasible: True; selection_size: 10; raw_score: 106.51\n\n# Instructions\n\nMake sure that the changes you propose are consistent with each other. For example, if you refer to a new config variable somewhere, you should also propose a change to add that variable.\n\nNote that the changes you propose will be applied sequentially, so you should assume that the previous changes have already been applied when writing the SEARCH block.\n\n# Task\n\nSuggest a new idea to improve the performance of the code that is inspired by your expert knowledge of the considered subject.\nYour goal is to maximize the `combined_score` of the program.\nDescribe each change with a SEARCH/REPLACE block.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.\n",
          "system_msg": "You are an expert algorithmist specializing in combinatorial optimization, particularly the Synergistic Dependency Selection (SDS) problem.\n\nThe SDS problem requires selecting a subset of variables that:\n1. Satisfies cardinality bounds (min/max number of items)\n2. Respects mutex constraints (cannot select both items in a mutex pair)\n3. Respects group constraints (at most one item per group)\n4. Satisfies precedence constraints (if j is selected, i must be selected)\n5. Maximizes the objective: sum of selected item weights + pairwise interaction values\n\nKey strategies to explore:\n1. Greedy selection with constraint-aware ordering\n2. Dynamic programming for small instances\n3. Constraint satisfaction with backtracking\n4. Weighted scoring that accounts for interactions\n5. Precedence-aware selection ordering\n6. Group-aware selection that maximizes diversity\n\nThe code should read JSON from stdin with \"requirements\" and \"catalog\", and output JSON to stdout with \"selection\" containing \"variables\" list.\n\nBe creative and find efficient solutions that maximize the objective while respecting all constraints.\nYou MUST repond using a edit name, description and the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n<NAME>\nA shortened name summarizing the edit you are proposing. Lowercase, no spaces, underscores allowed.\n</NAME>\n\n<DESCRIPTION>\nA description and argumentation process of the edit you are proposing.\n</DESCRIPTION>\n\n<DIFF>\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly including indentation)\n=======\n# New replacement code\n>>>>>>> REPLACE\n\n</DIFF>\n\n\nExample of a valid diff format:\n<DIFF>\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n\n</DIFF>\n\n* You may only modify text that lies below a line containing \"EVOLVE-BLOCK-START\" and above the next \"EVOLVE-BLOCK-END\". Everything outside those markers is read-only.\n* Do not repeat the markers \"EVOLVE-BLOCK-START\" and \"EVOLVE-BLOCK-END\" in the SEARCH/REPLACE blocks.  \n* Every block\u2019s SEARCH section must be copied **verbatim** from the current file.  Including indentation.\n* You can propose multiple independent edits. SEARCH/REPLACE blocks follow one after another. DO NOT ADD ANY OTHER TEXT BETWEEN THESE BLOCKS.\n* Make sure the file still runs after your changes.",
          "new_msg_history": [
            {
              "role": "user",
              "content": "\n# Current program\n\nHere is the current program we are trying to improve (you will need to propose a modification to it below):\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    This is a greedy baseline - evolution will improve this.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    # Simple greedy: select items with highest weights first\n    # This is a baseline - evolution will find better strategies\n    n = len(weights)\n    selected = []\n    \n    # Create score list (weight + interaction potential)\n    scores = []\n    for i in range(n):\n        score = weights[i] if i < len(weights) else 0.0\n        # Add potential interaction value\n        for k, v in interactions.items():\n            try:\n                u, w = map(int, k.split(\",\"))\n                if u == i or w == i:\n                    score += abs(v) * 0.5  # Potential value\n            except:\n                pass\n        scores.append((score, i))\n    \n    # Sort by score descending\n    scores.sort(reverse=True)\n    \n    # Greedy selection respecting constraints\n    selected_set = set()\n    for score, i in scores:\n        if len(selected_set) >= cardinality_bounds[1]:\n            break\n            \n        # Check mutex constraints\n        can_add = True\n        for a, b in mutex:\n            if (a == i and b in selected_set) or (b == i and a in selected_set):\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n            \n        # Check group constraints (at most one per group)\n        for grp_vars in groups.values():\n            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n        \n        # Check precedence (if j selected, i must be selected)\n        precedence_ok = True\n        for pred_i, pred_j in precedence:\n            if pred_j == i and pred_i not in selected_set:\n                precedence_ok = False\n                break\n        \n        if not precedence_ok:\n            continue\n        \n        # Add if we meet minimum cardinality or have room\n        if len(selected_set) < cardinality_bounds[1]:\n            selected_set.add(i)\n            selected.append(i)\n    \n    # Ensure minimum cardinality\n    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n        for i in range(n):\n            if i not in selected_set:\n                selected_set.add(i)\n                selected.append(i)\n                break\n    \n    # Output result\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n    \n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n    \n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n    \n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n    \n    result_str = stdout_capture.getvalue()\n    return result_str\n\n\n```\n\nHere are the performance metrics of the program:\n\nCombined score to maximize: 0.35\nfeasible: True; selection_size: 10; raw_score: 106.51\n\n# Instructions\n\nMake sure that the changes you propose are consistent with each other. For example, if you refer to a new config variable somewhere, you should also propose a change to add that variable.\n\nNote that the changes you propose will be applied sequentially, so you should assume that the previous changes have already been applied when writing the SEARCH block.\n\n# Task\n\nSuggest a new idea to improve the performance of the code that is inspired by your expert knowledge of the considered subject.\nYour goal is to maximize the `combined_score` of the program.\nDescribe each change with a SEARCH/REPLACE block.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.\n"
            },
            {
              "role": "assistant",
              "content": "<NAME>\ngreedy_marginal_with_local_search\n</NAME>\n\n<DESCRIPTION>\nReplace the baseline greedy solver with a stronger, constraint-aware greedy algorithm that:\n- Computes true marginal gains including pairwise interactions.\n- Handles precedence by computing closure of predecessors when considering adding an item.\n- Enforces mutex and group constraints when evaluating candidates.\n- Greedily adds the item (and required predecessors) with the best marginal gain, respecting cardinality bounds.\n- After initial construction, performs a simple local search (1-for-1 swaps) to escape local optima and improve the objective.\n- Contains robust parsing for different interaction key formats (\"i,j\" strings or nested dicts).\n\nThese changes preserve feasibility and aim to improve the combined score by better leveraging synergies and constraints.\n</DESCRIPTION>\n\n<DIFF>\n<<<<<<< SEARCH\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    This is a greedy baseline - evolution will improve this.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    # Simple greedy: select items with highest weights first\n    # This is a baseline - evolution will find better strategies\n    n = len(weights)\n    selected = []\n    \n    # Create score list (weight + interaction potential)\n    scores = []\n    for i in range(n):\n        score = weights[i] if i < len(weights) else 0.0\n        # Add potential interaction value\n        for k, v in interactions.items():\n            try:\n                u, w = map(int, k.split(\",\"))\n                if u == i or w == i:\n                    score += abs(v) * 0.5  # Potential value\n            except:\n                pass\n        scores.append((score, i))\n    \n    # Sort by score descending\n    scores.sort(reverse=True)\n    \n    # Greedy selection respecting constraints\n    selected_set = set()\n    for score, i in scores:\n        if len(selected_set) >= cardinality_bounds[1]:\n            break\n            \n        # Check mutex constraints\n        can_add = True\n        for a, b in mutex:\n            if (a == i and b in selected_set) or (b == i and a in selected_set):\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n            \n        # Check group constraints (at most one per group)\n        for grp_vars in groups.values():\n            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n        \n        # Check precedence (if j selected, i must be selected)\n        precedence_ok = True\n        for pred_i, pred_j in precedence:\n            if pred_j == i and pred_i not in selected_set:\n                precedence_ok = False\n                break\n        \n        if not precedence_ok:\n            continue\n        \n        # Add if we meet minimum cardinality or have room\n        if len(selected_set) < cardinality_bounds[1]:\n            selected_set.add(i)\n            selected.append(i)\n    \n    # Ensure minimum cardinality\n    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n        for i in range(n):\n            if i not in selected_set:\n                selected_set.add(i)\n                selected.append(i)\n                break\n    \n    # Output result\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n=======\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    Improved greedy + local search:\n    - Evaluate true marginal gains including interactions.\n    - Respect precedence by adding predecessor closures when needed.\n    - Enforce mutex and group constraints when considering additions.\n    - Perform simple 1-for-1 local-search swaps to improve objective.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    min_card, max_card = cardinality_bounds[0], cardinality_bounds[1]\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    n = len(weights)\n    \n    # Build interaction lookup function supporting both \"i,j\" keys and nested dicts\n    interaction_map = {}\n    # If interactions given as dict with string keys like \"i,j\"\n    for k, v in interactions.items():\n        if isinstance(k, str):\n            try:\n                i_s, j_s = k.split(\",\")\n                i, j = int(i_s), int(j_s)\n                if i > j:\n                    i, j = j, i\n                interaction_map[(i, j)] = float(v)\n            except Exception:\n                # fallback: ignore malformed keys\n                pass\n        elif isinstance(k, (list, tuple)) and len(k) == 2:\n            try:\n                i, j = int(k[0]), int(k[1])\n                if i > j:\n                    i, j = j, i\n                interaction_map[(i, j)] = float(v)\n            except Exception:\n                pass\n        else:\n            # maybe nested mapping interactions[i][j]\n            try:\n                # will handle below\n                pass\n            except Exception:\n                pass\n    # handle nested dict case: interactions may be like {i: {j: val}}\n    if not interaction_map:\n        try:\n            for i_key, row in interactions.items():\n                ii = int(i_key)\n                for j_key, v in row.items():\n                    jj = int(j_key)\n                    a, b = (ii, jj) if ii <= jj else (jj, ii)\n                    interaction_map[(a, b)] = float(v)\n        except Exception:\n            # If parsing fails, leave interaction_map empty\n            pass\n    \n    def get_interaction(i, j):\n        a, b = (i, j) if i <= j else (j, i)\n        return interaction_map.get((a, b), 0.0)\n    \n    # Build predecessor map for precedence constraints\n    preds = {i: set() for i in range(n)}\n    for p in precedence:\n        try:\n            pi, pj = int(p[0]), int(p[1])\n            # if pj selected then pi must be selected\n            preds[pj].add(pi)\n        except Exception:\n            pass\n    # compute transitive closure of predecessors for each node\n    pred_closure = {}\n    for i in range(n):\n        stack = list(preds.get(i, []))\n        closure = set()\n        while stack:\n            x = stack.pop()\n            if x in closure:\n                continue\n            closure.add(x)\n            for pp in preds.get(x, []):\n                if pp not in closure:\n                    stack.append(pp)\n        pred_closure[i] = closure\n    \n    # Helper: check feasibility of a full candidate set S (set of indices)\n    def is_feasible_set(S):\n        # cardinality\n        if len(S) > max_card or len(S) < 0:\n            return False\n        # mutex: no pair both present\n        for a, b in mutex:\n            if a in S and b in S:\n                return False\n        # groups: at most one per group\n        for grp_vars in groups.values():\n            if len(set(grp_vars).intersection(S)) > 1:\n                return False\n        # precedence: for every j in S, all its preds must be in S\n        for j in list(S):\n            if not pred_closure.get(j):\n                # OK\n                pass\n            # direct preds\n            for pi in preds.get(j, set()):\n                if pi not in S:\n                    return False\n        return True\n    \n    # Objective calculation\n    def objective(S):\n        S_list = list(S)\n        total = 0.0\n        for i in S_list:\n            total += weights[i] if i < len(weights) else 0.0\n        # pairwise interactions (count each pair once)\n        for idx in range(len(S_list)):\n            for jdx in range(idx+1, len(S_list)):\n                total += get_interaction(S_list[idx], S_list[jdx])\n        return total\n    \n    # Function to compute marginal gain of adding set A (iterable) to current set S\n    def marginal_gain(S, A):\n        A = set(A) - set(S)\n        if not A:\n            return 0.0\n        gain = 0.0\n        for i in A:\n            gain += weights[i] if i < len(weights) else 0.0\n        # interactions between A and S\n        for i in A:\n            for j in S:\n                gain += get_interaction(i, j)\n        # interactions internal to A\n        A_list = list(A)\n        for ii in range(len(A_list)):\n            for jj in range(ii+1, len(A_list)):\n                gain += get_interaction(A_list[ii], A_list[jj])\n        return gain\n    \n    # Helper: when trying to add item i, compute required closure (predecessors)\n    def closure_for(i, current_set):\n        # items that must be present if we include i: i plus all transitive predecessors\n        C = set([i])\n        for p in pred_closure.get(i, set()):\n            C.add(p)\n        # Some predecessors may themselves have predecessors already included by pred_closure\n        # pred_closure already transitive, so this suffices.\n        # Remove those already in current_set\n        return C - set(current_set)\n    \n    # Main greedy: iteratively add the candidate (plus its preds) with best marginal gain\n    selected_set = set()\n    # We'll allow adding until no improvement or until max_card reached.\n    while len(selected_set) < max_card:\n        best_gain = None\n        best_add = None\n        # evaluate every candidate not in selected_set\n        for i in range(n):\n            if i in selected_set:\n                continue\n            # compute closure needed\n            add_set = closure_for(i, selected_set)\n            # if adding would exceed max_card, skip\n            if len(selected_set) + len(add_set) > max_card:\n                continue\n            # Check feasibility when adding\n            new_set = set(selected_set) | set(add_set)\n            if not is_feasible_set(new_set):\n                continue\n            gain = marginal_gain(selected_set, add_set)\n            if best_gain is None or gain > best_gain:\n                best_gain = gain\n                best_add = add_set\n        # Stop if nothing feasible to add\n        if best_add is None:\n            break\n        # If best_gain is negative and we've already reached min_card, stop adding further\n        if best_gain is not None and best_gain < 0 and len(selected_set) >= min_card:\n            break\n        # Otherwise add the best_add\n        selected_set |= set(best_add)\n    \n    # If we haven't reached minimum cardinality, force-add best remaining items (respecting constraints)\n    if len(selected_set) < min_card:\n        # consider candidates by marginal gain ignoring negative cutoff\n        candidates = [i for i in range(n) if i not in selected_set]\n        # sort by simple heuristic gain (weight + sum positive interactions)\n        def heuristic_gain(i):\n            g = weights[i] if i < len(weights) else 0.0\n            for j in range(n):\n                if j == i:\n                    continue\n                g += abs(get_interaction(i, j)) * 0.2\n            return g\n        candidates.sort(key=heuristic_gain, reverse=True)\n        for i in candidates:\n            if len(selected_set) >= min_card:\n                break\n            add_set = closure_for(i, selected_set)\n            if len(selected_set) + len(add_set) > max_card:\n                continue\n            new_set = set(selected_set) | set(add_set)\n            if not is_feasible_set(new_set):\n                continue\n            selected_set |= set(add_set)\n    \n    # Local search: try single-item swaps to improve objective (remove one, add one or add closure)\n    improved = True\n    max_iters = 500\n    it = 0\n    current_obj = objective(selected_set)\n    # Precompute all items list\n    all_items = set(range(n))\n    while improved and it < max_iters:\n        improved = False\n        it += 1\n        # iterate possible removals and additions\n        removed_item = None\n        added_items = None\n        best_obj = current_obj\n        for rem in list(selected_set):\n            # Try remove rem and try to add any outside item (with its closure w.r.t resulting set)\n            base_set = set(selected_set)\n            base_set.remove(rem)\n            # Ensure base_set is still feasible (removing may break precedence if rem was a predecessor of others)\n            if not is_feasible_set(base_set):\n                # Can't remove this item unless we also remove dependents; skip for simplicity\n                continue\n            for add in (all_items - base_set):\n                if add in base_set:\n                    continue\n                add_closure = closure_for(add, base_set)\n                candidate_set = set(base_set) | set(add_closure)\n                # respect cardinality\n                if len(candidate_set) < min_card or len(candidate_set) > max_card:\n                    continue\n                if not is_feasible_set(candidate_set):\n                    continue\n                obj = objective(candidate_set)\n                if obj > best_obj + 1e-9:\n                    best_obj = obj\n                    removed_item = rem\n                    added_items = set(add_closure)\n        if best_obj > current_obj + 1e-9 and removed_item is not None:\n            # apply improvement\n            selected_set.remove(removed_item)\n            selected_set |= set(added_items)\n            current_obj = best_obj\n            improved = True\n    \n    # Final safety: ensure feasibility (if not, fall back to greedy selection by weight)\n    if not is_feasible_set(selected_set):\n        selected_set = set()\n        for i in sorted(range(n), key=lambda x: weights[x], reverse=True):\n            if len(selected_set) >= max_card:\n                break\n            add_set = closure_for(i, selected_set)\n            if len(selected_set) + len(add_set) > max_card:\n                continue\n            new_set = set(selected_set) | set(add_set)\n            if not is_feasible_set(new_set):\n                continue\n            selected_set |= set(add_set)\n        # fill up if still below min_card\n        i = 0\n        while len(selected_set) < min_card and i < n:\n            if i not in selected_set:\n                add_set = closure_for(i, selected_set)\n                if len(selected_set) + len(add_set) <= max_card:\n                    new_set = set(selected_set) | set(add_set)\n                    if is_feasible_set(new_set):\n                        selected_set |= set(add_set)\n            i += 1\n    \n    result = {\n        \"selection\": {\n            \"variables\": sorted(list(selected_set))\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n>>>>>>> REPLACE\n</DIFF>"
            }
          ],
          "model_name": "gpt-5-mini",
          "kwargs": {
            "temperature": 1.0,
            "max_output_tokens": 8192
          },
          "input_tokens": 1714,
          "output_tokens": 4419,
          "cost": 0.0092665,
          "input_cost": 0.0004285,
          "output_cost": 0.008838,
          "thought": "",
          "model_posteriors": {
            "gpt-5-mini": 1.0
          }
        },
        "diff_summary": {
          "added": 196,
          "deleted": 0,
          "modified": 66
        },
        "embed_cost": 5.026e-05,
        "novelty_cost": 0.0,
        "stdout_log": "Evaluating program: sds_dataset_output/problem_0/gen_2/main.py\nSaving results to: sds_dataset_output/problem_0/gen_2/results\nRun 1/1 completed in 0.00 seconds\nCorrectness and error status saved to sds_dataset_output/problem_0/gen_2/results/correct.json\nMetrics saved to sds_dataset_output/problem_0/gen_2/results/metrics.json\nEvaluation and Validation completed successfully.\nMetrics:\n  combined_score: 0.4306669471949661\n  public:\n    feasible: True\n    selection_size: 10\n    raw_score: 132.16052771701814\n  private:\n    selection: [3, 4, 5, 6, 7, 8, 9, 10, 11, 14]\n    raw_score: 132.16052771701814\n    normalized_fitness: 0.4306669471949661\n  execution_time_mean: 0.0010767919998215802\n  execution_time_std: 0.0\n  num_valid_runs: 1\n  num_invalid_runs: 0\n  all_validation_errors: []\n",
        "stderr_log": "",
        "code_analysis_metrics": {
          "cyclomatic_complexity": 65,
          "average_cyclomatic_complexity": 32.5,
          "halstead_volume": 1937.323409052896,
          "halstead_difficulty": 10.507462686567164,
          "halstead_effort": 20356.3534324364,
          "lines_of_code": 340,
          "logical_lines_of_code": 240,
          "comments": 58,
          "maintainability_index": -36.96534846708063,
          "max_nesting_depth": 6,
          "complexity_score": 1.0
        }
      },
      "in_archive": false
    },
    {
      "id": "9d6e84c8-6c25-460f-9f17-d3bcf0f35761",
      "code": "\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem using:\n    - precedence closure-aware greedy initialization\n    - adaptive interaction weighting\n    - local search (add/remove/swap) with occasional random shake\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    weights = requirements.get(\"weights\", [])\n    interactions_raw = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex_list = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    n = len(weights)\n    \n    # Parse interactions into dict of tuple(int,int)->float, symmetric\n    interactions = {}\n    total_abs_inter = 0.0\n    inter_count = 0\n    for k, v in interactions_raw.items():\n        try:\n            # accept \"i,j\" with optional spaces\n            parts = k.split(\",\")\n            if len(parts) != 2:\n                continue\n            u = int(parts[0].strip())\n            w = int(parts[1].strip())\n            if u == w:\n                # ignore self interactions\n                continue\n            interactions[(u, w)] = float(v)\n            interactions[(w, u)] = float(v)\n            total_abs_inter += abs(float(v))\n            inter_count += 1\n        except Exception:\n            continue\n    avg_abs_inter = (total_abs_inter / inter_count) if inter_count > 0 else 0.0\n    avg_abs_weight = (sum(abs(float(x)) for x in weights) / n) if n > 0 else 0.0\n    \n    # Adaptive interaction bias: scale interactions to be comparable to weights\n    interaction_bias = 1.0\n    if avg_abs_weight > 1e-9:\n        interaction_bias = max(0.2, min(3.0, (avg_abs_inter / (avg_abs_weight + 1e-9)) * 1.2))\n    # parameters (tunable)\n    MAX_ITERS = 5000\n    NO_IMPROVE_PATIENCE = 200\n    TOP_K_CANDIDATES = 50  # when searching adds/swaps consider top candidates by heuristic\n    SHAKE_PROB = 0.02\n    INIT_TEMP = 0.5\n    COOLING = 0.995\n    \n    # Build precedence graph: j -> list of required preds i (if j selected, i must be selected)\n    preds = defaultdict(set)\n    succs = defaultdict(set)  # reverse: i -> set of nodes that require i\n    for pair in precedence:\n        try:\n            a, b = pair\n            preds[int(b)].add(int(a))\n            succs[int(a)].add(int(b))\n        except Exception:\n            continue\n    \n    # Build group mapping: group_id -> set(vars), and var->set(group_ids)\n    group_to_vars = {}\n    var_to_groups = defaultdict(set)\n    for gid, vars_list in groups.items():\n        # group ids may be strings; treat as keys\n        try:\n            vars_iter = list(vars_list)\n        except Exception:\n            vars_iter = []\n        group_to_vars[gid] = set(vars_iter)\n        for v in vars_iter:\n            var_to_groups[int(v)].add(gid)\n    \n    # Build mutex set for quick lookup (unordered pair)\n    mutex_set = set()\n    for pair in mutex_list:\n        if len(pair) >= 2:\n            a, b = int(pair[0]), int(pair[1])\n            if a == b:\n                continue\n            mutex_set.add((a, b))\n            mutex_set.add((b, a))\n    \n    # Helper: get full precedence closure for a set of variables (all ancestors)\n    def closure_of_set(vars_set):\n        # BFS/DFS up preds edges\n        res = set(vars_set)\n        dq = deque(vars_set)\n        while dq:\n            v = dq.popleft()\n            for p in preds.get(v, ()):\n                if p not in res:\n                    res.add(p)\n                    dq.append(p)\n        return res\n    \n    # Helper: compute dependents closure (all nodes that require any in given set) - for removal cascades\n    def dependents_to_remove_for_removed(removed_vars, current_selected):\n        # If we remove some vars, any node that (directly or transitively) requires them must also be removed\n        to_remove = set()\n        dq = deque()\n        for r in removed_vars:\n            # only consider dependents that are currently selected\n            for s in succs.get(r, ()):\n                if s in current_selected and s not in to_remove:\n                    to_remove.add(s)\n                    dq.append(s)\n        while dq:\n            v = dq.popleft()\n            for s in succs.get(v, ()):\n                if s in current_selected and s not in to_remove:\n                    to_remove.add(s)\n                    dq.append(s)\n        return to_remove\n    \n    # Objective evaluation\n    def objective(selected_set):\n        # sum weights + sum pairwise interactions (each counted once)\n        s = 0.0\n        for v in selected_set:\n            if 0 <= v < n:\n                s += float(weights[v])\n        # interactions: iterate pairs from interactions dict unique by u<v\n        # More efficient: for each u in selected, sum interactions[u,w] for w>u in selected\n        sel_list = list(selected_set)\n        sel_set = set(selected_set)\n        # sum interactions symmetrically but ensure we add each pair once\n        seen = set()\n        for u in sel_list:\n            for v in sel_list:\n                if u == v:\n                    continue\n                if (u, v) in seen:\n                    continue\n                val = interactions.get((u, v), 0.0)\n                if val != 0.0:\n                    s += val * 1.0  # interactions already raw; bias applied when used for heuristics\n                seen.add((u, v))\n                seen.add((v, u))\n        return s\n    \n    # Feasibility checks\n    def violates_mutex_pairing(candidate_set):\n        # simple O(k^2) check for small sets\n        for a in candidate_set:\n            for b in candidate_set:\n                if a != b and (a, b) in mutex_set:\n                    return True\n        return False\n    \n    def violates_grouping(candidate_set):\n        # at most one per group id\n        group_seen = {}\n        for v in candidate_set:\n            for gid in var_to_groups.get(v, ()):\n                if gid in group_seen and group_seen[gid] != v:\n                    return True\n                group_seen[gid] = v\n        return False\n    \n    def feasible_after_adding(i, current_set, max_card):\n        # compute closure for i\n        to_add_closure = closure_of_set({i})\n        # new_set = current_set U to_add_closure\n        new_set = set(current_set) | to_add_closure\n        # Check cardinality\n        if len(new_set) > max_card:\n            return False, None\n        # Check group and mutex\n        if violates_grouping(new_set):\n            return False, None\n        if violates_mutex_pairing(new_set):\n            return False, None\n        return True, to_add_closure\n    \n    def feasible_swap(remove_set, add_set, current_set, min_card, max_card):\n        # remove_set: set of vars to remove (e.g. {a} plus dependents)\n        # add_set: set of vars to add (including closures)\n        new_set = set(current_set)\n        # cascade removals of dependents\n        removed_final = set(remove_set) | dependents_to_remove_for_removed(remove_set, current_set)\n        new_set -= removed_final\n        new_set |= add_set\n        # add closure for add_set (in case not already included)\n        new_set |= closure_of_set(add_set)\n        # Check cardinality\n        if len(new_set) < min_card or len(new_set) > max_card:\n            return False, None\n        if violates_grouping(new_set):\n            return False, None\n        if violates_mutex_pairing(new_set):\n            return False, None\n        return True, new_set\n    \n    # Greedy initialization (precedence-aware)\n    min_card, max_card = int(cardinality_bounds[0]), int(cardinality_bounds[1])\n    selected = set()\n    \n    # Candidate heuristic score: marginal weight + interaction_bias * sum interactions to current selected +\n    # include closure contributions (weights + interactions inside closure)\n    def marginal_gain_if_add(i, current_set):\n        feasible, closure = feasible_after_adding(i, current_set, max_card)\n        if not feasible:\n            return -math.inf, None\n        closure = closure or set()\n        new_items = closure - current_set\n        # compute sum weights for new items\n        gain = 0.0\n        for v in new_items:\n            if 0 <= v < n:\n                gain += float(weights[v])\n        # interactions: between new items and existing items, and between new items themselves\n        for u in new_items:\n            # interactions with current_set\n            for v in current_set:\n                gain += interaction_bias * interactions.get((u, v), 0.0)\n            # interactions inside new_items (u <-> w)\n            for w in new_items:\n                if u >= w:\n                    continue\n                gain += interaction_bias * interactions.get((u, w), 0.0)\n        # also subtract any negative interactions that new items might have with existing set (already accounted)\n        return gain, closure\n    \n    # Seed selection: choose highest marginal gains until max or no positive gains; also aim to reach min_card\n    # We'll consider candidates sorted by heuristic that includes interactions to the yet-empty set (so primarily weights)\n    candidate_scores = []\n    for i in range(n):\n        # simple base heuristic: weight + interaction_bias * sum of abs interactions to others (potential)\n        pot = float(weights[i]) + interaction_bias * sum(interactions.get((i, j), 0.0) for j in range(n) if j != i)\n        candidate_scores.append((pot, i))\n    candidate_scores.sort(reverse=True)\n    for _, i in candidate_scores:\n        if len(selected) >= max_card:\n            break\n        mg, closure = marginal_gain_if_add(i, selected)\n        if closure is None:\n            continue\n        # prefer positive gain or needed to reach min_card\n        if mg > -1e-9 or len(selected) + len(closure - selected) <= min_card:\n            selected |= closure\n    # If still below min_card, add best feasible items forcibly (minimal harm)\n    if len(selected) < min_card:\n        for i in range(n):\n            if len(selected) >= min_card:\n                break\n            feasible, closure = feasible_after_adding(i, selected, max_card)\n            if not feasible:\n                continue\n            selected |= closure\n    # If above max_card due to closure, attempt to prune (rare): remove least valuable items that have no dependents\n    def prune_to_max(selected_set):\n        if len(selected_set) <= max_card:\n            return selected_set\n        # remove candidates with smallest marginal loss (removing them and their dependents)\n        sel = set(selected_set)\n        while len(sel) > max_card:\n            best_loss = math.inf\n            best_remove = None\n            for v in list(sel):\n                # cannot remove if it causes removing many required items might be large loss - we measure objective delta\n                removed = {v} | dependents_to_remove_for_removed({v}, sel)\n                new_set = sel - removed\n                loss = objective(sel) - objective(new_set)\n                if loss < best_loss:\n                    best_loss = loss\n                    best_remove = removed\n            if best_remove is None:\n                break\n            sel -= best_remove\n        return sel\n    if len(selected) > max_card:\n        selected = prune_to_max(selected)\n    \n    # Local search improvement\n    current = set(selected)\n    best = set(current)\n    best_score = objective(best)\n    current_score = best_score\n    no_improve = 0\n    temperature = INIT_TEMP\n    rng = random.Random(123456789)  # deterministic seed for reproducibility\n    \n    iter_count = 0\n    while iter_count < MAX_ITERS and no_improve < NO_IMPROVE_PATIENCE:\n        iter_count += 1\n        improved = False\n        \n        # Build candidate lists\n        not_selected = [i for i in range(n) if i not in current]\n        # Evaluate marginal gains for top candidates\n        add_candidates = []\n        for i in not_selected:\n            mg, closure = marginal_gain_if_add(i, current)\n            if closure is None:\n                continue\n            add_candidates.append((mg, i, closure))\n        add_candidates.sort(reverse=True, key=lambda x: x[0])\n        \n        # Consider removals: compute marginal loss for removing each v (including dependents)\n        remove_candidates = []\n        for v in list(current):\n            removed = {v} | dependents_to_remove_for_removed({v}, current)\n            new_set = current - removed\n            if len(new_set) < min_card:\n                # can't remove below min\n                continue\n            loss = objective(current) - objective(new_set)\n            remove_candidates.append((loss, v, removed))\n        remove_candidates.sort(key=lambda x: x[0])  # smaller loss first\n        \n        # Try best add move\n        if add_candidates:\n            mg, i_add, closure_add = add_candidates[0]\n            if mg > 1e-9 and len(current | closure_add) <= max_card:\n                # apply add\n                current |= closure_add\n                current_score = objective(current)\n                if current_score > best_score + 1e-9:\n                    best = set(current)\n                    best_score = current_score\n                    no_improve = 0\n                else:\n                    no_improve += 1\n                improved = True\n            else:\n                # Try beneficial swaps: remove some v and add some u\n                # Consider top few adds and top few removes\n                swapped = False\n                top_adds = add_candidates[:TOP_K_CANDIDATES]\n                top_removes = remove_candidates[:TOP_K_CANDIDATES]\n                best_delta = 0.0\n                best_move = None\n                # Try single removals + single addition\n                for mg_val, u, closure_u in top_adds:\n                    for loss_val, v, removed_set in top_removes:\n                        # prepare add_set = closure_u\n                        feasible, new_set = feasible_swap(removed_set, closure_u, current, min_card, max_card)\n                        if not feasible:\n                            continue\n                        new_score = objective(new_set)\n                        delta = new_score - current_score\n                        if delta > best_delta:\n                            best_delta = delta\n                            best_move = (\"swap\", removed_set, closure_u, new_set, new_score)\n                if best_move:\n                    # apply best swap\n                    _, removed_set, closure_u, new_set, new_score = best_move\n                    current = set(new_set)\n                    current_score = new_score\n                    if current_score > best_score + 1e-9:\n                        best = set(current)\n                        best_score = current_score\n                        no_improve = 0\n                    else:\n                        no_improve += 1\n                    improved = True\n                    swapped = True\n                else:\n                    # consider accepting a small worsening move probabilistically (simulated annealing)\n                    if add_candidates and remove_candidates:\n                        # pick top random pair and consider\n                        cand_add = rng.choice(add_candidates[:min(5, len(add_candidates))])\n                        cand_rem = rng.choice(remove_candidates[:min(5, len(remove_candidates))])\n                        _, u, closure_u = cand_add\n                        _, v, removed_set = cand_rem\n                        feasible, new_set = feasible_swap(removed_set, closure_u, current, min_card, max_card)\n                        if feasible:\n                            new_score = objective(new_set)\n                            delta = new_score - current_score\n                            if delta > 0 or rng.random() < math.exp(delta / (temperature + 1e-12)):\n                                current = set(new_set)\n                                current_score = new_score\n                                if current_score > best_score + 1e-9:\n                                    best = set(current)\n                                    best_score = current_score\n                                    no_improve = 0\n                                else:\n                                    no_improve += 1\n                                improved = True\n        # If not improved, try pure removal if it leads to improvement (prune negative items)\n        if not improved and remove_candidates:\n            # remove the item which gives largest improvement (largest 'negative loss' meaning reduce objective negative interactions)\n            # We look for removals that increase objective (loss < 0)\n            candidate_removals = [rc for rc in remove_candidates if rc[0] < -1e-9]\n            if candidate_removals:\n                candidate_removals.sort()\n                loss_val, v, removed_set = candidate_removals[0]\n                new_set = current - removed_set\n                current = set(new_set)\n                current_score = objective(current)\n                if current_score > best_score + 1e-9:\n                    best = set(current)\n                    best_score = current_score\n                    no_improve = 0\n                else:\n                    no_improve += 1\n                improved = True\n        \n        # Random shake (small) to escape plateaus\n        if not improved and rng.random() < SHAKE_PROB:\n            # attempt random feasible add or swap\n            if add_candidates:\n                _, u, closure_u = rng.choice(add_candidates[:min(10, len(add_candidates))])\n                feasible_add, closure = feasible_after_adding(u, current, max_card)\n                if feasible_add:\n                    current |= closure\n                    current_score = objective(current)\n                    if current_score > best_score + 1e-9:\n                        best = set(current)\n                        best_score = current_score\n                        no_improve = 0\n                    else:\n                        no_improve += 1\n                    improved = True\n            elif remove_candidates:\n                _, v, removed_set = rng.choice(remove_candidates[:min(10, len(remove_candidates))])\n                new_set = current - removed_set\n                if len(new_set) >= min_card:\n                    current = set(new_set)\n                    current_score = objective(current)\n                    if current_score > best_score + 1e-9:\n                        best = set(current)\n                        best_score = current_score\n                        no_improve = 0\n                    else:\n                        no_improve += 1\n                    improved = True\n        \n        if not improved:\n            no_improve += 1\n        \n        # cooling\n        temperature *= COOLING\n    \n    # Final pruning to ensure within cardinality bounds and precedence closure\n    final_sel = closure_of_set(best)\n    # If still beyond max, prune low-contribution items\n    if len(final_sel) > max_card:\n        final_sel = prune_to_max(final_sel)\n    # Ensure at least min_card\n    if len(final_sel) < min_card:\n        # greedily add best remaining feasible items\n        for i in range(n):\n            if len(final_sel) >= min_card:\n                break\n            feasible, closure = feasible_after_adding(i, final_sel, max_card)\n            if feasible:\n                final_sel |= closure\n    final_list = sorted(int(x) for x in final_sel)\n    result = {\"selection\": {\"variables\": final_list}}\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n    \n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n    \n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n    \n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n    \n    result_str = stdout_capture.getvalue()\n    return result_str\n\n",
      "language": "python",
      "parent_id": "639d15e8-d1f9-4fa7-b731-6db3bcbdb880",
      "archive_inspiration_ids": [],
      "top_k_inspiration_ids": [],
      "island_idx": 0,
      "generation": 3,
      "timestamp": 1764668088.911102,
      "code_diff": "--- a/original.py\n+++ b/original.py\n@@ -1,145 +1,506 @@\n \"\"\"\n Initial solution for Synergistic Dependency Selection (SDS) problem.\n The code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n \"\"\"\n \n import json\n import sys\n import contextlib\n \n # EVOLVE-BLOCK-START\n def solve_sds():\n     \"\"\"\n-    Solve the Synergistic Dependency Selection problem.\n-    \n-    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n-    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n-    \n-    This is a greedy baseline - evolution will improve this.\n+    Solve the Synergistic Dependency Selection problem using:\n+    - precedence closure-aware greedy initialization\n+    - adaptive interaction weighting\n+    - local search (add/remove/swap) with occasional random shake\n     \"\"\"\n     # Read input\n     input_data = json.load(sys.stdin)\n     requirements = input_data.get(\"requirements\", {})\n     catalog = input_data.get(\"catalog\", {})\n     \n-    # Extract constraints\n     weights = requirements.get(\"weights\", [])\n-    interactions = requirements.get(\"interactions\", {})\n+    interactions_raw = requirements.get(\"interactions\", {})\n     cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n-    mutex = requirements.get(\"mutex\", [])\n+    mutex_list = requirements.get(\"mutex\", [])\n     groups = requirements.get(\"groups\", {})\n     precedence = requirements.get(\"precedence\", [])\n     \n-    # Simple greedy: select items with highest weights first\n-    # This is a baseline - evolution will find better strategies\n     n = len(weights)\n-    selected = []\n-    \n-    # Create score list (weight + interaction potential)\n-    scores = []\n+    \n+    # Parse interactions into dict of tuple(int,int)->float, symmetric\n+    interactions = {}\n+    total_abs_inter = 0.0\n+    inter_count = 0\n+    for k, v in interactions_raw.items():\n+        try:\n+            # accept \"i,j\" with optional spaces\n+            parts = k.split(\",\")\n+            if len(parts) != 2:\n+                continue\n+            u = int(parts[0].strip())\n+            w = int(parts[1].strip())\n+            if u == w:\n+                # ignore self interactions\n+                continue\n+            interactions[(u, w)] = float(v)\n+            interactions[(w, u)] = float(v)\n+            total_abs_inter += abs(float(v))\n+            inter_count += 1\n+        except Exception:\n+            continue\n+    avg_abs_inter = (total_abs_inter / inter_count) if inter_count > 0 else 0.0\n+    avg_abs_weight = (sum(abs(float(x)) for x in weights) / n) if n > 0 else 0.0\n+    \n+    # Adaptive interaction bias: scale interactions to be comparable to weights\n+    interaction_bias = 1.0\n+    if avg_abs_weight > 1e-9:\n+        interaction_bias = max(0.2, min(3.0, (avg_abs_inter / (avg_abs_weight + 1e-9)) * 1.2))\n+    # parameters (tunable)\n+    MAX_ITERS = 5000\n+    NO_IMPROVE_PATIENCE = 200\n+    TOP_K_CANDIDATES = 50  # when searching adds/swaps consider top candidates by heuristic\n+    SHAKE_PROB = 0.02\n+    INIT_TEMP = 0.5\n+    COOLING = 0.995\n+    \n+    # Build precedence graph: j -> list of required preds i (if j selected, i must be selected)\n+    preds = defaultdict(set)\n+    succs = defaultdict(set)  # reverse: i -> set of nodes that require i\n+    for pair in precedence:\n+        try:\n+            a, b = pair\n+            preds[int(b)].add(int(a))\n+            succs[int(a)].add(int(b))\n+        except Exception:\n+            continue\n+    \n+    # Build group mapping: group_id -> set(vars), and var->set(group_ids)\n+    group_to_vars = {}\n+    var_to_groups = defaultdict(set)\n+    for gid, vars_list in groups.items():\n+        # group ids may be strings; treat as keys\n+        try:\n+            vars_iter = list(vars_list)\n+        except Exception:\n+            vars_iter = []\n+        group_to_vars[gid] = set(vars_iter)\n+        for v in vars_iter:\n+            var_to_groups[int(v)].add(gid)\n+    \n+    # Build mutex set for quick lookup (unordered pair)\n+    mutex_set = set()\n+    for pair in mutex_list:\n+        if len(pair) >= 2:\n+            a, b = int(pair[0]), int(pair[1])\n+            if a == b:\n+                continue\n+            mutex_set.add((a, b))\n+            mutex_set.add((b, a))\n+    \n+    # Helper: get full precedence closure for a set of variables (all ancestors)\n+    def closure_of_set(vars_set):\n+        # BFS/DFS up preds edges\n+        res = set(vars_set)\n+        dq = deque(vars_set)\n+        while dq:\n+            v = dq.popleft()\n+            for p in preds.get(v, ()):\n+                if p not in res:\n+                    res.add(p)\n+                    dq.append(p)\n+        return res\n+    \n+    # Helper: compute dependents closure (all nodes that require any in given set) - for removal cascades\n+    def dependents_to_remove_for_removed(removed_vars, current_selected):\n+        # If we remove some vars, any node that (directly or transitively) requires them must also be removed\n+        to_remove = set()\n+        dq = deque()\n+        for r in removed_vars:\n+            # only consider dependents that are currently selected\n+            for s in succs.get(r, ()):\n+                if s in current_selected and s not in to_remove:\n+                    to_remove.add(s)\n+                    dq.append(s)\n+        while dq:\n+            v = dq.popleft()\n+            for s in succs.get(v, ()):\n+                if s in current_selected and s not in to_remove:\n+                    to_remove.add(s)\n+                    dq.append(s)\n+        return to_remove\n+    \n+    # Objective evaluation\n+    def objective(selected_set):\n+        # sum weights + sum pairwise interactions (each counted once)\n+        s = 0.0\n+        for v in selected_set:\n+            if 0 <= v < n:\n+                s += float(weights[v])\n+        # interactions: iterate pairs from interactions dict unique by u<v\n+        # More efficient: for each u in selected, sum interactions[u,w] for w>u in selected\n+        sel_list = list(selected_set)\n+        sel_set = set(selected_set)\n+        # sum interactions symmetrically but ensure we add each pair once\n+        seen = set()\n+        for u in sel_list:\n+            for v in sel_list:\n+                if u == v:\n+                    continue\n+                if (u, v) in seen:\n+                    continue\n+                val = interactions.get((u, v), 0.0)\n+                if val != 0.0:\n+                    s += val * 1.0  # interactions already raw; bias applied when used for heuristics\n+                seen.add((u, v))\n+                seen.add((v, u))\n+        return s\n+    \n+    # Feasibility checks\n+    def violates_mutex_pairing(candidate_set):\n+        # simple O(k^2) check for small sets\n+        for a in candidate_set:\n+            for b in candidate_set:\n+                if a != b and (a, b) in mutex_set:\n+                    return True\n+        return False\n+    \n+    def violates_grouping(candidate_set):\n+        # at most one per group id\n+        group_seen = {}\n+        for v in candidate_set:\n+            for gid in var_to_groups.get(v, ()):\n+                if gid in group_seen and group_seen[gid] != v:\n+                    return True\n+                group_seen[gid] = v\n+        return False\n+    \n+    def feasible_after_adding(i, current_set, max_card):\n+        # compute closure for i\n+        to_add_closure = closure_of_set({i})\n+        # new_set = current_set U to_add_closure\n+        new_set = set(current_set) | to_add_closure\n+        # Check cardinality\n+        if len(new_set) > max_card:\n+            return False, None\n+        # Check group and mutex\n+        if violates_grouping(new_set):\n+            return False, None\n+        if violates_mutex_pairing(new_set):\n+            return False, None\n+        return True, to_add_closure\n+    \n+    def feasible_swap(remove_set, add_set, current_set, min_card, max_card):\n+        # remove_set: set of vars to remove (e.g. {a} plus dependents)\n+        # add_set: set of vars to add (including closures)\n+        new_set = set(current_set)\n+        # cascade removals of dependents\n+        removed_final = set(remove_set) | dependents_to_remove_for_removed(remove_set, current_set)\n+        new_set -= removed_final\n+        new_set |= add_set\n+        # add closure for add_set (in case not already included)\n+        new_set |= closure_of_set(add_set)\n+        # Check cardinality\n+        if len(new_set) < min_card or len(new_set) > max_card:\n+            return False, None\n+        if violates_grouping(new_set):\n+            return False, None\n+        if violates_mutex_pairing(new_set):\n+            return False, None\n+        return True, new_set\n+    \n+    # Greedy initialization (precedence-aware)\n+    min_card, max_card = int(cardinality_bounds[0]), int(cardinality_bounds[1])\n+    selected = set()\n+    \n+    # Candidate heuristic score: marginal weight + interaction_bias * sum interactions to current selected +\n+    # include closure contributions (weights + interactions inside closure)\n+    def marginal_gain_if_add(i, current_set):\n+        feasible, closure = feasible_after_adding(i, current_set, max_card)\n+        if not feasible:\n+            return -math.inf, None\n+        closure = closure or set()\n+        new_items = closure - current_set\n+        # compute sum weights for new items\n+        gain = 0.0\n+        for v in new_items:\n+            if 0 <= v < n:\n+                gain += float(weights[v])\n+        # interactions: between new items and existing items, and between new items themselves\n+        for u in new_items:\n+            # interactions with current_set\n+            for v in current_set:\n+                gain += interaction_bias * interactions.get((u, v), 0.0)\n+            # interactions inside new_items (u <-> w)\n+            for w in new_items:\n+                if u >= w:\n+                    continue\n+                gain += interaction_bias * interactions.get((u, w), 0.0)\n+        # also subtract any negative interactions that new items might have with existing set (already accounted)\n+        return gain, closure\n+    \n+    # Seed selection: choose highest marginal gains until max or no positive gains; also aim to reach min_card\n+    # We'll consider candidates sorted by heuristic that includes interactions to the yet-empty set (so primarily weights)\n+    candidate_scores = []\n     for i in range(n):\n-        score = weights[i] if i < len(weights) else 0.0\n-        # Add potential interaction value\n-        for k, v in interactions.items():\n-            try:\n-                u, w = map(int, k.split(\",\"))\n-                if u == i or w == i:\n-                    score += abs(v) * 0.5  # Potential value\n-            except:\n-                pass\n-        scores.append((score, i))\n-    \n-    # Sort by score descending\n-    scores.sort(reverse=True)\n-    \n-    # Greedy selection respecting constraints\n-    selected_set = set()\n-    for score, i in scores:\n-        if len(selected_set) >= cardinality_bounds[1]:\n+        # simple base heuristic: weight + interaction_bias * sum of abs interactions to others (potential)\n+        pot = float(weights[i]) + interaction_bias * sum(interactions.get((i, j), 0.0) for j in range(n) if j != i)\n+        candidate_scores.append((pot, i))\n+    candidate_scores.sort(reverse=True)\n+    for _, i in candidate_scores:\n+        if len(selected) >= max_card:\n             break\n-            \n-        # Check mutex constraints\n-        can_add = True\n-        for a, b in mutex:\n-            if (a == i and b in selected_set) or (b == i and a in selected_set):\n-                can_add = False\n+        mg, closure = marginal_gain_if_add(i, selected)\n+        if closure is None:\n+            continue\n+        # prefer positive gain or needed to reach min_card\n+        if mg > -1e-9 or len(selected) + len(closure - selected) <= min_card:\n+            selected |= closure\n+    # If still below min_card, add best feasible items forcibly (minimal harm)\n+    if len(selected) < min_card:\n+        for i in range(n):\n+            if len(selected) >= min_card:\n                 break\n+            feasible, closure = feasible_after_adding(i, selected, max_card)\n+            if not feasible:\n+                continue\n+            selected |= closure\n+    # If above max_card due to closure, attempt to prune (rare): remove least valuable items that have no dependents\n+    def prune_to_max(selected_set):\n+        if len(selected_set) <= max_card:\n+            return selected_set\n+        # remove candidates with smallest marginal loss (removing them and their dependents)\n+        sel = set(selected_set)\n+        while len(sel) > max_card:\n+            best_loss = math.inf\n+            best_remove = None\n+            for v in list(sel):\n+                # cannot remove if it causes removing many required items might be large loss - we measure objective delta\n+                removed = {v} | dependents_to_remove_for_removed({v}, sel)\n+                new_set = sel - removed\n+                loss = objective(sel) - objective(new_set)\n+                if loss < best_loss:\n+                    best_loss = loss\n+                    best_remove = removed\n+            if best_remove is None:\n+                break\n+            sel -= best_remove\n+        return sel\n+    if len(selected) > max_card:\n+        selected = prune_to_max(selected)\n+    \n+    # Local search improvement\n+    current = set(selected)\n+    best = set(current)\n+    best_score = objective(best)\n+    current_score = best_score\n+    no_improve = 0\n+    temperature = INIT_TEMP\n+    rng = random.Random(123456789)  # deterministic seed for reproducibility\n+    \n+    iter_count = 0\n+    while iter_count < MAX_ITERS and no_improve < NO_IMPROVE_PATIENCE:\n+        iter_count += 1\n+        improved = False\n         \n-        if not can_add:\n-            continue\n-            \n-        # Check group constraints (at most one per group)\n-        for grp_vars in groups.values():\n-            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n-                can_add = False\n+        # Build candidate lists\n+        not_selected = [i for i in range(n) if i not in current]\n+        # Evaluate marginal gains for top candidates\n+        add_candidates = []\n+        for i in not_selected:\n+            mg, closure = marginal_gain_if_add(i, current)\n+            if closure is None:\n+                continue\n+            add_candidates.append((mg, i, closure))\n+        add_candidates.sort(reverse=True, key=lambda x: x[0])\n+        \n+        # Consider removals: compute marginal loss for removing each v (including dependents)\n+        remove_candidates = []\n+        for v in list(current):\n+            removed = {v} | dependents_to_remove_for_removed({v}, current)\n+            new_set = current - removed\n+            if len(new_set) < min_card:\n+                # can't remove below min\n+                continue\n+            loss = objective(current) - objective(new_set)\n+            remove_candidates.append((loss, v, removed))\n+        remove_candidates.sort(key=lambda x: x[0])  # smaller loss first\n+        \n+        # Try best add move\n+        if add_candidates:\n+            mg, i_add, closure_add = add_candidates[0]\n+            if mg > 1e-9 and len(current | closure_add) <= max_card:\n+                # apply add\n+                current |= closure_add\n+                current_score = objective(current)\n+                if current_score > best_score + 1e-9:\n+                    best = set(current)\n+                    best_score = current_score\n+                    no_improve = 0\n+                else:\n+                    no_improve += 1\n+                improved = True\n+            else:\n+                # Try beneficial swaps: remove some v and add some u\n+                # Consider top few adds and top few removes\n+                swapped = False\n+                top_adds = add_candidates[:TOP_K_CANDIDATES]\n+                top_removes = remove_candidates[:TOP_K_CANDIDATES]\n+                best_delta = 0.0\n+                best_move = None\n+                # Try single removals + single addition\n+                for mg_val, u, closure_u in top_adds:\n+                    for loss_val, v, removed_set in top_removes:\n+                        # prepare add_set = closure_u\n+                        feasible, new_set = feasible_swap(removed_set, closure_u, current, min_card, max_card)\n+                        if not feasible:\n+                            continue\n+                        new_score = objective(new_set)\n+                        delta = new_score - current_score\n+                        if delta > best_delta:\n+                            best_delta = delta\n+                            best_move = (\"swap\", removed_set, closure_u, new_set, new_score)\n+                if best_move:\n+                    # apply best swap\n+                    _, removed_set, closure_u, new_set, new_score = best_move\n+                    current = set(new_set)\n+                    current_score = new_score\n+                    if current_score > best_score + 1e-9:\n+                        best = set(current)\n+                        best_score = current_score\n+                        no_improve = 0\n+                    else:\n+                        no_improve += 1\n+                    improved = True\n+                    swapped = True\n+                else:\n+                    # consider accepting a small worsening move probabilistically (simulated annealing)\n+                    if add_candidates and remove_candidates:\n+                        # pick top random pair and consider\n+                        cand_add = rng.choice(add_candidates[:min(5, len(add_candidates))])\n+                        cand_rem = rng.choice(remove_candidates[:min(5, len(remove_candidates))])\n+                        _, u, closure_u = cand_add\n+                        _, v, removed_set = cand_rem\n+                        feasible, new_set = feasible_swap(removed_set, closure_u, current, min_card, max_card)\n+                        if feasible:\n+                            new_score = objective(new_set)\n+                            delta = new_score - current_score\n+                            if delta > 0 or rng.random() < math.exp(delta / (temperature + 1e-12)):\n+                                current = set(new_set)\n+                                current_score = new_score\n+                                if current_score > best_score + 1e-9:\n+                                    best = set(current)\n+                                    best_score = current_score\n+                                    no_improve = 0\n+                                else:\n+                                    no_improve += 1\n+                                improved = True\n+        # If not improved, try pure removal if it leads to improvement (prune negative items)\n+        if not improved and remove_candidates:\n+            # remove the item which gives largest improvement (largest 'negative loss' meaning reduce objective negative interactions)\n+            # We look for removals that increase objective (loss < 0)\n+            candidate_removals = [rc for rc in remove_candidates if rc[0] < -1e-9]\n+            if candidate_removals:\n+                candidate_removals.sort()\n+                loss_val, v, removed_set = candidate_removals[0]\n+                new_set = current - removed_set\n+                current = set(new_set)\n+                current_score = objective(current)\n+                if current_score > best_score + 1e-9:\n+                    best = set(current)\n+                    best_score = current_score\n+                    no_improve = 0\n+                else:\n+                    no_improve += 1\n+                improved = True\n+        \n+        # Random shake (small) to escape plateaus\n+        if not improved and rng.random() < SHAKE_PROB:\n+            # attempt random feasible add or swap\n+            if add_candidates:\n+                _, u, closure_u = rng.choice(add_candidates[:min(10, len(add_candidates))])\n+                feasible_add, closure = feasible_after_adding(u, current, max_card)\n+                if feasible_add:\n+                    current |= closure\n+                    current_score = objective(current)\n+                    if current_score > best_score + 1e-9:\n+                        best = set(current)\n+                        best_score = current_score\n+                        no_improve = 0\n+                    else:\n+                        no_improve += 1\n+                    improved = True\n+            elif remove_candidates:\n+                _, v, removed_set = rng.choice(remove_candidates[:min(10, len(remove_candidates))])\n+                new_set = current - removed_set\n+                if len(new_set) >= min_card:\n+                    current = set(new_set)\n+                    current_score = objective(current)\n+                    if current_score > best_score + 1e-9:\n+                        best = set(current)\n+                        best_score = current_score\n+                        no_improve = 0\n+                    else:\n+                        no_improve += 1\n+                    improved = True\n+        \n+        if not improved:\n+            no_improve += 1\n+        \n+        # cooling\n+        temperature *= COOLING\n+    \n+    # Final pruning to ensure within cardinality bounds and precedence closure\n+    final_sel = closure_of_set(best)\n+    # If still beyond max, prune low-contribution items\n+    if len(final_sel) > max_card:\n+        final_sel = prune_to_max(final_sel)\n+    # Ensure at least min_card\n+    if len(final_sel) < min_card:\n+        # greedily add best remaining feasible items\n+        for i in range(n):\n+            if len(final_sel) >= min_card:\n                 break\n-        \n-        if not can_add:\n-            continue\n-        \n-        # Check precedence (if j selected, i must be selected)\n-        precedence_ok = True\n-        for pred_i, pred_j in precedence:\n-            if pred_j == i and pred_i not in selected_set:\n-                precedence_ok = False\n-                break\n-        \n-        if not precedence_ok:\n-            continue\n-        \n-        # Add if we meet minimum cardinality or have room\n-        if len(selected_set) < cardinality_bounds[1]:\n-            selected_set.add(i)\n-            selected.append(i)\n-    \n-    # Ensure minimum cardinality\n-    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n-        for i in range(n):\n-            if i not in selected_set:\n-                selected_set.add(i)\n-                selected.append(i)\n-                break\n-    \n-    # Output result\n-    result = {\n-        \"selection\": {\n-            \"variables\": sorted(selected)\n-        }\n-    }\n+            feasible, closure = feasible_after_adding(i, final_sel, max_card)\n+            if feasible:\n+                final_sel |= closure\n+    final_list = sorted(int(x) for x in final_sel)\n+    result = {\"selection\": {\"variables\": final_list}}\n     print(json.dumps(result))\n # EVOLVE-BLOCK-END\n \n \n # This part remains fixed (not evolved)\n def run_sds(problem_data=None):\n     \"\"\"\n     Main function called by the evaluator.\n     Can accept problem_data as parameter or read from stdin.\n     Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n     \"\"\"\n     import sys\n     import json\n     import io\n     \n     if problem_data is None:\n         # Read from stdin (for compatibility)\n         input_data = json.load(sys.stdin)\n     else:\n         # Use provided problem data\n         input_data = problem_data\n     \n     # Capture stdout from solve_sds\n     stdout_capture = io.StringIO()\n     old_stdin = sys.stdin\n     \n     try:\n         # Create mock stdin\n         sys.stdin = io.StringIO(json.dumps(input_data))\n         with contextlib.redirect_stdout(stdout_capture):\n             solve_sds()\n     finally:\n         sys.stdin = old_stdin\n     \n     result_str = stdout_capture.getvalue()\n     return result_str\n \n",
      "combined_score": 0.0,
      "public_metrics": {},
      "private_metrics": {},
      "text_feedback": "",
      "correct": false,
      "children_count": 0,
      "complexity": 1.0,
      "embedding": [
        0.0051326803,
        -0.010644793,
        0.04136499,
        -0.023759343,
        0.013321513,
        0.018626664,
        0.033307232,
        -0.0012124578,
        -0.025580617,
        0.04360019,
        0.054445047,
        -0.049036413,
        -0.03700497,
        0.005487967,
        0.040675115,
        -0.012645435,
        0.019137172,
        -0.008844215,
        -0.019275147,
        0.023524785,
        0.03924017,
        0.0022558959,
        0.03416268,
        0.0067573395,
        0.027194928,
        -0.0014642627,
        0.038136367,
        0.055659227,
        0.059826083,
        -0.041282203,
        0.074506655,
        -0.00664351,
        -0.0452007,
        -0.014404619,
        -0.037612062,
        0.01792299,
        -0.0057294234,
        0.024683777,
        -0.044290066,
        0.008899406,
        -0.0003526993,
        -0.036811806,
        -0.018336914,
        0.0072092083,
        -0.015135888,
        -0.0039150487,
        0.0017281404,
        -0.009865233,
        0.03355559,
        0.0042047966,
        -0.03918498,
        0.022310603,
        0.008506176,
        0.050140217,
        0.0063468628,
        -0.015618802,
        0.006609016,
        -0.0054293275,
        0.006488288,
        0.012948981,
        0.033003688,
        -0.0018316219,
        0.061923306,
        0.00076058874,
        -0.020020213,
        -0.011417454,
        -0.01177619,
        0.013569869,
        0.014597785,
        -0.00068642705,
        -0.072354235,
        -0.01590855,
        0.016129311,
        -0.035708003,
        -0.014280441,
        -0.0047980906,
        0.041061442,
        0.042110056,
        0.0063434136,
        -0.03322445,
        -0.037087757,
        -0.025139097,
        0.05839114,
        -0.03700497,
        -0.05251339,
        -0.07412032,
        -0.02311086,
        -0.0100101065,
        -0.07378918,
        -0.07340285,
        -0.0245596,
        0.0048325844,
        -0.038467508,
        0.042717148,
        0.026615432,
        -0.026505051,
        0.05822557,
        -0.010527514,
        -0.011155302,
        0.016791591,
        0.012555751,
        -0.045531843,
        -0.006174394,
        -0.020613506,
        0.028146958,
        0.02182769,
        0.0041737524,
        0.020516925,
        -0.020047808,
        0.00072609494,
        -0.045255892,
        0.018999197,
        -0.013328413,
        0.021924272,
        0.0049602115,
        -0.052596178,
        -0.017605646,
        -0.008030161,
        0.007864591,
        -0.022917693,
        -0.012128027,
        0.009754852,
        -0.009485801,
        0.04246879,
        -0.020696292,
        0.018806031,
        0.026725812,
        -0.042661957,
        -0.03454901,
        -0.020268569,
        0.047960207,
        0.010762072,
        0.03529408,
        -0.02818835,
        -0.043682974,
        -0.0120866345,
        -0.024904538,
        0.005798411,
        -0.013652654,
        0.00058337674,
        0.010762072,
        -0.011603721,
        -0.006246831,
        0.025028717,
        -0.030851273,
        0.019951226,
        0.025953151,
        0.024049092,
        -0.071195245,
        0.04878806,
        0.030630512,
        -0.00031928343,
        -0.0032406945,
        0.007899085,
        0.056017965,
        -0.062309638,
        -0.019385528,
        0.021800095,
        0.045752604,
        -0.029002404,
        0.016143108,
        0.0028164205,
        -0.0011598547,
        -0.023786938,
        0.04448323,
        -0.0058191074,
        -0.0524582,
        0.028809238,
        -0.07516893,
        -0.033638373,
        0.012590244,
        -0.07384437,
        -0.016598426,
        -0.0078025023,
        0.013611262,
        -0.011265682,
        -0.008582062,
        -0.014528797,
        0.013066259,
        -0.025235679,
        -0.037805226,
        -0.015246268,
        -0.046801217,
        -0.03170672,
        -0.040730305,
        -0.0075886403,
        0.010817262,
        -0.0016315577,
        -0.017329695,
        0.0143632265,
        0.007305791,
        0.014501202,
        0.02277972,
        0.011382961,
        0.011038022,
        -0.01775742,
        0.061923306,
        0.050112624,
        0.015467029,
        0.023855926,
        0.0073195887,
        -0.020061607,
        0.037970796,
        -0.017398683,
        0.020392746,
        -0.030934058,
        -0.025318464,
        -0.016363868,
        -0.012341889,
        -0.015356649,
        0.03344521,
        -0.056128345,
        -0.00065883197,
        0.028643668,
        0.014597785,
        0.021124016,
        -0.030244181,
        0.013638857,
        0.00021299934,
        0.09890068,
        -0.017329695,
        0.028215945,
        0.00496711,
        -0.0041496065,
        -0.0031096179,
        0.069925874,
        0.005822557,
        -0.020475531,
        -0.0045014434,
        -0.014183859,
        -0.017095137,
        -0.021703511,
        -0.012190117,
        0.00859586,
        -0.0089339,
        -0.03366597,
        0.0012236682,
        -0.004698058,
        0.005260308,
        0.014294239,
        0.036204714,
        0.021869082,
        0.0030354562,
        -0.016736401,
        0.0318171,
        0.002618081,
        -0.05488657,
        -0.0042841323,
        -0.031679124,
        -0.004811888,
        0.028616073,
        -0.05844633,
        0.03579079,
        -0.011348467,
        -0.035708003,
        -0.023952508,
        0.0114036575,
        -0.020365153,
        -0.022227818,
        0.043075882,
        -0.060046844,
        0.015287661,
        0.01713653,
        -0.0329209,
        -0.033638373,
        0.006805631,
        -0.0037218833,
        -0.005577651,
        -0.0015780923,
        -0.017219314,
        -0.02237959,
        0.028754048,
        -0.03890903,
        -0.0066400603,
        -0.037888013,
        -0.025690997,
        -0.002016164,
        0.07798363,
        -0.027595056,
        -0.040675115,
        -0.05877747,
        -0.0026525748,
        0.057508096,
        0.0065607247,
        0.033527993,
        -0.010803465,
        -0.008699342,
        0.025001122,
        0.020475531,
        0.0014064856,
        -0.015342851,
        -0.016032727,
        0.027001763,
        -0.036066737,
        -0.021096421,
        -0.03874346,
        -0.022586554,
        -0.00390815,
        0.022696935,
        0.0022610698,
        0.07594159,
        0.0076438305,
        0.0035839078,
        0.015549814,
        -0.030740893,
        -0.016294882,
        0.059494942,
        -0.012500561,
        -0.0005885508,
        0.022586554,
        -0.0134525895,
        0.0023421305,
        0.002645676,
        -0.013017968,
        -0.03656345,
        -0.009837638,
        0.05336884,
        -0.008292315,
        0.039212573,
        0.010361943,
        -0.047353115,
        -0.022255413,
        0.030796083,
        0.023938712,
        0.026256695,
        -0.030409751,
        -0.0007601576,
        0.0022921143,
        0.0032872611,
        -0.027153535,
        -0.0030958203,
        -0.0065676235,
        0.03319685,
        0.029333545,
        -0.023869723,
        -0.04268955,
        -0.028422909,
        -0.009589282,
        0.0047084065,
        0.014473607,
        -0.04509032,
        -0.009196052,
        -0.014225252,
        -0.006429648,
        0.00016513916,
        0.0022645192,
        -0.002914728,
        0.055410873,
        0.05375517,
        0.01937173,
        -0.012190117,
        -0.008637252,
        -0.00848548,
        0.066835225,
        -0.024587195,
        -0.019454515,
        -0.012976576,
        0.012969676,
        -0.030602917,
        -0.003321755,
        0.008830418,
        -0.00025525427,
        0.015922347,
        -0.0049257176,
        -0.009140862,
        0.016598426,
        -0.020199582,
        0.024021497,
        -0.020861862,
        0.026008341,
        0.018033369,
        0.04840173,
        -0.0022731428,
        0.0217725,
        -0.07941857,
        -0.026256695,
        -0.006019172,
        0.026035937,
        0.05281694,
        0.025470236,
        0.009133964,
        -0.005643189,
        -0.038522698,
        -0.010837958,
        0.028174553,
        0.032672547,
        0.012328091,
        1.1284599e-05,
        -0.048429325,
        -0.039957643,
        0.030547727,
        -0.0429655,
        0.010286057,
        -0.005995026,
        0.012431573,
        -0.00048463818,
        0.0018574923,
        0.048236158,
        0.02758126,
        0.046166528,
        -0.0031803302,
        0.02338681,
        -0.023483394,
        -0.050278194,
        -0.040150806,
        -0.0022300256,
        0.059770893,
        0.03372116,
        -0.0044531524,
        -0.01724691,
        0.045862984,
        0.016722605,
        0.034797367,
        -0.0031751562,
        0.030823678,
        -0.008975292,
        -0.02048933,
        0.03857789,
        0.010589603,
        0.047656663,
        0.0005113709,
        -0.013969997,
        0.02355238,
        -0.05052655,
        -0.040426757,
        0.007781806,
        0.032451786,
        -0.019633882,
        0.04293791,
        0.011700304,
        -0.02254516,
        0.08322669,
        0.050195407,
        0.03557003,
        0.007595539,
        0.03394192,
        0.027857209,
        0.03264495,
        0.0023421305,
        0.0001662171,
        -0.025263274,
        -0.014197657,
        0.021855285,
        -0.0048360336,
        -0.04084068,
        0.013162842,
        0.011493341,
        -0.039819665,
        0.020006416,
        0.035956357,
        0.011417454,
        0.009064976,
        0.051657945,
        0.019385528,
        -0.008858013,
        -0.0021903575,
        0.06909802,
        -0.0019437268,
        0.04365538,
        -0.0044531524,
        0.035652813,
        0.03316926,
        -0.033914324,
        0.012065939,
        0.017729824,
        0.033693563,
        0.03176191,
        0.030023422,
        -0.020834267,
        0.025884163,
        0.034852557,
        -0.02551163,
        -0.027305309,
        -0.011886571,
        -0.026146315,
        -0.02919557,
        0.030437347,
        0.017481469,
        0.016170703,
        0.00848548,
        0.0014659874,
        -0.014004491,
        0.012183217,
        0.026298089,
        0.03957131,
        0.06297192,
        0.0368394,
        -0.028533287,
        -0.0049533127,
        0.011983153,
        0.029388735,
        0.019454515,
        -0.00843029,
        -0.01663982,
        0.010017006,
        -0.018875018,
        -0.0041323598,
        0.026311886,
        -0.013155943,
        0.0056845816,
        0.01764704,
        -0.011927963,
        -0.034907747,
        0.022448579,
        0.020723887,
        0.003728782,
        0.01473576,
        -0.0022903897,
        -0.008050858,
        0.031210009,
        -0.046194125,
        -0.012638535,
        -0.030464942,
        0.016708806,
        0.03717054,
        0.017426278,
        -0.024187068,
        -0.013466387,
        -0.032562166,
        0.0053741373,
        -0.0035632118,
        -0.022186425,
        -0.027429486,
        0.006184742,
        0.01708134,
        -0.021758702,
        0.010148082,
        -0.06324787,
        -0.05314808,
        -0.00097445044,
        0.0091753565,
        -0.011762393,
        -0.044897158,
        0.058059998,
        -0.034742177,
        0.0056466386,
        -0.021275789,
        -0.013500881,
        0.0050154016,
        0.011038022,
        -0.003990935,
        -0.006357211,
        -0.021703511,
        -0.009485801,
        0.0073264875,
        -0.03722573,
        0.0552729,
        0.027056953,
        -0.0018764639,
        -0.017550455,
        -0.023842128,
        -0.019150969,
        -0.0065745222,
        -0.018116154,
        -0.025139097,
        -0.0048256856,
        -0.045725007,
        -0.014432214,
        -0.007843895,
        -0.0015539466,
        0.0006704736,
        0.00115813,
        0.009741055,
        -0.006491737,
        -0.015411839,
        -0.012293598,
        0.0429655,
        0.030354561,
        -0.0012961053,
        0.030823678,
        -0.012128027,
        -0.035956357,
        0.0064055026,
        -0.055990368,
        0.05510733,
        0.004063372,
        0.0059294878,
        -0.03316926,
        -0.008209529,
        -0.014487404,
        -0.029499115,
        -0.023579976,
        -0.006115754,
        -0.0059743295,
        -0.09443028,
        0.03170672,
        -0.022890098,
        0.035597622,
        -0.00063511747,
        -0.007133322,
        0.0016815737,
        -0.000107362015,
        0.011900368,
        0.01373544,
        -0.0120107485,
        -0.007685223,
        -0.04666324,
        -0.00792668,
        -0.014025187,
        0.006609016,
        0.0022800416,
        -0.028892023,
        0.031237604,
        0.0006821153,
        -0.026367076,
        0.0046359696,
        0.019661477,
        0.0061571468,
        0.0043738163,
        -0.006491737,
        -0.028698858,
        -0.0020075403,
        0.0024921785,
        0.008188833,
        -0.035487242,
        -0.0038667573,
        -0.008195732,
        0.03325204,
        0.039985236,
        -0.042275626,
        0.019219957,
        -0.009106369,
        -0.012604042,
        0.029223165,
        0.039322954,
        -0.007464463,
        -0.004756698,
        -0.010017006,
        0.020641102,
        -0.021800095,
        -0.02963709,
        -0.0074713617,
        -0.032451786,
        0.03973688,
        -0.017481469,
        -0.0013901009,
        0.026918977,
        -0.013625059,
        -0.00043807153,
        0.005453473,
        0.015204876,
        -0.0045014434,
        -0.019247552,
        -0.03366597,
        0.027677841,
        0.02362137,
        -0.029388735,
        0.012245306,
        0.012245306,
        -0.0050326483,
        -0.02188288,
        -0.027788222,
        0.01662602,
        -0.027926197,
        0.047601473,
        -0.005091288,
        -0.0045911274,
        -0.019068183,
        -0.019040588,
        0.0043841647,
        -0.022627946,
        -0.008519974,
        -0.01043783,
        0.011762393,
        -0.007112626,
        0.023235038,
        0.018116154,
        0.036094334,
        0.031016843,
        0.0077266158,
        -0.027595056,
        0.013963099,
        0.011658912,
        -0.025953151,
        9.054628e-05,
        -0.022503769,
        0.024904538,
        -0.015218673,
        -0.0072574997,
        0.03454901,
        -0.012659232,
        -0.0077680084,
        -0.043131072,
        0.032672547,
        0.006615915,
        -0.02919557,
        0.022476174,
        -0.0011684782,
        0.0037253327,
        -0.0019316539,
        0.022407185,
        0.023814533,
        -0.0014780601,
        -0.01601893,
        0.013328413,
        0.025221882,
        0.0048153372,
        0.029112784,
        -0.013411198,
        -0.09139483,
        -0.02144136,
        0.03170672,
        0.001292656,
        -0.003528718,
        -0.026008341,
        -0.022917693,
        -0.0075886403,
        0.027332904,
        0.04119942,
        -0.009948018,
        0.006995347,
        0.016074121,
        -0.01121739,
        -0.0032372451,
        -0.041778915,
        0.013459489,
        0.03311407,
        0.015977537,
        0.014335631,
        -0.041447774,
        -0.05058174,
        -0.0090994695,
        -0.024062889,
        0.01792299,
        -0.039267763,
        -0.021165408,
        -0.012762713,
        0.023869723,
        0.002405944,
        0.024297448,
        0.026077328,
        0.0010391263,
        -0.0016781244,
        0.009637574,
        -0.013694047,
        -0.00039473866,
        -0.037832823,
        -0.009906625,
        -0.023800736,
        0.027926197,
        0.0021179207,
        -0.023055669,
        0.012900689,
        -0.005170624,
        -0.015991336,
        0.0027836512,
        -0.0004898122,
        0.042303223,
        -0.07665907,
        0.04365538,
        -0.041944485,
        0.011734798,
        -0.002148965,
        0.002204155,
        0.027677841,
        0.0262291,
        0.022241615,
        -0.0012771337,
        -0.025001122,
        0.03339002,
        -0.019909833,
        -0.0046428684,
        -0.03924017,
        -0.006860821,
        0.015025509,
        0.030713297,
        0.006705599,
        -0.020585911,
        0.009168457,
        0.033583183,
        0.032286216,
        -0.0067400923,
        0.019937428,
        0.010893148,
        0.019689072,
        -0.023097062,
        0.007436868,
        -0.045725007,
        -0.015287661,
        0.018281724,
        0.017619444,
        -0.007574843,
        0.00075713935,
        0.03297609,
        0.0062433816,
        -9.404956e-06,
        -0.0028612623,
        -0.007519653,
        0.03143077,
        -0.04081309,
        -0.02635328,
        0.01964768,
        -0.020309962,
        0.029968232,
        -0.01635007,
        0.006522781,
        -0.029857852,
        -0.13830642,
        -0.008278517,
        0.01864046,
        -0.009064976,
        -0.005698379,
        -0.016819187,
        0.00265085,
        -0.012231508,
        0.0038840042,
        -0.02769164,
        -0.04293791,
        -0.012493662,
        0.039902452,
        0.016501844,
        0.016667414,
        -0.025497831,
        -0.0016117238,
        0.028119363,
        0.012886891,
        -0.032948498,
        -0.027512271,
        0.01735729,
        -0.010575806,
        0.016874377,
        -0.014777153,
        -0.017164124,
        0.0023386811,
        0.028754048,
        -0.017536659,
        0.017164124,
        0.019068183,
        0.0019954676,
        0.019385528,
        0.03863308,
        -0.029692281,
        -0.0013495707,
        0.0148461405,
        -0.00026150627,
        -0.0053844852,
        0.006933258,
        0.025746187,
        -0.0018747392,
        0.056790628,
        -0.03744649,
        0.0072919936,
        -0.014666772,
        0.005391384,
        -0.00636411,
        -0.018985398,
        0.04089587,
        0.020365153,
        0.003399366,
        -0.0023455797,
        -0.023083264,
        -0.01741248,
        0.01792299,
        0.00326484,
        -0.007664527,
        -0.015660195,
        0.024173269,
        -0.004949863,
        0.015356649,
        0.06501395,
        -0.03562522,
        -0.034742177,
        0.007850793,
        -0.010044601,
        -0.011638215,
        -0.009030482,
        0.021620726,
        0.009575484,
        -0.0011236361,
        -0.020972243,
        -0.01379063,
        -0.030878868,
        0.04103385,
        -0.013473286,
        -0.0031182414,
        0.0003212237,
        -0.01847489,
        0.035432052,
        -0.027995184,
        0.0173021,
        0.031789504,
        0.019730465,
        0.05129921,
        0.01662602,
        0.008016364,
        0.019454515,
        0.036204714,
        -0.01027226,
        -0.010320551,
        0.003476977,
        -0.0077611096,
        -0.035487242,
        0.0064089517,
        -0.0033476253,
        -0.005850152,
        0.02745708,
        0.018723246,
        0.022241615,
        0.053893145,
        0.032065455,
        -0.02204845,
        -0.023800736,
        0.05256858,
        -0.01770223,
        0.008506176,
        -0.017854001,
        0.03562522,
        -0.01757805,
        0.0045566335,
        -0.049560722,
        0.029443925,
        -0.016736401,
        -0.0034959486,
        -0.0033700461,
        0.024642386,
        0.004170303,
        -0.0027181131,
        0.005446574,
        0.043682974,
        -0.022738326,
        0.02640847,
        -0.016846782,
        -0.0074161715,
        -0.012935183,
        0.0056742337,
        -0.00090115104,
        0.007912883,
        0.041944485,
        -0.005553505,
        -0.030796083,
        0.07251981,
        0.0080370605,
        0.018654259,
        0.037722442,
        -0.039543714,
        -0.016087918,
        -0.00046264837,
        0.02355238,
        0.020034011,
        -0.017619444,
        -0.026063532,
        0.00070065574,
        0.019302743,
        0.015549814,
        -0.013431894,
        -0.051271614,
        0.01757805,
        -0.016612224,
        -0.019178564,
        -0.0037736238,
        0.026767205,
        -0.023690356,
        0.03562522,
        -0.015673991,
        -0.030658107,
        -0.008754532,
        -0.02362137,
        0.03957131,
        0.009913524,
        0.007781806,
        -0.027319105,
        0.018957803,
        0.007333386,
        -0.0058398037,
        -0.033527993,
        0.035597622,
        0.02059971,
        -0.04699438,
        -0.027498474,
        -0.008388897,
        0.007519653,
        0.010251563,
        0.0329209,
        0.0032165488,
        -0.009299534,
        -0.0016168979,
        0.023138454,
        0.0041668536,
        0.028160755,
        -0.027498474,
        0.0010796565,
        0.046690837,
        -0.047767043,
        0.0056535373,
        0.0061985394,
        0.0018971601,
        -0.011307075,
        0.032203432,
        0.036922187,
        -0.01836451,
        0.05905342,
        -0.012024546,
        0.00010784709,
        0.0048084385,
        0.006012273,
        0.032506976,
        -0.02199326,
        -0.011976254,
        0.015039306,
        0.012914486,
        -0.04279993,
        0.02936114,
        0.053230863,
        0.0050947373,
        -0.012410876,
        -0.013542274,
        0.0012150449,
        -0.0013866515,
        0.0056638853,
        -0.028229743,
        -0.0033252044,
        -0.03755687,
        0.017978178,
        0.016763996,
        0.007912883,
        -0.04293791,
        -0.028947214,
        -0.03383154,
        -0.029747471,
        0.020958446,
        -0.00092184736,
        -0.0071678157,
        0.024463017,
        -0.01713653,
        0.020447936,
        0.0048877746,
        0.019413123,
        -0.026725812,
        0.015591207,
        -0.029057594,
        -0.0013547448,
        0.021731107,
        -0.033859134,
        0.020406544,
        0.008802823,
        -0.0020058157,
        0.041834105,
        0.01713653,
        -0.014542595,
        -0.0033321031,
        -0.0039495425,
        0.027319105,
        -0.02327643,
        0.023248835,
        0.027332904,
        0.014045884,
        -0.013659553,
        -0.021358574,
        -0.0058984435,
        0.04169613,
        -0.04382095,
        0.034576606,
        -0.010127386,
        0.031072034,
        0.0563767,
        0.013266323,
        -0.0009735881,
        0.0049912557,
        -0.0020092651,
        0.007830097,
        -0.013949301,
        -0.026560241,
        -0.022062248,
        -0.015370446,
        0.028422909,
        0.025842771,
        0.0009511671,
        -0.0015116917,
        0.040426757,
        -0.0156050045,
        0.03137558,
        -0.0123142935,
        -0.01931654,
        -0.0068470235,
        0.0006118341,
        -0.0006799594,
        -0.046746027,
        -0.01412177,
        0.021303384,
        0.0095547885,
        0.022862503,
        0.015825765,
        -0.045476653,
        0.0062882234,
        -0.031955075,
        0.012907588,
        -0.024945932,
        0.01875084,
        0.007747312,
        0.00086795073,
        -0.00095979054,
        0.0083751,
        -0.0051533766,
        -0.0026370527,
        -0.017260708,
        0.00876143,
        -0.013404299,
        -0.0034856005,
        0.009271939,
        0.02366276,
        -0.024062889,
        0.04326905,
        0.008927001,
        -0.011872773,
        0.0015039305,
        -0.019689072,
        -0.009623776,
        -0.015066901,
        -0.008775228,
        0.010230867,
        0.009899726,
        0.024076687,
        0.00023822294,
        -0.00036779037,
        -0.011141504,
        -0.023524785,
        0.018916411,
        0.009616877,
        0.043517403,
        -0.0024318143,
        -0.006174394,
        -0.016363868,
        -0.0007584329,
        0.012003849,
        0.0040116315,
        -0.0063848062,
        -0.022848707,
        0.0045014434,
        0.024959728,
        0.025484035,
        -0.008975292,
        -0.024863146,
        0.030106207,
        -0.050305787,
        -0.0031113427,
        -0.024738967,
        -0.016984757,
        -0.017591849,
        -0.003516645,
        -0.017177923,
        0.0018695651,
        -0.033362422,
        -0.007905983,
        -0.028257338,
        0.01585336,
        -0.018723246,
        0.0042289426,
        0.0892976,
        0.010796566,
        -0.02633948,
        0.0149979135,
        0.0028698859,
        0.021096421,
        -0.0009080498,
        -0.0064399964,
        -0.0018247231,
        -0.03678421,
        -0.04092347,
        0.02919557,
        0.006105406,
        0.0029888896,
        0.023469595,
        0.009016684,
        -0.0116313165,
        0.006184742,
        0.004849831,
        -0.02729151,
        0.024835551,
        0.022448579,
        0.014211454,
        0.00034148883,
        0.025539225,
        0.007954275,
        0.0075541465,
        -0.010837958,
        0.020116797,
        0.015494624,
        0.0019264799,
        -0.018378308,
        -0.037529275,
        0.0042737843,
        -0.012976576,
        0.021344775,
        -0.008471683,
        0.025553022,
        -0.00032941598,
        -0.03438344,
        -0.023248835,
        -0.0027146637,
        -0.014694368,
        0.0023524784,
        0.026201505,
        0.0100101065,
        -0.028215945,
        0.037253328,
        0.008989089,
        -0.0025991094,
        -0.010927643,
        0.020158188,
        -0.00018001463,
        -0.035432052,
        -0.027208725,
        -0.025428845,
        0.008326808,
        0.037750036,
        -0.0065124333,
        -0.021744905,
        -0.035901166,
        -0.025235679,
        0.017274505,
        0.048291348,
        0.016763996,
        -0.02662923,
        0.0092512425,
        -0.0063089198,
        -0.037943203,
        0.035956357,
        -0.04089587,
        0.0027319107,
        0.005236162,
        0.013466387,
        0.024104282,
        0.014777153,
        -0.015411839,
        0.02439403,
        0.0051533766,
        -0.027622651,
        -0.009754852,
        -0.0018557676,
        -0.024214663,
        -0.026491255,
        -0.008437188,
        0.0039219474,
        0.02204845,
        0.036204714,
        -0.022655541,
        0.0011365714,
        -0.05491416,
        0.003997834,
        0.0024939033,
        0.004222044,
        -0.0011960733,
        -0.025649605,
        0.008837317,
        0.000364341,
        -0.033362422,
        0.0021023983,
        0.00034730966,
        -0.015398041,
        0.037777632,
        -0.0049636606,
        -0.0820677,
        0.01959249,
        -0.03874346,
        0.0017272781,
        -0.015977537,
        0.01161062,
        -0.0008731248,
        0.0059639816,
        0.022131234,
        0.0038598585,
        -0.038081177,
        0.030658107,
        -0.0003276913,
        -0.019109577,
        -0.017881596,
        -0.015370446,
        0.025139097,
        -0.00390815,
        0.01635007,
        -0.02551163,
        -0.009161559,
        0.011465746,
        -0.0223244,
        -0.007878388,
        -0.03728092,
        0.018047167,
        0.0034079894,
        -0.002568065,
        0.03170672,
        0.024849348,
        -0.012217712,
        -0.011010427,
        -0.0077404133,
        -0.0057535693,
        -0.03868827,
        -0.005708727,
        -0.02311086,
        -0.02261415,
        -0.029554306,
        0.032148242,
        -0.029857852,
        -0.012307395,
        -0.0021955317,
        -0.006357211,
        0.017964382,
        0.023952508,
        0.009465104,
        -0.04086828,
        0.0017678083,
        0.01792299,
        -0.0139837945,
        0.0020006415,
        0.020185784,
        -0.009968714,
        -0.0008149165,
        -0.016708806,
        -0.01770223,
        0.00882352,
        0.036977377,
        -0.013514679,
        0.01323183,
        0.007657628,
        -0.004977458,
        0.014446012,
        0.048926033,
        0.0037529278,
        0.017536659,
        -0.038991816,
        -0.005381036,
        -0.013749237,
        0.0028008982,
        0.029278355,
        0.010534413,
        -0.016736401,
        -0.03868827,
        0.018737044,
        -0.019965023,
        0.017591849,
        0.015922347,
        -0.027512271,
        0.0217725,
        -0.018654259,
        0.023152253,
        -0.0094789015,
        0.0018954354,
        -0.00965827,
        -0.0042013475,
        -0.03355559,
        0.013031766,
        -0.023993902,
        0.03018899,
        0.016598426,
        -0.0031630832,
        -0.025870366,
        -0.01568779,
        0.036011547,
        0.02054452,
        0.0012883442,
        -0.011307075,
        -0.009423711,
        -0.00057044154,
        -0.0024680328,
        0.022131234,
        0.014970318,
        0.029057594,
        -0.010596502,
        0.044510826,
        -0.0046773623,
        0.01830932,
        0.005063693,
        0.016253488,
        0.015053104,
        0.000945993,
        0.024545802,
        -0.00591569,
        0.02142756,
        -0.02540125,
        -0.030547727,
        0.011658912,
        -0.0012840325,
        -0.044455636,
        0.0070919297,
        0.00046825362,
        0.004460051,
        -0.01662602,
        0.004767046,
        0.02551163,
        0.0031406623,
        -0.011734798,
        -0.0027991736,
        0.033527993,
        -0.0111622,
        -0.03143077,
        0.031899884,
        0.0011598547,
        -0.005546606,
        -0.049312364,
        -0.005832905,
        0.013369805,
        -0.0030320068,
        -0.0063123694,
        0.03667383,
        0.02327643,
        -0.0078163,
        -0.01038264,
        -0.013052462,
        0.0006855647,
        0.0025163242,
        -0.007250601,
        -0.037032567,
        0.019357933,
        -0.037943203,
        0.003471803,
        -0.04900882,
        0.005139579,
        0.0077059194,
        -0.0043600188,
        0.005519011,
        -0.011679607,
        0.011396758,
        0.019357933,
        -0.009699662,
        -0.03432825,
        0.004570431,
        -0.023083264,
        -0.03432825,
        -0.013997592,
        0.031347983,
        -0.03551484,
        -0.0061640455,
        0.0063261664,
        0.036370285,
        0.0031423871,
        -0.03361078,
        0.025415046,
        -0.032341406,
        0.038163964,
        0.012362585,
        -0.040371567,
        0.017619444,
        0.016474249,
        0.0011952108,
        -0.0039150487,
        0.0107689705,
        0.03355559,
        -0.00831991,
        0.039047007,
        -0.0044014114,
        0.00018087697,
        -0.020917052,
        -0.018971602,
        -0.012348788,
        0.004270335,
        -0.014377024,
        0.041061442,
        -0.0049084704,
        -0.008071554,
        0.013597464,
        0.03584598,
        -0.02450441,
        0.0051809717,
        -0.02545644,
        0.011113909,
        0.0312652,
        -0.018336914,
        0.024587195,
        -0.017991977,
        0.022531364,
        -0.01099663,
        -0.014942723,
        -0.019978821,
        0.0090994695,
        0.01027226,
        -0.00057690917,
        -0.06777346,
        0.042192843,
        -0.020392746,
        0.024007699,
        0.006426199,
        -0.017371088,
        0.004125461,
        -0.019150969,
        -0.030851273,
        0.004639419,
        0.041778915,
        -0.032534573,
        0.04715995,
        -0.011079415,
        0.03449382,
        0.0047532483,
        0.013852718,
        0.005453473,
        0.010037702,
        0.03303128,
        -0.006143349,
        0.0061536976,
        0.0030268328,
        0.025980746,
        -0.008030161,
        0.012500561,
        -0.011231188,
        0.038219154,
        0.0089339,
        -0.0043048286,
        -0.017716026,
        0.009575484,
        -0.004346221,
        -0.016156906,
        0.007857692,
        -0.033527993,
        -0.013521577,
        0.0021920823,
        -0.022903897,
        -0.028698858,
        -0.030023422,
        0.024918336,
        -0.047739446,
        0.008885608,
        0.009720359,
        -0.0156050045,
        0.0009778998,
        0.022903897,
        0.006426199,
        -0.012507459,
        -0.0034407587,
        -0.027098345,
        0.024476815,
        0.02054452,
        0.018433498,
        0.015356649,
        -0.0041323598,
        0.01757805,
        -0.01027226,
        -0.018668056,
        -0.0025525426,
        0.009520294,
        0.025580617,
        0.008582062,
        -0.010341248,
        -0.01768843,
        -0.0015806793,
        -0.0015401491,
        -0.0026491254,
        -0.0058018607,
        -0.02668442
      ],
      "embedding_pca_2d": [],
      "embedding_pca_3d": [],
      "embedding_cluster_id": null,
      "migration_history": [],
      "metadata": {
        "compute_time": 2.010892152786255,
        "patch_type": "full",
        "api_costs": 0.012316999999999998,
        "num_applied": 1,
        "patch_name": "localsearch_sds",
        "patch_description": "Key parameters in the original approach:\n- interaction potential factor (fixed 0.5)\n- single-pass greedy ordering by a simple score\n- no local improvement or precedence-aware closure handling\n- no adaptive behavior (static heuristics)\n\nNew algorithmic configuration and parameters:\n- Adaptive interaction weighting: interaction_bias adapts to problem scales using average absolute interaction vs average absolute weight. This prevents under- or over-counting pair synergies and improves candidate ranking.\n- Precedence closure logic: adding a variable automatically adds all required ancestors; removals consider forced cascades. This avoids infeasible picks and better evaluates true marginal cost/benefit.\n- Constraint-aware marginal gain computation: marginal gain for a candidate includes weights/interactions for any forced closure items and accounts for group/mutex conflicts and cardinality impact.\n- Iterated Local Search with deterministic greedy seed + targeted neighborhood moves (add/remove/swap) and simulated-annealing-style occasional acceptance (temperature schedule). Parameters:\n  - max_iters (5000) with patience for no improvement (200)\n  - swap-considered set sizes (top_k candidates) to control search breadth\n  - shake probability (0.02) to escape local optima\n  - initial_temperature (0.5) and cooling rate (0.995)\nThese parameters are chosen to balance runtime and solution quality; they are adaptive and tunable. The algorithm performs a strong constraint-aware greedy initialization followed by an intensive constrained local search that explores swaps, adds, and removals while respecting precedence/group/mutex/cardinality constraints. This typically produces higher raw_score by capturing synergies and ensuring feasible, compact moves.",
        "error_attempt": null,
        "novelty_attempt": 1,
        "resample_attempt": 1,
        "patch_attempt": 1,
        "model_name": "gpt-5-mini",
        "temperature": 1.0,
        "max_output_tokens": 8192,
        "llm_result": {
          "content": "<NAME>\nlocalsearch_sds\n</NAME>\n\n<DESCRIPTION>\nKey parameters in the original approach:\n- interaction potential factor (fixed 0.5)\n- single-pass greedy ordering by a simple score\n- no local improvement or precedence-aware closure handling\n- no adaptive behavior (static heuristics)\n\nNew algorithmic configuration and parameters:\n- Adaptive interaction weighting: interaction_bias adapts to problem scales using average absolute interaction vs average absolute weight. This prevents under- or over-counting pair synergies and improves candidate ranking.\n- Precedence closure logic: adding a variable automatically adds all required ancestors; removals consider forced cascades. This avoids infeasible picks and better evaluates true marginal cost/benefit.\n- Constraint-aware marginal gain computation: marginal gain for a candidate includes weights/interactions for any forced closure items and accounts for group/mutex conflicts and cardinality impact.\n- Iterated Local Search with deterministic greedy seed + targeted neighborhood moves (add/remove/swap) and simulated-annealing-style occasional acceptance (temperature schedule). Parameters:\n  - max_iters (5000) with patience for no improvement (200)\n  - swap-considered set sizes (top_k candidates) to control search breadth\n  - shake probability (0.02) to escape local optima\n  - initial_temperature (0.5) and cooling rate (0.995)\nThese parameters are chosen to balance runtime and solution quality; they are adaptive and tunable. The algorithm performs a strong constraint-aware greedy initialization followed by an intensive constrained local search that explores swaps, adds, and removals while respecting precedence/group/mutex/cardinality constraints. This typically produces higher raw_score by capturing synergies and ensuring feasible, compact moves.\n</DESCRIPTION>\n\n<CODE>\n```python\n#!/usr/bin/env python3\n\"\"\"\nEvolved solver for Synergistic Dependency Selection (SDS) problem.\nThis EVOLVE-BLOCK contains an improved parametric local-search algorithm.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\nimport math\nimport random\nimport time\nfrom collections import defaultdict, deque\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem using:\n    - precedence closure-aware greedy initialization\n    - adaptive interaction weighting\n    - local search (add/remove/swap) with occasional random shake\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    weights = requirements.get(\"weights\", [])\n    interactions_raw = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex_list = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    n = len(weights)\n    \n    # Parse interactions into dict of tuple(int,int)->float, symmetric\n    interactions = {}\n    total_abs_inter = 0.0\n    inter_count = 0\n    for k, v in interactions_raw.items():\n        try:\n            # accept \"i,j\" with optional spaces\n            parts = k.split(\",\")\n            if len(parts) != 2:\n                continue\n            u = int(parts[0].strip())\n            w = int(parts[1].strip())\n            if u == w:\n                # ignore self interactions\n                continue\n            interactions[(u, w)] = float(v)\n            interactions[(w, u)] = float(v)\n            total_abs_inter += abs(float(v))\n            inter_count += 1\n        except Exception:\n            continue\n    avg_abs_inter = (total_abs_inter / inter_count) if inter_count > 0 else 0.0\n    avg_abs_weight = (sum(abs(float(x)) for x in weights) / n) if n > 0 else 0.0\n    \n    # Adaptive interaction bias: scale interactions to be comparable to weights\n    interaction_bias = 1.0\n    if avg_abs_weight > 1e-9:\n        interaction_bias = max(0.2, min(3.0, (avg_abs_inter / (avg_abs_weight + 1e-9)) * 1.2))\n    # parameters (tunable)\n    MAX_ITERS = 5000\n    NO_IMPROVE_PATIENCE = 200\n    TOP_K_CANDIDATES = 50  # when searching adds/swaps consider top candidates by heuristic\n    SHAKE_PROB = 0.02\n    INIT_TEMP = 0.5\n    COOLING = 0.995\n    \n    # Build precedence graph: j -> list of required preds i (if j selected, i must be selected)\n    preds = defaultdict(set)\n    succs = defaultdict(set)  # reverse: i -> set of nodes that require i\n    for pair in precedence:\n        try:\n            a, b = pair\n            preds[int(b)].add(int(a))\n            succs[int(a)].add(int(b))\n        except Exception:\n            continue\n    \n    # Build group mapping: group_id -> set(vars), and var->set(group_ids)\n    group_to_vars = {}\n    var_to_groups = defaultdict(set)\n    for gid, vars_list in groups.items():\n        # group ids may be strings; treat as keys\n        try:\n            vars_iter = list(vars_list)\n        except Exception:\n            vars_iter = []\n        group_to_vars[gid] = set(vars_iter)\n        for v in vars_iter:\n            var_to_groups[int(v)].add(gid)\n    \n    # Build mutex set for quick lookup (unordered pair)\n    mutex_set = set()\n    for pair in mutex_list:\n        if len(pair) >= 2:\n            a, b = int(pair[0]), int(pair[1])\n            if a == b:\n                continue\n            mutex_set.add((a, b))\n            mutex_set.add((b, a))\n    \n    # Helper: get full precedence closure for a set of variables (all ancestors)\n    def closure_of_set(vars_set):\n        # BFS/DFS up preds edges\n        res = set(vars_set)\n        dq = deque(vars_set)\n        while dq:\n            v = dq.popleft()\n            for p in preds.get(v, ()):\n                if p not in res:\n                    res.add(p)\n                    dq.append(p)\n        return res\n    \n    # Helper: compute dependents closure (all nodes that require any in given set) - for removal cascades\n    def dependents_to_remove_for_removed(removed_vars, current_selected):\n        # If we remove some vars, any node that (directly or transitively) requires them must also be removed\n        to_remove = set()\n        dq = deque()\n        for r in removed_vars:\n            # only consider dependents that are currently selected\n            for s in succs.get(r, ()):\n                if s in current_selected and s not in to_remove:\n                    to_remove.add(s)\n                    dq.append(s)\n        while dq:\n            v = dq.popleft()\n            for s in succs.get(v, ()):\n                if s in current_selected and s not in to_remove:\n                    to_remove.add(s)\n                    dq.append(s)\n        return to_remove\n    \n    # Objective evaluation\n    def objective(selected_set):\n        # sum weights + sum pairwise interactions (each counted once)\n        s = 0.0\n        for v in selected_set:\n            if 0 <= v < n:\n                s += float(weights[v])\n        # interactions: iterate pairs from interactions dict unique by u<v\n        # More efficient: for each u in selected, sum interactions[u,w] for w>u in selected\n        sel_list = list(selected_set)\n        sel_set = set(selected_set)\n        # sum interactions symmetrically but ensure we add each pair once\n        seen = set()\n        for u in sel_list:\n            for v in sel_list:\n                if u == v:\n                    continue\n                if (u, v) in seen:\n                    continue\n                val = interactions.get((u, v), 0.0)\n                if val != 0.0:\n                    s += val * 1.0  # interactions already raw; bias applied when used for heuristics\n                seen.add((u, v))\n                seen.add((v, u))\n        return s\n    \n    # Feasibility checks\n    def violates_mutex_pairing(candidate_set):\n        # simple O(k^2) check for small sets\n        for a in candidate_set:\n            for b in candidate_set:\n                if a != b and (a, b) in mutex_set:\n                    return True\n        return False\n    \n    def violates_grouping(candidate_set):\n        # at most one per group id\n        group_seen = {}\n        for v in candidate_set:\n            for gid in var_to_groups.get(v, ()):\n                if gid in group_seen and group_seen[gid] != v:\n                    return True\n                group_seen[gid] = v\n        return False\n    \n    def feasible_after_adding(i, current_set, max_card):\n        # compute closure for i\n        to_add_closure = closure_of_set({i})\n        # new_set = current_set U to_add_closure\n        new_set = set(current_set) | to_add_closure\n        # Check cardinality\n        if len(new_set) > max_card:\n            return False, None\n        # Check group and mutex\n        if violates_grouping(new_set):\n            return False, None\n        if violates_mutex_pairing(new_set):\n            return False, None\n        return True, to_add_closure\n    \n    def feasible_swap(remove_set, add_set, current_set, min_card, max_card):\n        # remove_set: set of vars to remove (e.g. {a} plus dependents)\n        # add_set: set of vars to add (including closures)\n        new_set = set(current_set)\n        # cascade removals of dependents\n        removed_final = set(remove_set) | dependents_to_remove_for_removed(remove_set, current_set)\n        new_set -= removed_final\n        new_set |= add_set\n        # add closure for add_set (in case not already included)\n        new_set |= closure_of_set(add_set)\n        # Check cardinality\n        if len(new_set) < min_card or len(new_set) > max_card:\n            return False, None\n        if violates_grouping(new_set):\n            return False, None\n        if violates_mutex_pairing(new_set):\n            return False, None\n        return True, new_set\n    \n    # Greedy initialization (precedence-aware)\n    min_card, max_card = int(cardinality_bounds[0]), int(cardinality_bounds[1])\n    selected = set()\n    \n    # Candidate heuristic score: marginal weight + interaction_bias * sum interactions to current selected +\n    # include closure contributions (weights + interactions inside closure)\n    def marginal_gain_if_add(i, current_set):\n        feasible, closure = feasible_after_adding(i, current_set, max_card)\n        if not feasible:\n            return -math.inf, None\n        closure = closure or set()\n        new_items = closure - current_set\n        # compute sum weights for new items\n        gain = 0.0\n        for v in new_items:\n            if 0 <= v < n:\n                gain += float(weights[v])\n        # interactions: between new items and existing items, and between new items themselves\n        for u in new_items:\n            # interactions with current_set\n            for v in current_set:\n                gain += interaction_bias * interactions.get((u, v), 0.0)\n            # interactions inside new_items (u <-> w)\n            for w in new_items:\n                if u >= w:\n                    continue\n                gain += interaction_bias * interactions.get((u, w), 0.0)\n        # also subtract any negative interactions that new items might have with existing set (already accounted)\n        return gain, closure\n    \n    # Seed selection: choose highest marginal gains until max or no positive gains; also aim to reach min_card\n    # We'll consider candidates sorted by heuristic that includes interactions to the yet-empty set (so primarily weights)\n    candidate_scores = []\n    for i in range(n):\n        # simple base heuristic: weight + interaction_bias * sum of abs interactions to others (potential)\n        pot = float(weights[i]) + interaction_bias * sum(interactions.get((i, j), 0.0) for j in range(n) if j != i)\n        candidate_scores.append((pot, i))\n    candidate_scores.sort(reverse=True)\n    for _, i in candidate_scores:\n        if len(selected) >= max_card:\n            break\n        mg, closure = marginal_gain_if_add(i, selected)\n        if closure is None:\n            continue\n        # prefer positive gain or needed to reach min_card\n        if mg > -1e-9 or len(selected) + len(closure - selected) <= min_card:\n            selected |= closure\n    # If still below min_card, add best feasible items forcibly (minimal harm)\n    if len(selected) < min_card:\n        for i in range(n):\n            if len(selected) >= min_card:\n                break\n            feasible, closure = feasible_after_adding(i, selected, max_card)\n            if not feasible:\n                continue\n            selected |= closure\n    # If above max_card due to closure, attempt to prune (rare): remove least valuable items that have no dependents\n    def prune_to_max(selected_set):\n        if len(selected_set) <= max_card:\n            return selected_set\n        # remove candidates with smallest marginal loss (removing them and their dependents)\n        sel = set(selected_set)\n        while len(sel) > max_card:\n            best_loss = math.inf\n            best_remove = None\n            for v in list(sel):\n                # cannot remove if it causes removing many required items might be large loss - we measure objective delta\n                removed = {v} | dependents_to_remove_for_removed({v}, sel)\n                new_set = sel - removed\n                loss = objective(sel) - objective(new_set)\n                if loss < best_loss:\n                    best_loss = loss\n                    best_remove = removed\n            if best_remove is None:\n                break\n            sel -= best_remove\n        return sel\n    if len(selected) > max_card:\n        selected = prune_to_max(selected)\n    \n    # Local search improvement\n    current = set(selected)\n    best = set(current)\n    best_score = objective(best)\n    current_score = best_score\n    no_improve = 0\n    temperature = INIT_TEMP\n    rng = random.Random(123456789)  # deterministic seed for reproducibility\n    \n    iter_count = 0\n    while iter_count < MAX_ITERS and no_improve < NO_IMPROVE_PATIENCE:\n        iter_count += 1\n        improved = False\n        \n        # Build candidate lists\n        not_selected = [i for i in range(n) if i not in current]\n        # Evaluate marginal gains for top candidates\n        add_candidates = []\n        for i in not_selected:\n            mg, closure = marginal_gain_if_add(i, current)\n            if closure is None:\n                continue\n            add_candidates.append((mg, i, closure))\n        add_candidates.sort(reverse=True, key=lambda x: x[0])\n        \n        # Consider removals: compute marginal loss for removing each v (including dependents)\n        remove_candidates = []\n        for v in list(current):\n            removed = {v} | dependents_to_remove_for_removed({v}, current)\n            new_set = current - removed\n            if len(new_set) < min_card:\n                # can't remove below min\n                continue\n            loss = objective(current) - objective(new_set)\n            remove_candidates.append((loss, v, removed))\n        remove_candidates.sort(key=lambda x: x[0])  # smaller loss first\n        \n        # Try best add move\n        if add_candidates:\n            mg, i_add, closure_add = add_candidates[0]\n            if mg > 1e-9 and len(current | closure_add) <= max_card:\n                # apply add\n                current |= closure_add\n                current_score = objective(current)\n                if current_score > best_score + 1e-9:\n                    best = set(current)\n                    best_score = current_score\n                    no_improve = 0\n                else:\n                    no_improve += 1\n                improved = True\n            else:\n                # Try beneficial swaps: remove some v and add some u\n                # Consider top few adds and top few removes\n                swapped = False\n                top_adds = add_candidates[:TOP_K_CANDIDATES]\n                top_removes = remove_candidates[:TOP_K_CANDIDATES]\n                best_delta = 0.0\n                best_move = None\n                # Try single removals + single addition\n                for mg_val, u, closure_u in top_adds:\n                    for loss_val, v, removed_set in top_removes:\n                        # prepare add_set = closure_u\n                        feasible, new_set = feasible_swap(removed_set, closure_u, current, min_card, max_card)\n                        if not feasible:\n                            continue\n                        new_score = objective(new_set)\n                        delta = new_score - current_score\n                        if delta > best_delta:\n                            best_delta = delta\n                            best_move = (\"swap\", removed_set, closure_u, new_set, new_score)\n                if best_move:\n                    # apply best swap\n                    _, removed_set, closure_u, new_set, new_score = best_move\n                    current = set(new_set)\n                    current_score = new_score\n                    if current_score > best_score + 1e-9:\n                        best = set(current)\n                        best_score = current_score\n                        no_improve = 0\n                    else:\n                        no_improve += 1\n                    improved = True\n                    swapped = True\n                else:\n                    # consider accepting a small worsening move probabilistically (simulated annealing)\n                    if add_candidates and remove_candidates:\n                        # pick top random pair and consider\n                        cand_add = rng.choice(add_candidates[:min(5, len(add_candidates))])\n                        cand_rem = rng.choice(remove_candidates[:min(5, len(remove_candidates))])\n                        _, u, closure_u = cand_add\n                        _, v, removed_set = cand_rem\n                        feasible, new_set = feasible_swap(removed_set, closure_u, current, min_card, max_card)\n                        if feasible:\n                            new_score = objective(new_set)\n                            delta = new_score - current_score\n                            if delta > 0 or rng.random() < math.exp(delta / (temperature + 1e-12)):\n                                current = set(new_set)\n                                current_score = new_score\n                                if current_score > best_score + 1e-9:\n                                    best = set(current)\n                                    best_score = current_score\n                                    no_improve = 0\n                                else:\n                                    no_improve += 1\n                                improved = True\n        # If not improved, try pure removal if it leads to improvement (prune negative items)\n        if not improved and remove_candidates:\n            # remove the item which gives largest improvement (largest 'negative loss' meaning reduce objective negative interactions)\n            # We look for removals that increase objective (loss < 0)\n            candidate_removals = [rc for rc in remove_candidates if rc[0] < -1e-9]\n            if candidate_removals:\n                candidate_removals.sort()\n                loss_val, v, removed_set = candidate_removals[0]\n                new_set = current - removed_set\n                current = set(new_set)\n                current_score = objective(current)\n                if current_score > best_score + 1e-9:\n                    best = set(current)\n                    best_score = current_score\n                    no_improve = 0\n                else:\n                    no_improve += 1\n                improved = True\n        \n        # Random shake (small) to escape plateaus\n        if not improved and rng.random() < SHAKE_PROB:\n            # attempt random feasible add or swap\n            if add_candidates:\n                _, u, closure_u = rng.choice(add_candidates[:min(10, len(add_candidates))])\n                feasible_add, closure = feasible_after_adding(u, current, max_card)\n                if feasible_add:\n                    current |= closure\n                    current_score = objective(current)\n                    if current_score > best_score + 1e-9:\n                        best = set(current)\n                        best_score = current_score\n                        no_improve = 0\n                    else:\n                        no_improve += 1\n                    improved = True\n            elif remove_candidates:\n                _, v, removed_set = rng.choice(remove_candidates[:min(10, len(remove_candidates))])\n                new_set = current - removed_set\n                if len(new_set) >= min_card:\n                    current = set(new_set)\n                    current_score = objective(current)\n                    if current_score > best_score + 1e-9:\n                        best = set(current)\n                        best_score = current_score\n                        no_improve = 0\n                    else:\n                        no_improve += 1\n                    improved = True\n        \n        if not improved:\n            no_improve += 1\n        \n        # cooling\n        temperature *= COOLING\n    \n    # Final pruning to ensure within cardinality bounds and precedence closure\n    final_sel = closure_of_set(best)\n    # If still beyond max, prune low-contribution items\n    if len(final_sel) > max_card:\n        final_sel = prune_to_max(final_sel)\n    # Ensure at least min_card\n    if len(final_sel) < min_card:\n        # greedily add best remaining feasible items\n        for i in range(n):\n            if len(final_sel) >= min_card:\n                break\n            feasible, closure = feasible_after_adding(i, final_sel, max_card)\n            if feasible:\n                final_sel |= closure\n    final_list = sorted(int(x) for x in final_sel)\n    result = {\"selection\": {\"variables\": final_list}}\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n    \n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n    \n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n    \n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n    \n    result_str = stdout_capture.getvalue()\n    return result_str\n\n\n# If run as a script, call solve_sds()\nif __name__ == \"__main__\":\n    solve_sds()\n```\n</CODE>",
          "msg": "\n# Current program\n\nHere is the current program we are trying to improve (you will need to \npropose a new program with the same inputs and outputs as the original \nprogram, but with improved internal implementation):\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    This is a greedy baseline - evolution will improve this.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    # Simple greedy: select items with highest weights first\n    # This is a baseline - evolution will find better strategies\n    n = len(weights)\n    selected = []\n    \n    # Create score list (weight + interaction potential)\n    scores = []\n    for i in range(n):\n        score = weights[i] if i < len(weights) else 0.0\n        # Add potential interaction value\n        for k, v in interactions.items():\n            try:\n                u, w = map(int, k.split(\",\"))\n                if u == i or w == i:\n                    score += abs(v) * 0.5  # Potential value\n            except:\n                pass\n        scores.append((score, i))\n    \n    # Sort by score descending\n    scores.sort(reverse=True)\n    \n    # Greedy selection respecting constraints\n    selected_set = set()\n    for score, i in scores:\n        if len(selected_set) >= cardinality_bounds[1]:\n            break\n            \n        # Check mutex constraints\n        can_add = True\n        for a, b in mutex:\n            if (a == i and b in selected_set) or (b == i and a in selected_set):\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n            \n        # Check group constraints (at most one per group)\n        for grp_vars in groups.values():\n            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n        \n        # Check precedence (if j selected, i must be selected)\n        precedence_ok = True\n        for pred_i, pred_j in precedence:\n            if pred_j == i and pred_i not in selected_set:\n                precedence_ok = False\n                break\n        \n        if not precedence_ok:\n            continue\n        \n        # Add if we meet minimum cardinality or have room\n        if len(selected_set) < cardinality_bounds[1]:\n            selected_set.add(i)\n            selected.append(i)\n    \n    # Ensure minimum cardinality\n    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n        for i in range(n):\n            if i not in selected_set:\n                selected_set.add(i)\n                selected.append(i)\n                break\n    \n    # Output result\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n    \n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n    \n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n    \n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n    \n    result_str = stdout_capture.getvalue()\n    return result_str\n\n\n```\n\nHere are the performance metrics of the program:\n\nCombined score to maximize: 0.35\nfeasible: True; selection_size: 10; raw_score: 106.51\n\n# Task\n\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs as the original program, but with improved internal implementation.\n",
          "system_msg": "You are an expert algorithmist specializing in combinatorial optimization, particularly the Synergistic Dependency Selection (SDS) problem.\n\nThe SDS problem requires selecting a subset of variables that:\n1. Satisfies cardinality bounds (min/max number of items)\n2. Respects mutex constraints (cannot select both items in a mutex pair)\n3. Respects group constraints (at most one item per group)\n4. Satisfies precedence constraints (if j is selected, i must be selected)\n5. Maximizes the objective: sum of selected item weights + pairwise interaction values\n\nKey strategies to explore:\n1. Greedy selection with constraint-aware ordering\n2. Dynamic programming for small instances\n3. Constraint satisfaction with backtracking\n4. Weighted scoring that accounts for interactions\n5. Precedence-aware selection ordering\n6. Group-aware selection that maximizes diversity\n\nThe code should read JSON from stdin with \"requirements\" and \"catalog\", and output JSON to stdout with \"selection\" containing \"variables\" list.\n\nBe creative and find efficient solutions that maximize the objective while respecting all constraints.\nAnalyze the current program to identify its key parameters and algorithmic components, then design a new algorithm with different parameter settings and configurations.\nYou MUST respond using a short summary name, description and the full code:\n\n<NAME>\nA shortened name summarizing the code you are proposing. Lowercase, no \nspaces, underscores allowed.\n</NAME>\n\n<DESCRIPTION>\nIdentify the key parameters in the current approach and explain how your new parameter choices or algorithmic configuration will lead to better performance.\n</DESCRIPTION>\n\n<CODE>\n```{language}\n# The new parametric algorithm implementation here.\n```\n</CODE>\n\n* Keep the markers \"EVOLVE-BLOCK-START\" and \"EVOLVE-BLOCK-END\" in the code.\n* Identify parameters like: learning rates, iteration counts, thresholds, weights, selection criteria, etc.\n* Design a new algorithm with different parameter values or configurations.\n* Consider adaptive parameters, different optimization strategies, or alternative heuristics.\n* Maintain the same inputs and outputs as the original program.\n* Use the <NAME>, <DESCRIPTION>, and <CODE> delimiters to structure your response. It will be parsed afterwards.",
          "new_msg_history": [
            {
              "role": "user",
              "content": "\n# Current program\n\nHere is the current program we are trying to improve (you will need to \npropose a new program with the same inputs and outputs as the original \nprogram, but with improved internal implementation):\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    This is a greedy baseline - evolution will improve this.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    # Simple greedy: select items with highest weights first\n    # This is a baseline - evolution will find better strategies\n    n = len(weights)\n    selected = []\n    \n    # Create score list (weight + interaction potential)\n    scores = []\n    for i in range(n):\n        score = weights[i] if i < len(weights) else 0.0\n        # Add potential interaction value\n        for k, v in interactions.items():\n            try:\n                u, w = map(int, k.split(\",\"))\n                if u == i or w == i:\n                    score += abs(v) * 0.5  # Potential value\n            except:\n                pass\n        scores.append((score, i))\n    \n    # Sort by score descending\n    scores.sort(reverse=True)\n    \n    # Greedy selection respecting constraints\n    selected_set = set()\n    for score, i in scores:\n        if len(selected_set) >= cardinality_bounds[1]:\n            break\n            \n        # Check mutex constraints\n        can_add = True\n        for a, b in mutex:\n            if (a == i and b in selected_set) or (b == i and a in selected_set):\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n            \n        # Check group constraints (at most one per group)\n        for grp_vars in groups.values():\n            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n        \n        # Check precedence (if j selected, i must be selected)\n        precedence_ok = True\n        for pred_i, pred_j in precedence:\n            if pred_j == i and pred_i not in selected_set:\n                precedence_ok = False\n                break\n        \n        if not precedence_ok:\n            continue\n        \n        # Add if we meet minimum cardinality or have room\n        if len(selected_set) < cardinality_bounds[1]:\n            selected_set.add(i)\n            selected.append(i)\n    \n    # Ensure minimum cardinality\n    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n        for i in range(n):\n            if i not in selected_set:\n                selected_set.add(i)\n                selected.append(i)\n                break\n    \n    # Output result\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n    \n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n    \n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n    \n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n    \n    result_str = stdout_capture.getvalue()\n    return result_str\n\n\n```\n\nHere are the performance metrics of the program:\n\nCombined score to maximize: 0.35\nfeasible: True; selection_size: 10; raw_score: 106.51\n\n# Task\n\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs as the original program, but with improved internal implementation.\n"
            },
            {
              "role": "assistant",
              "content": "<NAME>\nlocalsearch_sds\n</NAME>\n\n<DESCRIPTION>\nKey parameters in the original approach:\n- interaction potential factor (fixed 0.5)\n- single-pass greedy ordering by a simple score\n- no local improvement or precedence-aware closure handling\n- no adaptive behavior (static heuristics)\n\nNew algorithmic configuration and parameters:\n- Adaptive interaction weighting: interaction_bias adapts to problem scales using average absolute interaction vs average absolute weight. This prevents under- or over-counting pair synergies and improves candidate ranking.\n- Precedence closure logic: adding a variable automatically adds all required ancestors; removals consider forced cascades. This avoids infeasible picks and better evaluates true marginal cost/benefit.\n- Constraint-aware marginal gain computation: marginal gain for a candidate includes weights/interactions for any forced closure items and accounts for group/mutex conflicts and cardinality impact.\n- Iterated Local Search with deterministic greedy seed + targeted neighborhood moves (add/remove/swap) and simulated-annealing-style occasional acceptance (temperature schedule). Parameters:\n  - max_iters (5000) with patience for no improvement (200)\n  - swap-considered set sizes (top_k candidates) to control search breadth\n  - shake probability (0.02) to escape local optima\n  - initial_temperature (0.5) and cooling rate (0.995)\nThese parameters are chosen to balance runtime and solution quality; they are adaptive and tunable. The algorithm performs a strong constraint-aware greedy initialization followed by an intensive constrained local search that explores swaps, adds, and removals while respecting precedence/group/mutex/cardinality constraints. This typically produces higher raw_score by capturing synergies and ensuring feasible, compact moves.\n</DESCRIPTION>\n\n<CODE>\n```python\n#!/usr/bin/env python3\n\"\"\"\nEvolved solver for Synergistic Dependency Selection (SDS) problem.\nThis EVOLVE-BLOCK contains an improved parametric local-search algorithm.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\nimport math\nimport random\nimport time\nfrom collections import defaultdict, deque\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem using:\n    - precedence closure-aware greedy initialization\n    - adaptive interaction weighting\n    - local search (add/remove/swap) with occasional random shake\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    weights = requirements.get(\"weights\", [])\n    interactions_raw = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex_list = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    n = len(weights)\n    \n    # Parse interactions into dict of tuple(int,int)->float, symmetric\n    interactions = {}\n    total_abs_inter = 0.0\n    inter_count = 0\n    for k, v in interactions_raw.items():\n        try:\n            # accept \"i,j\" with optional spaces\n            parts = k.split(\",\")\n            if len(parts) != 2:\n                continue\n            u = int(parts[0].strip())\n            w = int(parts[1].strip())\n            if u == w:\n                # ignore self interactions\n                continue\n            interactions[(u, w)] = float(v)\n            interactions[(w, u)] = float(v)\n            total_abs_inter += abs(float(v))\n            inter_count += 1\n        except Exception:\n            continue\n    avg_abs_inter = (total_abs_inter / inter_count) if inter_count > 0 else 0.0\n    avg_abs_weight = (sum(abs(float(x)) for x in weights) / n) if n > 0 else 0.0\n    \n    # Adaptive interaction bias: scale interactions to be comparable to weights\n    interaction_bias = 1.0\n    if avg_abs_weight > 1e-9:\n        interaction_bias = max(0.2, min(3.0, (avg_abs_inter / (avg_abs_weight + 1e-9)) * 1.2))\n    # parameters (tunable)\n    MAX_ITERS = 5000\n    NO_IMPROVE_PATIENCE = 200\n    TOP_K_CANDIDATES = 50  # when searching adds/swaps consider top candidates by heuristic\n    SHAKE_PROB = 0.02\n    INIT_TEMP = 0.5\n    COOLING = 0.995\n    \n    # Build precedence graph: j -> list of required preds i (if j selected, i must be selected)\n    preds = defaultdict(set)\n    succs = defaultdict(set)  # reverse: i -> set of nodes that require i\n    for pair in precedence:\n        try:\n            a, b = pair\n            preds[int(b)].add(int(a))\n            succs[int(a)].add(int(b))\n        except Exception:\n            continue\n    \n    # Build group mapping: group_id -> set(vars), and var->set(group_ids)\n    group_to_vars = {}\n    var_to_groups = defaultdict(set)\n    for gid, vars_list in groups.items():\n        # group ids may be strings; treat as keys\n        try:\n            vars_iter = list(vars_list)\n        except Exception:\n            vars_iter = []\n        group_to_vars[gid] = set(vars_iter)\n        for v in vars_iter:\n            var_to_groups[int(v)].add(gid)\n    \n    # Build mutex set for quick lookup (unordered pair)\n    mutex_set = set()\n    for pair in mutex_list:\n        if len(pair) >= 2:\n            a, b = int(pair[0]), int(pair[1])\n            if a == b:\n                continue\n            mutex_set.add((a, b))\n            mutex_set.add((b, a))\n    \n    # Helper: get full precedence closure for a set of variables (all ancestors)\n    def closure_of_set(vars_set):\n        # BFS/DFS up preds edges\n        res = set(vars_set)\n        dq = deque(vars_set)\n        while dq:\n            v = dq.popleft()\n            for p in preds.get(v, ()):\n                if p not in res:\n                    res.add(p)\n                    dq.append(p)\n        return res\n    \n    # Helper: compute dependents closure (all nodes that require any in given set) - for removal cascades\n    def dependents_to_remove_for_removed(removed_vars, current_selected):\n        # If we remove some vars, any node that (directly or transitively) requires them must also be removed\n        to_remove = set()\n        dq = deque()\n        for r in removed_vars:\n            # only consider dependents that are currently selected\n            for s in succs.get(r, ()):\n                if s in current_selected and s not in to_remove:\n                    to_remove.add(s)\n                    dq.append(s)\n        while dq:\n            v = dq.popleft()\n            for s in succs.get(v, ()):\n                if s in current_selected and s not in to_remove:\n                    to_remove.add(s)\n                    dq.append(s)\n        return to_remove\n    \n    # Objective evaluation\n    def objective(selected_set):\n        # sum weights + sum pairwise interactions (each counted once)\n        s = 0.0\n        for v in selected_set:\n            if 0 <= v < n:\n                s += float(weights[v])\n        # interactions: iterate pairs from interactions dict unique by u<v\n        # More efficient: for each u in selected, sum interactions[u,w] for w>u in selected\n        sel_list = list(selected_set)\n        sel_set = set(selected_set)\n        # sum interactions symmetrically but ensure we add each pair once\n        seen = set()\n        for u in sel_list:\n            for v in sel_list:\n                if u == v:\n                    continue\n                if (u, v) in seen:\n                    continue\n                val = interactions.get((u, v), 0.0)\n                if val != 0.0:\n                    s += val * 1.0  # interactions already raw; bias applied when used for heuristics\n                seen.add((u, v))\n                seen.add((v, u))\n        return s\n    \n    # Feasibility checks\n    def violates_mutex_pairing(candidate_set):\n        # simple O(k^2) check for small sets\n        for a in candidate_set:\n            for b in candidate_set:\n                if a != b and (a, b) in mutex_set:\n                    return True\n        return False\n    \n    def violates_grouping(candidate_set):\n        # at most one per group id\n        group_seen = {}\n        for v in candidate_set:\n            for gid in var_to_groups.get(v, ()):\n                if gid in group_seen and group_seen[gid] != v:\n                    return True\n                group_seen[gid] = v\n        return False\n    \n    def feasible_after_adding(i, current_set, max_card):\n        # compute closure for i\n        to_add_closure = closure_of_set({i})\n        # new_set = current_set U to_add_closure\n        new_set = set(current_set) | to_add_closure\n        # Check cardinality\n        if len(new_set) > max_card:\n            return False, None\n        # Check group and mutex\n        if violates_grouping(new_set):\n            return False, None\n        if violates_mutex_pairing(new_set):\n            return False, None\n        return True, to_add_closure\n    \n    def feasible_swap(remove_set, add_set, current_set, min_card, max_card):\n        # remove_set: set of vars to remove (e.g. {a} plus dependents)\n        # add_set: set of vars to add (including closures)\n        new_set = set(current_set)\n        # cascade removals of dependents\n        removed_final = set(remove_set) | dependents_to_remove_for_removed(remove_set, current_set)\n        new_set -= removed_final\n        new_set |= add_set\n        # add closure for add_set (in case not already included)\n        new_set |= closure_of_set(add_set)\n        # Check cardinality\n        if len(new_set) < min_card or len(new_set) > max_card:\n            return False, None\n        if violates_grouping(new_set):\n            return False, None\n        if violates_mutex_pairing(new_set):\n            return False, None\n        return True, new_set\n    \n    # Greedy initialization (precedence-aware)\n    min_card, max_card = int(cardinality_bounds[0]), int(cardinality_bounds[1])\n    selected = set()\n    \n    # Candidate heuristic score: marginal weight + interaction_bias * sum interactions to current selected +\n    # include closure contributions (weights + interactions inside closure)\n    def marginal_gain_if_add(i, current_set):\n        feasible, closure = feasible_after_adding(i, current_set, max_card)\n        if not feasible:\n            return -math.inf, None\n        closure = closure or set()\n        new_items = closure - current_set\n        # compute sum weights for new items\n        gain = 0.0\n        for v in new_items:\n            if 0 <= v < n:\n                gain += float(weights[v])\n        # interactions: between new items and existing items, and between new items themselves\n        for u in new_items:\n            # interactions with current_set\n            for v in current_set:\n                gain += interaction_bias * interactions.get((u, v), 0.0)\n            # interactions inside new_items (u <-> w)\n            for w in new_items:\n                if u >= w:\n                    continue\n                gain += interaction_bias * interactions.get((u, w), 0.0)\n        # also subtract any negative interactions that new items might have with existing set (already accounted)\n        return gain, closure\n    \n    # Seed selection: choose highest marginal gains until max or no positive gains; also aim to reach min_card\n    # We'll consider candidates sorted by heuristic that includes interactions to the yet-empty set (so primarily weights)\n    candidate_scores = []\n    for i in range(n):\n        # simple base heuristic: weight + interaction_bias * sum of abs interactions to others (potential)\n        pot = float(weights[i]) + interaction_bias * sum(interactions.get((i, j), 0.0) for j in range(n) if j != i)\n        candidate_scores.append((pot, i))\n    candidate_scores.sort(reverse=True)\n    for _, i in candidate_scores:\n        if len(selected) >= max_card:\n            break\n        mg, closure = marginal_gain_if_add(i, selected)\n        if closure is None:\n            continue\n        # prefer positive gain or needed to reach min_card\n        if mg > -1e-9 or len(selected) + len(closure - selected) <= min_card:\n            selected |= closure\n    # If still below min_card, add best feasible items forcibly (minimal harm)\n    if len(selected) < min_card:\n        for i in range(n):\n            if len(selected) >= min_card:\n                break\n            feasible, closure = feasible_after_adding(i, selected, max_card)\n            if not feasible:\n                continue\n            selected |= closure\n    # If above max_card due to closure, attempt to prune (rare): remove least valuable items that have no dependents\n    def prune_to_max(selected_set):\n        if len(selected_set) <= max_card:\n            return selected_set\n        # remove candidates with smallest marginal loss (removing them and their dependents)\n        sel = set(selected_set)\n        while len(sel) > max_card:\n            best_loss = math.inf\n            best_remove = None\n            for v in list(sel):\n                # cannot remove if it causes removing many required items might be large loss - we measure objective delta\n                removed = {v} | dependents_to_remove_for_removed({v}, sel)\n                new_set = sel - removed\n                loss = objective(sel) - objective(new_set)\n                if loss < best_loss:\n                    best_loss = loss\n                    best_remove = removed\n            if best_remove is None:\n                break\n            sel -= best_remove\n        return sel\n    if len(selected) > max_card:\n        selected = prune_to_max(selected)\n    \n    # Local search improvement\n    current = set(selected)\n    best = set(current)\n    best_score = objective(best)\n    current_score = best_score\n    no_improve = 0\n    temperature = INIT_TEMP\n    rng = random.Random(123456789)  # deterministic seed for reproducibility\n    \n    iter_count = 0\n    while iter_count < MAX_ITERS and no_improve < NO_IMPROVE_PATIENCE:\n        iter_count += 1\n        improved = False\n        \n        # Build candidate lists\n        not_selected = [i for i in range(n) if i not in current]\n        # Evaluate marginal gains for top candidates\n        add_candidates = []\n        for i in not_selected:\n            mg, closure = marginal_gain_if_add(i, current)\n            if closure is None:\n                continue\n            add_candidates.append((mg, i, closure))\n        add_candidates.sort(reverse=True, key=lambda x: x[0])\n        \n        # Consider removals: compute marginal loss for removing each v (including dependents)\n        remove_candidates = []\n        for v in list(current):\n            removed = {v} | dependents_to_remove_for_removed({v}, current)\n            new_set = current - removed\n            if len(new_set) < min_card:\n                # can't remove below min\n                continue\n            loss = objective(current) - objective(new_set)\n            remove_candidates.append((loss, v, removed))\n        remove_candidates.sort(key=lambda x: x[0])  # smaller loss first\n        \n        # Try best add move\n        if add_candidates:\n            mg, i_add, closure_add = add_candidates[0]\n            if mg > 1e-9 and len(current | closure_add) <= max_card:\n                # apply add\n                current |= closure_add\n                current_score = objective(current)\n                if current_score > best_score + 1e-9:\n                    best = set(current)\n                    best_score = current_score\n                    no_improve = 0\n                else:\n                    no_improve += 1\n                improved = True\n            else:\n                # Try beneficial swaps: remove some v and add some u\n                # Consider top few adds and top few removes\n                swapped = False\n                top_adds = add_candidates[:TOP_K_CANDIDATES]\n                top_removes = remove_candidates[:TOP_K_CANDIDATES]\n                best_delta = 0.0\n                best_move = None\n                # Try single removals + single addition\n                for mg_val, u, closure_u in top_adds:\n                    for loss_val, v, removed_set in top_removes:\n                        # prepare add_set = closure_u\n                        feasible, new_set = feasible_swap(removed_set, closure_u, current, min_card, max_card)\n                        if not feasible:\n                            continue\n                        new_score = objective(new_set)\n                        delta = new_score - current_score\n                        if delta > best_delta:\n                            best_delta = delta\n                            best_move = (\"swap\", removed_set, closure_u, new_set, new_score)\n                if best_move:\n                    # apply best swap\n                    _, removed_set, closure_u, new_set, new_score = best_move\n                    current = set(new_set)\n                    current_score = new_score\n                    if current_score > best_score + 1e-9:\n                        best = set(current)\n                        best_score = current_score\n                        no_improve = 0\n                    else:\n                        no_improve += 1\n                    improved = True\n                    swapped = True\n                else:\n                    # consider accepting a small worsening move probabilistically (simulated annealing)\n                    if add_candidates and remove_candidates:\n                        # pick top random pair and consider\n                        cand_add = rng.choice(add_candidates[:min(5, len(add_candidates))])\n                        cand_rem = rng.choice(remove_candidates[:min(5, len(remove_candidates))])\n                        _, u, closure_u = cand_add\n                        _, v, removed_set = cand_rem\n                        feasible, new_set = feasible_swap(removed_set, closure_u, current, min_card, max_card)\n                        if feasible:\n                            new_score = objective(new_set)\n                            delta = new_score - current_score\n                            if delta > 0 or rng.random() < math.exp(delta / (temperature + 1e-12)):\n                                current = set(new_set)\n                                current_score = new_score\n                                if current_score > best_score + 1e-9:\n                                    best = set(current)\n                                    best_score = current_score\n                                    no_improve = 0\n                                else:\n                                    no_improve += 1\n                                improved = True\n        # If not improved, try pure removal if it leads to improvement (prune negative items)\n        if not improved and remove_candidates:\n            # remove the item which gives largest improvement (largest 'negative loss' meaning reduce objective negative interactions)\n            # We look for removals that increase objective (loss < 0)\n            candidate_removals = [rc for rc in remove_candidates if rc[0] < -1e-9]\n            if candidate_removals:\n                candidate_removals.sort()\n                loss_val, v, removed_set = candidate_removals[0]\n                new_set = current - removed_set\n                current = set(new_set)\n                current_score = objective(current)\n                if current_score > best_score + 1e-9:\n                    best = set(current)\n                    best_score = current_score\n                    no_improve = 0\n                else:\n                    no_improve += 1\n                improved = True\n        \n        # Random shake (small) to escape plateaus\n        if not improved and rng.random() < SHAKE_PROB:\n            # attempt random feasible add or swap\n            if add_candidates:\n                _, u, closure_u = rng.choice(add_candidates[:min(10, len(add_candidates))])\n                feasible_add, closure = feasible_after_adding(u, current, max_card)\n                if feasible_add:\n                    current |= closure\n                    current_score = objective(current)\n                    if current_score > best_score + 1e-9:\n                        best = set(current)\n                        best_score = current_score\n                        no_improve = 0\n                    else:\n                        no_improve += 1\n                    improved = True\n            elif remove_candidates:\n                _, v, removed_set = rng.choice(remove_candidates[:min(10, len(remove_candidates))])\n                new_set = current - removed_set\n                if len(new_set) >= min_card:\n                    current = set(new_set)\n                    current_score = objective(current)\n                    if current_score > best_score + 1e-9:\n                        best = set(current)\n                        best_score = current_score\n                        no_improve = 0\n                    else:\n                        no_improve += 1\n                    improved = True\n        \n        if not improved:\n            no_improve += 1\n        \n        # cooling\n        temperature *= COOLING\n    \n    # Final pruning to ensure within cardinality bounds and precedence closure\n    final_sel = closure_of_set(best)\n    # If still beyond max, prune low-contribution items\n    if len(final_sel) > max_card:\n        final_sel = prune_to_max(final_sel)\n    # Ensure at least min_card\n    if len(final_sel) < min_card:\n        # greedily add best remaining feasible items\n        for i in range(n):\n            if len(final_sel) >= min_card:\n                break\n            feasible, closure = feasible_after_adding(i, final_sel, max_card)\n            if feasible:\n                final_sel |= closure\n    final_list = sorted(int(x) for x in final_sel)\n    result = {\"selection\": {\"variables\": final_list}}\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n    \n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n    \n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n    \n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n    \n    result_str = stdout_capture.getvalue()\n    return result_str\n\n\n# If run as a script, call solve_sds()\nif __name__ == \"__main__\":\n    solve_sds()\n```\n</CODE>"
            }
          ],
          "model_name": "gpt-5-mini",
          "kwargs": {
            "temperature": 1.0,
            "max_output_tokens": 8192
          },
          "input_tokens": 1524,
          "output_tokens": 5968,
          "cost": 0.012316999999999998,
          "input_cost": 0.000381,
          "output_cost": 0.011935999999999999,
          "thought": "",
          "model_posteriors": {
            "gpt-5-mini": 1.0
          }
        },
        "diff_summary": {
          "added": 361,
          "deleted": 0,
          "modified": 79
        },
        "embed_cost": 8.3e-05,
        "novelty_cost": 0.0,
        "stdout_log": "Evaluating program: sds_dataset_output/problem_0/gen_3/main.py\nSaving results to: sds_dataset_output/problem_0/gen_3/results\nEvaluation error: name 'defaultdict' is not defined\nCorrectness and error status saved to sds_dataset_output/problem_0/gen_3/results/correct.json\nMetrics saved to sds_dataset_output/problem_0/gen_3/results/metrics.json\nEvaluation or Validation failed: name 'defaultdict' is not defined\nMetrics:\n  combined_score: 0.0\n  execution_time_mean: 0.0\n  execution_time_std: 0.0\n  num_successful_runs: 0\n  num_valid_runs: 0\n  num_invalid_runs: 0\n  all_validation_errors: []\n",
        "stderr_log": "",
        "code_analysis_metrics": {
          "cyclomatic_complexity": 77,
          "average_cyclomatic_complexity": 38.5,
          "halstead_volume": 3173.6470415780577,
          "halstead_difficulty": 14.142857142857142,
          "halstead_effort": 44884.43673088967,
          "lines_of_code": 506,
          "logical_lines_of_code": 389,
          "comments": 84,
          "maintainability_index": -52.72051096367923,
          "max_nesting_depth": 9,
          "complexity_score": 1.0
        }
      },
      "in_archive": false
    },
    {
      "id": "df7c65cb-4abe-4b96-ae87-60e1fc25136c",
      "code": "\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\nA novel SDS solver: precedence-aware beam + simulated-annealing-style local search.\nReads JSON from stdin with \"requirements\" and \"catalog\", writes JSON to stdout:\n{\"selection\":{\"variables\":[...]}}\n\nThis block is intended to be evolved by ShinkaEvolve.\n\"\"\"\nimport sys\nimport json\nimport math\nimport random\nimport time\n\ndef solve_sds():\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    min_card, max_card = cardinality_bounds[0], cardinality_bounds[1]\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n\n    n = len(weights)\n\n    # Robust interaction parsing: handle \"i,j\" -> value or nested dicts\n    interaction_map = {}\n    # first try string keys like \"i,j\" or tuple-like\n    if isinstance(interactions, dict):\n        for k, v in interactions.items():\n            if isinstance(k, str):\n                if \",\" in k:\n                    try:\n                        a_s, b_s = k.split(\",\")\n                        a, b = int(a_s), int(b_s)\n                        if a > b:\n                            a, b = b, a\n                        interaction_map[(a, b)] = float(v)\n                    except Exception:\n                        continue\n                else:\n                    # maybe nested mapping case handled later\n                    continue\n            elif isinstance(k, (list, tuple)) and len(k) == 2:\n                try:\n                    a, b = int(k[0]), int(k[1])\n                    if a > b:\n                        a, b = b, a\n                    interaction_map[(a, b)] = float(v)\n                except Exception:\n                    continue\n    # try nested dict form interactions[i][j] = val\n    if not interaction_map and isinstance(interactions, dict):\n        try:\n            for ik, row in interactions.items():\n                ii = int(ik)\n                if isinstance(row, dict):\n                    for jk, vv in row.items():\n                        jj = int(jk)\n                        a, b = (ii, jj) if ii <= jj else (jj, ii)\n                        interaction_map[(a, b)] = float(vv)\n        except Exception:\n            pass\n\n    def get_interaction(i, j):\n        if i > j:\n            i, j = j, i\n        return interaction_map.get((i, j), 0.0)\n\n    # Precedence maps\n    preds = {i: set() for i in range(n)}\n    succs = {i: set() for i in range(n)}\n    for p in precedence:\n        try:\n            a = int(p[0]); b = int(p[1])\n            # if b selected then a must be selected => a is predecessor of b\n            preds[b].add(a)\n            succs[a].add(b)\n        except Exception:\n            continue\n\n    # Compute transitive predecessor closure and successor closure\n    pred_closure = {}\n    for i in range(n):\n        seen = set()\n        stack = list(preds.get(i, []))\n        while stack:\n            x = stack.pop()\n            if x in seen:\n                continue\n            seen.add(x)\n            for y in preds.get(x, ()):\n                if y not in seen:\n                    stack.append(y)\n        pred_closure[i] = seen\n\n    succ_closure = {}\n    for i in range(n):\n        seen = set()\n        stack = list(succs.get(i, []))\n        while stack:\n            x = stack.pop()\n            if x in seen:\n                continue\n            seen.add(x)\n            for y in succs.get(x, ()):\n                if y not in seen:\n                    stack.append(y)\n        succ_closure[i] = seen\n\n    # Precompute group and mutex quick checks\n    # groups: dict name -> list of vars\n    var_to_group = {}\n    for gname, vars_list in groups.items():\n        for v in vars_list:\n            var_to_group[v] = gname\n\n    mutex_pairs = set()\n    mutex_map = {i: set() for i in range(n)}\n    for a, b in mutex:\n        mutex_pairs.add((a, b))\n        mutex_pairs.add((b, a))\n        if 0 <= a < n and 0 <= b < n:\n            mutex_map[a].add(b)\n            mutex_map[b].add(a)\n\n    # Quick feasibility check\n    def is_feasible_set(S):\n        if len(S) > max_card or len(S) < 0:\n            return False\n        # precedence: all preds must be included\n        for j in S:\n            for p in preds.get(j, ()):\n                if p not in S:\n                    return False\n        # mutex\n        for a in S:\n            for b in mutex_map.get(a, ()):\n                if b in S:\n                    return False\n        # groups\n        seen_groups = {}\n        for v in S:\n            g = var_to_group.get(v)\n            if g is not None:\n                if g in seen_groups:\n                    return False\n                seen_groups[g] = v\n        return True\n\n    # Objective computation optimized: sum weights + sum interactions for pairs (i<j)\n    # We'll maintain an interactions adjacency list for non-zero interactions\n    neighbors = {i: {} for i in range(n)}\n    for (a, b), val in interaction_map.items():\n        if 0 <= a < n and 0 <= b < n:\n            neighbors[a][b] = val\n            neighbors[b][a] = val\n\n    def objective(S):\n        total = 0.0\n        for i in S:\n            if 0 <= i < n:\n                total += weights[i]\n        # pairwise interactions\n        # sum over each i neighbors j>i in S\n        Sset = set(S)\n        for i in Sset:\n            for j, val in neighbors[i].items():\n                if j in Sset and j > i:\n                    total += val\n        return total\n\n    # Marginal gain for adding a set A to S (A disjoint or overlap handled)\n    def marginal_gain(S, A):\n        Sset = set(S)\n        Aset = set(A) - Sset\n        if not Aset:\n            return 0.0\n        gain = 0.0\n        for i in Aset:\n            if 0 <= i < n:\n                gain += weights[i]\n        # interactions between A and S\n        for i in Aset:\n            for j, val in neighbors[i].items():\n                if j in Sset:\n                    gain += val\n        # interactions internal to A\n        Alist = list(Aset)\n        for ui in range(len(Alist)):\n            ii = Alist[ui]\n            for uj in range(ui + 1, len(Alist)):\n                jj = Alist[uj]\n                gain += neighbors[ii].get(jj, 0.0)\n        return gain\n\n    # closure_for: when adding i, include its predecessors (transitive)\n    def closure_for_add(i, current_set):\n        res = set([i])\n        for p in pred_closure.get(i, set()):\n            res.add(p)\n        # exclude already present\n        return res - set(current_set)\n\n    # closure_for_remove: when removing i, need to remove all successors that depend on it (transitive)\n    def closure_for_remove(i):\n        res = set([i])\n        for s in succ_closure.get(i, set()):\n            res.add(s)\n        return res\n\n    # centrality heuristic: base for seeding\n    centrality = []\n    for i in range(n):\n        s = weights[i] if 0 <= i < n else 0.0\n        # sum of positive interactions\n        pos_sum = 0.0\n        for j, val in neighbors[i].items():\n            if val > 0:\n                pos_sum += val\n            else:\n                pos_sum += 0.1 * val  # small weight for negative links\n        s += pos_sum\n        centrality.append((s, i))\n    centrality.sort(reverse=True)\n\n    # Beam parameters scaled with n\n    beam_width = max(5, min(40, n // 3 + 1))\n    seeds_to_try = beam_width\n    seed_indices = [i for _, i in centrality[:seeds_to_try]]\n\n    # If too few seeds (small n), consider random seeds for diversity\n    if len(seed_indices) < beam_width:\n        others = [i for i in range(n) if i not in seed_indices]\n        random.shuffle(others)\n        seed_indices += others[:beam_width - len(seed_indices)]\n\n    # Greedy augment function (respect closures, groups, mutex)\n    def greedy_augment(initial_set):\n        S = set(initial_set)\n        # If initial violates precedence, fix by adding needed preds\n        changed = True\n        while changed:\n            changed = False\n            for j in list(S):\n                for p in preds.get(j, ()):\n                    if p not in S:\n                        S.add(p)\n                        changed = True\n        # Greedily add items with best positive marginal gain\n        while len(S) < max_card:\n            best_gain = -1e18\n            best_add = None\n            for i in range(n):\n                if i in S:\n                    continue\n                add_set = closure_for_add(i, S)\n                if not add_set:\n                    continue\n                if len(S) + len(add_set) > max_card:\n                    continue\n                # check group/mutex feasibility quickly\n                violated = False\n                # group conflict\n                existing_groups = set(var_to_group.get(v) for v in S if var_to_group.get(v) is not None)\n                for v in add_set:\n                    g = var_to_group.get(v)\n                    if g is not None and g in existing_groups:\n                        violated = True\n                        break\n                if violated:\n                    continue\n                # mutex: any v in add_set conflicting with S?\n                for v in add_set:\n                    for m in mutex_map.get(v, ()):\n                        if m in S:\n                            violated = True\n                            break\n                    if violated:\n                        break\n                if violated:\n                    continue\n                gain = marginal_gain(S, add_set)\n                # prefer positive gains; otherwise small positive if need to reach min_card\n                if gain > best_gain:\n                    best_gain = gain\n                    best_add = add_set\n            if best_add is None or (best_gain <= 1e-12 and len(S) >= min_card):\n                break\n            S |= set(best_add)\n        # If below min_card, force add highest marginal items (even negative if necessary)\n        if len(S) < min_card:\n            # consider all candidates sorted by marginal gain\n            cand_list = []\n            for i in range(n):\n                if i in S:\n                    continue\n                add_set = closure_for_add(i, S)\n                if not add_set:\n                    continue\n                if len(S) + len(add_set) > max_card:\n                    continue\n                # skip if group/mutex violate\n                violated = False\n                existing_groups = set(var_to_group.get(v) for v in S if var_to_group.get(v) is not None)\n                for v in add_set:\n                    g = var_to_group.get(v)\n                    if g is not None and g in existing_groups:\n                        violated = True\n                        break\n                    for m in mutex_map.get(v, ()):\n                        if m in S:\n                            violated = True\n                            break\n                    if violated:\n                        break\n                if violated:\n                    continue\n                cand_list.append((marginal_gain(S, add_set), add_set))\n            cand_list.sort(reverse=True, key=lambda x: x[0])\n            for gain, add_set in cand_list:\n                if len(S) >= min_card:\n                    break\n                if len(S) + len(add_set) > max_card:\n                    continue\n                S |= set(add_set)\n        # final feasibility guard\n        if not is_feasible_set(S):\n            # fallback: simple weight-based fill respecting closures\n            S = set()\n            for i in sorted(range(n), key=lambda x: weights[x], reverse=True):\n                add_set = closure_for_add(i, S)\n                if len(S) + len(add_set) > max_card:\n                    continue\n                if not is_feasible_set(S | set(add_set)):\n                    continue\n                S |= set(add_set)\n                if len(S) >= max_card:\n                    break\n        return S\n\n    # Build initial beam of solutions\n    beam = []\n    tried_seeds = set()\n    for sidx in seed_indices:\n        if sidx in tried_seeds:\n            continue\n        tried_seeds.add(sidx)\n        init = closure_for_add(sidx, set())\n        # if too large, skip seed\n        if len(init) > max_card:\n            continue\n        sol = greedy_augment(init)\n        beam.append(sol)\n    # If beam too small, add some empties and singletons\n    if not beam:\n        beam.append(set())\n    # ensure beam unique\n    uniq = []\n    seen = set()\n    for sol in beam:\n        key = tuple(sorted(sol))\n        if key not in seen:\n            uniq.append(sol)\n            seen.add(key)\n    beam = uniq[:beam_width]\n\n    # Local search with simulated annealing for each beam member\n    best_sol = None\n    best_score = -1e99\n\n    # Tune iterations by problem size\n    base_iters = 300\n    iter_scale = max(1, n // 10)\n    max_iters_per_seed = min(2000, base_iters * iter_scale)\n\n    rng = random.Random()\n    # deterministic-ish seed based on weights to be reproducible across runs\n    rng.seed(int(sum(weights) * 1000) if weights else 12345)\n\n    start_time = time.time()\n    time_limit = 1.8  # try to keep runtime modest; evaluator may limit\n    for sol in beam:\n        S = set(sol)\n        S = greedy_augment(S)  # tighten\n        cur_score = objective(S)\n        if cur_score > best_score:\n            best_score = cur_score\n            best_sol = set(S)\n        # SA parameters\n        T0 = max(1.0, abs(cur_score) * 0.1 + 1.0)\n        Tmin = 1e-3\n        iters = 0\n        last_improve = 0\n        while iters < max_iters_per_seed:\n            iters += 1\n            # time cut\n            if time.time() - start_time > time_limit:\n                break\n            # temperature schedule\n            frac = iters / float(max_iters_per_seed + 1)\n            temp = T0 * (1.0 - frac) + Tmin * frac\n            op = rng.choice(['add', 'remove', 'swap'])\n            accepted = False\n            if op == 'add':\n                # pick candidate item not in S that might improve\n                candidates = list(set(range(n)) - S)\n                rng.shuffle(candidates)\n                for cand in candidates[:min(50, len(candidates))]:\n                    add_set = closure_for_add(cand, S)\n                    if not add_set:\n                        continue\n                    if len(S) + len(add_set) > max_card:\n                        continue\n                    # group/mutex check\n                    violated = False\n                    existing_groups = set(var_to_group.get(v) for v in S if var_to_group.get(v) is not None)\n                    for v in add_set:\n                        g = var_to_group.get(v)\n                        if g is not None and g in existing_groups:\n                            violated = True\n                            break\n                        for m in mutex_map.get(v, ()):\n                            if m in S:\n                                violated = True\n                                break\n                        if violated:\n                            break\n                    if violated:\n                        continue\n                    newS = set(S) | set(add_set)\n                    # ensure not violating precedence (add_set includes preds)\n                    if not is_feasible_set(newS):\n                        continue\n                    new_score = objective(newS)\n                    delta = new_score - cur_score\n                    if delta > 1e-12 or math.exp(min(50.0, delta / max(1e-9, temp))) > rng.random():\n                        S = newS\n                        cur_score = new_score\n                        accepted = True\n                        last_improve = iters\n                        break\n            elif op == 'remove':\n                if len(S) == 0:\n                    continue\n                removes = list(S)\n                rng.shuffle(removes)\n                for rem in removes[:min(50, len(removes))]:\n                    rem_set = closure_for_remove(rem)\n                    newS = set(S) - rem_set\n                    # enforce min_card or allow temporary below with small prob\n                    if len(newS) < min_card:\n                        # permit removal with low probability if helps and temperature high\n                        pass_prob = math.exp(- (min_card - len(newS)) / (1.0 + temp))\n                        if rng.random() > pass_prob:\n                            continue\n                    if not is_feasible_set(newS):\n                        continue\n                    new_score = objective(newS)\n                    delta = new_score - cur_score\n                    if delta > 1e-12 or math.exp(min(50.0, delta / max(1e-9, temp))) > rng.random():\n                        S = newS\n                        cur_score = new_score\n                        accepted = True\n                        last_improve = iters\n                        break\n            else:  # swap: remove some dependent cluster and add some other closure\n                if len(S) == 0:\n                    continue\n                rem = rng.choice(list(S))\n                rem_set = closure_for_remove(rem)\n                base = set(S) - rem_set\n                # consider candidates to add given base\n                candidates = list(set(range(n)) - base)\n                rng.shuffle(candidates)\n                for cand in candidates[:min(80, len(candidates))]:\n                    add_set = closure_for_add(cand, base)\n                    if not add_set:\n                        continue\n                    if len(base) + len(add_set) > max_card:\n                        continue\n                    # group/mutex check\n                    violated = False\n                    existing_groups = set(var_to_group.get(v) for v in base if var_to_group.get(v) is not None)\n                    for v in add_set:\n                        g = var_to_group.get(v)\n                        if g is not None and g in existing_groups:\n                            violated = True\n                            break\n                        for m in mutex_map.get(v, ()):\n                            if m in base:\n                                violated = True\n                                break\n                        if violated:\n                            break\n                    if violated:\n                        continue\n                    newS = set(base) | set(add_set)\n                    if len(newS) < min_card:\n                        continue\n                    if not is_feasible_set(newS):\n                        continue\n                    new_score = objective(newS)\n                    delta = new_score - cur_score\n                    if delta > 1e-12 or math.exp(min(50.0, delta / max(1e-9, temp))) > rng.random():\n                        S = newS\n                        cur_score = new_score\n                        accepted = True\n                        last_improve = iters\n                        break\n            # record best\n            if cur_score > best_score + 1e-12:\n                best_score = cur_score\n                best_sol = set(S)\n            # small early stop if no improvement for long\n            if iters - last_improve > 400 and iters > 800:\n                break\n        # time limit guard\n        if time.time() - start_time > time_limit:\n            break\n\n    # Final repair and ensure feasibility and cardinality\n    if best_sol is None:\n        best_sol = set()\n    S = set(best_sol)\n    # Ensure precedence closure included\n    changed = True\n    while changed:\n        changed = False\n        for j in list(S):\n            for p in preds.get(j, ()):\n                if p not in S:\n                    S.add(p)\n                    changed = True\n    # If too large, try removing low marginal contributors while respecting precedence\n    if len(S) > max_card:\n        # rank items by marginal contribution (with respect to S)\n        def marginal_contrib(i, curS):\n            # contribution approximated as weight + sum interactions with curS - interactions lost from removal\n            contrib = weights[i]\n            for j, val in neighbors[i].items():\n                if j in curS and j != i:\n                    contrib += val\n            return contrib\n        # try removing items with smallest contrib but ensure we also remove dependents\n        items = sorted(list(S), key=lambda x: marginal_contrib(x, S))\n        for itv in items:\n            if len(S) <= max_card:\n                break\n            # can't remove if it has predecessors that would remain invalid (we'll remove dependents)\n            rem_cluster = closure_for_remove(itv)\n            # ensure we don't violate min_card after removal\n            if len(S) - len(rem_cluster) < min_card:\n                continue\n            S -= rem_cluster\n        # final safety: if still too large, keep top by contrib\n        if len(S) > max_card:\n            items = sorted(list(S), key=lambda x: marginal_contrib(x, S), reverse=True)\n            S = set(items[:max_card])\n\n    # If too small, fill greedily\n    if len(S) < min_card:\n        # add best marginal additions\n        while len(S) < min_card:\n            best_gain = -1e99\n            best_add = None\n            for i in range(n):\n                if i in S:\n                    continue\n                add_set = closure_for_add(i, S)\n                if not add_set:\n                    continue\n                if len(S) + len(add_set) > max_card:\n                    continue\n                # group/mutex check\n                violated = False\n                existing_groups = set(var_to_group.get(v) for v in S if var_to_group.get(v) is not None)\n                for v in add_set:\n                    g = var_to_group.get(v)\n                    if g is not None and g in existing_groups:\n                        violated = True\n                        break\n                    for m in mutex_map.get(v, ()):\n                        if m in S:\n                            violated = True\n                            break\n                    if violated:\n                        break\n                if violated:\n                    continue\n                gain = marginal_gain(S, add_set)\n                if gain > best_gain:\n                    best_gain = gain\n                    best_add = add_set\n            if best_add is None:\n                break\n            S |= set(best_add)\n\n    # Final enforced feasibility (last resort simple greedy)\n    if not is_feasible_set(S):\n        S = set()\n        for i in sorted(range(n), key=lambda x: weights[x], reverse=True):\n            add_set = closure_for_add(i, S)\n            if len(S) + len(add_set) > max_card:\n                continue\n            if not is_feasible_set(S | set(add_set)):\n                continue\n            S |= set(add_set)\n            if len(S) >= max_card:\n                break\n        i = 0\n        while len(S) < min_card and i < n:\n            if i not in S:\n                add_set = closure_for_add(i, S)\n                if len(S) + len(add_set) <= max_card and is_feasible_set(S | set(add_set)):\n                    S |= set(add_set)\n            i += 1\n\n    result = {\"selection\": {\"variables\": sorted(list(S))}}\n    print(json.dumps(result))\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n\n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n\n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n\n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n\n    result_str = stdout_capture.getvalue()\n    return result_str\n",
      "language": "python",
      "parent_id": "831127dd-538f-4048-8e94-392255459053",
      "archive_inspiration_ids": [
        "051ec677-21ad-422b-9eff-f6fe22d20b09"
      ],
      "top_k_inspiration_ids": [],
      "island_idx": 1,
      "generation": 4,
      "timestamp": 1764668185.232233,
      "code_diff": "--- a/original.py\n+++ b/original.py\n@@ -1,340 +1,668 @@\n \"\"\"\n Initial solution for Synergistic Dependency Selection (SDS) problem.\n The code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n \"\"\"\n \n import json\n import sys\n import contextlib\n \n # EVOLVE-BLOCK-START\n+A novel SDS solver: precedence-aware beam + simulated-annealing-style local search.\n+Reads JSON from stdin with \"requirements\" and \"catalog\", writes JSON to stdout:\n+{\"selection\":{\"variables\":[...]}}\n+\n+This block is intended to be evolved by ShinkaEvolve.\n+\"\"\"\n+import sys\n+import json\n+import math\n+import random\n+import time\n+\n def solve_sds():\n-    \"\"\"\n-    Solve the Synergistic Dependency Selection problem.\n-\n-    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n-    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n-\n-    Improved greedy + local search:\n-    - Evaluate true marginal gains including interactions.\n-    - Respect precedence by adding predecessor closures when needed.\n-    - Enforce mutex and group constraints when considering additions.\n-    - Perform simple 1-for-1 local-search swaps to improve objective.\n-    \"\"\"\n-    # Read input\n     input_data = json.load(sys.stdin)\n     requirements = input_data.get(\"requirements\", {})\n     catalog = input_data.get(\"catalog\", {})\n \n-    # Extract constraints\n     weights = requirements.get(\"weights\", [])\n     interactions = requirements.get(\"interactions\", {})\n     cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n     min_card, max_card = cardinality_bounds[0], cardinality_bounds[1]\n     mutex = requirements.get(\"mutex\", [])\n     groups = requirements.get(\"groups\", {})\n     precedence = requirements.get(\"precedence\", [])\n \n     n = len(weights)\n \n-    # Build interaction lookup function supporting both \"i,j\" keys and nested dicts\n+    # Robust interaction parsing: handle \"i,j\" -> value or nested dicts\n     interaction_map = {}\n-    # If interactions given as dict with string keys like \"i,j\"\n-    for k, v in interactions.items():\n-        if isinstance(k, str):\n-            try:\n-                i_s, j_s = k.split(\",\")\n-                i, j = int(i_s), int(j_s)\n-                if i > j:\n-                    i, j = j, i\n-                interaction_map[(i, j)] = float(v)\n-            except Exception:\n-                # fallback: ignore malformed keys\n-                pass\n-        elif isinstance(k, (list, tuple)) and len(k) == 2:\n-            try:\n-                i, j = int(k[0]), int(k[1])\n-                if i > j:\n-                    i, j = j, i\n-                interaction_map[(i, j)] = float(v)\n-            except Exception:\n-                pass\n-        else:\n-            # maybe nested mapping interactions[i][j]\n-            try:\n-                # will handle below\n-                pass\n-            except Exception:\n-                pass\n-    # handle nested dict case: interactions may be like {i: {j: val}}\n-    if not interaction_map:\n+    # first try string keys like \"i,j\" or tuple-like\n+    if isinstance(interactions, dict):\n+        for k, v in interactions.items():\n+            if isinstance(k, str):\n+                if \",\" in k:\n+                    try:\n+                        a_s, b_s = k.split(\",\")\n+                        a, b = int(a_s), int(b_s)\n+                        if a > b:\n+                            a, b = b, a\n+                        interaction_map[(a, b)] = float(v)\n+                    except Exception:\n+                        continue\n+                else:\n+                    # maybe nested mapping case handled later\n+                    continue\n+            elif isinstance(k, (list, tuple)) and len(k) == 2:\n+                try:\n+                    a, b = int(k[0]), int(k[1])\n+                    if a > b:\n+                        a, b = b, a\n+                    interaction_map[(a, b)] = float(v)\n+                except Exception:\n+                    continue\n+    # try nested dict form interactions[i][j] = val\n+    if not interaction_map and isinstance(interactions, dict):\n         try:\n-            for i_key, row in interactions.items():\n-                ii = int(i_key)\n-                for j_key, v in row.items():\n-                    jj = int(j_key)\n-                    a, b = (ii, jj) if ii <= jj else (jj, ii)\n-                    interaction_map[(a, b)] = float(v)\n+            for ik, row in interactions.items():\n+                ii = int(ik)\n+                if isinstance(row, dict):\n+                    for jk, vv in row.items():\n+                        jj = int(jk)\n+                        a, b = (ii, jj) if ii <= jj else (jj, ii)\n+                        interaction_map[(a, b)] = float(vv)\n         except Exception:\n-            # If parsing fails, leave interaction_map empty\n             pass\n \n     def get_interaction(i, j):\n-        a, b = (i, j) if i <= j else (j, i)\n-        return interaction_map.get((a, b), 0.0)\n-\n-    # Build predecessor map for precedence constraints\n+        if i > j:\n+            i, j = j, i\n+        return interaction_map.get((i, j), 0.0)\n+\n+    # Precedence maps\n     preds = {i: set() for i in range(n)}\n+    succs = {i: set() for i in range(n)}\n     for p in precedence:\n         try:\n-            pi, pj = int(p[0]), int(p[1])\n-            # if pj selected then pi must be selected\n-            preds[pj].add(pi)\n+            a = int(p[0]); b = int(p[1])\n+            # if b selected then a must be selected => a is predecessor of b\n+            preds[b].add(a)\n+            succs[a].add(b)\n         except Exception:\n-            pass\n-    # compute transitive closure of predecessors for each node\n+            continue\n+\n+    # Compute transitive predecessor closure and successor closure\n     pred_closure = {}\n     for i in range(n):\n+        seen = set()\n         stack = list(preds.get(i, []))\n-        closure = set()\n         while stack:\n             x = stack.pop()\n-            if x in closure:\n+            if x in seen:\n                 continue\n-            closure.add(x)\n-            for pp in preds.get(x, []):\n-                if pp not in closure:\n-                    stack.append(pp)\n-        pred_closure[i] = closure\n-\n-    # Helper: check feasibility of a full candidate set S (set of indices)\n+            seen.add(x)\n+            for y in preds.get(x, ()):\n+                if y not in seen:\n+                    stack.append(y)\n+        pred_closure[i] = seen\n+\n+    succ_closure = {}\n+    for i in range(n):\n+        seen = set()\n+        stack = list(succs.get(i, []))\n+        while stack:\n+            x = stack.pop()\n+            if x in seen:\n+                continue\n+            seen.add(x)\n+            for y in succs.get(x, ()):\n+                if y not in seen:\n+                    stack.append(y)\n+        succ_closure[i] = seen\n+\n+    # Precompute group and mutex quick checks\n+    # groups: dict name -> list of vars\n+    var_to_group = {}\n+    for gname, vars_list in groups.items():\n+        for v in vars_list:\n+            var_to_group[v] = gname\n+\n+    mutex_pairs = set()\n+    mutex_map = {i: set() for i in range(n)}\n+    for a, b in mutex:\n+        mutex_pairs.add((a, b))\n+        mutex_pairs.add((b, a))\n+        if 0 <= a < n and 0 <= b < n:\n+            mutex_map[a].add(b)\n+            mutex_map[b].add(a)\n+\n+    # Quick feasibility check\n     def is_feasible_set(S):\n-        # cardinality\n         if len(S) > max_card or len(S) < 0:\n             return False\n-        # mutex: no pair both present\n-        for a, b in mutex:\n-            if a in S and b in S:\n-                return False\n-        # groups: at most one per group\n-        for grp_vars in groups.values():\n-            if len(set(grp_vars).intersection(S)) > 1:\n-                return False\n-        # precedence: for every j in S, all its preds must be in S\n-        for j in list(S):\n-            if not pred_closure.get(j):\n-                # OK\n-                pass\n-            # direct preds\n-            for pi in preds.get(j, set()):\n-                if pi not in S:\n+        # precedence: all preds must be included\n+        for j in S:\n+            for p in preds.get(j, ()):\n+                if p not in S:\n                     return False\n+        # mutex\n+        for a in S:\n+            for b in mutex_map.get(a, ()):\n+                if b in S:\n+                    return False\n+        # groups\n+        seen_groups = {}\n+        for v in S:\n+            g = var_to_group.get(v)\n+            if g is not None:\n+                if g in seen_groups:\n+                    return False\n+                seen_groups[g] = v\n         return True\n \n-    # Objective calculation\n+    # Objective computation optimized: sum weights + sum interactions for pairs (i<j)\n+    # We'll maintain an interactions adjacency list for non-zero interactions\n+    neighbors = {i: {} for i in range(n)}\n+    for (a, b), val in interaction_map.items():\n+        if 0 <= a < n and 0 <= b < n:\n+            neighbors[a][b] = val\n+            neighbors[b][a] = val\n+\n     def objective(S):\n-        S_list = list(S)\n         total = 0.0\n-        for i in S_list:\n-            total += weights[i] if i < len(weights) else 0.0\n-        # pairwise interactions (count each pair once)\n-        for idx in range(len(S_list)):\n-            for jdx in range(idx+1, len(S_list)):\n-                total += get_interaction(S_list[idx], S_list[jdx])\n+        for i in S:\n+            if 0 <= i < n:\n+                total += weights[i]\n+        # pairwise interactions\n+        # sum over each i neighbors j>i in S\n+        Sset = set(S)\n+        for i in Sset:\n+            for j, val in neighbors[i].items():\n+                if j in Sset and j > i:\n+                    total += val\n         return total\n \n-    # Function to compute marginal gain of adding set A (iterable) to current set S\n+    # Marginal gain for adding a set A to S (A disjoint or overlap handled)\n     def marginal_gain(S, A):\n-        A = set(A) - set(S)\n-        if not A:\n+        Sset = set(S)\n+        Aset = set(A) - Sset\n+        if not Aset:\n             return 0.0\n         gain = 0.0\n-        for i in A:\n-            gain += weights[i] if i < len(weights) else 0.0\n+        for i in Aset:\n+            if 0 <= i < n:\n+                gain += weights[i]\n         # interactions between A and S\n-        for i in A:\n-            for j in S:\n-                gain += get_interaction(i, j)\n+        for i in Aset:\n+            for j, val in neighbors[i].items():\n+                if j in Sset:\n+                    gain += val\n         # interactions internal to A\n-        A_list = list(A)\n-        for ii in range(len(A_list)):\n-            for jj in range(ii+1, len(A_list)):\n-                gain += get_interaction(A_list[ii], A_list[jj])\n+        Alist = list(Aset)\n+        for ui in range(len(Alist)):\n+            ii = Alist[ui]\n+            for uj in range(ui + 1, len(Alist)):\n+                jj = Alist[uj]\n+                gain += neighbors[ii].get(jj, 0.0)\n         return gain\n \n-    # Helper: when trying to add item i, compute required closure (predecessors)\n-    def closure_for(i, current_set):\n-        # items that must be present if we include i: i plus all transitive predecessors\n-        C = set([i])\n+    # closure_for: when adding i, include its predecessors (transitive)\n+    def closure_for_add(i, current_set):\n+        res = set([i])\n         for p in pred_closure.get(i, set()):\n-            C.add(p)\n-        # Some predecessors may themselves have predecessors already included by pred_closure\n-        # pred_closure already transitive, so this suffices.\n-        # Remove those already in current_set\n-        return C - set(current_set)\n-\n-    # Main greedy: iteratively add the candidate (plus its preds) with best marginal gain\n-    selected_set = set()\n-    # We'll allow adding until no improvement or until max_card reached.\n-    while len(selected_set) < max_card:\n-        best_gain = None\n-        best_add = None\n-        # evaluate every candidate not in selected_set\n-        for i in range(n):\n-            if i in selected_set:\n+            res.add(p)\n+        # exclude already present\n+        return res - set(current_set)\n+\n+    # closure_for_remove: when removing i, need to remove all successors that depend on it (transitive)\n+    def closure_for_remove(i):\n+        res = set([i])\n+        for s in succ_closure.get(i, set()):\n+            res.add(s)\n+        return res\n+\n+    # centrality heuristic: base for seeding\n+    centrality = []\n+    for i in range(n):\n+        s = weights[i] if 0 <= i < n else 0.0\n+        # sum of positive interactions\n+        pos_sum = 0.0\n+        for j, val in neighbors[i].items():\n+            if val > 0:\n+                pos_sum += val\n+            else:\n+                pos_sum += 0.1 * val  # small weight for negative links\n+        s += pos_sum\n+        centrality.append((s, i))\n+    centrality.sort(reverse=True)\n+\n+    # Beam parameters scaled with n\n+    beam_width = max(5, min(40, n // 3 + 1))\n+    seeds_to_try = beam_width\n+    seed_indices = [i for _, i in centrality[:seeds_to_try]]\n+\n+    # If too few seeds (small n), consider random seeds for diversity\n+    if len(seed_indices) < beam_width:\n+        others = [i for i in range(n) if i not in seed_indices]\n+        random.shuffle(others)\n+        seed_indices += others[:beam_width - len(seed_indices)]\n+\n+    # Greedy augment function (respect closures, groups, mutex)\n+    def greedy_augment(initial_set):\n+        S = set(initial_set)\n+        # If initial violates precedence, fix by adding needed preds\n+        changed = True\n+        while changed:\n+            changed = False\n+            for j in list(S):\n+                for p in preds.get(j, ()):\n+                    if p not in S:\n+                        S.add(p)\n+                        changed = True\n+        # Greedily add items with best positive marginal gain\n+        while len(S) < max_card:\n+            best_gain = -1e18\n+            best_add = None\n+            for i in range(n):\n+                if i in S:\n+                    continue\n+                add_set = closure_for_add(i, S)\n+                if not add_set:\n+                    continue\n+                if len(S) + len(add_set) > max_card:\n+                    continue\n+                # check group/mutex feasibility quickly\n+                violated = False\n+                # group conflict\n+                existing_groups = set(var_to_group.get(v) for v in S if var_to_group.get(v) is not None)\n+                for v in add_set:\n+                    g = var_to_group.get(v)\n+                    if g is not None and g in existing_groups:\n+                        violated = True\n+                        break\n+                if violated:\n+                    continue\n+                # mutex: any v in add_set conflicting with S?\n+                for v in add_set:\n+                    for m in mutex_map.get(v, ()):\n+                        if m in S:\n+                            violated = True\n+                            break\n+                    if violated:\n+                        break\n+                if violated:\n+                    continue\n+                gain = marginal_gain(S, add_set)\n+                # prefer positive gains; otherwise small positive if need to reach min_card\n+                if gain > best_gain:\n+                    best_gain = gain\n+                    best_add = add_set\n+            if best_add is None or (best_gain <= 1e-12 and len(S) >= min_card):\n+                break\n+            S |= set(best_add)\n+        # If below min_card, force add highest marginal items (even negative if necessary)\n+        if len(S) < min_card:\n+            # consider all candidates sorted by marginal gain\n+            cand_list = []\n+            for i in range(n):\n+                if i in S:\n+                    continue\n+                add_set = closure_for_add(i, S)\n+                if not add_set:\n+                    continue\n+                if len(S) + len(add_set) > max_card:\n+                    continue\n+                # skip if group/mutex violate\n+                violated = False\n+                existing_groups = set(var_to_group.get(v) for v in S if var_to_group.get(v) is not None)\n+                for v in add_set:\n+                    g = var_to_group.get(v)\n+                    if g is not None and g in existing_groups:\n+                        violated = True\n+                        break\n+                    for m in mutex_map.get(v, ()):\n+                        if m in S:\n+                            violated = True\n+                            break\n+                    if violated:\n+                        break\n+                if violated:\n+                    continue\n+                cand_list.append((marginal_gain(S, add_set), add_set))\n+            cand_list.sort(reverse=True, key=lambda x: x[0])\n+            for gain, add_set in cand_list:\n+                if len(S) >= min_card:\n+                    break\n+                if len(S) + len(add_set) > max_card:\n+                    continue\n+                S |= set(add_set)\n+        # final feasibility guard\n+        if not is_feasible_set(S):\n+            # fallback: simple weight-based fill respecting closures\n+            S = set()\n+            for i in sorted(range(n), key=lambda x: weights[x], reverse=True):\n+                add_set = closure_for_add(i, S)\n+                if len(S) + len(add_set) > max_card:\n+                    continue\n+                if not is_feasible_set(S | set(add_set)):\n+                    continue\n+                S |= set(add_set)\n+                if len(S) >= max_card:\n+                    break\n+        return S\n+\n+    # Build initial beam of solutions\n+    beam = []\n+    tried_seeds = set()\n+    for sidx in seed_indices:\n+        if sidx in tried_seeds:\n+            continue\n+        tried_seeds.add(sidx)\n+        init = closure_for_add(sidx, set())\n+        # if too large, skip seed\n+        if len(init) > max_card:\n+            continue\n+        sol = greedy_augment(init)\n+        beam.append(sol)\n+    # If beam too small, add some empties and singletons\n+    if not beam:\n+        beam.append(set())\n+    # ensure beam unique\n+    uniq = []\n+    seen = set()\n+    for sol in beam:\n+        key = tuple(sorted(sol))\n+        if key not in seen:\n+            uniq.append(sol)\n+            seen.add(key)\n+    beam = uniq[:beam_width]\n+\n+    # Local search with simulated annealing for each beam member\n+    best_sol = None\n+    best_score = -1e99\n+\n+    # Tune iterations by problem size\n+    base_iters = 300\n+    iter_scale = max(1, n // 10)\n+    max_iters_per_seed = min(2000, base_iters * iter_scale)\n+\n+    rng = random.Random()\n+    # deterministic-ish seed based on weights to be reproducible across runs\n+    rng.seed(int(sum(weights) * 1000) if weights else 12345)\n+\n+    start_time = time.time()\n+    time_limit = 1.8  # try to keep runtime modest; evaluator may limit\n+    for sol in beam:\n+        S = set(sol)\n+        S = greedy_augment(S)  # tighten\n+        cur_score = objective(S)\n+        if cur_score > best_score:\n+            best_score = cur_score\n+            best_sol = set(S)\n+        # SA parameters\n+        T0 = max(1.0, abs(cur_score) * 0.1 + 1.0)\n+        Tmin = 1e-3\n+        iters = 0\n+        last_improve = 0\n+        while iters < max_iters_per_seed:\n+            iters += 1\n+            # time cut\n+            if time.time() - start_time > time_limit:\n+                break\n+            # temperature schedule\n+            frac = iters / float(max_iters_per_seed + 1)\n+            temp = T0 * (1.0 - frac) + Tmin * frac\n+            op = rng.choice(['add', 'remove', 'swap'])\n+            accepted = False\n+            if op == 'add':\n+                # pick candidate item not in S that might improve\n+                candidates = list(set(range(n)) - S)\n+                rng.shuffle(candidates)\n+                for cand in candidates[:min(50, len(candidates))]:\n+                    add_set = closure_for_add(cand, S)\n+                    if not add_set:\n+                        continue\n+                    if len(S) + len(add_set) > max_card:\n+                        continue\n+                    # group/mutex check\n+                    violated = False\n+                    existing_groups = set(var_to_group.get(v) for v in S if var_to_group.get(v) is not None)\n+                    for v in add_set:\n+                        g = var_to_group.get(v)\n+                        if g is not None and g in existing_groups:\n+                            violated = True\n+                            break\n+                        for m in mutex_map.get(v, ()):\n+                            if m in S:\n+                                violated = True\n+                                break\n+                        if violated:\n+                            break\n+                    if violated:\n+                        continue\n+                    newS = set(S) | set(add_set)\n+                    # ensure not violating precedence (add_set includes preds)\n+                    if not is_feasible_set(newS):\n+                        continue\n+                    new_score = objective(newS)\n+                    delta = new_score - cur_score\n+                    if delta > 1e-12 or math.exp(min(50.0, delta / max(1e-9, temp))) > rng.random():\n+                        S = newS\n+                        cur_score = new_score\n+                        accepted = True\n+                        last_improve = iters\n+                        break\n+            elif op == 'remove':\n+                if len(S) == 0:\n+                    continue\n+                removes = list(S)\n+                rng.shuffle(removes)\n+                for rem in removes[:min(50, len(removes))]:\n+                    rem_set = closure_for_remove(rem)\n+                    newS = set(S) - rem_set\n+                    # enforce min_card or allow temporary below with small prob\n+                    if len(newS) < min_card:\n+                        # permit removal with low probability if helps and temperature high\n+                        pass_prob = math.exp(- (min_card - len(newS)) / (1.0 + temp))\n+                        if rng.random() > pass_prob:\n+                            continue\n+                    if not is_feasible_set(newS):\n+                        continue\n+                    new_score = objective(newS)\n+                    delta = new_score - cur_score\n+                    if delta > 1e-12 or math.exp(min(50.0, delta / max(1e-9, temp))) > rng.random():\n+                        S = newS\n+                        cur_score = new_score\n+                        accepted = True\n+                        last_improve = iters\n+                        break\n+            else:  # swap: remove some dependent cluster and add some other closure\n+                if len(S) == 0:\n+                    continue\n+                rem = rng.choice(list(S))\n+                rem_set = closure_for_remove(rem)\n+                base = set(S) - rem_set\n+                # consider candidates to add given base\n+                candidates = list(set(range(n)) - base)\n+                rng.shuffle(candidates)\n+                for cand in candidates[:min(80, len(candidates))]:\n+                    add_set = closure_for_add(cand, base)\n+                    if not add_set:\n+                        continue\n+                    if len(base) + len(add_set) > max_card:\n+                        continue\n+                    # group/mutex check\n+                    violated = False\n+                    existing_groups = set(var_to_group.get(v) for v in base if var_to_group.get(v) is not None)\n+                    for v in add_set:\n+                        g = var_to_group.get(v)\n+                        if g is not None and g in existing_groups:\n+                            violated = True\n+                            break\n+                        for m in mutex_map.get(v, ()):\n+                            if m in base:\n+                                violated = True\n+                                break\n+                        if violated:\n+                            break\n+                    if violated:\n+                        continue\n+                    newS = set(base) | set(add_set)\n+                    if len(newS) < min_card:\n+                        continue\n+                    if not is_feasible_set(newS):\n+                        continue\n+                    new_score = objective(newS)\n+                    delta = new_score - cur_score\n+                    if delta > 1e-12 or math.exp(min(50.0, delta / max(1e-9, temp))) > rng.random():\n+                        S = newS\n+                        cur_score = new_score\n+                        accepted = True\n+                        last_improve = iters\n+                        break\n+            # record best\n+            if cur_score > best_score + 1e-12:\n+                best_score = cur_score\n+                best_sol = set(S)\n+            # small early stop if no improvement for long\n+            if iters - last_improve > 400 and iters > 800:\n+                break\n+        # time limit guard\n+        if time.time() - start_time > time_limit:\n+            break\n+\n+    # Final repair and ensure feasibility and cardinality\n+    if best_sol is None:\n+        best_sol = set()\n+    S = set(best_sol)\n+    # Ensure precedence closure included\n+    changed = True\n+    while changed:\n+        changed = False\n+        for j in list(S):\n+            for p in preds.get(j, ()):\n+                if p not in S:\n+                    S.add(p)\n+                    changed = True\n+    # If too large, try removing low marginal contributors while respecting precedence\n+    if len(S) > max_card:\n+        # rank items by marginal contribution (with respect to S)\n+        def marginal_contrib(i, curS):\n+            # contribution approximated as weight + sum interactions with curS - interactions lost from removal\n+            contrib = weights[i]\n+            for j, val in neighbors[i].items():\n+                if j in curS and j != i:\n+                    contrib += val\n+            return contrib\n+        # try removing items with smallest contrib but ensure we also remove dependents\n+        items = sorted(list(S), key=lambda x: marginal_contrib(x, S))\n+        for itv in items:\n+            if len(S) <= max_card:\n+                break\n+            # can't remove if it has predecessors that would remain invalid (we'll remove dependents)\n+            rem_cluster = closure_for_remove(itv)\n+            # ensure we don't violate min_card after removal\n+            if len(S) - len(rem_cluster) < min_card:\n                 continue\n-            # compute closure needed\n-            add_set = closure_for(i, selected_set)\n-            # if adding would exceed max_card, skip\n-            if len(selected_set) + len(add_set) > max_card:\n+            S -= rem_cluster\n+        # final safety: if still too large, keep top by contrib\n+        if len(S) > max_card:\n+            items = sorted(list(S), key=lambda x: marginal_contrib(x, S), reverse=True)\n+            S = set(items[:max_card])\n+\n+    # If too small, fill greedily\n+    if len(S) < min_card:\n+        # add best marginal additions\n+        while len(S) < min_card:\n+            best_gain = -1e99\n+            best_add = None\n+            for i in range(n):\n+                if i in S:\n+                    continue\n+                add_set = closure_for_add(i, S)\n+                if not add_set:\n+                    continue\n+                if len(S) + len(add_set) > max_card:\n+                    continue\n+                # group/mutex check\n+                violated = False\n+                existing_groups = set(var_to_group.get(v) for v in S if var_to_group.get(v) is not None)\n+                for v in add_set:\n+                    g = var_to_group.get(v)\n+                    if g is not None and g in existing_groups:\n+                        violated = True\n+                        break\n+                    for m in mutex_map.get(v, ()):\n+                        if m in S:\n+                            violated = True\n+                            break\n+                    if violated:\n+                        break\n+                if violated:\n+                    continue\n+                gain = marginal_gain(S, add_set)\n+                if gain > best_gain:\n+                    best_gain = gain\n+                    best_add = add_set\n+            if best_add is None:\n+                break\n+            S |= set(best_add)\n+\n+    # Final enforced feasibility (last resort simple greedy)\n+    if not is_feasible_set(S):\n+        S = set()\n+        for i in sorted(range(n), key=lambda x: weights[x], reverse=True):\n+            add_set = closure_for_add(i, S)\n+            if len(S) + len(add_set) > max_card:\n                 continue\n-            # Check feasibility when adding\n-            new_set = set(selected_set) | set(add_set)\n-            if not is_feasible_set(new_set):\n+            if not is_feasible_set(S | set(add_set)):\n                 continue\n-            gain = marginal_gain(selected_set, add_set)\n-            if best_gain is None or gain > best_gain:\n-                best_gain = gain\n-                best_add = add_set\n-        # Stop if nothing feasible to add\n-        if best_add is None:\n-            break\n-        # If best_gain is negative and we've already reached min_card, stop adding further\n-        if best_gain is not None and best_gain < 0 and len(selected_set) >= min_card:\n-            break\n-        # Otherwise add the best_add\n-        selected_set |= set(best_add)\n-\n-    # If we haven't reached minimum cardinality, force-add best remaining items (respecting constraints)\n-    if len(selected_set) < min_card:\n-        # consider candidates by marginal gain ignoring negative cutoff\n-        candidates = [i for i in range(n) if i not in selected_set]\n-        # sort by simple heuristic gain (weight + sum positive interactions)\n-        def heuristic_gain(i):\n-            g = weights[i] if i < len(weights) else 0.0\n-            for j in range(n):\n-                if j == i:\n-                    continue\n-                g += abs(get_interaction(i, j)) * 0.2\n-            return g\n-        candidates.sort(key=heuristic_gain, reverse=True)\n-        for i in candidates:\n-            if len(selected_set) >= min_card:\n+            S |= set(add_set)\n+            if len(S) >= max_card:\n                 break\n-            add_set = closure_for(i, selected_set)\n-            if len(selected_set) + len(add_set) > max_card:\n-                continue\n-            new_set = set(selected_set) | set(add_set)\n-            if not is_feasible_set(new_set):\n-                continue\n-            selected_set |= set(add_set)\n-\n-    # Local search: try single-item swaps to improve objective (remove one, add one or add closure)\n-    improved = True\n-    max_iters = 500\n-    it = 0\n-    current_obj = objective(selected_set)\n-    # Precompute all items list\n-    all_items = set(range(n))\n-    while improved and it < max_iters:\n-        improved = False\n-        it += 1\n-        # iterate possible removals and additions\n-        removed_item = None\n-        added_items = None\n-        best_obj = current_obj\n-        for rem in list(selected_set):\n-            # Try remove rem and try to add any outside item (with its closure w.r.t resulting set)\n-            base_set = set(selected_set)\n-            base_set.remove(rem)\n-            # Ensure base_set is still feasible (removing may break precedence if rem was a predecessor of others)\n-            if not is_feasible_set(base_set):\n-                # Can't remove this item unless we also remove dependents; skip for simplicity\n-                continue\n-            for add in (all_items - base_set):\n-                if add in base_set:\n-                    continue\n-                add_closure = closure_for(add, base_set)\n-                candidate_set = set(base_set) | set(add_closure)\n-                # respect cardinality\n-                if len(candidate_set) < min_card or len(candidate_set) > max_card:\n-                    continue\n-                if not is_feasible_set(candidate_set):\n-                    continue\n-                obj = objective(candidate_set)\n-                if obj > best_obj + 1e-9:\n-                    best_obj = obj\n-                    removed_item = rem\n-                    added_items = set(add_closure)\n-        if best_obj > current_obj + 1e-9 and removed_item is not None:\n-            # apply improvement\n-            selected_set.remove(removed_item)\n-            selected_set |= set(added_items)\n-            current_obj = best_obj\n-            improved = True\n-\n-    # Final safety: ensure feasibility (if not, fall back to greedy selection by weight)\n-    if not is_feasible_set(selected_set):\n-        selected_set = set()\n-        for i in sorted(range(n), key=lambda x: weights[x], reverse=True):\n-            if len(selected_set) >= max_card:\n-                break\n-            add_set = closure_for(i, selected_set)\n-            if len(selected_set) + len(add_set) > max_card:\n-                continue\n-            new_set = set(selected_set) | set(add_set)\n-            if not is_feasible_set(new_set):\n-                continue\n-            selected_set |= set(add_set)\n-        # fill up if still below min_card\n         i = 0\n-        while len(selected_set) < min_card and i < n:\n-            if i not in selected_set:\n-                add_set = closure_for(i, selected_set)\n-                if len(selected_set) + len(add_set) <= max_card:\n-                    new_set = set(selected_set) | set(add_set)\n-                    if is_feasible_set(new_set):\n-                        selected_set |= set(add_set)\n+        while len(S) < min_card and i < n:\n+            if i not in S:\n+                add_set = closure_for_add(i, S)\n+                if len(S) + len(add_set) <= max_card and is_feasible_set(S | set(add_set)):\n+                    S |= set(add_set)\n             i += 1\n \n-    result = {\n-        \"selection\": {\n-            \"variables\": sorted(list(selected_set))\n-        }\n-    }\n+    result = {\"selection\": {\"variables\": sorted(list(S))}}\n     print(json.dumps(result))\n+\n # EVOLVE-BLOCK-END\n \n \n # This part remains fixed (not evolved)\n def run_sds(problem_data=None):\n     \"\"\"\n     Main function called by the evaluator.\n     Can accept problem_data as parameter or read from stdin.\n     Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n     \"\"\"\n     import sys\n     import json\n     import io\n \n     if problem_data is None:\n         # Read from stdin (for compatibility)\n         input_data = json.load(sys.stdin)\n     else:\n         # Use provided problem data\n         input_data = problem_data\n \n     # Capture stdout from solve_sds\n     stdout_capture = io.StringIO()\n     old_stdin = sys.stdin\n \n     try:\n         # Create mock stdin\n         sys.stdin = io.StringIO(json.dumps(input_data))\n         with contextlib.redirect_stdout(stdout_capture):\n             solve_sds()\n     finally:\n         sys.stdin = old_stdin\n \n     result_str = stdout_capture.getvalue()\n     return result_str\n",
      "combined_score": 0.0,
      "public_metrics": {},
      "private_metrics": {},
      "text_feedback": "",
      "correct": false,
      "children_count": 0,
      "complexity": 0.934,
      "embedding": [
        0.026590163,
        0.0033894645,
        0.043833997,
        -0.031021856,
        0.0039238953,
        0.019786377,
        0.027740698,
        -0.01856482,
        -0.014133126,
        0.024402725,
        0.05943015,
        -0.03894777,
        -0.043663546,
        -0.025837343,
        0.019857397,
        -0.0036043022,
        0.011342011,
        -0.030908223,
        -0.02041136,
        0.04323742,
        0.03383428,
        -0.00011773906,
        0.041362476,
        -0.00011895973,
        0.013692797,
        0.0066155815,
        0.024672603,
        0.023735128,
        0.034885384,
        -0.04258403,
        0.06624814,
        -0.021632915,
        -0.028166823,
        -0.008004037,
        -0.046703234,
        0.043379463,
        -0.015496724,
        0.037527356,
        -0.024445336,
        -0.000969433,
        -0.009893188,
        -0.039402302,
        -0.021249404,
        -0.0041511618,
        -0.01774098,
        -0.008437263,
        0.020681238,
        0.012094831,
        0.017499508,
        0.005365616,
        0.019772172,
        0.041362476,
        -0.013145938,
        0.023024922,
        0.0017240283,
        0.0019583968,
        -0.028692376,
        0.0023933987,
        0.020468175,
        -7.434983e-05,
        0.03028324,
        -0.020013643,
        0.04261244,
        0.021817569,
        -0.021107363,
        0.0020702544,
        -0.020638624,
        0.015596153,
        0.0014088738,
        -0.004729981,
        -0.045907803,
        -0.005124146,
        0.0147297,
        -0.045538493,
        -0.050623577,
        -0.0092397975,
        0.040453408,
        0.060850564,
        1.1957006e-05,
        -0.034544483,
        -0.03247068,
        -0.023252187,
        0.06289596,
        -0.032413863,
        -0.018721065,
        -0.07602059,
        -0.024019212,
        0.0021146424,
        -0.08539533,
        -0.04925998,
        -0.030396873,
        0.0052661872,
        -0.0517315,
        0.04292493,
        0.068293534,
        -0.040396594,
        0.03926026,
        -0.009992617,
        0.017016567,
        -0.002675706,
        0.017499508,
        -0.019204006,
        -0.007954322,
        -0.007854893,
        0.048237283,
        0.033209294,
        0.028308865,
        -0.0024058274,
        -0.010113352,
        -0.027939556,
        -0.037697807,
        0.009964209,
        -0.00045386687,
        -0.0066297855,
        -0.012655894,
        -0.009587799,
        -0.028962255,
        0.0046767155,
        0.029402584,
        0.005745577,
        -0.022996513,
        0.020326134,
        -0.02853613,
        0.033720642,
        0.007450075,
        -0.0026934613,
        0.057782467,
        -0.055367764,
        -0.032243412,
        0.0052413302,
        0.03926026,
        -0.020127276,
        0.03065255,
        -0.045197595,
        -0.034714933,
        0.018650044,
        -0.048322506,
        0.013557858,
        -0.006111334,
        0.003966508,
        0.023237985,
        0.029544625,
        -0.00021539257,
        -0.011888871,
        -0.008131874,
        0.023905579,
        -0.00040459624,
        0.017385876,
        -0.05431666,
        0.025510648,
        0.06681631,
        -0.028777601,
        0.008181589,
        -0.007727056,
        0.07721374,
        -0.07806599,
        -0.029913932,
        0.05357804,
        0.018919924,
        -0.005820149,
        -0.002425358,
        0.012208464,
        -0.042669255,
        -0.0150705995,
        0.02661857,
        -0.009232695,
        -0.041163616,
        0.026902653,
        -0.050538354,
        -0.03744213,
        0.036533065,
        -0.051220153,
        -0.008984122,
        0.004783246,
        0.010738335,
        -0.009616207,
        -0.008856285,
        -0.0517315,
        -0.02785433,
        -0.04374877,
        -0.03227182,
        -0.0081247715,
        -0.041902233,
        -0.027428208,
        -0.023039127,
        -0.002079132,
        0.024431132,
        -0.01654783,
        -0.01024119,
        0.009580697,
        -0.012137444,
        0.035766043,
        0.03829438,
        0.008948612,
        -0.011327807,
        0.0007177533,
        0.047725935,
        0.044231713,
        -0.015624561,
        0.042811297,
        0.0004674052,
        -0.054998457,
        0.052186035,
        -0.011384623,
        0.0072157066,
        -0.049117938,
        -0.029601442,
        -0.023791946,
        -0.019473884,
        -0.017158609,
        0.038067114,
        -0.030112792,
        0.019402863,
        -0.0067469697,
        0.013721205,
        0.031874105,
        0.010290904,
        0.02846511,
        -0.01732906,
        0.089770205,
        -0.02171814,
        0.033521786,
        0.010418742,
        0.016249543,
        0.0029686666,
        0.06204371,
        0.012613283,
        -0.015809216,
        0.0088349795,
        -0.033692237,
        0.0066013774,
        -0.02072385,
        -0.027286166,
        0.009651718,
        -0.008621917,
        -0.029203726,
        -0.028905438,
        -0.00599415,
        0.0006915644,
        -0.022755044,
        0.016093299,
        0.016505219,
        0.021931203,
        0.0027769108,
        -0.00060811505,
        -0.0028372782,
        -0.04928839,
        0.0025194606,
        -0.030482098,
        0.01377092,
        0.042186316,
        -0.045481678,
        0.026760612,
        -0.01531207,
        -0.04295334,
        0.0037001802,
        -0.01613591,
        -0.025340198,
        -0.023777742,
        0.03778303,
        -0.06141873,
        0.0075139934,
        -0.016590443,
        -0.040481817,
        -0.008920204,
        0.006228518,
        -0.0022282754,
        0.00047450728,
        0.0033415256,
        -0.01654783,
        -0.0053088,
        0.025468035,
        -0.04874863,
        -0.016604647,
        -0.027200941,
        -0.031021856,
        2.9767674e-05,
        0.0722707,
        -0.019757967,
        -0.049544062,
        -0.04891908,
        -0.003155096,
        0.0524133,
        -0.0006107783,
        0.014530842,
        0.0065978263,
        -0.008863388,
        0.047186173,
        0.01178234,
        0.0038919363,
        -0.0073080333,
        -0.015099008,
        0.01774098,
        -0.018607432,
        -0.01157638,
        -0.0476123,
        -0.0053088,
        0.0024502154,
        -0.018436983,
        -0.0012526282,
        0.085622594,
        -0.0015012007,
        -0.00945286,
        0.014445617,
        -0.04326583,
        -0.015411499,
        0.01616432,
        0.0029278297,
        0.013557858,
        0.006487744,
        0.0043535708,
        0.017513713,
        -0.03542514,
        -0.02712992,
        -0.032385454,
        -0.026007792,
        0.065225445,
        0.0100778425,
        0.034203585,
        -0.00013094448,
        -0.028834417,
        -0.035567183,
        0.028493518,
        0.012322097,
        0.03846483,
        -0.025013503,
        0.01240022,
        0.008181589,
        -0.000593467,
        -0.037300088,
        0.00137869,
        0.034942202,
        0.061816446,
        0.038095523,
        -0.03894777,
        -0.040055692,
        0.005319453,
        0.017868817,
        0.034544483,
        0.032499086,
        -0.030595731,
        -0.017357467,
        -0.034999017,
        -0.0236357,
        -0.008408855,
        0.0070346035,
        0.0075779124,
        0.02894805,
        0.043549914,
        0.013145938,
        -0.010489763,
        -0.00048205323,
        -0.028820213,
        0.03690237,
        -0.0070523587,
        -0.025879955,
        -0.0045950413,
        -0.0025372156,
        -0.036845557,
        -0.01914719,
        0.013742512,
        0.014275167,
        0.016348973,
        0.01257067,
        -0.002558522,
        0.02445954,
        0.026845837,
        0.03681715,
        0.0011691789,
        0.013522347,
        0.014885945,
        0.057327937,
        -0.0076986477,
        0.01856482,
        -0.07852052,
        0.023337413,
        0.0032829335,
        0.0541178,
        0.020851687,
        0.038123928,
        -0.0239766,
        0.01119997,
        -0.04715777,
        -0.007975629,
        0.020809075,
        0.04559531,
        0.0184938,
        0.028834417,
        -0.045737352,
        -0.019644335,
        0.02586575,
        -0.031788882,
        0.01890572,
        -0.009317921,
        0.014076309,
        -0.010234088,
        0.019814784,
        0.0630096,
        0.023919784,
        0.049032714,
        0.0043003056,
        0.01730065,
        -0.017755182,
        -0.04059545,
        -0.027328778,
        0.0026970124,
        0.050367903,
        0.043635137,
        -0.004641205,
        0.017854612,
        0.038180746,
        0.014857537,
        0.036362614,
        -0.025766322,
        0.025666893,
        0.005234228,
        -0.025595872,
        0.03613535,
        -0.002753829,
        0.0798273,
        0.00561774,
        -0.03232864,
        0.018309144,
        -0.026320284,
        -0.03130594,
        0.03315248,
        0.02668959,
        -0.042754482,
        0.041334067,
        -0.010226985,
        0.017357467,
        0.06800945,
        0.060907383,
        0.03661829,
        -0.010539477,
        0.034175176,
        0.013898757,
        0.026391305,
        -0.008565101,
        0.0065339073,
        -0.016434198,
        -0.011924381,
        -0.011228378,
        0.016846118,
        -0.037498947,
        -0.008721346,
        0.0008828765,
        -0.0054650456,
        0.011022418,
        0.011398828,
        0.041390885,
        -0.0164484,
        0.040709086,
        0.024558969,
        -0.006984889,
        -0.017499508,
        0.08613394,
        -0.006019007,
        0.035879675,
        0.013430021,
        0.038152337,
        0.024843052,
        -0.022073245,
        0.021320425,
        0.0011052601,
        0.0140052885,
        0.031561613,
        0.020908505,
        -0.019417068,
        0.044316936,
        0.014573455,
        -0.025169747,
        -0.015056396,
        -0.021916999,
        -0.050169047,
        -0.034146767,
        0.018451186,
        0.00017677505,
        0.024189662,
        0.006125538,
        0.002086234,
        -0.01846539,
        0.017868817,
        0.035851266,
        0.04928839,
        0.03840801,
        0.03511265,
        -0.040027287,
        0.0059692925,
        0.007435871,
        0.015922848,
        -0.006125538,
        0.017130202,
        -0.01771257,
        0.017698366,
        -0.030851407,
        -0.019814784,
        0.02812421,
        -0.004271897,
        0.0076205246,
        0.019005148,
        -0.0017266916,
        -0.03690237,
        -0.002631318,
        0.03761258,
        -0.016704077,
        0.021774957,
        0.009325022,
        -0.005234228,
        0.017527917,
        -0.0294594,
        -0.014871742,
        0.015681379,
        0.025325993,
        0.0462487,
        -0.0026668285,
        0.0001640135,
        -8.422615e-05,
        -0.010880376,
        0.028038986,
        0.0039274464,
        -0.025056114,
        -0.017272241,
        0.005830802,
        0.01965854,
        -0.037726212,
        -0.005021166,
        -0.06550953,
        -0.037981886,
        0.008295221,
        -0.010908784,
        -0.028891234,
        -0.020780666,
        0.06539589,
        -0.041845415,
        0.0033219948,
        -0.03374905,
        -0.004680266,
        0.024331704,
        -0.013465531,
        0.0044814083,
        0.0067576226,
        -0.025752118,
        -0.0025230115,
        0.022513572,
        -0.044885103,
        0.0530951,
        0.026845837,
        -0.0039345487,
        -0.0030911774,
        -0.00678248,
        -0.027314574,
        0.010134659,
        -0.03144798,
        -0.021632915,
        0.020155685,
        -0.044174895,
        -0.00055484945,
        -0.0029029725,
        0.015908644,
        0.0028710132,
        0.0056070867,
        0.019445477,
        -0.017087588,
        -0.04877704,
        -0.02795376,
        0.025837343,
        0.022925492,
        -0.003764099,
        0.04411808,
        -0.015695581,
        -0.008359141,
        -0.009765351,
        -0.08624758,
        0.04644756,
        0.003962957,
        -0.01757053,
        -0.02788274,
        -0.014452719,
        -0.0038457727,
        -0.036845557,
        -0.033919502,
        -0.024203867,
        -0.023479454,
        -0.09090654,
        0.024374316,
        -0.019132985,
        0.08022502,
        0.015468316,
        0.0003173739,
        0.0033113416,
        0.012172953,
        0.019573314,
        0.012066423,
        -0.014310678,
        -0.026831632,
        -0.037896663,
        -0.01808188,
        -5.8148224e-05,
        0.0044210404,
        0.0040339776,
        -0.03894777,
        0.034402445,
        -0.0010981581,
        -0.023706721,
        -0.00054641574,
        0.03826597,
        0.007247666,
        0.013366102,
        0.0060580685,
        -0.016505219,
        0.014189943,
        0.0037072822,
        -0.021774957,
        -0.023280596,
        -0.0020667033,
        -0.0065374584,
        0.049231574,
        0.05474278,
        -0.041248843,
        -0.0131956525,
        0.020184092,
        0.023451047,
        0.021789161,
        0.011526665,
        -0.0044956123,
        -0.02747082,
        -0.0066475407,
        -0.0023135005,
        0.018777883,
        -0.028422497,
        0.008607713,
        -0.028067393,
        0.013309285,
        -0.015539336,
        0.032413863,
        0.01965854,
        -0.0038102623,
        7.884411e-05,
        0.013841941,
        0.024658399,
        0.027499229,
        0.009360532,
        -0.04874863,
        0.023408433,
        0.031987738,
        -0.027556045,
        0.013174346,
        0.008245507,
        -0.034942202,
        -0.031163897,
        -0.018706862,
        0.029260542,
        -0.026575958,
        0.0479532,
        -0.0044103875,
        9.166113e-05,
        -0.032215003,
        -0.010141761,
        -0.019701151,
        -0.019601723,
        0.0011940361,
        -0.008089261,
        0.022527777,
        0.007336442,
        0.010702824,
        0.011810748,
        0.03948753,
        0.022740839,
        0.0038280175,
        -0.0208943,
        0.023408433,
        0.013721205,
        -0.025681097,
        -0.0081247715,
        0.0014142004,
        0.013302184,
        -0.014672884,
        -0.021760752,
        0.049799737,
        -0.005323004,
        -0.011626094,
        -0.045339637,
        -0.0010750764,
        0.028891234,
        -0.020425564,
        0.019374456,
        0.018635841,
        0.019743765,
        -0.0010848417,
        0.008913102,
        0.029374175,
        -0.031902514,
        0.0066226833,
        0.027257757,
        0.005415331,
        0.012236873,
        0.028067393,
        -0.017755182,
        -0.1065311,
        -0.010908784,
        0.018479595,
        0.0016343646,
        -0.020581808,
        -0.030595731,
        -0.03514106,
        -0.026803225,
        0.032186598,
        0.04176019,
        -0.021561895,
        0.007293829,
        -0.004769042,
        -0.03514106,
        0.025070319,
        -0.032385454,
        -0.017726775,
        0.033862684,
        0.025936771,
        0.02873499,
        -2.7686989e-05,
        -0.027556045,
        0.0020844585,
        -0.05423143,
        -0.010773845,
        -0.019488089,
        -0.034004726,
        -0.010674416,
        0.034714933,
        0.011299399,
        0.0037250374,
        0.032243412,
        0.005074431,
        0.0121800555,
        -0.012172953,
        -0.02188859,
        0.0043074074,
        -0.03627739,
        -0.015894441,
        -0.02853613,
        0.020880096,
        -0.01654783,
        -0.02545383,
        0.031220714,
        -0.006317294,
        -0.030709365,
        -0.0010448926,
        0.015155825,
        0.05391894,
        -0.06175963,
        0.036192164,
        -0.026945267,
        0.0125351595,
        0.0012401995,
        0.0077838725,
        0.03840801,
        0.034544483,
        0.018422779,
        0.021675527,
        0.0026455224,
        0.019431273,
        -0.02839409,
        -0.013749614,
        -0.039572753,
        0.014310678,
        0.03360701,
        0.029885525,
        0.009786657,
        -0.012478343,
        0.023621496,
        0.018706862,
        0.001647681,
        0.03215819,
        0.006675949,
        0.013586266,
        0.022002224,
        -0.04647597,
        0.009637513,
        -0.04562372,
        -0.04016933,
        -0.011469848,
        0.005425984,
        -0.012996795,
        -0.0066262344,
        0.03281158,
        0.0074429726,
        0.026718,
        0.0033663828,
        -0.019900009,
        0.019601723,
        -0.01722963,
        -0.02904748,
        0.007268972,
        -0.0038599768,
        0.008891796,
        -0.01514162,
        0.012258179,
        -0.0044174897,
        -0.11011054,
        -0.017542122,
        0.034828566,
        0.024658399,
        -0.0115479715,
        -0.03548196,
        0.01181785,
        0.008927306,
        0.015013783,
        -0.010290904,
        -0.053720083,
        -0.026902653,
        0.0148433335,
        0.020809075,
        0.03394791,
        -0.03394791,
        -0.0025017054,
        0.040226143,
        0.0052413302,
        -0.00870004,
        -0.014914354,
        0.03394791,
        0.019346047,
        0.018380165,
        -0.0019850296,
        -4.655187e-05,
        0.0030379118,
        0.02247096,
        -0.018948331,
        -0.016206931,
        0.032612722,
        0.023408433,
        0.016008073,
        0.016902935,
        -0.038748913,
        -0.028138414,
        0.026590163,
        0.024402725,
        0.002428909,
        0.012393118,
        0.0012251077,
        -0.013643083,
        0.029658258,
        -0.047328215,
        0.018834699,
        0.0018571921,
        -0.010496864,
        -0.009736942,
        -0.0030006259,
        0.040652268,
        0.0027165432,
        0.008195792,
        -0.031930923,
        -0.01582342,
        -0.0018136919,
        0.016533626,
        -0.013870349,
        -0.0066013774,
        -0.02346525,
        0.024843052,
        -0.02438852,
        0.005323004,
        0.063180044,
        -0.03278317,
        -0.036675107,
        0.014260964,
        -0.006896113,
        -0.019005148,
        -0.014083412,
        0.010951397,
        0.009381839,
        -0.018621637,
        -0.018536411,
        0.0022833166,
        -0.026874246,
        0.025198156,
        -0.0069777872,
        -0.0035670162,
        -0.0036043022,
        -0.016689872,
        0.028877031,
        -0.015354683,
        0.011022418,
        0.033408154,
        0.013046509,
        0.024772031,
        0.031107081,
        0.03360701,
        0.025070319,
        0.044458978,
        -0.009211389,
        -0.00965882,
        0.01281214,
        -0.0022176225,
        -0.022144265,
        0.0044956123,
        0.0034267504,
        -0.0035528122,
        0.019686947,
        0.020240908,
        0.014189943,
        0.057129078,
        0.037044413,
        -0.018337553,
        -0.028422497,
        0.064373195,
        -0.0037321395,
        0.01972956,
        -0.039544344,
        0.03826597,
        0.0097227385,
        -0.004445898,
        -0.03894777,
        0.035538774,
        -0.019061964,
        -0.011299399,
        0.00058458943,
        -0.0043216115,
        0.0067150104,
        0.0065410095,
        -0.009644615,
        0.030737773,
        -0.022513572,
        -0.0011585257,
        -0.00791171,
        0.007464279,
        -0.011363317,
        -0.018365962,
        -0.0023099494,
        0.005337208,
        0.06340731,
        0.015241049,
        -0.0016672118,
        0.06210053,
        0.002569175,
        0.026021997,
        0.027016288,
        -0.023919784,
        -0.027513431,
        -0.0041369577,
        0.020127276,
        -0.00057304854,
        -0.0013742512,
        -0.017286446,
        0.014168636,
        0.00010397879,
        -0.006775378,
        -0.011349113,
        -0.030993449,
        0.031050265,
        -0.001323649,
        -0.044714652,
        -0.017471101,
        0.014687087,
        -0.037413724,
        0.042697664,
        -0.032555904,
        -0.030425282,
        -0.044174895,
        -0.013408715,
        0.014537944,
        0.032555904,
        -0.004261244,
        -0.010290904,
        0.012854753,
        0.009523881,
        -0.029544625,
        -0.024445336,
        0.025240768,
        0.005333657,
        -0.059316516,
        -0.05329396,
        -0.0062214164,
        0.0043109586,
        0.026078813,
        0.007933016,
        -0.013259571,
        -0.022016427,
        0.0013298632,
        0.020624422,
        -0.0017728551,
        0.016505219,
        -0.015241049,
        0.009182981,
        0.042527214,
        -0.026575958,
        -0.013280877,
        -0.0044849594,
        -0.0069032153,
        0.0006591612,
        0.012861854,
        0.0328968,
        -0.02977189,
        0.043663546,
        0.0031053815,
        0.021689732,
        -0.00056461483,
        0.009580697,
        0.021973815,
        -0.018962536,
        -0.0071198284,
        0.0032598516,
        0.022868676,
        -0.049799737,
        0.0020400705,
        0.05829382,
        -0.021902794,
        -0.0054685962,
        -0.028905438,
        -0.0127127115,
        -0.019828988,
        -0.031163897,
        -0.02470101,
        0.005046023,
        -0.041021574,
        0.0141828405,
        0.019331845,
        0.0024040518,
        -0.051703095,
        -0.031561613,
        -0.017030772,
        -0.03096504,
        0.011718421,
        0.02620665,
        -0.0058698636,
        0.008778162,
        -0.01688873,
        0.0208943,
        -0.018209716,
        0.016093299,
        -0.013039406,
        0.0033308724,
        -0.011853361,
        0.00034844546,
        0.03758417,
        -0.01157638,
        -0.019104578,
        -0.005528964,
        0.0035883226,
        0.039345488,
        0.018323349,
        0.019374456,
        0.0039203446,
        -0.0077199535,
        0.025908364,
        0.0104826605,
        0.03210137,
        0.03195933,
        -0.006960032,
        0.0017675285,
        0.0009942902,
        -0.0037143843,
        0.009104858,
        -0.029544625,
        0.02421807,
        -0.02754184,
        0.016902935,
        0.038976178,
        0.016292157,
        -0.009665922,
        0.016789302,
        0.0011629645,
        -0.023337413,
        -4.9880968e-05,
        -0.012939977,
        -0.025155544,
        -0.018479595,
        0.036419433,
        0.0132453665,
        -0.0029100745,
        -0.010589192,
        -0.0059586396,
        -0.015553541,
        0.02681743,
        -0.027754903,
        0.010525272,
        -0.009616207,
        -0.008756856,
        0.018721065,
        -0.041163616,
        -0.016661463,
        0.017428488,
        -0.0049075326,
        0.011455644,
        0.028450906,
        -0.029999157,
        -0.00022571276,
        -0.031987738,
        0.024686808,
        0.00031315704,
        0.0043074074,
        0.030709365,
        -0.0117752375,
        0.0056390464,
        0.024416927,
        -0.018550616,
        -0.0031604227,
        0.009843473,
        0.013749614,
        -0.015638765,
        -0.04630552,
        -0.0024839502,
        0.0028692377,
        -0.008508284,
        0.03525469,
        0.017939838,
        -0.0065126014,
        -0.011306501,
        -0.031760473,
        -0.010610498,
        0.0010218108,
        -0.009921596,
        -0.0034036688,
        0.0070203994,
        0.0103051085,
        -0.019104578,
        -0.008565101,
        0.014914354,
        -0.011270991,
        0.005046023,
        -0.001577548,
        0.02654755,
        -0.00503537,
        0.014658679,
        -0.0064486824,
        0.013863247,
        0.029345768,
        -0.014083412,
        -0.012165852,
        -0.0081247715,
        0.018039266,
        0.019757967,
        0.051021297,
        -0.0032705048,
        -0.022442551,
        0.031192306,
        -0.04940202,
        -0.021036342,
        -0.00791171,
        -0.027840128,
        -0.034061544,
        -0.021746548,
        -0.0062604775,
        0.008934408,
        -0.035737634,
        -0.018294942,
        -0.022684023,
        0.0024448887,
        0.0062178653,
        -0.0016618852,
        0.0948837,
        0.03130594,
        -0.016419994,
        0.009779555,
        0.016462605,
        -0.0012579547,
        0.0070381546,
        0.0040020184,
        0.022925492,
        -0.03394791,
        -0.0346013,
        0.024331704,
        -0.0052839424,
        -0.0051419013,
        0.030737773,
        0.007656035,
        0.019204006,
        0.011107643,
        -0.0022566838,
        -0.015979664,
        0.008004037,
        0.019374456,
        0.02664698,
        -0.0010635355,
        0.016633056,
        -0.004534674,
        0.011143153,
        0.016633056,
        -0.0017835081,
        0.02860715,
        0.00965882,
        -0.009161674,
        -0.021093158,
        0.0003937212,
        -0.022215286,
        0.0013911186,
        -0.024757827,
        0.017087588,
        -0.021377241,
        -0.0042932034,
        -0.028720785,
        -0.011136051,
        -0.023550475,
        0.011917279,
        0.030368466,
        0.0018856005,
        -0.007975629,
        0.03610694,
        0.0087071415,
        -0.018607432,
        -0.02596518,
        0.017371671,
        0.008543794,
        -0.028280456,
        -0.014800721,
        -0.015241049,
        0.03227182,
        0.023351617,
        -0.010766743,
        -0.025908364,
        -0.02589416,
        -0.03514106,
        -0.0011460971,
        0.05559503,
        0.003984263,
        -0.01681771,
        0.004872022,
        -0.019275026,
        -0.04158974,
        0.026348691,
        -0.033266112,
        0.0073861564,
        0.010475558,
        0.029430991,
        0.022414144,
        0.00030871824,
        -0.01822392,
        0.02356468,
        -0.008423059,
        -0.023649905,
        -0.0130678145,
        0.019544905,
        -0.025240768,
        -0.016206931,
        -0.0090125315,
        0.0009889638,
        0.04644756,
        0.037044413,
        -0.019402863,
        0.0036469146,
        -0.04778275,
        0.018451186,
        -0.0057810876,
        0.021050544,
        0.006970685,
        -0.009431553,
        0.011555073,
        0.0029136257,
        -0.028351476,
        -0.015851827,
        0.0115479715,
        -0.00986478,
        0.03360701,
        0.010006822,
        -0.069032155,
        0.020198297,
        -0.020567605,
        -0.009673024,
        0.010809355,
        0.0047761444,
        0.0051774113,
        0.017840408,
        0.007826485,
        -0.020809075,
        -0.03511265,
        0.031845696,
        -0.003682425,
        -0.0062675797,
        -0.01664726,
        -0.011519563,
        0.014324882,
        0.0024058274,
        0.0123078935,
        -0.023919784,
        -0.0042789993,
        -0.0020542748,
        0.0015606806,
        0.0065374584,
        -0.013692797,
        0.012243974,
        0.020936912,
        -0.007968526,
        0.04278289,
        0.011824952,
        0.012520955,
        -0.013437123,
        -0.00866453,
        0.0012162301,
        -0.028138414,
        0.012769528,
        -0.02315276,
        -0.031533204,
        -0.03758417,
        0.025368607,
        -0.0263771,
        0.0019086822,
        -0.0006400744,
        -0.012329199,
        0.01798245,
        0.038351197,
        0.013898757,
        -0.04079431,
        0.013834839,
        -0.0046198987,
        -0.0074287686,
        -0.0024892767,
        0.010589192,
        -0.0033734848,
        0.005624842,
        -0.028266251,
        -0.013131734,
        0.015454112,
        0.008472773,
        -0.0006445132,
        0.034885384,
        -0.007148237,
        -0.00058192614,
        -0.001024474,
        0.032016147,
        0.016263748,
        -0.0066795,
        -0.025084523,
        0.00087710604,
        -0.004229285,
        0.0043074074,
        0.015695581,
        0.021434058,
        -0.020084664,
        -0.029743483,
        0.025354402,
        -0.018749474,
        0.0031693003,
        -0.00022648956,
        -0.019942623,
        0.01963013,
        -0.017655754,
        0.026334489,
        -0.0004922625,
        -0.01691714,
        -0.010837764,
        0.0020311929,
        -0.027911149,
        -0.007205053,
        -0.026590163,
        0.021689732,
        0.011491154,
        -0.008522488,
        -0.034516077,
        -0.01897674,
        0.037186455,
        0.018536411,
        0.013380306,
        0.025254972,
        0.0034693629,
        -0.0044068363,
        -0.014417209,
        0.0010386782,
        0.020965321,
        0.025610076,
        0.004453,
        0.012670099,
        -0.005294596,
        0.013536552,
        0.008138976,
        0.020993728,
        0.009530982,
        -0.01764155,
        0.034260403,
        0.024090232,
        0.008785265,
        0.012854753,
        -0.00705591,
        -0.0027999924,
        -0.030936632,
        -0.046021435,
        0.011057928,
        -0.01281214,
        0.0010795151,
        0.011377522,
        -0.0072867274,
        0.025539055,
        -0.0013556082,
        -0.0101275565,
        0.010496864,
        0.030595731,
        -0.019346047,
        -0.021093158,
        0.021561895,
        -0.014601863,
        0.002904748,
        -0.035993308,
        0.0059586396,
        0.019843193,
        0.0054863514,
        -0.0115479715,
        0.053521223,
        0.01931764,
        0.006210763,
        -0.005830802,
        -0.009346329,
        0.007961424,
        0.02778331,
        -0.020695442,
        -0.039572753,
        0.005518311,
        -0.003966508,
        0.009609105,
        -0.030879814,
        0.012591976,
        0.020127276,
        0.007542402,
        0.007627627,
        -0.0067008063,
        0.007762566,
        0.0033202192,
        -0.021561895,
        -0.008259711,
        -0.011143153,
        -0.0020063356,
        -0.021703936,
        -0.014474025,
        0.022655614,
        -0.038010295,
        -0.01822392,
        0.0027875637,
        0.016050685,
        -0.008146078,
        -0.020368746,
        0.030425282,
        -0.022797655,
        0.031192306,
        -0.006839297,
        -0.0346013,
        0.011789442,
        0.023394229,
        0.008032445,
        -0.015922848,
        0.023323208,
        0.0003380143,
        -0.004492061,
        0.041078392,
        -0.020709645,
        0.010496864,
        -0.026831632,
        -0.0243175,
        -0.012989692,
        0.0049110837,
        -0.011363317,
        0.03997047,
        0.009673024,
        -0.013458429,
        0.0037996091,
        0.024189662,
        -0.020439766,
        -0.0043003056,
        -0.029715074,
        0.013877451,
        0.038720503,
        -0.0063243965,
        0.018280737,
        0.009815065,
        0.020013643,
        -0.019516498,
        0.0030894019,
        -0.0004161371,
        0.010731232,
        0.010021025,
        0.0026490733,
        -0.05505527,
        0.031021856,
        -0.0094670635,
        0.027385594,
        0.025354402,
        -0.015780807,
        0.0042967545,
        -0.0047761444,
        -0.02757025,
        0.003874181,
        0.044458978,
        -0.030737773,
        0.021320425,
        -0.007063012,
        0.029430991,
        0.0024519907,
        0.010795152,
        -0.014268065,
        -0.0046909195,
        0.028905438,
        -0.021760752,
        0.0027698085,
        0.021590304,
        0.010390333,
        -0.021107363,
        -0.012236873,
        -0.033038843,
        0.029516216,
        -0.005326555,
        -0.013280877,
        -0.008906,
        0.0029402582,
        0.00270589,
        0.0049821045,
        -0.0043287138,
        -0.03857846,
        -0.01603648,
        0.0008140752,
        -0.0034196484,
        0.00561774,
        -0.014431413,
        -0.0016982832,
        -0.056021154,
        0.0027964413,
        0.030368466,
        -0.021902794,
        -0.012996795,
        -0.00077057496,
        0.018834699,
        1.1617161e-05,
        0.011526665,
        -0.027825924,
        0.028891234,
        0.021249404,
        0.03315248,
        0.018650044,
        0.0021022137,
        0.016320564,
        -0.0088349795,
        -0.0015455887,
        -0.009254002,
        0.005908925,
        0.030510508,
        0.013479735,
        0.015525132,
        -0.010638906,
        0.024843052,
        -0.010901683,
        -0.011306501,
        -0.010042332,
        -0.020752259
      ],
      "embedding_pca_2d": [],
      "embedding_pca_3d": [],
      "embedding_cluster_id": null,
      "migration_history": [],
      "metadata": {
        "compute_time": 2.011078119277954,
        "patch_type": "full",
        "api_costs": 0.014044,
        "num_applied": 1,
        "patch_name": "precedence_beam_anneal",
        "patch_description": "Inspired by the previous greedy + local-search solutions, this program implements a different hybrid approach: a precedence-aware beam of seeded greedy constructions followed by a compact simulated-annealing-style local search (stochastic hill-climb with tabu-like memory). Key novel elements:\n\n- Beam of diverse seeds: instead of a single greedy build, the algorithm generates several promising starting solutions by seeding from high-centrality items (weights + summed interactions) and performing a constraint-aware greedy augmentation that always respects precedence closures, group and mutex constraints.\n- Succession-aware removals: when removing items we automatically remove all dependents (successor closure), keeping all intermediate states feasible with respect to precedence.\n- Lightweight simulated annealing for each beam member: randomized add/remove/swap moves that consider adding an item together with its predecessor closure and removing items together with their dependent closure. Moves are accepted if they improve the objective or with a decaying probability to escape local optima.\n- Group and mutex pruning at move time: additions or swaps are only considered if resulting sets respect group/mutex/cardinality constraints.\n- Compactness and adaptivity: number of seeds and local-search iterations scales with the problem size to remain efficient while exploring broader parts of the search space for higher-quality solutions.\n\nThis combination preserves the precedence closure logic from earlier solutions but departs from pure deterministic greedy and simple 1-for-1 swaps by adding beam diversity and stochastic exploration, which tends to find better synergy configurations when interactions are important.",
        "error_attempt": null,
        "novelty_attempt": 1,
        "resample_attempt": 1,
        "patch_attempt": 1,
        "model_name": "gpt-5-mini",
        "temperature": 1.0,
        "max_output_tokens": 8192,
        "llm_result": {
          "content": "<NAME>\nprecedence_beam_anneal\n</NAME>\n\n<DESCRIPTION>\nInspired by the previous greedy + local-search solutions, this program implements a different hybrid approach: a precedence-aware beam of seeded greedy constructions followed by a compact simulated-annealing-style local search (stochastic hill-climb with tabu-like memory). Key novel elements:\n\n- Beam of diverse seeds: instead of a single greedy build, the algorithm generates several promising starting solutions by seeding from high-centrality items (weights + summed interactions) and performing a constraint-aware greedy augmentation that always respects precedence closures, group and mutex constraints.\n- Succession-aware removals: when removing items we automatically remove all dependents (successor closure), keeping all intermediate states feasible with respect to precedence.\n- Lightweight simulated annealing for each beam member: randomized add/remove/swap moves that consider adding an item together with its predecessor closure and removing items together with their dependent closure. Moves are accepted if they improve the objective or with a decaying probability to escape local optima.\n- Group and mutex pruning at move time: additions or swaps are only considered if resulting sets respect group/mutex/cardinality constraints.\n- Compactness and adaptivity: number of seeds and local-search iterations scales with the problem size to remain efficient while exploring broader parts of the search space for higher-quality solutions.\n\nThis combination preserves the precedence closure logic from earlier solutions but departs from pure deterministic greedy and simple 1-for-1 swaps by adding beam diversity and stochastic exploration, which tends to find better synergy configurations when interactions are important.\n</DESCRIPTION>\n\n<CODE>\n```python\n#!/usr/bin/env python3\n\"\"\"\nEVOLVE-BLOCK-START\nA novel SDS solver: precedence-aware beam + simulated-annealing-style local search.\nReads JSON from stdin with \"requirements\" and \"catalog\", writes JSON to stdout:\n{\"selection\":{\"variables\":[...]}}\n\nThis block is intended to be evolved by ShinkaEvolve.\n\"\"\"\nimport sys\nimport json\nimport math\nimport random\nimport time\n\ndef solve_sds():\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    min_card, max_card = cardinality_bounds[0], cardinality_bounds[1]\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n\n    n = len(weights)\n\n    # Robust interaction parsing: handle \"i,j\" -> value or nested dicts\n    interaction_map = {}\n    # first try string keys like \"i,j\" or tuple-like\n    if isinstance(interactions, dict):\n        for k, v in interactions.items():\n            if isinstance(k, str):\n                if \",\" in k:\n                    try:\n                        a_s, b_s = k.split(\",\")\n                        a, b = int(a_s), int(b_s)\n                        if a > b:\n                            a, b = b, a\n                        interaction_map[(a, b)] = float(v)\n                    except Exception:\n                        continue\n                else:\n                    # maybe nested mapping case handled later\n                    continue\n            elif isinstance(k, (list, tuple)) and len(k) == 2:\n                try:\n                    a, b = int(k[0]), int(k[1])\n                    if a > b:\n                        a, b = b, a\n                    interaction_map[(a, b)] = float(v)\n                except Exception:\n                    continue\n    # try nested dict form interactions[i][j] = val\n    if not interaction_map and isinstance(interactions, dict):\n        try:\n            for ik, row in interactions.items():\n                ii = int(ik)\n                if isinstance(row, dict):\n                    for jk, vv in row.items():\n                        jj = int(jk)\n                        a, b = (ii, jj) if ii <= jj else (jj, ii)\n                        interaction_map[(a, b)] = float(vv)\n        except Exception:\n            pass\n\n    def get_interaction(i, j):\n        if i > j:\n            i, j = j, i\n        return interaction_map.get((i, j), 0.0)\n\n    # Precedence maps\n    preds = {i: set() for i in range(n)}\n    succs = {i: set() for i in range(n)}\n    for p in precedence:\n        try:\n            a = int(p[0]); b = int(p[1])\n            # if b selected then a must be selected => a is predecessor of b\n            preds[b].add(a)\n            succs[a].add(b)\n        except Exception:\n            continue\n\n    # Compute transitive predecessor closure and successor closure\n    pred_closure = {}\n    for i in range(n):\n        seen = set()\n        stack = list(preds.get(i, []))\n        while stack:\n            x = stack.pop()\n            if x in seen:\n                continue\n            seen.add(x)\n            for y in preds.get(x, ()):\n                if y not in seen:\n                    stack.append(y)\n        pred_closure[i] = seen\n\n    succ_closure = {}\n    for i in range(n):\n        seen = set()\n        stack = list(succs.get(i, []))\n        while stack:\n            x = stack.pop()\n            if x in seen:\n                continue\n            seen.add(x)\n            for y in succs.get(x, ()):\n                if y not in seen:\n                    stack.append(y)\n        succ_closure[i] = seen\n\n    # Precompute group and mutex quick checks\n    # groups: dict name -> list of vars\n    var_to_group = {}\n    for gname, vars_list in groups.items():\n        for v in vars_list:\n            var_to_group[v] = gname\n\n    mutex_pairs = set()\n    mutex_map = {i: set() for i in range(n)}\n    for a, b in mutex:\n        mutex_pairs.add((a, b))\n        mutex_pairs.add((b, a))\n        if 0 <= a < n and 0 <= b < n:\n            mutex_map[a].add(b)\n            mutex_map[b].add(a)\n\n    # Quick feasibility check\n    def is_feasible_set(S):\n        if len(S) > max_card or len(S) < 0:\n            return False\n        # precedence: all preds must be included\n        for j in S:\n            for p in preds.get(j, ()):\n                if p not in S:\n                    return False\n        # mutex\n        for a in S:\n            for b in mutex_map.get(a, ()):\n                if b in S:\n                    return False\n        # groups\n        seen_groups = {}\n        for v in S:\n            g = var_to_group.get(v)\n            if g is not None:\n                if g in seen_groups:\n                    return False\n                seen_groups[g] = v\n        return True\n\n    # Objective computation optimized: sum weights + sum interactions for pairs (i<j)\n    # We'll maintain an interactions adjacency list for non-zero interactions\n    neighbors = {i: {} for i in range(n)}\n    for (a, b), val in interaction_map.items():\n        if 0 <= a < n and 0 <= b < n:\n            neighbors[a][b] = val\n            neighbors[b][a] = val\n\n    def objective(S):\n        total = 0.0\n        for i in S:\n            if 0 <= i < n:\n                total += weights[i]\n        # pairwise interactions\n        # sum over each i neighbors j>i in S\n        Sset = set(S)\n        for i in Sset:\n            for j, val in neighbors[i].items():\n                if j in Sset and j > i:\n                    total += val\n        return total\n\n    # Marginal gain for adding a set A to S (A disjoint or overlap handled)\n    def marginal_gain(S, A):\n        Sset = set(S)\n        Aset = set(A) - Sset\n        if not Aset:\n            return 0.0\n        gain = 0.0\n        for i in Aset:\n            if 0 <= i < n:\n                gain += weights[i]\n        # interactions between A and S\n        for i in Aset:\n            for j, val in neighbors[i].items():\n                if j in Sset:\n                    gain += val\n        # interactions internal to A\n        Alist = list(Aset)\n        for ui in range(len(Alist)):\n            ii = Alist[ui]\n            for uj in range(ui + 1, len(Alist)):\n                jj = Alist[uj]\n                gain += neighbors[ii].get(jj, 0.0)\n        return gain\n\n    # closure_for: when adding i, include its predecessors (transitive)\n    def closure_for_add(i, current_set):\n        res = set([i])\n        for p in pred_closure.get(i, set()):\n            res.add(p)\n        # exclude already present\n        return res - set(current_set)\n\n    # closure_for_remove: when removing i, need to remove all successors that depend on it (transitive)\n    def closure_for_remove(i):\n        res = set([i])\n        for s in succ_closure.get(i, set()):\n            res.add(s)\n        return res\n\n    # centrality heuristic: base for seeding\n    centrality = []\n    for i in range(n):\n        s = weights[i] if 0 <= i < n else 0.0\n        # sum of positive interactions\n        pos_sum = 0.0\n        for j, val in neighbors[i].items():\n            if val > 0:\n                pos_sum += val\n            else:\n                pos_sum += 0.1 * val  # small weight for negative links\n        s += pos_sum\n        centrality.append((s, i))\n    centrality.sort(reverse=True)\n\n    # Beam parameters scaled with n\n    beam_width = max(5, min(40, n // 3 + 1))\n    seeds_to_try = beam_width\n    seed_indices = [i for _, i in centrality[:seeds_to_try]]\n\n    # If too few seeds (small n), consider random seeds for diversity\n    if len(seed_indices) < beam_width:\n        others = [i for i in range(n) if i not in seed_indices]\n        random.shuffle(others)\n        seed_indices += others[:beam_width - len(seed_indices)]\n\n    # Greedy augment function (respect closures, groups, mutex)\n    def greedy_augment(initial_set):\n        S = set(initial_set)\n        # If initial violates precedence, fix by adding needed preds\n        changed = True\n        while changed:\n            changed = False\n            for j in list(S):\n                for p in preds.get(j, ()):\n                    if p not in S:\n                        S.add(p)\n                        changed = True\n        # Greedily add items with best positive marginal gain\n        while len(S) < max_card:\n            best_gain = -1e18\n            best_add = None\n            for i in range(n):\n                if i in S:\n                    continue\n                add_set = closure_for_add(i, S)\n                if not add_set:\n                    continue\n                if len(S) + len(add_set) > max_card:\n                    continue\n                # check group/mutex feasibility quickly\n                violated = False\n                # group conflict\n                existing_groups = set(var_to_group.get(v) for v in S if var_to_group.get(v) is not None)\n                for v in add_set:\n                    g = var_to_group.get(v)\n                    if g is not None and g in existing_groups:\n                        violated = True\n                        break\n                if violated:\n                    continue\n                # mutex: any v in add_set conflicting with S?\n                for v in add_set:\n                    for m in mutex_map.get(v, ()):\n                        if m in S:\n                            violated = True\n                            break\n                    if violated:\n                        break\n                if violated:\n                    continue\n                gain = marginal_gain(S, add_set)\n                # prefer positive gains; otherwise small positive if need to reach min_card\n                if gain > best_gain:\n                    best_gain = gain\n                    best_add = add_set\n            if best_add is None or (best_gain <= 1e-12 and len(S) >= min_card):\n                break\n            S |= set(best_add)\n        # If below min_card, force add highest marginal items (even negative if necessary)\n        if len(S) < min_card:\n            # consider all candidates sorted by marginal gain\n            cand_list = []\n            for i in range(n):\n                if i in S:\n                    continue\n                add_set = closure_for_add(i, S)\n                if not add_set:\n                    continue\n                if len(S) + len(add_set) > max_card:\n                    continue\n                # skip if group/mutex violate\n                violated = False\n                existing_groups = set(var_to_group.get(v) for v in S if var_to_group.get(v) is not None)\n                for v in add_set:\n                    g = var_to_group.get(v)\n                    if g is not None and g in existing_groups:\n                        violated = True\n                        break\n                    for m in mutex_map.get(v, ()):\n                        if m in S:\n                            violated = True\n                            break\n                    if violated:\n                        break\n                if violated:\n                    continue\n                cand_list.append((marginal_gain(S, add_set), add_set))\n            cand_list.sort(reverse=True, key=lambda x: x[0])\n            for gain, add_set in cand_list:\n                if len(S) >= min_card:\n                    break\n                if len(S) + len(add_set) > max_card:\n                    continue\n                S |= set(add_set)\n        # final feasibility guard\n        if not is_feasible_set(S):\n            # fallback: simple weight-based fill respecting closures\n            S = set()\n            for i in sorted(range(n), key=lambda x: weights[x], reverse=True):\n                add_set = closure_for_add(i, S)\n                if len(S) + len(add_set) > max_card:\n                    continue\n                if not is_feasible_set(S | set(add_set)):\n                    continue\n                S |= set(add_set)\n                if len(S) >= max_card:\n                    break\n        return S\n\n    # Build initial beam of solutions\n    beam = []\n    tried_seeds = set()\n    for sidx in seed_indices:\n        if sidx in tried_seeds:\n            continue\n        tried_seeds.add(sidx)\n        init = closure_for_add(sidx, set())\n        # if too large, skip seed\n        if len(init) > max_card:\n            continue\n        sol = greedy_augment(init)\n        beam.append(sol)\n    # If beam too small, add some empties and singletons\n    if not beam:\n        beam.append(set())\n    # ensure beam unique\n    uniq = []\n    seen = set()\n    for sol in beam:\n        key = tuple(sorted(sol))\n        if key not in seen:\n            uniq.append(sol)\n            seen.add(key)\n    beam = uniq[:beam_width]\n\n    # Local search with simulated annealing for each beam member\n    best_sol = None\n    best_score = -1e99\n\n    # Tune iterations by problem size\n    base_iters = 300\n    iter_scale = max(1, n // 10)\n    max_iters_per_seed = min(2000, base_iters * iter_scale)\n\n    rng = random.Random()\n    # deterministic-ish seed based on weights to be reproducible across runs\n    rng.seed(int(sum(weights) * 1000) if weights else 12345)\n\n    start_time = time.time()\n    time_limit = 1.8  # try to keep runtime modest; evaluator may limit\n    for sol in beam:\n        S = set(sol)\n        S = greedy_augment(S)  # tighten\n        cur_score = objective(S)\n        if cur_score > best_score:\n            best_score = cur_score\n            best_sol = set(S)\n        # SA parameters\n        T0 = max(1.0, abs(cur_score) * 0.1 + 1.0)\n        Tmin = 1e-3\n        iters = 0\n        last_improve = 0\n        while iters < max_iters_per_seed:\n            iters += 1\n            # time cut\n            if time.time() - start_time > time_limit:\n                break\n            # temperature schedule\n            frac = iters / float(max_iters_per_seed + 1)\n            temp = T0 * (1.0 - frac) + Tmin * frac\n            op = rng.choice(['add', 'remove', 'swap'])\n            accepted = False\n            if op == 'add':\n                # pick candidate item not in S that might improve\n                candidates = list(set(range(n)) - S)\n                rng.shuffle(candidates)\n                for cand in candidates[:min(50, len(candidates))]:\n                    add_set = closure_for_add(cand, S)\n                    if not add_set:\n                        continue\n                    if len(S) + len(add_set) > max_card:\n                        continue\n                    # group/mutex check\n                    violated = False\n                    existing_groups = set(var_to_group.get(v) for v in S if var_to_group.get(v) is not None)\n                    for v in add_set:\n                        g = var_to_group.get(v)\n                        if g is not None and g in existing_groups:\n                            violated = True\n                            break\n                        for m in mutex_map.get(v, ()):\n                            if m in S:\n                                violated = True\n                                break\n                        if violated:\n                            break\n                    if violated:\n                        continue\n                    newS = set(S) | set(add_set)\n                    # ensure not violating precedence (add_set includes preds)\n                    if not is_feasible_set(newS):\n                        continue\n                    new_score = objective(newS)\n                    delta = new_score - cur_score\n                    if delta > 1e-12 or math.exp(min(50.0, delta / max(1e-9, temp))) > rng.random():\n                        S = newS\n                        cur_score = new_score\n                        accepted = True\n                        last_improve = iters\n                        break\n            elif op == 'remove':\n                if len(S) == 0:\n                    continue\n                removes = list(S)\n                rng.shuffle(removes)\n                for rem in removes[:min(50, len(removes))]:\n                    rem_set = closure_for_remove(rem)\n                    newS = set(S) - rem_set\n                    # enforce min_card or allow temporary below with small prob\n                    if len(newS) < min_card:\n                        # permit removal with low probability if helps and temperature high\n                        pass_prob = math.exp(- (min_card - len(newS)) / (1.0 + temp))\n                        if rng.random() > pass_prob:\n                            continue\n                    if not is_feasible_set(newS):\n                        continue\n                    new_score = objective(newS)\n                    delta = new_score - cur_score\n                    if delta > 1e-12 or math.exp(min(50.0, delta / max(1e-9, temp))) > rng.random():\n                        S = newS\n                        cur_score = new_score\n                        accepted = True\n                        last_improve = iters\n                        break\n            else:  # swap: remove some dependent cluster and add some other closure\n                if len(S) == 0:\n                    continue\n                rem = rng.choice(list(S))\n                rem_set = closure_for_remove(rem)\n                base = set(S) - rem_set\n                # consider candidates to add given base\n                candidates = list(set(range(n)) - base)\n                rng.shuffle(candidates)\n                for cand in candidates[:min(80, len(candidates))]:\n                    add_set = closure_for_add(cand, base)\n                    if not add_set:\n                        continue\n                    if len(base) + len(add_set) > max_card:\n                        continue\n                    # group/mutex check\n                    violated = False\n                    existing_groups = set(var_to_group.get(v) for v in base if var_to_group.get(v) is not None)\n                    for v in add_set:\n                        g = var_to_group.get(v)\n                        if g is not None and g in existing_groups:\n                            violated = True\n                            break\n                        for m in mutex_map.get(v, ()):\n                            if m in base:\n                                violated = True\n                                break\n                        if violated:\n                            break\n                    if violated:\n                        continue\n                    newS = set(base) | set(add_set)\n                    if len(newS) < min_card:\n                        continue\n                    if not is_feasible_set(newS):\n                        continue\n                    new_score = objective(newS)\n                    delta = new_score - cur_score\n                    if delta > 1e-12 or math.exp(min(50.0, delta / max(1e-9, temp))) > rng.random():\n                        S = newS\n                        cur_score = new_score\n                        accepted = True\n                        last_improve = iters\n                        break\n            # record best\n            if cur_score > best_score + 1e-12:\n                best_score = cur_score\n                best_sol = set(S)\n            # small early stop if no improvement for long\n            if iters - last_improve > 400 and iters > 800:\n                break\n        # time limit guard\n        if time.time() - start_time > time_limit:\n            break\n\n    # Final repair and ensure feasibility and cardinality\n    if best_sol is None:\n        best_sol = set()\n    S = set(best_sol)\n    # Ensure precedence closure included\n    changed = True\n    while changed:\n        changed = False\n        for j in list(S):\n            for p in preds.get(j, ()):\n                if p not in S:\n                    S.add(p)\n                    changed = True\n    # If too large, try removing low marginal contributors while respecting precedence\n    if len(S) > max_card:\n        # rank items by marginal contribution (with respect to S)\n        def marginal_contrib(i, curS):\n            # contribution approximated as weight + sum interactions with curS - interactions lost from removal\n            contrib = weights[i]\n            for j, val in neighbors[i].items():\n                if j in curS and j != i:\n                    contrib += val\n            return contrib\n        # try removing items with smallest contrib but ensure we also remove dependents\n        items = sorted(list(S), key=lambda x: marginal_contrib(x, S))\n        for itv in items:\n            if len(S) <= max_card:\n                break\n            # can't remove if it has predecessors that would remain invalid (we'll remove dependents)\n            rem_cluster = closure_for_remove(itv)\n            # ensure we don't violate min_card after removal\n            if len(S) - len(rem_cluster) < min_card:\n                continue\n            S -= rem_cluster\n        # final safety: if still too large, keep top by contrib\n        if len(S) > max_card:\n            items = sorted(list(S), key=lambda x: marginal_contrib(x, S), reverse=True)\n            S = set(items[:max_card])\n\n    # If too small, fill greedily\n    if len(S) < min_card:\n        # add best marginal additions\n        while len(S) < min_card:\n            best_gain = -1e99\n            best_add = None\n            for i in range(n):\n                if i in S:\n                    continue\n                add_set = closure_for_add(i, S)\n                if not add_set:\n                    continue\n                if len(S) + len(add_set) > max_card:\n                    continue\n                # group/mutex check\n                violated = False\n                existing_groups = set(var_to_group.get(v) for v in S if var_to_group.get(v) is not None)\n                for v in add_set:\n                    g = var_to_group.get(v)\n                    if g is not None and g in existing_groups:\n                        violated = True\n                        break\n                    for m in mutex_map.get(v, ()):\n                        if m in S:\n                            violated = True\n                            break\n                    if violated:\n                        break\n                if violated:\n                    continue\n                gain = marginal_gain(S, add_set)\n                if gain > best_gain:\n                    best_gain = gain\n                    best_add = add_set\n            if best_add is None:\n                break\n            S |= set(best_add)\n\n    # Final enforced feasibility (last resort simple greedy)\n    if not is_feasible_set(S):\n        S = set()\n        for i in sorted(range(n), key=lambda x: weights[x], reverse=True):\n            add_set = closure_for_add(i, S)\n            if len(S) + len(add_set) > max_card:\n                continue\n            if not is_feasible_set(S | set(add_set)):\n                continue\n            S |= set(add_set)\n            if len(S) >= max_card:\n                break\n        i = 0\n        while len(S) < min_card and i < n:\n            if i not in S:\n                add_set = closure_for_add(i, S)\n                if len(S) + len(add_set) <= max_card and is_feasible_set(S | set(add_set)):\n                    S |= set(add_set)\n            i += 1\n\n    result = {\"selection\": {\"variables\": sorted(list(S))}}\n    print(json.dumps(result))\n\n# EVOLVE-BLOCK-END\n\nif __name__ == \"__main__\":\n    solve_sds()\n```\n</CODE>",
          "msg": "Here are the performance metrics of a set of prioviously implemented programs:\n\n# Prior programs\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    This is a greedy baseline - evolution will improve this.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    # Simple greedy: select items with highest weights first\n    # This is a baseline - evolution will find better strategies\n    n = len(weights)\n    selected = []\n    \n    # Create score list (weight + interaction potential)\n    scores = []\n    for i in range(n):\n        score = weights[i] if i < len(weights) else 0.0\n        # Add potential interaction value\n        for k, v in interactions.items():\n            try:\n                u, w = map(int, k.split(\",\"))\n                if u == i or w == i:\n                    score += abs(v) * 0.5  # Potential value\n            except:\n                pass\n        scores.append((score, i))\n    \n    # Sort by score descending\n    scores.sort(reverse=True)\n    \n    # Greedy selection respecting constraints\n    selected_set = set()\n    for score, i in scores:\n        if len(selected_set) >= cardinality_bounds[1]:\n            break\n            \n        # Check mutex constraints\n        can_add = True\n        for a, b in mutex:\n            if (a == i and b in selected_set) or (b == i and a in selected_set):\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n            \n        # Check group constraints (at most one per group)\n        for grp_vars in groups.values():\n            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n        \n        # Check precedence (if j selected, i must be selected)\n        precedence_ok = True\n        for pred_i, pred_j in precedence:\n            if pred_j == i and pred_i not in selected_set:\n                precedence_ok = False\n                break\n        \n        if not precedence_ok:\n            continue\n        \n        # Add if we meet minimum cardinality or have room\n        if len(selected_set) < cardinality_bounds[1]:\n            selected_set.add(i)\n            selected.append(i)\n    \n    # Ensure minimum cardinality\n    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n        for i in range(n):\n            if i not in selected_set:\n                selected_set.add(i)\n                selected.append(i)\n                break\n    \n    # Output result\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n    \n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n    \n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n    \n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n    \n    result_str = stdout_capture.getvalue()\n    return result_str\n\n\n```\n\nPerformance metrics:\nCombined score to maximize: 0.35\nfeasible: True; selection_size: 10; raw_score: 106.51\n\n\n# Current program\n\nHere is the current program we are trying to improve (you will need to \npropose a new program with the same inputs and outputs as the original \nprogram, but with improved internal implementation):\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n\n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n\n    Improved greedy + local search:\n    - Evaluate true marginal gains including interactions.\n    - Respect precedence by adding predecessor closures when needed.\n    - Enforce mutex and group constraints when considering additions.\n    - Perform simple 1-for-1 local-search swaps to improve objective.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n\n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    min_card, max_card = cardinality_bounds[0], cardinality_bounds[1]\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n\n    n = len(weights)\n\n    # Build interaction lookup function supporting both \"i,j\" keys and nested dicts\n    interaction_map = {}\n    # If interactions given as dict with string keys like \"i,j\"\n    for k, v in interactions.items():\n        if isinstance(k, str):\n            try:\n                i_s, j_s = k.split(\",\")\n                i, j = int(i_s), int(j_s)\n                if i > j:\n                    i, j = j, i\n                interaction_map[(i, j)] = float(v)\n            except Exception:\n                # fallback: ignore malformed keys\n                pass\n        elif isinstance(k, (list, tuple)) and len(k) == 2:\n            try:\n                i, j = int(k[0]), int(k[1])\n                if i > j:\n                    i, j = j, i\n                interaction_map[(i, j)] = float(v)\n            except Exception:\n                pass\n        else:\n            # maybe nested mapping interactions[i][j]\n            try:\n                # will handle below\n                pass\n            except Exception:\n                pass\n    # handle nested dict case: interactions may be like {i: {j: val}}\n    if not interaction_map:\n        try:\n            for i_key, row in interactions.items():\n                ii = int(i_key)\n                for j_key, v in row.items():\n                    jj = int(j_key)\n                    a, b = (ii, jj) if ii <= jj else (jj, ii)\n                    interaction_map[(a, b)] = float(v)\n        except Exception:\n            # If parsing fails, leave interaction_map empty\n            pass\n\n    def get_interaction(i, j):\n        a, b = (i, j) if i <= j else (j, i)\n        return interaction_map.get((a, b), 0.0)\n\n    # Build predecessor map for precedence constraints\n    preds = {i: set() for i in range(n)}\n    for p in precedence:\n        try:\n            pi, pj = int(p[0]), int(p[1])\n            # if pj selected then pi must be selected\n            preds[pj].add(pi)\n        except Exception:\n            pass\n    # compute transitive closure of predecessors for each node\n    pred_closure = {}\n    for i in range(n):\n        stack = list(preds.get(i, []))\n        closure = set()\n        while stack:\n            x = stack.pop()\n            if x in closure:\n                continue\n            closure.add(x)\n            for pp in preds.get(x, []):\n                if pp not in closure:\n                    stack.append(pp)\n        pred_closure[i] = closure\n\n    # Helper: check feasibility of a full candidate set S (set of indices)\n    def is_feasible_set(S):\n        # cardinality\n        if len(S) > max_card or len(S) < 0:\n            return False\n        # mutex: no pair both present\n        for a, b in mutex:\n            if a in S and b in S:\n                return False\n        # groups: at most one per group\n        for grp_vars in groups.values():\n            if len(set(grp_vars).intersection(S)) > 1:\n                return False\n        # precedence: for every j in S, all its preds must be in S\n        for j in list(S):\n            if not pred_closure.get(j):\n                # OK\n                pass\n            # direct preds\n            for pi in preds.get(j, set()):\n                if pi not in S:\n                    return False\n        return True\n\n    # Objective calculation\n    def objective(S):\n        S_list = list(S)\n        total = 0.0\n        for i in S_list:\n            total += weights[i] if i < len(weights) else 0.0\n        # pairwise interactions (count each pair once)\n        for idx in range(len(S_list)):\n            for jdx in range(idx+1, len(S_list)):\n                total += get_interaction(S_list[idx], S_list[jdx])\n        return total\n\n    # Function to compute marginal gain of adding set A (iterable) to current set S\n    def marginal_gain(S, A):\n        A = set(A) - set(S)\n        if not A:\n            return 0.0\n        gain = 0.0\n        for i in A:\n            gain += weights[i] if i < len(weights) else 0.0\n        # interactions between A and S\n        for i in A:\n            for j in S:\n                gain += get_interaction(i, j)\n        # interactions internal to A\n        A_list = list(A)\n        for ii in range(len(A_list)):\n            for jj in range(ii+1, len(A_list)):\n                gain += get_interaction(A_list[ii], A_list[jj])\n        return gain\n\n    # Helper: when trying to add item i, compute required closure (predecessors)\n    def closure_for(i, current_set):\n        # items that must be present if we include i: i plus all transitive predecessors\n        C = set([i])\n        for p in pred_closure.get(i, set()):\n            C.add(p)\n        # Some predecessors may themselves have predecessors already included by pred_closure\n        # pred_closure already transitive, so this suffices.\n        # Remove those already in current_set\n        return C - set(current_set)\n\n    # Main greedy: iteratively add the candidate (plus its preds) with best marginal gain\n    selected_set = set()\n    # We'll allow adding until no improvement or until max_card reached.\n    while len(selected_set) < max_card:\n        best_gain = None\n        best_add = None\n        # evaluate every candidate not in selected_set\n        for i in range(n):\n            if i in selected_set:\n                continue\n            # compute closure needed\n            add_set = closure_for(i, selected_set)\n            # if adding would exceed max_card, skip\n            if len(selected_set) + len(add_set) > max_card:\n                continue\n            # Check feasibility when adding\n            new_set = set(selected_set) | set(add_set)\n            if not is_feasible_set(new_set):\n                continue\n            gain = marginal_gain(selected_set, add_set)\n            if best_gain is None or gain > best_gain:\n                best_gain = gain\n                best_add = add_set\n        # Stop if nothing feasible to add\n        if best_add is None:\n            break\n        # If best_gain is negative and we've already reached min_card, stop adding further\n        if best_gain is not None and best_gain < 0 and len(selected_set) >= min_card:\n            break\n        # Otherwise add the best_add\n        selected_set |= set(best_add)\n\n    # If we haven't reached minimum cardinality, force-add best remaining items (respecting constraints)\n    if len(selected_set) < min_card:\n        # consider candidates by marginal gain ignoring negative cutoff\n        candidates = [i for i in range(n) if i not in selected_set]\n        # sort by simple heuristic gain (weight + sum positive interactions)\n        def heuristic_gain(i):\n            g = weights[i] if i < len(weights) else 0.0\n            for j in range(n):\n                if j == i:\n                    continue\n                g += abs(get_interaction(i, j)) * 0.2\n            return g\n        candidates.sort(key=heuristic_gain, reverse=True)\n        for i in candidates:\n            if len(selected_set) >= min_card:\n                break\n            add_set = closure_for(i, selected_set)\n            if len(selected_set) + len(add_set) > max_card:\n                continue\n            new_set = set(selected_set) | set(add_set)\n            if not is_feasible_set(new_set):\n                continue\n            selected_set |= set(add_set)\n\n    # Local search: try single-item swaps to improve objective (remove one, add one or add closure)\n    improved = True\n    max_iters = 500\n    it = 0\n    current_obj = objective(selected_set)\n    # Precompute all items list\n    all_items = set(range(n))\n    while improved and it < max_iters:\n        improved = False\n        it += 1\n        # iterate possible removals and additions\n        removed_item = None\n        added_items = None\n        best_obj = current_obj\n        for rem in list(selected_set):\n            # Try remove rem and try to add any outside item (with its closure w.r.t resulting set)\n            base_set = set(selected_set)\n            base_set.remove(rem)\n            # Ensure base_set is still feasible (removing may break precedence if rem was a predecessor of others)\n            if not is_feasible_set(base_set):\n                # Can't remove this item unless we also remove dependents; skip for simplicity\n                continue\n            for add in (all_items - base_set):\n                if add in base_set:\n                    continue\n                add_closure = closure_for(add, base_set)\n                candidate_set = set(base_set) | set(add_closure)\n                # respect cardinality\n                if len(candidate_set) < min_card or len(candidate_set) > max_card:\n                    continue\n                if not is_feasible_set(candidate_set):\n                    continue\n                obj = objective(candidate_set)\n                if obj > best_obj + 1e-9:\n                    best_obj = obj\n                    removed_item = rem\n                    added_items = set(add_closure)\n        if best_obj > current_obj + 1e-9 and removed_item is not None:\n            # apply improvement\n            selected_set.remove(removed_item)\n            selected_set |= set(added_items)\n            current_obj = best_obj\n            improved = True\n\n    # Final safety: ensure feasibility (if not, fall back to greedy selection by weight)\n    if not is_feasible_set(selected_set):\n        selected_set = set()\n        for i in sorted(range(n), key=lambda x: weights[x], reverse=True):\n            if len(selected_set) >= max_card:\n                break\n            add_set = closure_for(i, selected_set)\n            if len(selected_set) + len(add_set) > max_card:\n                continue\n            new_set = set(selected_set) | set(add_set)\n            if not is_feasible_set(new_set):\n                continue\n            selected_set |= set(add_set)\n        # fill up if still below min_card\n        i = 0\n        while len(selected_set) < min_card and i < n:\n            if i not in selected_set:\n                add_set = closure_for(i, selected_set)\n                if len(selected_set) + len(add_set) <= max_card:\n                    new_set = set(selected_set) | set(add_set)\n                    if is_feasible_set(new_set):\n                        selected_set |= set(add_set)\n            i += 1\n\n    result = {\n        \"selection\": {\n            \"variables\": sorted(list(selected_set))\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n\n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n\n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n\n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n\n    result_str = stdout_capture.getvalue()\n    return result_str\n\n```\n\nHere are the performance metrics of the program:\n\nCombined score to maximize: 0.43\nfeasible: True; selection_size: 10; raw_score: 132.16\n\n# Task\n\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs as the original program, but with improved internal implementation.\n",
          "system_msg": "You are an expert algorithmist specializing in combinatorial optimization, particularly the Synergistic Dependency Selection (SDS) problem.\n\nThe SDS problem requires selecting a subset of variables that:\n1. Satisfies cardinality bounds (min/max number of items)\n2. Respects mutex constraints (cannot select both items in a mutex pair)\n3. Respects group constraints (at most one item per group)\n4. Satisfies precedence constraints (if j is selected, i must be selected)\n5. Maximizes the objective: sum of selected item weights + pairwise interaction values\n\nKey strategies to explore:\n1. Greedy selection with constraint-aware ordering\n2. Dynamic programming for small instances\n3. Constraint satisfaction with backtracking\n4. Weighted scoring that accounts for interactions\n5. Precedence-aware selection ordering\n6. Group-aware selection that maximizes diversity\n\nThe code should read JSON from stdin with \"requirements\" and \"catalog\", and output JSON to stdout with \"selection\" containing \"variables\" list.\n\nBe creative and find efficient solutions that maximize the objective while respecting all constraints.\nCreate a novel algorithm that draws inspiration from the provided context programs but implements a fundamentally different approach.\nStudy the patterns and techniques from the examples, then design something new.\nYou MUST respond using a short summary name, description and the full code:\n\n<NAME>\nA shortened name summarizing the code you are proposing. Lowercase, no spaces, underscores allowed.\n</NAME>\n\n<DESCRIPTION>\nExplain how you drew inspiration from the context programs and what novel approach you are implementing. Detail the key insights that led to this design.\n</DESCRIPTION>\n\n<CODE>\n```{language}\n# The inspired but novel algorithm implementation here.\n```\n</CODE>\n\n* Keep the markers \"EVOLVE-BLOCK-START\" and \"EVOLVE-BLOCK-END\" in the code.\n* Learn from the context programs but don't copy their approaches directly.\n* Combine ideas in novel ways or apply insights to different algorithmic paradigms.\n* Maintain the same inputs and outputs as the original program.\n* Use the <NAME>, <DESCRIPTION>, and <CODE> delimiters to structure your response. It will be parsed afterwards.",
          "new_msg_history": [
            {
              "role": "user",
              "content": "Here are the performance metrics of a set of prioviously implemented programs:\n\n# Prior programs\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    This is a greedy baseline - evolution will improve this.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    # Simple greedy: select items with highest weights first\n    # This is a baseline - evolution will find better strategies\n    n = len(weights)\n    selected = []\n    \n    # Create score list (weight + interaction potential)\n    scores = []\n    for i in range(n):\n        score = weights[i] if i < len(weights) else 0.0\n        # Add potential interaction value\n        for k, v in interactions.items():\n            try:\n                u, w = map(int, k.split(\",\"))\n                if u == i or w == i:\n                    score += abs(v) * 0.5  # Potential value\n            except:\n                pass\n        scores.append((score, i))\n    \n    # Sort by score descending\n    scores.sort(reverse=True)\n    \n    # Greedy selection respecting constraints\n    selected_set = set()\n    for score, i in scores:\n        if len(selected_set) >= cardinality_bounds[1]:\n            break\n            \n        # Check mutex constraints\n        can_add = True\n        for a, b in mutex:\n            if (a == i and b in selected_set) or (b == i and a in selected_set):\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n            \n        # Check group constraints (at most one per group)\n        for grp_vars in groups.values():\n            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n        \n        # Check precedence (if j selected, i must be selected)\n        precedence_ok = True\n        for pred_i, pred_j in precedence:\n            if pred_j == i and pred_i not in selected_set:\n                precedence_ok = False\n                break\n        \n        if not precedence_ok:\n            continue\n        \n        # Add if we meet minimum cardinality or have room\n        if len(selected_set) < cardinality_bounds[1]:\n            selected_set.add(i)\n            selected.append(i)\n    \n    # Ensure minimum cardinality\n    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n        for i in range(n):\n            if i not in selected_set:\n                selected_set.add(i)\n                selected.append(i)\n                break\n    \n    # Output result\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n    \n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n    \n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n    \n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n    \n    result_str = stdout_capture.getvalue()\n    return result_str\n\n\n```\n\nPerformance metrics:\nCombined score to maximize: 0.35\nfeasible: True; selection_size: 10; raw_score: 106.51\n\n\n# Current program\n\nHere is the current program we are trying to improve (you will need to \npropose a new program with the same inputs and outputs as the original \nprogram, but with improved internal implementation):\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n\n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n\n    Improved greedy + local search:\n    - Evaluate true marginal gains including interactions.\n    - Respect precedence by adding predecessor closures when needed.\n    - Enforce mutex and group constraints when considering additions.\n    - Perform simple 1-for-1 local-search swaps to improve objective.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n\n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    min_card, max_card = cardinality_bounds[0], cardinality_bounds[1]\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n\n    n = len(weights)\n\n    # Build interaction lookup function supporting both \"i,j\" keys and nested dicts\n    interaction_map = {}\n    # If interactions given as dict with string keys like \"i,j\"\n    for k, v in interactions.items():\n        if isinstance(k, str):\n            try:\n                i_s, j_s = k.split(\",\")\n                i, j = int(i_s), int(j_s)\n                if i > j:\n                    i, j = j, i\n                interaction_map[(i, j)] = float(v)\n            except Exception:\n                # fallback: ignore malformed keys\n                pass\n        elif isinstance(k, (list, tuple)) and len(k) == 2:\n            try:\n                i, j = int(k[0]), int(k[1])\n                if i > j:\n                    i, j = j, i\n                interaction_map[(i, j)] = float(v)\n            except Exception:\n                pass\n        else:\n            # maybe nested mapping interactions[i][j]\n            try:\n                # will handle below\n                pass\n            except Exception:\n                pass\n    # handle nested dict case: interactions may be like {i: {j: val}}\n    if not interaction_map:\n        try:\n            for i_key, row in interactions.items():\n                ii = int(i_key)\n                for j_key, v in row.items():\n                    jj = int(j_key)\n                    a, b = (ii, jj) if ii <= jj else (jj, ii)\n                    interaction_map[(a, b)] = float(v)\n        except Exception:\n            # If parsing fails, leave interaction_map empty\n            pass\n\n    def get_interaction(i, j):\n        a, b = (i, j) if i <= j else (j, i)\n        return interaction_map.get((a, b), 0.0)\n\n    # Build predecessor map for precedence constraints\n    preds = {i: set() for i in range(n)}\n    for p in precedence:\n        try:\n            pi, pj = int(p[0]), int(p[1])\n            # if pj selected then pi must be selected\n            preds[pj].add(pi)\n        except Exception:\n            pass\n    # compute transitive closure of predecessors for each node\n    pred_closure = {}\n    for i in range(n):\n        stack = list(preds.get(i, []))\n        closure = set()\n        while stack:\n            x = stack.pop()\n            if x in closure:\n                continue\n            closure.add(x)\n            for pp in preds.get(x, []):\n                if pp not in closure:\n                    stack.append(pp)\n        pred_closure[i] = closure\n\n    # Helper: check feasibility of a full candidate set S (set of indices)\n    def is_feasible_set(S):\n        # cardinality\n        if len(S) > max_card or len(S) < 0:\n            return False\n        # mutex: no pair both present\n        for a, b in mutex:\n            if a in S and b in S:\n                return False\n        # groups: at most one per group\n        for grp_vars in groups.values():\n            if len(set(grp_vars).intersection(S)) > 1:\n                return False\n        # precedence: for every j in S, all its preds must be in S\n        for j in list(S):\n            if not pred_closure.get(j):\n                # OK\n                pass\n            # direct preds\n            for pi in preds.get(j, set()):\n                if pi not in S:\n                    return False\n        return True\n\n    # Objective calculation\n    def objective(S):\n        S_list = list(S)\n        total = 0.0\n        for i in S_list:\n            total += weights[i] if i < len(weights) else 0.0\n        # pairwise interactions (count each pair once)\n        for idx in range(len(S_list)):\n            for jdx in range(idx+1, len(S_list)):\n                total += get_interaction(S_list[idx], S_list[jdx])\n        return total\n\n    # Function to compute marginal gain of adding set A (iterable) to current set S\n    def marginal_gain(S, A):\n        A = set(A) - set(S)\n        if not A:\n            return 0.0\n        gain = 0.0\n        for i in A:\n            gain += weights[i] if i < len(weights) else 0.0\n        # interactions between A and S\n        for i in A:\n            for j in S:\n                gain += get_interaction(i, j)\n        # interactions internal to A\n        A_list = list(A)\n        for ii in range(len(A_list)):\n            for jj in range(ii+1, len(A_list)):\n                gain += get_interaction(A_list[ii], A_list[jj])\n        return gain\n\n    # Helper: when trying to add item i, compute required closure (predecessors)\n    def closure_for(i, current_set):\n        # items that must be present if we include i: i plus all transitive predecessors\n        C = set([i])\n        for p in pred_closure.get(i, set()):\n            C.add(p)\n        # Some predecessors may themselves have predecessors already included by pred_closure\n        # pred_closure already transitive, so this suffices.\n        # Remove those already in current_set\n        return C - set(current_set)\n\n    # Main greedy: iteratively add the candidate (plus its preds) with best marginal gain\n    selected_set = set()\n    # We'll allow adding until no improvement or until max_card reached.\n    while len(selected_set) < max_card:\n        best_gain = None\n        best_add = None\n        # evaluate every candidate not in selected_set\n        for i in range(n):\n            if i in selected_set:\n                continue\n            # compute closure needed\n            add_set = closure_for(i, selected_set)\n            # if adding would exceed max_card, skip\n            if len(selected_set) + len(add_set) > max_card:\n                continue\n            # Check feasibility when adding\n            new_set = set(selected_set) | set(add_set)\n            if not is_feasible_set(new_set):\n                continue\n            gain = marginal_gain(selected_set, add_set)\n            if best_gain is None or gain > best_gain:\n                best_gain = gain\n                best_add = add_set\n        # Stop if nothing feasible to add\n        if best_add is None:\n            break\n        # If best_gain is negative and we've already reached min_card, stop adding further\n        if best_gain is not None and best_gain < 0 and len(selected_set) >= min_card:\n            break\n        # Otherwise add the best_add\n        selected_set |= set(best_add)\n\n    # If we haven't reached minimum cardinality, force-add best remaining items (respecting constraints)\n    if len(selected_set) < min_card:\n        # consider candidates by marginal gain ignoring negative cutoff\n        candidates = [i for i in range(n) if i not in selected_set]\n        # sort by simple heuristic gain (weight + sum positive interactions)\n        def heuristic_gain(i):\n            g = weights[i] if i < len(weights) else 0.0\n            for j in range(n):\n                if j == i:\n                    continue\n                g += abs(get_interaction(i, j)) * 0.2\n            return g\n        candidates.sort(key=heuristic_gain, reverse=True)\n        for i in candidates:\n            if len(selected_set) >= min_card:\n                break\n            add_set = closure_for(i, selected_set)\n            if len(selected_set) + len(add_set) > max_card:\n                continue\n            new_set = set(selected_set) | set(add_set)\n            if not is_feasible_set(new_set):\n                continue\n            selected_set |= set(add_set)\n\n    # Local search: try single-item swaps to improve objective (remove one, add one or add closure)\n    improved = True\n    max_iters = 500\n    it = 0\n    current_obj = objective(selected_set)\n    # Precompute all items list\n    all_items = set(range(n))\n    while improved and it < max_iters:\n        improved = False\n        it += 1\n        # iterate possible removals and additions\n        removed_item = None\n        added_items = None\n        best_obj = current_obj\n        for rem in list(selected_set):\n            # Try remove rem and try to add any outside item (with its closure w.r.t resulting set)\n            base_set = set(selected_set)\n            base_set.remove(rem)\n            # Ensure base_set is still feasible (removing may break precedence if rem was a predecessor of others)\n            if not is_feasible_set(base_set):\n                # Can't remove this item unless we also remove dependents; skip for simplicity\n                continue\n            for add in (all_items - base_set):\n                if add in base_set:\n                    continue\n                add_closure = closure_for(add, base_set)\n                candidate_set = set(base_set) | set(add_closure)\n                # respect cardinality\n                if len(candidate_set) < min_card or len(candidate_set) > max_card:\n                    continue\n                if not is_feasible_set(candidate_set):\n                    continue\n                obj = objective(candidate_set)\n                if obj > best_obj + 1e-9:\n                    best_obj = obj\n                    removed_item = rem\n                    added_items = set(add_closure)\n        if best_obj > current_obj + 1e-9 and removed_item is not None:\n            # apply improvement\n            selected_set.remove(removed_item)\n            selected_set |= set(added_items)\n            current_obj = best_obj\n            improved = True\n\n    # Final safety: ensure feasibility (if not, fall back to greedy selection by weight)\n    if not is_feasible_set(selected_set):\n        selected_set = set()\n        for i in sorted(range(n), key=lambda x: weights[x], reverse=True):\n            if len(selected_set) >= max_card:\n                break\n            add_set = closure_for(i, selected_set)\n            if len(selected_set) + len(add_set) > max_card:\n                continue\n            new_set = set(selected_set) | set(add_set)\n            if not is_feasible_set(new_set):\n                continue\n            selected_set |= set(add_set)\n        # fill up if still below min_card\n        i = 0\n        while len(selected_set) < min_card and i < n:\n            if i not in selected_set:\n                add_set = closure_for(i, selected_set)\n                if len(selected_set) + len(add_set) <= max_card:\n                    new_set = set(selected_set) | set(add_set)\n                    if is_feasible_set(new_set):\n                        selected_set |= set(add_set)\n            i += 1\n\n    result = {\n        \"selection\": {\n            \"variables\": sorted(list(selected_set))\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n\n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n\n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n\n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n\n    result_str = stdout_capture.getvalue()\n    return result_str\n\n```\n\nHere are the performance metrics of the program:\n\nCombined score to maximize: 0.43\nfeasible: True; selection_size: 10; raw_score: 132.16\n\n# Task\n\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs as the original program, but with improved internal implementation.\n"
            },
            {
              "role": "assistant",
              "content": "<NAME>\nprecedence_beam_anneal\n</NAME>\n\n<DESCRIPTION>\nInspired by the previous greedy + local-search solutions, this program implements a different hybrid approach: a precedence-aware beam of seeded greedy constructions followed by a compact simulated-annealing-style local search (stochastic hill-climb with tabu-like memory). Key novel elements:\n\n- Beam of diverse seeds: instead of a single greedy build, the algorithm generates several promising starting solutions by seeding from high-centrality items (weights + summed interactions) and performing a constraint-aware greedy augmentation that always respects precedence closures, group and mutex constraints.\n- Succession-aware removals: when removing items we automatically remove all dependents (successor closure), keeping all intermediate states feasible with respect to precedence.\n- Lightweight simulated annealing for each beam member: randomized add/remove/swap moves that consider adding an item together with its predecessor closure and removing items together with their dependent closure. Moves are accepted if they improve the objective or with a decaying probability to escape local optima.\n- Group and mutex pruning at move time: additions or swaps are only considered if resulting sets respect group/mutex/cardinality constraints.\n- Compactness and adaptivity: number of seeds and local-search iterations scales with the problem size to remain efficient while exploring broader parts of the search space for higher-quality solutions.\n\nThis combination preserves the precedence closure logic from earlier solutions but departs from pure deterministic greedy and simple 1-for-1 swaps by adding beam diversity and stochastic exploration, which tends to find better synergy configurations when interactions are important.\n</DESCRIPTION>\n\n<CODE>\n```python\n#!/usr/bin/env python3\n\"\"\"\nEVOLVE-BLOCK-START\nA novel SDS solver: precedence-aware beam + simulated-annealing-style local search.\nReads JSON from stdin with \"requirements\" and \"catalog\", writes JSON to stdout:\n{\"selection\":{\"variables\":[...]}}\n\nThis block is intended to be evolved by ShinkaEvolve.\n\"\"\"\nimport sys\nimport json\nimport math\nimport random\nimport time\n\ndef solve_sds():\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    min_card, max_card = cardinality_bounds[0], cardinality_bounds[1]\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n\n    n = len(weights)\n\n    # Robust interaction parsing: handle \"i,j\" -> value or nested dicts\n    interaction_map = {}\n    # first try string keys like \"i,j\" or tuple-like\n    if isinstance(interactions, dict):\n        for k, v in interactions.items():\n            if isinstance(k, str):\n                if \",\" in k:\n                    try:\n                        a_s, b_s = k.split(\",\")\n                        a, b = int(a_s), int(b_s)\n                        if a > b:\n                            a, b = b, a\n                        interaction_map[(a, b)] = float(v)\n                    except Exception:\n                        continue\n                else:\n                    # maybe nested mapping case handled later\n                    continue\n            elif isinstance(k, (list, tuple)) and len(k) == 2:\n                try:\n                    a, b = int(k[0]), int(k[1])\n                    if a > b:\n                        a, b = b, a\n                    interaction_map[(a, b)] = float(v)\n                except Exception:\n                    continue\n    # try nested dict form interactions[i][j] = val\n    if not interaction_map and isinstance(interactions, dict):\n        try:\n            for ik, row in interactions.items():\n                ii = int(ik)\n                if isinstance(row, dict):\n                    for jk, vv in row.items():\n                        jj = int(jk)\n                        a, b = (ii, jj) if ii <= jj else (jj, ii)\n                        interaction_map[(a, b)] = float(vv)\n        except Exception:\n            pass\n\n    def get_interaction(i, j):\n        if i > j:\n            i, j = j, i\n        return interaction_map.get((i, j), 0.0)\n\n    # Precedence maps\n    preds = {i: set() for i in range(n)}\n    succs = {i: set() for i in range(n)}\n    for p in precedence:\n        try:\n            a = int(p[0]); b = int(p[1])\n            # if b selected then a must be selected => a is predecessor of b\n            preds[b].add(a)\n            succs[a].add(b)\n        except Exception:\n            continue\n\n    # Compute transitive predecessor closure and successor closure\n    pred_closure = {}\n    for i in range(n):\n        seen = set()\n        stack = list(preds.get(i, []))\n        while stack:\n            x = stack.pop()\n            if x in seen:\n                continue\n            seen.add(x)\n            for y in preds.get(x, ()):\n                if y not in seen:\n                    stack.append(y)\n        pred_closure[i] = seen\n\n    succ_closure = {}\n    for i in range(n):\n        seen = set()\n        stack = list(succs.get(i, []))\n        while stack:\n            x = stack.pop()\n            if x in seen:\n                continue\n            seen.add(x)\n            for y in succs.get(x, ()):\n                if y not in seen:\n                    stack.append(y)\n        succ_closure[i] = seen\n\n    # Precompute group and mutex quick checks\n    # groups: dict name -> list of vars\n    var_to_group = {}\n    for gname, vars_list in groups.items():\n        for v in vars_list:\n            var_to_group[v] = gname\n\n    mutex_pairs = set()\n    mutex_map = {i: set() for i in range(n)}\n    for a, b in mutex:\n        mutex_pairs.add((a, b))\n        mutex_pairs.add((b, a))\n        if 0 <= a < n and 0 <= b < n:\n            mutex_map[a].add(b)\n            mutex_map[b].add(a)\n\n    # Quick feasibility check\n    def is_feasible_set(S):\n        if len(S) > max_card or len(S) < 0:\n            return False\n        # precedence: all preds must be included\n        for j in S:\n            for p in preds.get(j, ()):\n                if p not in S:\n                    return False\n        # mutex\n        for a in S:\n            for b in mutex_map.get(a, ()):\n                if b in S:\n                    return False\n        # groups\n        seen_groups = {}\n        for v in S:\n            g = var_to_group.get(v)\n            if g is not None:\n                if g in seen_groups:\n                    return False\n                seen_groups[g] = v\n        return True\n\n    # Objective computation optimized: sum weights + sum interactions for pairs (i<j)\n    # We'll maintain an interactions adjacency list for non-zero interactions\n    neighbors = {i: {} for i in range(n)}\n    for (a, b), val in interaction_map.items():\n        if 0 <= a < n and 0 <= b < n:\n            neighbors[a][b] = val\n            neighbors[b][a] = val\n\n    def objective(S):\n        total = 0.0\n        for i in S:\n            if 0 <= i < n:\n                total += weights[i]\n        # pairwise interactions\n        # sum over each i neighbors j>i in S\n        Sset = set(S)\n        for i in Sset:\n            for j, val in neighbors[i].items():\n                if j in Sset and j > i:\n                    total += val\n        return total\n\n    # Marginal gain for adding a set A to S (A disjoint or overlap handled)\n    def marginal_gain(S, A):\n        Sset = set(S)\n        Aset = set(A) - Sset\n        if not Aset:\n            return 0.0\n        gain = 0.0\n        for i in Aset:\n            if 0 <= i < n:\n                gain += weights[i]\n        # interactions between A and S\n        for i in Aset:\n            for j, val in neighbors[i].items():\n                if j in Sset:\n                    gain += val\n        # interactions internal to A\n        Alist = list(Aset)\n        for ui in range(len(Alist)):\n            ii = Alist[ui]\n            for uj in range(ui + 1, len(Alist)):\n                jj = Alist[uj]\n                gain += neighbors[ii].get(jj, 0.0)\n        return gain\n\n    # closure_for: when adding i, include its predecessors (transitive)\n    def closure_for_add(i, current_set):\n        res = set([i])\n        for p in pred_closure.get(i, set()):\n            res.add(p)\n        # exclude already present\n        return res - set(current_set)\n\n    # closure_for_remove: when removing i, need to remove all successors that depend on it (transitive)\n    def closure_for_remove(i):\n        res = set([i])\n        for s in succ_closure.get(i, set()):\n            res.add(s)\n        return res\n\n    # centrality heuristic: base for seeding\n    centrality = []\n    for i in range(n):\n        s = weights[i] if 0 <= i < n else 0.0\n        # sum of positive interactions\n        pos_sum = 0.0\n        for j, val in neighbors[i].items():\n            if val > 0:\n                pos_sum += val\n            else:\n                pos_sum += 0.1 * val  # small weight for negative links\n        s += pos_sum\n        centrality.append((s, i))\n    centrality.sort(reverse=True)\n\n    # Beam parameters scaled with n\n    beam_width = max(5, min(40, n // 3 + 1))\n    seeds_to_try = beam_width\n    seed_indices = [i for _, i in centrality[:seeds_to_try]]\n\n    # If too few seeds (small n), consider random seeds for diversity\n    if len(seed_indices) < beam_width:\n        others = [i for i in range(n) if i not in seed_indices]\n        random.shuffle(others)\n        seed_indices += others[:beam_width - len(seed_indices)]\n\n    # Greedy augment function (respect closures, groups, mutex)\n    def greedy_augment(initial_set):\n        S = set(initial_set)\n        # If initial violates precedence, fix by adding needed preds\n        changed = True\n        while changed:\n            changed = False\n            for j in list(S):\n                for p in preds.get(j, ()):\n                    if p not in S:\n                        S.add(p)\n                        changed = True\n        # Greedily add items with best positive marginal gain\n        while len(S) < max_card:\n            best_gain = -1e18\n            best_add = None\n            for i in range(n):\n                if i in S:\n                    continue\n                add_set = closure_for_add(i, S)\n                if not add_set:\n                    continue\n                if len(S) + len(add_set) > max_card:\n                    continue\n                # check group/mutex feasibility quickly\n                violated = False\n                # group conflict\n                existing_groups = set(var_to_group.get(v) for v in S if var_to_group.get(v) is not None)\n                for v in add_set:\n                    g = var_to_group.get(v)\n                    if g is not None and g in existing_groups:\n                        violated = True\n                        break\n                if violated:\n                    continue\n                # mutex: any v in add_set conflicting with S?\n                for v in add_set:\n                    for m in mutex_map.get(v, ()):\n                        if m in S:\n                            violated = True\n                            break\n                    if violated:\n                        break\n                if violated:\n                    continue\n                gain = marginal_gain(S, add_set)\n                # prefer positive gains; otherwise small positive if need to reach min_card\n                if gain > best_gain:\n                    best_gain = gain\n                    best_add = add_set\n            if best_add is None or (best_gain <= 1e-12 and len(S) >= min_card):\n                break\n            S |= set(best_add)\n        # If below min_card, force add highest marginal items (even negative if necessary)\n        if len(S) < min_card:\n            # consider all candidates sorted by marginal gain\n            cand_list = []\n            for i in range(n):\n                if i in S:\n                    continue\n                add_set = closure_for_add(i, S)\n                if not add_set:\n                    continue\n                if len(S) + len(add_set) > max_card:\n                    continue\n                # skip if group/mutex violate\n                violated = False\n                existing_groups = set(var_to_group.get(v) for v in S if var_to_group.get(v) is not None)\n                for v in add_set:\n                    g = var_to_group.get(v)\n                    if g is not None and g in existing_groups:\n                        violated = True\n                        break\n                    for m in mutex_map.get(v, ()):\n                        if m in S:\n                            violated = True\n                            break\n                    if violated:\n                        break\n                if violated:\n                    continue\n                cand_list.append((marginal_gain(S, add_set), add_set))\n            cand_list.sort(reverse=True, key=lambda x: x[0])\n            for gain, add_set in cand_list:\n                if len(S) >= min_card:\n                    break\n                if len(S) + len(add_set) > max_card:\n                    continue\n                S |= set(add_set)\n        # final feasibility guard\n        if not is_feasible_set(S):\n            # fallback: simple weight-based fill respecting closures\n            S = set()\n            for i in sorted(range(n), key=lambda x: weights[x], reverse=True):\n                add_set = closure_for_add(i, S)\n                if len(S) + len(add_set) > max_card:\n                    continue\n                if not is_feasible_set(S | set(add_set)):\n                    continue\n                S |= set(add_set)\n                if len(S) >= max_card:\n                    break\n        return S\n\n    # Build initial beam of solutions\n    beam = []\n    tried_seeds = set()\n    for sidx in seed_indices:\n        if sidx in tried_seeds:\n            continue\n        tried_seeds.add(sidx)\n        init = closure_for_add(sidx, set())\n        # if too large, skip seed\n        if len(init) > max_card:\n            continue\n        sol = greedy_augment(init)\n        beam.append(sol)\n    # If beam too small, add some empties and singletons\n    if not beam:\n        beam.append(set())\n    # ensure beam unique\n    uniq = []\n    seen = set()\n    for sol in beam:\n        key = tuple(sorted(sol))\n        if key not in seen:\n            uniq.append(sol)\n            seen.add(key)\n    beam = uniq[:beam_width]\n\n    # Local search with simulated annealing for each beam member\n    best_sol = None\n    best_score = -1e99\n\n    # Tune iterations by problem size\n    base_iters = 300\n    iter_scale = max(1, n // 10)\n    max_iters_per_seed = min(2000, base_iters * iter_scale)\n\n    rng = random.Random()\n    # deterministic-ish seed based on weights to be reproducible across runs\n    rng.seed(int(sum(weights) * 1000) if weights else 12345)\n\n    start_time = time.time()\n    time_limit = 1.8  # try to keep runtime modest; evaluator may limit\n    for sol in beam:\n        S = set(sol)\n        S = greedy_augment(S)  # tighten\n        cur_score = objective(S)\n        if cur_score > best_score:\n            best_score = cur_score\n            best_sol = set(S)\n        # SA parameters\n        T0 = max(1.0, abs(cur_score) * 0.1 + 1.0)\n        Tmin = 1e-3\n        iters = 0\n        last_improve = 0\n        while iters < max_iters_per_seed:\n            iters += 1\n            # time cut\n            if time.time() - start_time > time_limit:\n                break\n            # temperature schedule\n            frac = iters / float(max_iters_per_seed + 1)\n            temp = T0 * (1.0 - frac) + Tmin * frac\n            op = rng.choice(['add', 'remove', 'swap'])\n            accepted = False\n            if op == 'add':\n                # pick candidate item not in S that might improve\n                candidates = list(set(range(n)) - S)\n                rng.shuffle(candidates)\n                for cand in candidates[:min(50, len(candidates))]:\n                    add_set = closure_for_add(cand, S)\n                    if not add_set:\n                        continue\n                    if len(S) + len(add_set) > max_card:\n                        continue\n                    # group/mutex check\n                    violated = False\n                    existing_groups = set(var_to_group.get(v) for v in S if var_to_group.get(v) is not None)\n                    for v in add_set:\n                        g = var_to_group.get(v)\n                        if g is not None and g in existing_groups:\n                            violated = True\n                            break\n                        for m in mutex_map.get(v, ()):\n                            if m in S:\n                                violated = True\n                                break\n                        if violated:\n                            break\n                    if violated:\n                        continue\n                    newS = set(S) | set(add_set)\n                    # ensure not violating precedence (add_set includes preds)\n                    if not is_feasible_set(newS):\n                        continue\n                    new_score = objective(newS)\n                    delta = new_score - cur_score\n                    if delta > 1e-12 or math.exp(min(50.0, delta / max(1e-9, temp))) > rng.random():\n                        S = newS\n                        cur_score = new_score\n                        accepted = True\n                        last_improve = iters\n                        break\n            elif op == 'remove':\n                if len(S) == 0:\n                    continue\n                removes = list(S)\n                rng.shuffle(removes)\n                for rem in removes[:min(50, len(removes))]:\n                    rem_set = closure_for_remove(rem)\n                    newS = set(S) - rem_set\n                    # enforce min_card or allow temporary below with small prob\n                    if len(newS) < min_card:\n                        # permit removal with low probability if helps and temperature high\n                        pass_prob = math.exp(- (min_card - len(newS)) / (1.0 + temp))\n                        if rng.random() > pass_prob:\n                            continue\n                    if not is_feasible_set(newS):\n                        continue\n                    new_score = objective(newS)\n                    delta = new_score - cur_score\n                    if delta > 1e-12 or math.exp(min(50.0, delta / max(1e-9, temp))) > rng.random():\n                        S = newS\n                        cur_score = new_score\n                        accepted = True\n                        last_improve = iters\n                        break\n            else:  # swap: remove some dependent cluster and add some other closure\n                if len(S) == 0:\n                    continue\n                rem = rng.choice(list(S))\n                rem_set = closure_for_remove(rem)\n                base = set(S) - rem_set\n                # consider candidates to add given base\n                candidates = list(set(range(n)) - base)\n                rng.shuffle(candidates)\n                for cand in candidates[:min(80, len(candidates))]:\n                    add_set = closure_for_add(cand, base)\n                    if not add_set:\n                        continue\n                    if len(base) + len(add_set) > max_card:\n                        continue\n                    # group/mutex check\n                    violated = False\n                    existing_groups = set(var_to_group.get(v) for v in base if var_to_group.get(v) is not None)\n                    for v in add_set:\n                        g = var_to_group.get(v)\n                        if g is not None and g in existing_groups:\n                            violated = True\n                            break\n                        for m in mutex_map.get(v, ()):\n                            if m in base:\n                                violated = True\n                                break\n                        if violated:\n                            break\n                    if violated:\n                        continue\n                    newS = set(base) | set(add_set)\n                    if len(newS) < min_card:\n                        continue\n                    if not is_feasible_set(newS):\n                        continue\n                    new_score = objective(newS)\n                    delta = new_score - cur_score\n                    if delta > 1e-12 or math.exp(min(50.0, delta / max(1e-9, temp))) > rng.random():\n                        S = newS\n                        cur_score = new_score\n                        accepted = True\n                        last_improve = iters\n                        break\n            # record best\n            if cur_score > best_score + 1e-12:\n                best_score = cur_score\n                best_sol = set(S)\n            # small early stop if no improvement for long\n            if iters - last_improve > 400 and iters > 800:\n                break\n        # time limit guard\n        if time.time() - start_time > time_limit:\n            break\n\n    # Final repair and ensure feasibility and cardinality\n    if best_sol is None:\n        best_sol = set()\n    S = set(best_sol)\n    # Ensure precedence closure included\n    changed = True\n    while changed:\n        changed = False\n        for j in list(S):\n            for p in preds.get(j, ()):\n                if p not in S:\n                    S.add(p)\n                    changed = True\n    # If too large, try removing low marginal contributors while respecting precedence\n    if len(S) > max_card:\n        # rank items by marginal contribution (with respect to S)\n        def marginal_contrib(i, curS):\n            # contribution approximated as weight + sum interactions with curS - interactions lost from removal\n            contrib = weights[i]\n            for j, val in neighbors[i].items():\n                if j in curS and j != i:\n                    contrib += val\n            return contrib\n        # try removing items with smallest contrib but ensure we also remove dependents\n        items = sorted(list(S), key=lambda x: marginal_contrib(x, S))\n        for itv in items:\n            if len(S) <= max_card:\n                break\n            # can't remove if it has predecessors that would remain invalid (we'll remove dependents)\n            rem_cluster = closure_for_remove(itv)\n            # ensure we don't violate min_card after removal\n            if len(S) - len(rem_cluster) < min_card:\n                continue\n            S -= rem_cluster\n        # final safety: if still too large, keep top by contrib\n        if len(S) > max_card:\n            items = sorted(list(S), key=lambda x: marginal_contrib(x, S), reverse=True)\n            S = set(items[:max_card])\n\n    # If too small, fill greedily\n    if len(S) < min_card:\n        # add best marginal additions\n        while len(S) < min_card:\n            best_gain = -1e99\n            best_add = None\n            for i in range(n):\n                if i in S:\n                    continue\n                add_set = closure_for_add(i, S)\n                if not add_set:\n                    continue\n                if len(S) + len(add_set) > max_card:\n                    continue\n                # group/mutex check\n                violated = False\n                existing_groups = set(var_to_group.get(v) for v in S if var_to_group.get(v) is not None)\n                for v in add_set:\n                    g = var_to_group.get(v)\n                    if g is not None and g in existing_groups:\n                        violated = True\n                        break\n                    for m in mutex_map.get(v, ()):\n                        if m in S:\n                            violated = True\n                            break\n                    if violated:\n                        break\n                if violated:\n                    continue\n                gain = marginal_gain(S, add_set)\n                if gain > best_gain:\n                    best_gain = gain\n                    best_add = add_set\n            if best_add is None:\n                break\n            S |= set(best_add)\n\n    # Final enforced feasibility (last resort simple greedy)\n    if not is_feasible_set(S):\n        S = set()\n        for i in sorted(range(n), key=lambda x: weights[x], reverse=True):\n            add_set = closure_for_add(i, S)\n            if len(S) + len(add_set) > max_card:\n                continue\n            if not is_feasible_set(S | set(add_set)):\n                continue\n            S |= set(add_set)\n            if len(S) >= max_card:\n                break\n        i = 0\n        while len(S) < min_card and i < n:\n            if i not in S:\n                add_set = closure_for_add(i, S)\n                if len(S) + len(add_set) <= max_card and is_feasible_set(S | set(add_set)):\n                    S |= set(add_set)\n            i += 1\n\n    result = {\"selection\": {\"variables\": sorted(list(S))}}\n    print(json.dumps(result))\n\n# EVOLVE-BLOCK-END\n\nif __name__ == \"__main__\":\n    solve_sds()\n```\n</CODE>"
            }
          ],
          "model_name": "gpt-5-mini",
          "kwargs": {
            "temperature": 1.0,
            "max_output_tokens": 8192
          },
          "input_tokens": 4344,
          "output_tokens": 6479,
          "cost": 0.014044,
          "input_cost": 0.001086,
          "output_cost": 0.012957999999999999,
          "thought": "",
          "model_posteriors": {
            "gpt-5-mini": 1.0
          }
        },
        "diff_summary": {
          "added": 328,
          "deleted": 0,
          "modified": 238
        },
        "embed_cost": 0.00010052,
        "novelty_cost": 0.0,
        "stdout_log": "Evaluating program: sds_dataset_output/problem_0/gen_4/main.py\nSaving results to: sds_dataset_output/problem_0/gen_4/results\nEvaluation error: unterminated triple-quoted string literal (detected at line 668) (main.py, line 643)\nCorrectness and error status saved to sds_dataset_output/problem_0/gen_4/results/correct.json\nMetrics saved to sds_dataset_output/problem_0/gen_4/results/metrics.json\nEvaluation or Validation failed: unterminated triple-quoted string literal (detected at line 668) (main.py, line 643)\nMetrics:\n  combined_score: 0.0\n  execution_time_mean: 0.0\n  execution_time_std: 0.0\n  num_successful_runs: 0\n  num_valid_runs: 0\n  num_invalid_runs: 0\n  all_validation_errors: []\n",
        "stderr_log": "",
        "code_analysis_metrics": {
          "cyclomatic_complexity": 231,
          "average_cyclomatic_complexity": 231,
          "halstead_volume": 4938.7501470506995,
          "halstead_difficulty": 1.0,
          "halstead_effort": 4938.7501470506995,
          "lines_of_code": 669,
          "logical_lines_of_code": 629,
          "comments": 0,
          "maintainability_index": 0,
          "max_nesting_depth": 2,
          "complexity_score": 0.934
        }
      },
      "in_archive": false
    },
    {
      "id": "41c4e403-070f-4e25-9757-64fb47df1aa9",
      "code": "\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Improved solver for the Synergistic Dependency Selection problem.\n\n    - Reads JSON from stdin with \"requirements\" and \"catalog\".\n    - Produces JSON to stdout with \"selection\": {\"variables\": [...] }.\n    - Uses a precedence-aware marginal-gain greedy algorithm that:\n        * when adding an item, also includes its required predecessors (closure),\n        * computes the marginal objective (weights + pairwise interactions),\n        * checks mutex/group/cardinality feasibility for the closure before adding.\n    \"\"\"\n    import re\n\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n\n    # Extract constraints\n    weights = list(requirements.get(\"weights\", []))\n    interactions_raw = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    min_card, max_card = (cardinality_bounds + [len(weights), len(weights)])[:2]\n    mutex = [tuple(m) for m in requirements.get(\"mutex\", [])]\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n\n    n = len(weights)\n\n    # Parse interactions into dict of tuple->float for quick lookup (undirected)\n    interactions = {}\n    for k, v in interactions_raw.items():\n        try:\n            if isinstance(k, str):\n                # allow \"u,v\" or \"u v\"\n                parts = re.split(r'\\s*,\\s*|\\s+', k.strip())\n                if len(parts) >= 2:\n                    u = int(parts[0]); w = int(parts[1])\n                else:\n                    continue\n            elif isinstance(k, (list, tuple)) and len(k) >= 2:\n                u = int(k[0]); w = int(k[1])\n            else:\n                continue\n            interactions[(u, w)] = float(v)\n            interactions[(w, u)] = float(v)\n        except Exception:\n            # skip malformed keys\n            continue\n\n    # Build precedence graph: if (p, j) then p is a prerequisite of j\n    preds = {i: set() for i in range(n)}\n    succs = {i: set() for i in range(n)}\n    for entry in precedence:\n        try:\n            a, b = entry\n            a = int(a); b = int(b)\n            preds[b].add(a)\n            succs[a].add(b)\n        except Exception:\n            continue\n\n    # Precompute ancestors (transitive closure of preds) using DFS/memoization\n    ancestor_cache = {}\n\n    def get_ancestors(i):\n        if i in ancestor_cache:\n            return ancestor_cache[i].copy()\n        res = set()\n        stack = [i]\n        while stack:\n            cur = stack.pop()\n            for p in preds.get(cur, []):\n                if p not in res:\n                    res.add(p)\n                    stack.append(p)\n        ancestor_cache[i] = res.copy()\n        return res\n\n    # Map variable -> group (assume at most one group membership; if multiple, first wins)\n    var_to_group = {}\n    for gname, vars_list in groups.items():\n        for v in vars_list:\n            try:\n                var_to_group[int(v)] = gname\n            except Exception:\n                pass\n\n    # Helper: check feasibility of adding a closure set given current selected_set\n    def feasible_closure(closure_set, selected_set):\n        # Cardinality\n        if len(selected_set) + len(closure_set - selected_set) > max_card:\n            return False\n        # Mutex: none of closure can conflict with each other or with selected_set\n        for a, b in mutex:\n            if a in closure_set and b in closure_set:\n                return False\n            if (a in closure_set and b in selected_set) or (b in closure_set and a in selected_set):\n                return False\n        # Group: ensure at most one per group overall\n        # Build per-group counts\n        group_counts = {}\n        for v in selected_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in closure_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: closure itself must include ancestors for each element\n        for v in closure_set:\n            if not get_ancestors(v).issubset(closure_set.union(selected_set)):\n                return False\n        return True\n\n    # Compute marginal gain of adding closure_set (items that will be newly included)\n    def marginal_gain(closure_set, selected_set):\n        new_items = set(closure_set) - set(selected_set)\n        gain = 0.0\n        for i in new_items:\n            if i < len(weights):\n                gain += float(weights[i])\n        # interactions among new items\n        new_list = list(new_items)\n        for i in range(len(new_list)):\n            for j in range(i + 1, len(new_list)):\n                gain += interactions.get((new_list[i], new_list[j]), 0.0)\n        # interactions between new items and already selected\n        for i in new_items:\n            for j in selected_set:\n                gain += interactions.get((i, j), 0.0)\n        return gain\n\n    # Greedy loop: at each step try to add an item (and its ancestors) with max marginal gain\n    selected_set = set()\n    # Keep iterating while we can still add and haven't reached max_card\n    improved = True\n    while len(selected_set) < max_card and improved:\n        improved = False\n        best_gain = float(\"-inf\")\n        best_closure = None\n        # Consider candidates not already selected\n        for i in range(n):\n            if i in selected_set:\n                continue\n            # closure includes i and its ancestors\n            closure = get_ancestors(i).union({i})\n            # Only consider closures that are feasible\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # Prefer closures that add more items when gain is equal (to help reach min_card)\n            if gain > best_gain or (abs(gain - best_gain) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_gain = gain\n                best_closure = closure\n        # If we found a positive-gain move, take it\n        if best_closure is not None and best_gain > -1e-12:\n            to_add = set(best_closure) - selected_set\n            if to_add:\n                selected_set.update(to_add)\n                improved = True\n        else:\n            # No non-negative gain move; stop greedy improvements\n            break\n\n    # If we still haven't met minimum cardinality, greedily add best feasible closures regardless of gain\n    while len(selected_set) < min_card:\n        best_gain = float(\"-inf\")\n        best_closure = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = get_ancestors(i).union({i})\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # choose closure that gives best gain (even if negative), tie-breaker favors larger closures\n            if gain > best_gain or (abs(gain - best_gain) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_gain = gain\n                best_closure = closure\n        if best_closure is None:\n            # No feasible closure remains; break to avoid infinite loop\n            break\n        selected_set.update(set(best_closure) - selected_set)\n\n    # Final trim if over max_card (shouldn't happen due to checks) - keep highest-weight items\n    if len(selected_set) > max_card:\n        # score items by marginal contribution relative to selected (approx): weight + interactions with others\n        def item_score(i):\n            s = float(weights[i]) if i < len(weights) else 0.0\n            for j in selected_set:\n                if j == i:\n                    continue\n                s += interactions.get((i, j), 0.0)\n            return s\n        sorted_items = sorted(selected_set, key=item_score, reverse=True)\n        selected_set = set(sorted_items[:max_card])\n\n    result = {\n        \"selection\": {\n            \"variables\": sorted(int(x) for x in selected_set)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n\n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n\n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n\n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n\n    result_str = stdout_capture.getvalue()\n    return result_str\n",
      "language": "python",
      "parent_id": "639d15e8-d1f9-4fa7-b731-6db3bcbdb880",
      "archive_inspiration_ids": [],
      "top_k_inspiration_ids": [],
      "island_idx": 0,
      "generation": 5,
      "timestamp": 1764668241.728321,
      "code_diff": "--- a/original.py\n+++ b/original.py\n@@ -1,144 +1,252 @@\n \"\"\"\n Initial solution for Synergistic Dependency Selection (SDS) problem.\n The code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n \"\"\"\n \n import json\n import sys\n import contextlib\n \n # EVOLVE-BLOCK-START\n def solve_sds():\n     \"\"\"\n-    Solve the Synergistic Dependency Selection problem.\n-\n-    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n-    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n-\n-    This is a greedy baseline - evolution will improve this.\n-    \"\"\"\n+    Improved solver for the Synergistic Dependency Selection problem.\n+\n+    - Reads JSON from stdin with \"requirements\" and \"catalog\".\n+    - Produces JSON to stdout with \"selection\": {\"variables\": [...] }.\n+    - Uses a precedence-aware marginal-gain greedy algorithm that:\n+        * when adding an item, also includes its required predecessors (closure),\n+        * computes the marginal objective (weights + pairwise interactions),\n+        * checks mutex/group/cardinality feasibility for the closure before adding.\n+    \"\"\"\n+    import re\n+\n     # Read input\n     input_data = json.load(sys.stdin)\n     requirements = input_data.get(\"requirements\", {})\n     catalog = input_data.get(\"catalog\", {})\n \n     # Extract constraints\n-    weights = requirements.get(\"weights\", [])\n-    interactions = requirements.get(\"interactions\", {})\n+    weights = list(requirements.get(\"weights\", []))\n+    interactions_raw = requirements.get(\"interactions\", {})\n     cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n-    mutex = requirements.get(\"mutex\", [])\n+    min_card, max_card = (cardinality_bounds + [len(weights), len(weights)])[:2]\n+    mutex = [tuple(m) for m in requirements.get(\"mutex\", [])]\n     groups = requirements.get(\"groups\", {})\n     precedence = requirements.get(\"precedence\", [])\n \n-    # Simple greedy: select items with highest weights first\n-    # This is a baseline - evolution will find better strategies\n     n = len(weights)\n-    selected = []\n-\n-    # Create score list (weight + interaction potential)\n-    scores = []\n-    for i in range(n):\n-        score = weights[i] if i < len(weights) else 0.0\n-        # Add potential interaction value\n-        for k, v in interactions.items():\n+\n+    # Parse interactions into dict of tuple->float for quick lookup (undirected)\n+    interactions = {}\n+    for k, v in interactions_raw.items():\n+        try:\n+            if isinstance(k, str):\n+                # allow \"u,v\" or \"u v\"\n+                parts = re.split(r'\\s*,\\s*|\\s+', k.strip())\n+                if len(parts) >= 2:\n+                    u = int(parts[0]); w = int(parts[1])\n+                else:\n+                    continue\n+            elif isinstance(k, (list, tuple)) and len(k) >= 2:\n+                u = int(k[0]); w = int(k[1])\n+            else:\n+                continue\n+            interactions[(u, w)] = float(v)\n+            interactions[(w, u)] = float(v)\n+        except Exception:\n+            # skip malformed keys\n+            continue\n+\n+    # Build precedence graph: if (p, j) then p is a prerequisite of j\n+    preds = {i: set() for i in range(n)}\n+    succs = {i: set() for i in range(n)}\n+    for entry in precedence:\n+        try:\n+            a, b = entry\n+            a = int(a); b = int(b)\n+            preds[b].add(a)\n+            succs[a].add(b)\n+        except Exception:\n+            continue\n+\n+    # Precompute ancestors (transitive closure of preds) using DFS/memoization\n+    ancestor_cache = {}\n+\n+    def get_ancestors(i):\n+        if i in ancestor_cache:\n+            return ancestor_cache[i].copy()\n+        res = set()\n+        stack = [i]\n+        while stack:\n+            cur = stack.pop()\n+            for p in preds.get(cur, []):\n+                if p not in res:\n+                    res.add(p)\n+                    stack.append(p)\n+        ancestor_cache[i] = res.copy()\n+        return res\n+\n+    # Map variable -> group (assume at most one group membership; if multiple, first wins)\n+    var_to_group = {}\n+    for gname, vars_list in groups.items():\n+        for v in vars_list:\n             try:\n-                u, w = map(int, k.split(\",\"))\n-                if u == i or w == i:\n-                    score += abs(v) * 0.5  # Potential value\n-            except:\n+                var_to_group[int(v)] = gname\n+            except Exception:\n                 pass\n-        scores.append((score, i))\n-\n-    # Sort by score descending\n-    scores.sort(reverse=True)\n-\n-    # Greedy selection respecting constraints\n+\n+    # Helper: check feasibility of adding a closure set given current selected_set\n+    def feasible_closure(closure_set, selected_set):\n+        # Cardinality\n+        if len(selected_set) + len(closure_set - selected_set) > max_card:\n+            return False\n+        # Mutex: none of closure can conflict with each other or with selected_set\n+        for a, b in mutex:\n+            if a in closure_set and b in closure_set:\n+                return False\n+            if (a in closure_set and b in selected_set) or (b in closure_set and a in selected_set):\n+                return False\n+        # Group: ensure at most one per group overall\n+        # Build per-group counts\n+        group_counts = {}\n+        for v in selected_set:\n+            g = var_to_group.get(v)\n+            if g is not None:\n+                group_counts[g] = group_counts.get(g, 0) + 1\n+        for v in closure_set:\n+            g = var_to_group.get(v)\n+            if g is not None:\n+                group_counts[g] = group_counts.get(g, 0) + 1\n+                if group_counts[g] > 1:\n+                    return False\n+        # Precedence: closure itself must include ancestors for each element\n+        for v in closure_set:\n+            if not get_ancestors(v).issubset(closure_set.union(selected_set)):\n+                return False\n+        return True\n+\n+    # Compute marginal gain of adding closure_set (items that will be newly included)\n+    def marginal_gain(closure_set, selected_set):\n+        new_items = set(closure_set) - set(selected_set)\n+        gain = 0.0\n+        for i in new_items:\n+            if i < len(weights):\n+                gain += float(weights[i])\n+        # interactions among new items\n+        new_list = list(new_items)\n+        for i in range(len(new_list)):\n+            for j in range(i + 1, len(new_list)):\n+                gain += interactions.get((new_list[i], new_list[j]), 0.0)\n+        # interactions between new items and already selected\n+        for i in new_items:\n+            for j in selected_set:\n+                gain += interactions.get((i, j), 0.0)\n+        return gain\n+\n+    # Greedy loop: at each step try to add an item (and its ancestors) with max marginal gain\n     selected_set = set()\n-    for score, i in scores:\n-        if len(selected_set) >= cardinality_bounds[1]:\n+    # Keep iterating while we can still add and haven't reached max_card\n+    improved = True\n+    while len(selected_set) < max_card and improved:\n+        improved = False\n+        best_gain = float(\"-inf\")\n+        best_closure = None\n+        # Consider candidates not already selected\n+        for i in range(n):\n+            if i in selected_set:\n+                continue\n+            # closure includes i and its ancestors\n+            closure = get_ancestors(i).union({i})\n+            # Only consider closures that are feasible\n+            if not feasible_closure(closure, selected_set):\n+                continue\n+            gain = marginal_gain(closure, selected_set)\n+            # Prefer closures that add more items when gain is equal (to help reach min_card)\n+            if gain > best_gain or (abs(gain - best_gain) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n+                best_gain = gain\n+                best_closure = closure\n+        # If we found a positive-gain move, take it\n+        if best_closure is not None and best_gain > -1e-12:\n+            to_add = set(best_closure) - selected_set\n+            if to_add:\n+                selected_set.update(to_add)\n+                improved = True\n+        else:\n+            # No non-negative gain move; stop greedy improvements\n             break\n \n-        # Check mutex constraints\n-        can_add = True\n-        for a, b in mutex:\n-            if (a == i and b in selected_set) or (b == i and a in selected_set):\n-                can_add = False\n-                break\n-\n-        if not can_add:\n-            continue\n-\n-        # Check group constraints (at most one per group)\n-        for grp_vars in groups.values():\n-            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n-                can_add = False\n-                break\n-\n-        if not can_add:\n-            continue\n-\n-        # Check precedence (if j selected, i must be selected)\n-        precedence_ok = True\n-        for pred_i, pred_j in precedence:\n-            if pred_j == i and pred_i not in selected_set:\n-                precedence_ok = False\n-                break\n-\n-        if not precedence_ok:\n-            continue\n-\n-        # Add if we meet minimum cardinality or have room\n-        if len(selected_set) < cardinality_bounds[1]:\n-            selected_set.add(i)\n-            selected.append(i)\n-\n-    # Ensure minimum cardinality\n-    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n+    # If we still haven't met minimum cardinality, greedily add best feasible closures regardless of gain\n+    while len(selected_set) < min_card:\n+        best_gain = float(\"-inf\")\n+        best_closure = None\n         for i in range(n):\n-            if i not in selected_set:\n-                selected_set.add(i)\n-                selected.append(i)\n-                break\n-\n-    # Output result\n+            if i in selected_set:\n+                continue\n+            closure = get_ancestors(i).union({i})\n+            if not feasible_closure(closure, selected_set):\n+                continue\n+            gain = marginal_gain(closure, selected_set)\n+            # choose closure that gives best gain (even if negative), tie-breaker favors larger closures\n+            if gain > best_gain or (abs(gain - best_gain) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n+                best_gain = gain\n+                best_closure = closure\n+        if best_closure is None:\n+            # No feasible closure remains; break to avoid infinite loop\n+            break\n+        selected_set.update(set(best_closure) - selected_set)\n+\n+    # Final trim if over max_card (shouldn't happen due to checks) - keep highest-weight items\n+    if len(selected_set) > max_card:\n+        # score items by marginal contribution relative to selected (approx): weight + interactions with others\n+        def item_score(i):\n+            s = float(weights[i]) if i < len(weights) else 0.0\n+            for j in selected_set:\n+                if j == i:\n+                    continue\n+                s += interactions.get((i, j), 0.0)\n+            return s\n+        sorted_items = sorted(selected_set, key=item_score, reverse=True)\n+        selected_set = set(sorted_items[:max_card])\n+\n     result = {\n         \"selection\": {\n-            \"variables\": sorted(selected)\n+            \"variables\": sorted(int(x) for x in selected_set)\n         }\n     }\n     print(json.dumps(result))\n # EVOLVE-BLOCK-END\n \n \n # This part remains fixed (not evolved)\n def run_sds(problem_data=None):\n     \"\"\"\n     Main function called by the evaluator.\n     Can accept problem_data as parameter or read from stdin.\n     Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n     \"\"\"\n     import sys\n     import json\n     import io\n \n     if problem_data is None:\n         # Read from stdin (for compatibility)\n         input_data = json.load(sys.stdin)\n     else:\n         # Use provided problem data\n         input_data = problem_data\n \n     # Capture stdout from solve_sds\n     stdout_capture = io.StringIO()\n     old_stdin = sys.stdin\n \n     try:\n         # Create mock stdin\n         sys.stdin = io.StringIO(json.dumps(input_data))\n         with contextlib.redirect_stdout(stdout_capture):\n             solve_sds()\n     finally:\n         sys.stdin = old_stdin\n \n     result_str = stdout_capture.getvalue()\n     return result_str\n",
      "combined_score": 0.3993475858389672,
      "public_metrics": {
        "feasible": true,
        "selection_size": 10,
        "raw_score": 122.54942718671678
      },
      "private_metrics": {
        "selection": [
          3,
          4,
          5,
          6,
          7,
          9,
          10,
          11,
          13,
          14
        ],
        "raw_score": 122.54942718671678,
        "normalized_fitness": 0.3993475858389672
      },
      "text_feedback": "",
      "correct": true,
      "children_count": 0,
      "complexity": 1.0,
      "embedding": [
        0.028730197,
        0.0003288478,
        0.0077201836,
        -0.020514665,
        0.01589947,
        0.032185555,
        0.03636581,
        0.0047722575,
        -0.008475288,
        0.03143649,
        0.036994055,
        -0.057653703,
        -0.023825042,
        0.029140973,
        -0.0010662068,
        -0.020562991,
        0.048254166,
        0.0072489986,
        -0.012866972,
        0.0019934746,
        0.036704097,
        0.020043481,
        0.037743118,
        0.034360252,
        0.01895613,
        -0.004509481,
        0.03733234,
        0.08843778,
        0.032765474,
        -0.03919292,
        0.015549102,
        -0.011725255,
        -0.03346621,
        0.0070375693,
        -0.025250679,
        0.039386224,
        0.0031533143,
        0.032209717,
        -0.05001809,
        -0.019632705,
        -0.0033224577,
        -0.032620493,
        -0.028077787,
        0.020007236,
        -0.0150175085,
        -0.020562991,
        0.0014362078,
        0.007055692,
        0.025468148,
        -0.01763923,
        -0.03542344,
        0.032499675,
        0.025540639,
        -0.008143041,
        -0.017083474,
        -0.04426722,
        0.0017171066,
        0.014969182,
        -0.008076592,
        -0.0029811505,
        0.024078757,
        -0.038298875,
        0.041585088,
        0.013458974,
        -0.021831566,
        0.009768025,
        0.0132656675,
        0.0016853921,
        -0.027594522,
        -0.0105714565,
        -0.035544258,
        -0.010420435,
        0.012003133,
        -0.022230262,
        -0.0055001774,
        0.031484816,
        0.023752552,
        0.031823102,
        0.0049383803,
        -0.03614834,
        -0.053400956,
        -0.028271094,
        -0.0063489145,
        -0.012432032,
        -0.060794935,
        -0.07060525,
        -0.0026232314,
        0.027473705,
        -0.046345264,
        -0.06548262,
        -0.0059713623,
        -0.0012972687,
        -0.070411935,
        0.010819131,
        0.02403043,
        -0.04668355,
        0.029817548,
        -0.018968213,
        0.011405091,
        0.0018938008,
        0.0059049134,
        -0.039313734,
        0.014461752,
        -0.038516346,
        0.0073214886,
        0.023849204,
        0.031122366,
        0.0112782335,
        0.009592841,
        -0.01966895,
        -0.043977257,
        0.026627988,
        0.0020025359,
        0.040473577,
        0.026869621,
        -0.060359992,
        -0.04530624,
        -0.017458005,
        -0.009393494,
        -0.0055273613,
        -0.022955162,
        -0.009870719,
        -0.015150406,
        0.05871689,
        -0.013966404,
        0.025468148,
        0.02578227,
        -0.08442667,
        -0.024078757,
        0.015585347,
        0.053739242,
        0.012806564,
        0.0037996834,
        -0.037622303,
        -0.05538235,
        -0.023136387,
        -0.035302624,
        -0.015657837,
        -0.007841,
        0.013144851,
        0.022496058,
        0.0012617788,
        0.00834843,
        0.025299005,
        -0.05228944,
        -0.030083343,
        0.0026700478,
        -0.002352904,
        -0.09157901,
        0.049124047,
        0.042068355,
        -0.03252384,
        -0.0009959822,
        0.008070552,
        0.04885825,
        -0.052821036,
        -0.0436873,
        0.011386968,
        0.055092387,
        -0.03491601,
        -0.012879054,
        0.011362805,
        -0.018992376,
        -0.008475288,
        0.049196538,
        -0.02242357,
        -0.032064736,
        0.049679805,
        -0.035085153,
        -0.02213361,
        -0.010335864,
        -0.08437834,
        -0.003434213,
        0.023100141,
        -0.0072489986,
        -0.03921708,
        -0.0049987887,
        -0.020454258,
        -0.008294063,
        -0.024417043,
        -0.044460524,
        -0.028343584,
        -0.0135797905,
        -0.0480367,
        -0.027425377,
        -0.044025585,
        -0.0124682775,
        -0.002287965,
        0.0052162586,
        0.01953605,
        -0.020502584,
        0.010770803,
        0.011350723,
        -0.0069892425,
        0.005352177,
        -0.017409679,
        0.053545937,
        0.038202222,
        -0.013313994,
        0.023329694,
        0.015669918,
        -0.0039235204,
        0.025758108,
        -0.00900688,
        -0.016008206,
        -0.02308806,
        -0.060601626,
        -0.012685747,
        -0.01749425,
        -0.049341515,
        0.027207907,
        -0.03107404,
        -0.012160195,
        0.052579403,
        0.054270834,
        0.013374402,
        -0.0012527176,
        -0.0019481684,
        -0.0086625535,
        0.052434422,
        -0.026579661,
        0.008215532,
        -0.0005731239,
        -0.0005285728,
        -0.00012638554,
        0.035544258,
        -0.01611694,
        -0.03999031,
        0.013350239,
        -0.04284158,
        0.0011122682,
        0.0026428641,
        -0.012021256,
        0.04361481,
        -0.0046876855,
        -0.014280527,
        -0.031823102,
        0.016467309,
        0.010184843,
        -0.012987789,
        0.03100155,
        -0.012281012,
        0.012613257,
        0.007841,
        0.010752681,
        -0.0041198474,
        -0.04426722,
        -0.018750742,
        -0.0013093504,
        -0.0060740565,
        0.024767412,
        -0.023269285,
        0.028005298,
        -0.02802946,
        -0.018327884,
        -0.03404613,
        -0.021759078,
        -0.02184365,
        -0.0027802929,
        0.046514407,
        -0.051806174,
        0.0024676798,
        0.039821167,
        -0.022544386,
        -0.044557177,
        -0.012202481,
        0.019572295,
        0.0006977161,
        -0.0028407013,
        0.009677413,
        0.00066260376,
        0.03759814,
        -0.048085023,
        0.024815738,
        -0.044992115,
        0.00522532,
        -0.013712688,
        0.07350484,
        -0.028851014,
        -0.008118878,
        -0.04537873,
        0.0044188686,
        0.045185424,
        0.0070677735,
        0.036559116,
        0.0057327496,
        -0.0075329174,
        0.0052827075,
        0.0027787827,
        0.037139036,
        0.0012315747,
        -0.038129732,
        0.028295258,
        -0.047046,
        -0.03527846,
        -0.032789636,
        -0.0025658435,
        0.016503554,
        0.0053914427,
        0.013567708,
        0.08273523,
        -0.00016744432,
        -0.014485915,
        -0.018762825,
        -0.020985851,
        -0.0061163423,
        0.036510788,
        -0.039434552,
        0.032185555,
        0.031339835,
        -0.017288862,
        -0.011942725,
        0.006808018,
        0.015851144,
        -0.025250679,
        -0.023172632,
        0.059345134,
        -0.033514537,
        0.036438297,
        0.0032620493,
        -0.03382866,
        0.010233169,
        0.033973638,
        -0.018509109,
        0.011803786,
        -0.06267967,
        -0.01205146,
        -0.003636581,
        -0.0028709054,
        -0.024586186,
        -0.027352888,
        0.017530495,
        0.025927251,
        0.03783977,
        -0.009103534,
        -0.047432613,
        0.028802687,
        -0.0012640441,
        0.0171318,
        0.0041440106,
        -0.032427188,
        0.015621591,
        -0.028198604,
        -0.04037692,
        0.0030113547,
        -0.033369556,
        -0.02214569,
        0.08998423,
        0.05436749,
        -0.033127923,
        0.010698314,
        0.002664007,
        -0.01575449,
        0.037863936,
        -0.007128182,
        0.008215532,
        -0.019439397,
        -0.021118749,
        -0.0017986577,
        -0.037743118,
        0.030904897,
        -0.0043252357,
        -0.018642008,
        0.01582698,
        -0.003207682,
        0.026652152,
        -0.039507043,
        0.03926541,
        0.022556467,
        -0.015271223,
        0.049414005,
        0.04426722,
        -0.017325107,
        0.023293449,
        -0.077226,
        -0.010269415,
        0.0055303816,
        0.020526748,
        0.011103049,
        0.046876855,
        0.0003705673,
        0.013761016,
        -0.03803308,
        0.0034493152,
        0.010505007,
        -0.00046438896,
        -0.02984171,
        -0.0066449153,
        -0.023909613,
        -0.017880863,
        0.032354698,
        -0.022616874,
        0.020732136,
        0.0052585443,
        -0.012951544,
        0.01386975,
        0.016346492,
        0.021505361,
        0.028005298,
        0.03805724,
        0.007732265,
        0.016080694,
        -0.014679222,
        -0.038371366,
        -0.022556467,
        0.003304335,
        0.04653857,
        0.04617612,
        0.0011991052,
        -0.01582698,
        0.036969893,
        0.014292609,
        0.04298656,
        -0.008849819,
        0.011912521,
        -0.009574719,
        -0.03179894,
        0.040231943,
        0.017844617,
        0.07543791,
        -0.0055938107,
        -0.018895723,
        0.03230637,
        -0.036534954,
        -0.0054639326,
        0.022061119,
        0.045330405,
        -0.02672464,
        0.057895336,
        0.011272193,
        -0.0052827075,
        0.04663522,
        0.059345134,
        0.007128182,
        -0.00058898114,
        0.049776457,
        0.029817548,
        0.02737705,
        0.020091807,
        -0.014763794,
        -0.014570487,
        0.010704354,
        0.022532303,
        -0.015198734,
        -0.019560214,
        0.012939462,
        0.027787827,
        -0.013156932,
        0.030010853,
        0.014763794,
        -0.0010767783,
        -0.006336833,
        0.021589933,
        -0.020575074,
        -0.004965564,
        0.015875306,
        0.03469854,
        -0.02933428,
        0.06316294,
        -0.0076114484,
        0.060166687,
        0.035810053,
        -0.03682491,
        -0.0017322086,
        0.0023317612,
        0.03846802,
        0.028343584,
        0.012891135,
        -0.03020416,
        0.045837834,
        0.019052785,
        0.0014022281,
        -0.057605375,
        -0.0060287504,
        -0.01901654,
        -0.034940172,
        0.03100155,
        0.0089766765,
        0.016044449,
        0.0021082503,
        -0.006191853,
        -0.018388294,
        0.0134227285,
        0.033707842,
        0.023148468,
        0.052579403,
        -0.009260596,
        -0.048882414,
        -0.027763665,
        0.0039446633,
        0.022846427,
        0.007726224,
        0.014485915,
        -0.012063541,
        -0.011797745,
        -0.03230637,
        -0.010178802,
        0.015669918,
        -0.0124682775,
        -0.0104929255,
        0.01894405,
        -0.019946827,
        -0.050839644,
        0.055189043,
        0.024078757,
        -0.015186652,
        0.00054254226,
        -0.021142913,
        -0.006687201,
        -0.006910712,
        -0.011743378,
        0.023692144,
        -0.017699638,
        0.023353856,
        0.024441207,
        -0.00010637528,
        -0.028416075,
        -0.042938236,
        -0.012148113,
        0.006191853,
        -0.012564931,
        -0.03542344,
        -0.029116811,
        0.016201511,
        -0.009230391,
        -0.018992376,
        0.0198985,
        -0.074036434,
        -0.044774648,
        -0.0063428734,
        0.0034070292,
        -0.016636452,
        -0.0634529,
        0.07239333,
        -0.037863936,
        3.0628908e-05,
        -0.0299142,
        -0.0299142,
        -0.031267345,
        0.009351208,
        -0.009103534,
        -0.005886791,
        -0.024066675,
        -0.014208037,
        0.030349141,
        -0.01895613,
        0.06408115,
        0.008016184,
        -0.0042165006,
        0.0012187379,
        -0.025613127,
        -0.035012662,
        -0.007297325,
        0.013024034,
        -0.015814899,
        -7.569918e-05,
        -0.02962424,
        -0.02214569,
        -0.007961817,
        -0.045354567,
        0.0052827075,
        -0.0027108234,
        0.021722833,
        0.010565415,
        -0.012673666,
        -0.012099787,
        0.04581367,
        0.02889934,
        -0.025105698,
        0.013495219,
        0.009375371,
        -0.016986819,
        0.0069711204,
        -0.047070164,
        0.048882414,
        0.018569518,
        -0.016358573,
        -0.027401214,
        -0.008263858,
        0.0014581059,
        -0.0072671208,
        -0.022520222,
        -0.010897661,
        -0.0021460056,
        -0.07012198,
        0.012589094,
        -0.006518058,
        0.010939946,
        0.022061119,
        0.01684184,
        -0.022701446,
        -0.0041983784,
        0.027159581,
        0.0004326746,
        -0.016394818,
        -0.003811765,
        -0.012244767,
        -0.009115616,
        -0.00914582,
        0.018279558,
        0.011441336,
        -0.036897402,
        0.022773936,
        0.019064866,
        -0.04218917,
        -0.011362805,
        0.05494741,
        0.028174441,
        0.0062764245,
        0.020019317,
        -0.010637905,
        -0.040666882,
        0.015041672,
        0.0023680062,
        -0.04252746,
        0.0034764989,
        -0.013326076,
        0.041053496,
        0.00544581,
        -0.027546193,
        0.012854891,
        -0.013169014,
        0.006663038,
        0.024562024,
        0.050742988,
        0.007158386,
        -0.009780107,
        0.007895367,
        -0.013809342,
        -0.020128053,
        -0.021541607,
        0.005183034,
        -0.017941272,
        0.010903702,
        -0.0056028715,
        -0.00024578636,
        0.019717276,
        0.0052011563,
        0.001059411,
        0.01807417,
        0.009441821,
        0.01110909,
        0.004588012,
        -0.029672567,
        0.026386354,
        0.011779622,
        -0.016177349,
        -0.009737821,
        0.01763923,
        -0.0031200896,
        -0.029285954,
        -0.014485915,
        -0.0015373918,
        -0.015911551,
        0.049196538,
        0.044243053,
        -0.0025326188,
        -0.02737705,
        -0.019753521,
        0.0037362545,
        -0.0032348656,
        -0.025806434,
        0.014618814,
        0.043204032,
        0.010082149,
        0.01902862,
        0.032572165,
        0.03914459,
        -0.0013199218,
        -0.0024329452,
        -0.037066545,
        -0.013845587,
        0.031049877,
        -0.0020931484,
        -0.00522834,
        -0.024707003,
        0.030300813,
        0.004455114,
        -0.050211396,
        0.023498837,
        -0.01633441,
        0.024066675,
        -0.0084934095,
        0.009176024,
        0.02026095,
        -0.03740483,
        -0.00019972501,
        -0.0047299713,
        0.008801492,
        0.015138325,
        0.014208037,
        0.0049202577,
        -0.004035276,
        -0.0270146,
        0.03233053,
        0.023257203,
        0.022121526,
        0.04617612,
        -0.008016184,
        -0.09684662,
        0.0011877787,
        0.009321004,
        0.0177238,
        -0.010631865,
        -0.00067581807,
        -0.03803308,
        -0.023353856,
        0.013120688,
        0.03527846,
        0.002286455,
        -0.0006237159,
        0.0026292722,
        -0.012842809,
        -0.008825656,
        -0.011743378,
        0.010752681,
        0.029140973,
        0.035157643,
        0.037018217,
        -0.021154994,
        -0.054270834,
        -0.035471767,
        -0.020502584,
        0.0088619,
        -0.06234139,
        -0.031895593,
        -0.008553818,
        0.037936427,
        -0.0008064511,
        0.0076054074,
        0.005343116,
        -0.0062341387,
        -0.043832276,
        0.016068613,
        -0.0060076076,
        -0.025347332,
        -0.036244992,
        -0.008499451,
        -0.04624861,
        0.03187143,
        -0.017361352,
        -0.0077141426,
        0.026120558,
        0.006330792,
        -0.029769221,
        -0.014075139,
        0.007303366,
        0.015029591,
        -0.02969673,
        0.03883047,
        -0.02926179,
        0.007816836,
        -0.0010103291,
        -0.005554545,
        0.027159581,
        0.004905156,
        0.014606732,
        -0.0021384545,
        -0.024767412,
        0.009085411,
        -0.02032136,
        -0.021034177,
        -0.040086962,
        -0.0038359284,
        0.021589933,
        0.026120558,
        0.0027636806,
        -0.022338998,
        0.013036116,
        0.025395658,
        0.033490375,
        0.005690464,
        4.7500762e-05,
        0.011380928,
        -0.0031351917,
        -0.021505361,
        -0.0018031884,
        -0.03291045,
        0.007931612,
        0.015452448,
        0.013543545,
        0.0003365876,
        -0.00791349,
        0.029237628,
        0.026120558,
        -0.0041228677,
        0.011695051,
        -0.01139301,
        0.037549812,
        -0.044388033,
        -0.03201641,
        -0.0012421461,
        0.007194631,
        0.038153894,
        -0.013700607,
        0.047819227,
        -0.038782142,
        -0.10912159,
        -0.00915186,
        0.001190799,
        -0.03172645,
        0.009755944,
        -0.01524706,
        0.012335379,
        0.016382737,
        -0.009550556,
        -0.012903217,
        -0.031098204,
        -0.031895593,
        -0.0017729842,
        0.037573975,
        -0.0006176751,
        -0.017023064,
        -0.03114653,
        0.0028875177,
        0.026048068,
        -0.03237886,
        -0.012256849,
        0.010921825,
        -0.0023075978,
        0.007804755,
        -0.043928932,
        0.0012187379,
        0.006222057,
        0.027256234,
        -0.005744831,
        0.0014898202,
        0.0044973996,
        -0.0016249839,
        -0.011042641,
        0.037090708,
        -0.025540639,
        0.00017556168,
        0.011652765,
        -0.005219279,
        -0.01800168,
        0.016153185,
        0.024078757,
        -0.024187492,
        0.022338998,
        -0.06403282,
        0.004560828,
        0.017917108,
        -0.0149571,
        -0.0011704112,
        0.003826867,
        0.05349761,
        0.0030793143,
        0.03324874,
        -0.01691433,
        -0.02969673,
        -0.022894753,
        0.012830728,
        0.007236917,
        0.013024034,
        -0.008143041,
        0.031702287,
        -0.027062928,
        -0.019620623,
        0.03928957,
        -0.009900924,
        -0.033490375,
        0.010752681,
        -0.029116811,
        -0.023353856,
        0.0024737208,
        0.019282335,
        -0.021734914,
        2.2936285e-05,
        -0.016467309,
        -0.0139059955,
        -0.03733234,
        0.030179996,
        0.018690335,
        -0.02055091,
        -0.0150175085,
        0.013144851,
        0.048471637,
        -0.0075147953,
        0.0054578916,
        0.025637291,
        -0.0022018834,
        0.023184713,
        0.017409679,
        0.045982815,
        -0.0033556821,
        0.057653703,
        -0.020067643,
        -0.027787827,
        0.013555627,
        0.00726108,
        -0.039434552,
        0.04175423,
        0.018484946,
        -0.03803308,
        0.01894405,
        -0.0063730776,
        0.020925442,
        0.06263135,
        0.004871931,
        0.00043758278,
        0.008028266,
        0.029358445,
        -0.05808864,
        0.021287892,
        -2.7520002e-06,
        0.03339372,
        0.0039446633,
        0.014437589,
        -0.03622083,
        0.025975578,
        -0.01466714,
        -0.03368368,
        0.012601175,
        0.015222897,
        0.00544581,
        0.0153316315,
        -0.00014667895,
        0.031702287,
        -0.03680075,
        0.035036825,
        -0.015802817,
        0.03143649,
        -0.00406548,
        -0.004298052,
        -0.012015215,
        0.025057372,
        0.016394818,
        -0.0015706164,
        -0.009979455,
        0.054560795,
        0.0025431903,
        0.02491239,
        0.036969893,
        -0.009991536,
        -0.017143881,
        0.02962424,
        0.019777684,
        0.0066690785,
        -0.005273646,
        -0.00010429874,
        -0.016938493,
        0.008233654,
        0.03745316,
        -0.0361725,
        -0.059055176,
        0.038902957,
        -0.014050975,
        -0.029140973,
        0.014751712,
        0.014389262,
        0.017300943,
        0.043300685,
        -0.0010986764,
        -0.02119124,
        -0.0033798455,
        -0.048374984,
        -0.0019647807,
        0.026023904,
        0.0040715206,
        -0.040763535,
        0.04107766,
        0.026676314,
        -0.009834475,
        -0.02301557,
        0.005167932,
        0.011586316,
        -0.040256105,
        -0.017965434,
        -0.029865874,
        -0.009592841,
        -0.010631865,
        0.0019844132,
        -0.024525778,
        0.017313024,
        0.029310117,
        0.029358445,
        0.0008555328,
        0.04064272,
        -0.0011968398,
        0.005204177,
        0.021577852,
        -0.042237498,
        -0.012407869,
        -0.0073637743,
        -0.0051165847,
        -0.021626178,
        0.02802946,
        0.020309277,
        -0.005910954,
        0.04719098,
        0.005889811,
        0.02969673,
        -0.0061797714,
        0.014232201,
        0.04057023,
        -0.029310117,
        -0.012407869,
        0.002446537,
        0.019451478,
        -0.06156816,
        0.015597428,
        0.059345134,
        0.0057267086,
        -0.00067204254,
        -0.027401214,
        -0.015138325,
        0.011314479,
        0.016878085,
        -0.01937899,
        0.0034493152,
        -0.013338157,
        0.029116811,
        0.037477322,
        -0.0011590846,
        -0.040231943,
        -0.030687427,
        -0.023583408,
        -0.020176379,
        0.022483977,
        -0.0057236883,
        -0.0071040187,
        0.026990438,
        0.020720053,
        0.015742408,
        0.011948766,
        0.002707803,
        -0.0019919644,
        0.012504523,
        -0.0006237159,
        -0.0052796872,
        0.021287892,
        -0.023837123,
        -0.010057986,
        -0.0069288346,
        5.144146e-05,
        0.029310117,
        0.024525778,
        -0.020152215,
        -0.0010337374,
        -0.012746155,
        0.023426346,
        -0.029865874,
        0.014316772,
        0.016721023,
        0.015718246,
        -0.009641168,
        -0.036414135,
        -0.0017518413,
        0.021034177,
        -0.030300813,
        0.030663263,
        -0.027183745,
        0.027401214,
        0.038129732,
        0.0016355553,
        -0.0047511146,
        -0.0030264568,
        -0.0034221313,
        -0.008052429,
        -0.015706163,
        -0.031750612,
        -0.015041672,
        -0.01742176,
        0.012220603,
        0.011882316,
        -0.00074302236,
        0.017482167,
        0.024731167,
        -0.024586186,
        0.0010790436,
        -0.0138939135,
        -0.009375371,
        -0.010148598,
        -0.00820345,
        0.013628117,
        -0.030518284,
        -0.020055562,
        0.030083343,
        0.009562637,
        0.043276522,
        0.033007108,
        -0.0484958,
        0.029745057,
        -0.011097008,
        0.04769841,
        -0.02984171,
        -0.005119605,
        0.015089998,
        -0.008288021,
        -0.009429739,
        -0.019004459,
        -0.00108886,
        0.008481328,
        -0.024429126,
        -0.0035308662,
        -0.035955034,
        -0.013434811,
        0.024308309,
        0.018279558,
        -0.039603695,
        0.034746867,
        0.007049651,
        -0.06359788,
        -0.00071470597,
        -0.009725739,
        -0.019910583,
        0.0036184585,
        -0.005554545,
        -0.00027183743,
        0.011241988,
        0.0006252261,
        -0.009617005,
        0.0077383057,
        0.00871088,
        -0.008088674,
        0.0405219,
        0.0067113643,
        0.024199573,
        -0.0032348656,
        -0.02578227,
        -0.029527588,
        0.009182065,
        0.03020416,
        0.0042467047,
        0.007726224,
        -0.036776587,
        0.011568193,
        0.02301557,
        0.02868187,
        -0.025637291,
        -0.028923504,
        -0.00041832763,
        -0.059490114,
        -0.0036124175,
        -0.0075027132,
        -0.0135797905,
        -0.022338998,
        -0.024960717,
        -0.006759691,
        -0.005270626,
        -0.010873497,
        -0.003428172,
        -0.016817676,
        0.01190648,
        -0.017288862,
        0.025371494,
        0.075244606,
        0.0047420533,
        -0.021952383,
        0.008547777,
        0.008082633,
        0.004240664,
        -0.01837621,
        -0.0021535566,
        0.013156932,
        -0.044508852,
        0.003237886,
        0.0055575655,
        0.0013380443,
        0.02082879,
        0.025685618,
        -0.017627148,
        -0.008245735,
        0.03056661,
        0.011725255,
        -0.023945859,
        0.0041500516,
        0.010589578,
        -0.00069582835,
        0.016358573,
        0.005418626,
        0.023788797,
        0.023027651,
        -0.0071765087,
        0.0067415684,
        0.009411616,
        0.009018962,
        -0.00370303,
        -0.02578227,
        -0.003295274,
        -0.027811991,
        0.0022184956,
        -0.021638261,
        0.0140630575,
        -0.010535211,
        -0.046079468,
        -0.020297196,
        -0.013060279,
        -0.033732004,
        0.023462592,
        0.06045665,
        0.020756299,
        -0.019451478,
        0.016866002,
        0.0029177219,
        -0.0022547406,
        -0.0008902676,
        0.012999871,
        -0.022375243,
        -0.04189921,
        -0.0036547035,
        -0.016926412,
        0.003796663,
        0.016636452,
        -0.0021022095,
        -0.0021384545,
        -0.025516475,
        -0.025226515,
        0.015585347,
        0.047239307,
        0.023365939,
        -0.026048068,
        0.02243565,
        -0.006512017,
        -0.025033208,
        0.038153894,
        -0.036051687,
        -0.0028558034,
        -0.0016249839,
        0.010396272,
        -0.010752681,
        0.04958315,
        0.0147033855,
        0.017083474,
        0.0015675959,
        -0.014268446,
        -0.010523129,
        0.012383706,
        -0.029527588,
        -0.039313734,
        -0.01336232,
        0.004231603,
        0.009810312,
        0.025299005,
        -0.03660744,
        0.020297196,
        -0.03984533,
        -0.03100155,
        -0.020345522,
        0.008070552,
        0.01153799,
        -0.02323304,
        0.02933428,
        0.018315803,
        -0.048254166,
        -0.014365098,
        -0.020079726,
        -0.016636452,
        0.01865409,
        0.0006686446,
        -0.056735493,
        0.00023615878,
        -0.044243053,
        0.007998061,
        0.00675365,
        -0.004436991,
        0.0047813184,
        0.015669918,
        -0.016346492,
        0.020309277,
        -0.02149328,
        0.021602016,
        -0.030832406,
        -0.019777684,
        -0.020055562,
        -0.035785887,
        0.019644786,
        -0.003043069,
        3.8840662e-05,
        -0.007575203,
        7.041345e-05,
        0.018279558,
        -0.002213965,
        -0.014268446,
        -0.022520222,
        0.025323167,
        0.0043735625,
        -0.003796663,
        0.03259633,
        0.02947926,
        0.008112838,
        -0.014655058,
        -0.010625823,
        0.0024087818,
        -0.02417541,
        0.0120756235,
        -0.028633544,
        -0.016503554,
        -0.040328596,
        0.031992245,
        -0.04115015,
        0.023124306,
        -0.022471895,
        -0.013555627,
        0.022556467,
        0.0412468,
        0.007134223,
        -0.013736852,
        -0.013640199,
        0.0020387808,
        -0.0058354437,
        0.00020312298,
        0.025806434,
        -0.012625339,
        1.3001947e-05,
        -0.013603954,
        -0.014353017,
        0.019523969,
        0.008722962,
        -0.016817676,
        0.003790622,
        0.008281981,
        0.009314963,
        0.007702061,
        0.018448701,
        0.016612288,
        0.006469731,
        -0.028657706,
        0.02381296,
        -0.0077624694,
        -0.02149328,
        0.03629332,
        0.01836413,
        -0.014473834,
        -0.008167205,
        0.0017835557,
        0.004433971,
        0.027232071,
        0.012063541,
        -0.017095555,
        0.02155369,
        -0.016890166,
        0.0111211715,
        -0.017772129,
        -0.0021807405,
        -0.0060287504,
        0.0067053237,
        -0.0076114484,
        -0.017844617,
        -0.010958069,
        0.019560214,
        0.025057372,
        0.0008698798,
        -0.042358313,
        -0.011241988,
        0.04537873,
        -0.009846556,
        0.00076982856,
        0.002795395,
        -0.0021505363,
        0.0038782142,
        -0.018207068,
        0.018617844,
        0.006367037,
        0.023220958,
        0.009109574,
        0.072345,
        -0.012419951,
        0.00039831735,
        0.0067415684,
        0.010861416,
        0.017699638,
        -0.0045125014,
        0.010202966,
        0.004554787,
        0.0108070485,
        0.003724173,
        -0.051516216,
        -0.018980294,
        0.0010994314,
        -0.04885825,
        0.015234979,
        0.009731781,
        -0.011248029,
        -0.0025718843,
        -0.0015630653,
        0.023861287,
        0.0008019205,
        0.016310247,
        -0.0029947425,
        -0.001524555,
        -0.013156932,
        -0.05422251,
        0.046586897,
        0.02330553,
        -0.010287537,
        -0.033852823,
        0.014981263,
        0.02998669,
        0.0062462203,
        0.012685747,
        0.039047938,
        0.0020780463,
        0.026289701,
        0.007853081,
        -0.019584378,
        -0.01560951,
        -0.004485318,
        -0.0108855795,
        -0.043808114,
        -0.01401473,
        -0.038250547,
        0.00051384827,
        -0.017397596,
        0.0040503778,
        0.00994321,
        -0.017337188,
        0.004183276,
        -0.033804495,
        0.007224835,
        -0.00061691995,
        -0.012999871,
        -0.02242357,
        -0.025733944,
        -0.013120688,
        -0.004853809,
        0.009435779,
        0.016684778,
        -0.04173007,
        -0.009236433,
        0.009484107,
        -0.002155067,
        0.008414879,
        -0.02018846,
        0.026966274,
        0.0036063767,
        0.051999483,
        -0.002497884,
        -0.0463211,
        -0.0025175167,
        0.021022096,
        0.012256849,
        -0.00965325,
        -0.0025190269,
        0.026362192,
        0.009997577,
        0.03796059,
        -0.011664847,
        -0.0018756783,
        -0.016588125,
        0.00046929714,
        0.003180498,
        0.022906834,
        -0.0089766765,
        0.028053625,
        0.0022668221,
        -0.031194856,
        0.013241504,
        0.013821424,
        -0.031460654,
        -0.012589094,
        -0.010764763,
        0.01401473,
        0.021227485,
        -0.026748804,
        0.025975578,
        -0.0015811878,
        0.021106668,
        -0.024380798,
        0.0016325349,
        -0.0071040187,
        0.033007108,
        0.0200314,
        0.019620623,
        -0.03078408,
        0.035254296,
        -0.02904432,
        0.027473705,
        0.013338157,
        -0.015138325,
        -0.0018817192,
        -0.008813574,
        -0.012637421,
        -0.0005844505,
        0.04276909,
        -0.0059200153,
        0.04371146,
        -0.0135797905,
        0.0092907995,
        0.016358573,
        0.03421527,
        0.012148113,
        -0.0013516361,
        0.024864065,
        -0.018025843,
        0.0037694792,
        0.0036577238,
        0.014679222,
        -0.0025658435,
        0.0105593745,
        -0.01626192,
        0.022628957,
        0.004014133,
        -0.0043312768,
        -0.0028663748,
        0.008608186,
        -0.019415235,
        -0.023390101,
        -0.018050006,
        -0.043155704,
        -0.0067113643,
        0.0034795192,
        -0.03013167,
        -0.02055091,
        -0.050066415,
        0.023619654,
        -0.03984533,
        -0.016793514,
        -0.020393848,
        -0.007128182,
        0.025999742,
        0.022483977,
        -0.019475643,
        -0.0019406173,
        0.012208521,
        -0.03100155,
        0.04755343,
        0.025806434,
        0.0105714565,
        0.019064866,
        -0.016926412,
        -0.0035187847,
        -0.0150054265,
        0.0038963368,
        0.0021580872,
        -0.0045638485,
        0.004056419,
        0.01830372,
        -0.0012006154,
        -0.013978485,
        0.009532433,
        -0.0033587026,
        0.006119363,
        -0.013120688,
        -0.015851144
      ],
      "embedding_pca_2d": [],
      "embedding_pca_3d": [],
      "embedding_cluster_id": null,
      "migration_history": [],
      "metadata": {
        "compute_time": 2.0111050605773926,
        "patch_type": "diff",
        "api_costs": 0.0081465,
        "num_applied": 1,
        "patch_name": "precedence_closure_greedy_with_marginal_gain",
        "patch_description": "Improve the baseline greedy solver to account for precedence dependencies, group/mutex constraints and pairwise interactions more intelligently.\n\nKey changes:\n- Build a precedence graph and compute ancestor (prerequisite) closure so selecting an item will also consider and include required predecessors.\n- Parse interaction keys more robustly and precompute a dictionary keyed by (u, v) tuples for fast lookup.\n- Use a marginal-gain greedy: at each step consider adding an item together with its ancestor closure (if not already selected), check feasibility (mutex/group/cardinality), and compute the marginal objective gain including interactions among closure and between closure and already-selected items. Pick the closure with maximum marginal gain.\n- If no positive-marginal move is available but minimum cardinality is not met, continue selecting best feasible closures (even if marginal <= 0) until min cardinality is reached.\n- Better group checks by mapping variables to their group for quick testing.\n- Robust handling of malformed interaction keys and precedence entries.\n\nThis targeted improvement increases the quality of the constructed solution by being precedence-aware, respecting constraints when adding whole prerequisite chains, and using interaction-aware marginal scoring rather than naive weight-only sorting.",
        "error_attempt": null,
        "novelty_attempt": 1,
        "resample_attempt": 1,
        "patch_attempt": 1,
        "model_name": "gpt-5-mini",
        "temperature": 1.0,
        "max_output_tokens": 8192,
        "llm_result": {
          "content": "<NAME>\nprecedence_closure_greedy_with_marginal_gain\n</NAME>\n\n<DESCRIPTION>\nImprove the baseline greedy solver to account for precedence dependencies, group/mutex constraints and pairwise interactions more intelligently.\n\nKey changes:\n- Build a precedence graph and compute ancestor (prerequisite) closure so selecting an item will also consider and include required predecessors.\n- Parse interaction keys more robustly and precompute a dictionary keyed by (u, v) tuples for fast lookup.\n- Use a marginal-gain greedy: at each step consider adding an item together with its ancestor closure (if not already selected), check feasibility (mutex/group/cardinality), and compute the marginal objective gain including interactions among closure and between closure and already-selected items. Pick the closure with maximum marginal gain.\n- If no positive-marginal move is available but minimum cardinality is not met, continue selecting best feasible closures (even if marginal <= 0) until min cardinality is reached.\n- Better group checks by mapping variables to their group for quick testing.\n- Robust handling of malformed interaction keys and precedence entries.\n\nThis targeted improvement increases the quality of the constructed solution by being precedence-aware, respecting constraints when adding whole prerequisite chains, and using interaction-aware marginal scoring rather than naive weight-only sorting.\n</DESCRIPTION>\n\n<DIFF>\n<<<<<<< SEARCH\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    This is a greedy baseline - evolution will improve this.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    # Simple greedy: select items with highest weights first\n    # This is a baseline - evolution will find better strategies\n    n = len(weights)\n    selected = []\n    \n    # Create score list (weight + interaction potential)\n    scores = []\n    for i in range(n):\n        score = weights[i] if i < len(weights) else 0.0\n        # Add potential interaction value\n        for k, v in interactions.items():\n            try:\n                u, w = map(int, k.split(\",\"))\n                if u == i or w == i:\n                    score += abs(v) * 0.5  # Potential value\n            except:\n                pass\n        scores.append((score, i))\n    \n    # Sort by score descending\n    scores.sort(reverse=True)\n    \n    # Greedy selection respecting constraints\n    selected_set = set()\n    for score, i in scores:\n        if len(selected_set) >= cardinality_bounds[1]:\n            break\n            \n        # Check mutex constraints\n        can_add = True\n        for a, b in mutex:\n            if (a == i and b in selected_set) or (b == i and a in selected_set):\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n            \n        # Check group constraints (at most one per group)\n        for grp_vars in groups.values():\n            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n        \n        # Check precedence (if j selected, i must be selected)\n        precedence_ok = True\n        for pred_i, pred_j in precedence:\n            if pred_j == i and pred_i not in selected_set:\n                precedence_ok = False\n                break\n        \n        if not precedence_ok:\n            continue\n        \n        # Add if we meet minimum cardinality or have room\n        if len(selected_set) < cardinality_bounds[1]:\n            selected_set.add(i)\n            selected.append(i)\n    \n    # Ensure minimum cardinality\n    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n        for i in range(n):\n            if i not in selected_set:\n                selected_set.add(i)\n                selected.append(i)\n                break\n    \n    # Output result\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected)\n        }\n    }\n    print(json.dumps(result))\n=======\ndef solve_sds():\n    \"\"\"\n    Improved solver for the Synergistic Dependency Selection problem.\n\n    - Reads JSON from stdin with \"requirements\" and \"catalog\".\n    - Produces JSON to stdout with \"selection\": {\"variables\": [...] }.\n    - Uses a precedence-aware marginal-gain greedy algorithm that:\n        * when adding an item, also includes its required predecessors (closure),\n        * computes the marginal objective (weights + pairwise interactions),\n        * checks mutex/group/cardinality feasibility for the closure before adding.\n    \"\"\"\n    import re\n\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n\n    # Extract constraints\n    weights = list(requirements.get(\"weights\", []))\n    interactions_raw = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    min_card, max_card = (cardinality_bounds + [len(weights), len(weights)])[:2]\n    mutex = [tuple(m) for m in requirements.get(\"mutex\", [])]\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n\n    n = len(weights)\n\n    # Parse interactions into dict of tuple->float for quick lookup (undirected)\n    interactions = {}\n    for k, v in interactions_raw.items():\n        try:\n            if isinstance(k, str):\n                # allow \"u,v\" or \"u v\"\n                parts = re.split(r'\\s*,\\s*|\\s+', k.strip())\n                if len(parts) >= 2:\n                    u = int(parts[0]); w = int(parts[1])\n                else:\n                    continue\n            elif isinstance(k, (list, tuple)) and len(k) >= 2:\n                u = int(k[0]); w = int(k[1])\n            else:\n                continue\n            interactions[(u, w)] = float(v)\n            interactions[(w, u)] = float(v)\n        except Exception:\n            # skip malformed keys\n            continue\n\n    # Build precedence graph: if (p, j) then p is a prerequisite of j\n    preds = {i: set() for i in range(n)}\n    succs = {i: set() for i in range(n)}\n    for entry in precedence:\n        try:\n            a, b = entry\n            a = int(a); b = int(b)\n            preds[b].add(a)\n            succs[a].add(b)\n        except Exception:\n            continue\n\n    # Precompute ancestors (transitive closure of preds) using DFS/memoization\n    ancestor_cache = {}\n\n    def get_ancestors(i):\n        if i in ancestor_cache:\n            return ancestor_cache[i].copy()\n        res = set()\n        stack = [i]\n        while stack:\n            cur = stack.pop()\n            for p in preds.get(cur, []):\n                if p not in res:\n                    res.add(p)\n                    stack.append(p)\n        ancestor_cache[i] = res.copy()\n        return res\n\n    # Map variable -> group (assume at most one group membership; if multiple, first wins)\n    var_to_group = {}\n    for gname, vars_list in groups.items():\n        for v in vars_list:\n            try:\n                var_to_group[int(v)] = gname\n            except Exception:\n                pass\n\n    # Helper: check feasibility of adding a closure set given current selected_set\n    def feasible_closure(closure_set, selected_set):\n        # Cardinality\n        if len(selected_set) + len(closure_set - selected_set) > max_card:\n            return False\n        # Mutex: none of closure can conflict with each other or with selected_set\n        for a, b in mutex:\n            if a in closure_set and b in closure_set:\n                return False\n            if (a in closure_set and b in selected_set) or (b in closure_set and a in selected_set):\n                return False\n        # Group: ensure at most one per group overall\n        # Build per-group counts\n        group_counts = {}\n        for v in selected_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in closure_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: closure itself must include ancestors for each element\n        for v in closure_set:\n            if not get_ancestors(v).issubset(closure_set.union(selected_set)):\n                return False\n        return True\n\n    # Compute marginal gain of adding closure_set (items that will be newly included)\n    def marginal_gain(closure_set, selected_set):\n        new_items = set(closure_set) - set(selected_set)\n        gain = 0.0\n        for i in new_items:\n            if i < len(weights):\n                gain += float(weights[i])\n        # interactions among new items\n        new_list = list(new_items)\n        for i in range(len(new_list)):\n            for j in range(i + 1, len(new_list)):\n                gain += interactions.get((new_list[i], new_list[j]), 0.0)\n        # interactions between new items and already selected\n        for i in new_items:\n            for j in selected_set:\n                gain += interactions.get((i, j), 0.0)\n        return gain\n\n    # Greedy loop: at each step try to add an item (and its ancestors) with max marginal gain\n    selected_set = set()\n    # Keep iterating while we can still add and haven't reached max_card\n    improved = True\n    while len(selected_set) < max_card and improved:\n        improved = False\n        best_gain = float(\"-inf\")\n        best_closure = None\n        # Consider candidates not already selected\n        for i in range(n):\n            if i in selected_set:\n                continue\n            # closure includes i and its ancestors\n            closure = get_ancestors(i).union({i})\n            # Only consider closures that are feasible\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # Prefer closures that add more items when gain is equal (to help reach min_card)\n            if gain > best_gain or (abs(gain - best_gain) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_gain = gain\n                best_closure = closure\n        # If we found a positive-gain move, take it\n        if best_closure is not None and best_gain > -1e-12:\n            to_add = set(best_closure) - selected_set\n            if to_add:\n                selected_set.update(to_add)\n                improved = True\n        else:\n            # No non-negative gain move; stop greedy improvements\n            break\n\n    # If we still haven't met minimum cardinality, greedily add best feasible closures regardless of gain\n    while len(selected_set) < min_card:\n        best_gain = float(\"-inf\")\n        best_closure = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = get_ancestors(i).union({i})\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # choose closure that gives best gain (even if negative), tie-breaker favors larger closures\n            if gain > best_gain or (abs(gain - best_gain) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_gain = gain\n                best_closure = closure\n        if best_closure is None:\n            # No feasible closure remains; break to avoid infinite loop\n            break\n        selected_set.update(set(best_closure) - selected_set)\n\n    # Final trim if over max_card (shouldn't happen due to checks) - keep highest-weight items\n    if len(selected_set) > max_card:\n        # score items by marginal contribution relative to selected (approx): weight + interactions with others\n        def item_score(i):\n            s = float(weights[i]) if i < len(weights) else 0.0\n            for j in selected_set:\n                if j == i:\n                    continue\n                s += interactions.get((i, j), 0.0)\n            return s\n        sorted_items = sorted(selected_set, key=item_score, reverse=True)\n        selected_set = set(sorted_items[:max_card])\n\n    result = {\n        \"selection\": {\n            \"variables\": sorted(int(x) for x in selected_set)\n        }\n    }\n    print(json.dumps(result))\n>>>>>>> REPLACE\n</DIFF>",
          "msg": "\n# Current program\n\nHere is the current program we are trying to improve (you will need to propose a modification to it below):\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    This is a greedy baseline - evolution will improve this.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    # Simple greedy: select items with highest weights first\n    # This is a baseline - evolution will find better strategies\n    n = len(weights)\n    selected = []\n    \n    # Create score list (weight + interaction potential)\n    scores = []\n    for i in range(n):\n        score = weights[i] if i < len(weights) else 0.0\n        # Add potential interaction value\n        for k, v in interactions.items():\n            try:\n                u, w = map(int, k.split(\",\"))\n                if u == i or w == i:\n                    score += abs(v) * 0.5  # Potential value\n            except:\n                pass\n        scores.append((score, i))\n    \n    # Sort by score descending\n    scores.sort(reverse=True)\n    \n    # Greedy selection respecting constraints\n    selected_set = set()\n    for score, i in scores:\n        if len(selected_set) >= cardinality_bounds[1]:\n            break\n            \n        # Check mutex constraints\n        can_add = True\n        for a, b in mutex:\n            if (a == i and b in selected_set) or (b == i and a in selected_set):\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n            \n        # Check group constraints (at most one per group)\n        for grp_vars in groups.values():\n            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n        \n        # Check precedence (if j selected, i must be selected)\n        precedence_ok = True\n        for pred_i, pred_j in precedence:\n            if pred_j == i and pred_i not in selected_set:\n                precedence_ok = False\n                break\n        \n        if not precedence_ok:\n            continue\n        \n        # Add if we meet minimum cardinality or have room\n        if len(selected_set) < cardinality_bounds[1]:\n            selected_set.add(i)\n            selected.append(i)\n    \n    # Ensure minimum cardinality\n    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n        for i in range(n):\n            if i not in selected_set:\n                selected_set.add(i)\n                selected.append(i)\n                break\n    \n    # Output result\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n    \n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n    \n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n    \n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n    \n    result_str = stdout_capture.getvalue()\n    return result_str\n\n\n```\n\nHere are the performance metrics of the program:\n\nCombined score to maximize: 0.35\nfeasible: True; selection_size: 10; raw_score: 106.51\n\n# Instructions\n\nMake sure that the changes you propose are consistent with each other. For example, if you refer to a new config variable somewhere, you should also propose a change to add that variable.\n\nNote that the changes you propose will be applied sequentially, so you should assume that the previous changes have already been applied when writing the SEARCH block.\n\n# Task\n\nSuggest a new idea to improve the performance of the code that is inspired by your expert knowledge of the considered subject.\nYour goal is to maximize the `combined_score` of the program.\nDescribe each change with a SEARCH/REPLACE block.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.\n",
          "system_msg": "You are an expert algorithmist specializing in combinatorial optimization, particularly the Synergistic Dependency Selection (SDS) problem.\n\nThe SDS problem requires selecting a subset of variables that:\n1. Satisfies cardinality bounds (min/max number of items)\n2. Respects mutex constraints (cannot select both items in a mutex pair)\n3. Respects group constraints (at most one item per group)\n4. Satisfies precedence constraints (if j is selected, i must be selected)\n5. Maximizes the objective: sum of selected item weights + pairwise interaction values\n\nKey strategies to explore:\n1. Greedy selection with constraint-aware ordering\n2. Dynamic programming for small instances\n3. Constraint satisfaction with backtracking\n4. Weighted scoring that accounts for interactions\n5. Precedence-aware selection ordering\n6. Group-aware selection that maximizes diversity\n\nThe code should read JSON from stdin with \"requirements\" and \"catalog\", and output JSON to stdout with \"selection\" containing \"variables\" list.\n\nBe creative and find efficient solutions that maximize the objective while respecting all constraints.\nYou MUST repond using a edit name, description and the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n<NAME>\nA shortened name summarizing the edit you are proposing. Lowercase, no spaces, underscores allowed.\n</NAME>\n\n<DESCRIPTION>\nA description and argumentation process of the edit you are proposing.\n</DESCRIPTION>\n\n<DIFF>\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly including indentation)\n=======\n# New replacement code\n>>>>>>> REPLACE\n\n</DIFF>\n\n\nExample of a valid diff format:\n<DIFF>\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n\n</DIFF>\n\n* You may only modify text that lies below a line containing \"EVOLVE-BLOCK-START\" and above the next \"EVOLVE-BLOCK-END\". Everything outside those markers is read-only.\n* Do not repeat the markers \"EVOLVE-BLOCK-START\" and \"EVOLVE-BLOCK-END\" in the SEARCH/REPLACE blocks.  \n* Every block\u2019s SEARCH section must be copied **verbatim** from the current file.  Including indentation.\n* You can propose multiple independent edits. SEARCH/REPLACE blocks follow one after another. DO NOT ADD ANY OTHER TEXT BETWEEN THESE BLOCKS.\n* Make sure the file still runs after your changes.",
          "new_msg_history": [
            {
              "role": "user",
              "content": "\n# Current program\n\nHere is the current program we are trying to improve (you will need to propose a modification to it below):\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    This is a greedy baseline - evolution will improve this.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    # Simple greedy: select items with highest weights first\n    # This is a baseline - evolution will find better strategies\n    n = len(weights)\n    selected = []\n    \n    # Create score list (weight + interaction potential)\n    scores = []\n    for i in range(n):\n        score = weights[i] if i < len(weights) else 0.0\n        # Add potential interaction value\n        for k, v in interactions.items():\n            try:\n                u, w = map(int, k.split(\",\"))\n                if u == i or w == i:\n                    score += abs(v) * 0.5  # Potential value\n            except:\n                pass\n        scores.append((score, i))\n    \n    # Sort by score descending\n    scores.sort(reverse=True)\n    \n    # Greedy selection respecting constraints\n    selected_set = set()\n    for score, i in scores:\n        if len(selected_set) >= cardinality_bounds[1]:\n            break\n            \n        # Check mutex constraints\n        can_add = True\n        for a, b in mutex:\n            if (a == i and b in selected_set) or (b == i and a in selected_set):\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n            \n        # Check group constraints (at most one per group)\n        for grp_vars in groups.values():\n            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n        \n        # Check precedence (if j selected, i must be selected)\n        precedence_ok = True\n        for pred_i, pred_j in precedence:\n            if pred_j == i and pred_i not in selected_set:\n                precedence_ok = False\n                break\n        \n        if not precedence_ok:\n            continue\n        \n        # Add if we meet minimum cardinality or have room\n        if len(selected_set) < cardinality_bounds[1]:\n            selected_set.add(i)\n            selected.append(i)\n    \n    # Ensure minimum cardinality\n    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n        for i in range(n):\n            if i not in selected_set:\n                selected_set.add(i)\n                selected.append(i)\n                break\n    \n    # Output result\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n    \n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n    \n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n    \n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n    \n    result_str = stdout_capture.getvalue()\n    return result_str\n\n\n```\n\nHere are the performance metrics of the program:\n\nCombined score to maximize: 0.35\nfeasible: True; selection_size: 10; raw_score: 106.51\n\n# Instructions\n\nMake sure that the changes you propose are consistent with each other. For example, if you refer to a new config variable somewhere, you should also propose a change to add that variable.\n\nNote that the changes you propose will be applied sequentially, so you should assume that the previous changes have already been applied when writing the SEARCH block.\n\n# Task\n\nSuggest a new idea to improve the performance of the code that is inspired by your expert knowledge of the considered subject.\nYour goal is to maximize the `combined_score` of the program.\nDescribe each change with a SEARCH/REPLACE block.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.\n"
            },
            {
              "role": "assistant",
              "content": "<NAME>\nprecedence_closure_greedy_with_marginal_gain\n</NAME>\n\n<DESCRIPTION>\nImprove the baseline greedy solver to account for precedence dependencies, group/mutex constraints and pairwise interactions more intelligently.\n\nKey changes:\n- Build a precedence graph and compute ancestor (prerequisite) closure so selecting an item will also consider and include required predecessors.\n- Parse interaction keys more robustly and precompute a dictionary keyed by (u, v) tuples for fast lookup.\n- Use a marginal-gain greedy: at each step consider adding an item together with its ancestor closure (if not already selected), check feasibility (mutex/group/cardinality), and compute the marginal objective gain including interactions among closure and between closure and already-selected items. Pick the closure with maximum marginal gain.\n- If no positive-marginal move is available but minimum cardinality is not met, continue selecting best feasible closures (even if marginal <= 0) until min cardinality is reached.\n- Better group checks by mapping variables to their group for quick testing.\n- Robust handling of malformed interaction keys and precedence entries.\n\nThis targeted improvement increases the quality of the constructed solution by being precedence-aware, respecting constraints when adding whole prerequisite chains, and using interaction-aware marginal scoring rather than naive weight-only sorting.\n</DESCRIPTION>\n\n<DIFF>\n<<<<<<< SEARCH\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    This is a greedy baseline - evolution will improve this.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    # Simple greedy: select items with highest weights first\n    # This is a baseline - evolution will find better strategies\n    n = len(weights)\n    selected = []\n    \n    # Create score list (weight + interaction potential)\n    scores = []\n    for i in range(n):\n        score = weights[i] if i < len(weights) else 0.0\n        # Add potential interaction value\n        for k, v in interactions.items():\n            try:\n                u, w = map(int, k.split(\",\"))\n                if u == i or w == i:\n                    score += abs(v) * 0.5  # Potential value\n            except:\n                pass\n        scores.append((score, i))\n    \n    # Sort by score descending\n    scores.sort(reverse=True)\n    \n    # Greedy selection respecting constraints\n    selected_set = set()\n    for score, i in scores:\n        if len(selected_set) >= cardinality_bounds[1]:\n            break\n            \n        # Check mutex constraints\n        can_add = True\n        for a, b in mutex:\n            if (a == i and b in selected_set) or (b == i and a in selected_set):\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n            \n        # Check group constraints (at most one per group)\n        for grp_vars in groups.values():\n            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n        \n        # Check precedence (if j selected, i must be selected)\n        precedence_ok = True\n        for pred_i, pred_j in precedence:\n            if pred_j == i and pred_i not in selected_set:\n                precedence_ok = False\n                break\n        \n        if not precedence_ok:\n            continue\n        \n        # Add if we meet minimum cardinality or have room\n        if len(selected_set) < cardinality_bounds[1]:\n            selected_set.add(i)\n            selected.append(i)\n    \n    # Ensure minimum cardinality\n    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n        for i in range(n):\n            if i not in selected_set:\n                selected_set.add(i)\n                selected.append(i)\n                break\n    \n    # Output result\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected)\n        }\n    }\n    print(json.dumps(result))\n=======\ndef solve_sds():\n    \"\"\"\n    Improved solver for the Synergistic Dependency Selection problem.\n\n    - Reads JSON from stdin with \"requirements\" and \"catalog\".\n    - Produces JSON to stdout with \"selection\": {\"variables\": [...] }.\n    - Uses a precedence-aware marginal-gain greedy algorithm that:\n        * when adding an item, also includes its required predecessors (closure),\n        * computes the marginal objective (weights + pairwise interactions),\n        * checks mutex/group/cardinality feasibility for the closure before adding.\n    \"\"\"\n    import re\n\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n\n    # Extract constraints\n    weights = list(requirements.get(\"weights\", []))\n    interactions_raw = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    min_card, max_card = (cardinality_bounds + [len(weights), len(weights)])[:2]\n    mutex = [tuple(m) for m in requirements.get(\"mutex\", [])]\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n\n    n = len(weights)\n\n    # Parse interactions into dict of tuple->float for quick lookup (undirected)\n    interactions = {}\n    for k, v in interactions_raw.items():\n        try:\n            if isinstance(k, str):\n                # allow \"u,v\" or \"u v\"\n                parts = re.split(r'\\s*,\\s*|\\s+', k.strip())\n                if len(parts) >= 2:\n                    u = int(parts[0]); w = int(parts[1])\n                else:\n                    continue\n            elif isinstance(k, (list, tuple)) and len(k) >= 2:\n                u = int(k[0]); w = int(k[1])\n            else:\n                continue\n            interactions[(u, w)] = float(v)\n            interactions[(w, u)] = float(v)\n        except Exception:\n            # skip malformed keys\n            continue\n\n    # Build precedence graph: if (p, j) then p is a prerequisite of j\n    preds = {i: set() for i in range(n)}\n    succs = {i: set() for i in range(n)}\n    for entry in precedence:\n        try:\n            a, b = entry\n            a = int(a); b = int(b)\n            preds[b].add(a)\n            succs[a].add(b)\n        except Exception:\n            continue\n\n    # Precompute ancestors (transitive closure of preds) using DFS/memoization\n    ancestor_cache = {}\n\n    def get_ancestors(i):\n        if i in ancestor_cache:\n            return ancestor_cache[i].copy()\n        res = set()\n        stack = [i]\n        while stack:\n            cur = stack.pop()\n            for p in preds.get(cur, []):\n                if p not in res:\n                    res.add(p)\n                    stack.append(p)\n        ancestor_cache[i] = res.copy()\n        return res\n\n    # Map variable -> group (assume at most one group membership; if multiple, first wins)\n    var_to_group = {}\n    for gname, vars_list in groups.items():\n        for v in vars_list:\n            try:\n                var_to_group[int(v)] = gname\n            except Exception:\n                pass\n\n    # Helper: check feasibility of adding a closure set given current selected_set\n    def feasible_closure(closure_set, selected_set):\n        # Cardinality\n        if len(selected_set) + len(closure_set - selected_set) > max_card:\n            return False\n        # Mutex: none of closure can conflict with each other or with selected_set\n        for a, b in mutex:\n            if a in closure_set and b in closure_set:\n                return False\n            if (a in closure_set and b in selected_set) or (b in closure_set and a in selected_set):\n                return False\n        # Group: ensure at most one per group overall\n        # Build per-group counts\n        group_counts = {}\n        for v in selected_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in closure_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: closure itself must include ancestors for each element\n        for v in closure_set:\n            if not get_ancestors(v).issubset(closure_set.union(selected_set)):\n                return False\n        return True\n\n    # Compute marginal gain of adding closure_set (items that will be newly included)\n    def marginal_gain(closure_set, selected_set):\n        new_items = set(closure_set) - set(selected_set)\n        gain = 0.0\n        for i in new_items:\n            if i < len(weights):\n                gain += float(weights[i])\n        # interactions among new items\n        new_list = list(new_items)\n        for i in range(len(new_list)):\n            for j in range(i + 1, len(new_list)):\n                gain += interactions.get((new_list[i], new_list[j]), 0.0)\n        # interactions between new items and already selected\n        for i in new_items:\n            for j in selected_set:\n                gain += interactions.get((i, j), 0.0)\n        return gain\n\n    # Greedy loop: at each step try to add an item (and its ancestors) with max marginal gain\n    selected_set = set()\n    # Keep iterating while we can still add and haven't reached max_card\n    improved = True\n    while len(selected_set) < max_card and improved:\n        improved = False\n        best_gain = float(\"-inf\")\n        best_closure = None\n        # Consider candidates not already selected\n        for i in range(n):\n            if i in selected_set:\n                continue\n            # closure includes i and its ancestors\n            closure = get_ancestors(i).union({i})\n            # Only consider closures that are feasible\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # Prefer closures that add more items when gain is equal (to help reach min_card)\n            if gain > best_gain or (abs(gain - best_gain) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_gain = gain\n                best_closure = closure\n        # If we found a positive-gain move, take it\n        if best_closure is not None and best_gain > -1e-12:\n            to_add = set(best_closure) - selected_set\n            if to_add:\n                selected_set.update(to_add)\n                improved = True\n        else:\n            # No non-negative gain move; stop greedy improvements\n            break\n\n    # If we still haven't met minimum cardinality, greedily add best feasible closures regardless of gain\n    while len(selected_set) < min_card:\n        best_gain = float(\"-inf\")\n        best_closure = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = get_ancestors(i).union({i})\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # choose closure that gives best gain (even if negative), tie-breaker favors larger closures\n            if gain > best_gain or (abs(gain - best_gain) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_gain = gain\n                best_closure = closure\n        if best_closure is None:\n            # No feasible closure remains; break to avoid infinite loop\n            break\n        selected_set.update(set(best_closure) - selected_set)\n\n    # Final trim if over max_card (shouldn't happen due to checks) - keep highest-weight items\n    if len(selected_set) > max_card:\n        # score items by marginal contribution relative to selected (approx): weight + interactions with others\n        def item_score(i):\n            s = float(weights[i]) if i < len(weights) else 0.0\n            for j in selected_set:\n                if j == i:\n                    continue\n                s += interactions.get((i, j), 0.0)\n            return s\n        sorted_items = sorted(selected_set, key=item_score, reverse=True)\n        selected_set = set(sorted_items[:max_card])\n\n    result = {\n        \"selection\": {\n            \"variables\": sorted(int(x) for x in selected_set)\n        }\n    }\n    print(json.dumps(result))\n>>>>>>> REPLACE\n</DIFF>"
            }
          ],
          "model_name": "gpt-5-mini",
          "kwargs": {
            "temperature": 1.0,
            "max_output_tokens": 8192
          },
          "input_tokens": 1714,
          "output_tokens": 3859,
          "cost": 0.0081465,
          "input_cost": 0.0004285,
          "output_cost": 0.007718,
          "thought": "",
          "model_posteriors": {
            "gpt-5-mini": 1.0
          }
        },
        "diff_summary": {
          "added": 108,
          "deleted": 0,
          "modified": 75
        },
        "embed_cost": 3.734e-05,
        "novelty_cost": 0.0,
        "stdout_log": "Evaluating program: sds_dataset_output/problem_0/gen_5/main.py\nSaving results to: sds_dataset_output/problem_0/gen_5/results\nRun 1/1 completed in 0.00 seconds\nCorrectness and error status saved to sds_dataset_output/problem_0/gen_5/results/correct.json\nMetrics saved to sds_dataset_output/problem_0/gen_5/results/metrics.json\nEvaluation and Validation completed successfully.\nMetrics:\n  combined_score: 0.3993475858389672\n  public:\n    feasible: True\n    selection_size: 10\n    raw_score: 122.54942718671678\n  private:\n    selection: [3, 4, 5, 6, 7, 9, 10, 11, 13, 14]\n    raw_score: 122.54942718671678\n    normalized_fitness: 0.3993475858389672\n  execution_time_mean: 0.0006440420002036262\n  execution_time_std: 0.0\n  num_valid_runs: 1\n  num_invalid_runs: 0\n  all_validation_errors: []\n",
        "stderr_log": "",
        "code_analysis_metrics": {
          "cyclomatic_complexity": 40,
          "average_cyclomatic_complexity": 20.0,
          "halstead_volume": 1383.1345766392212,
          "halstead_difficulty": 10.461538461538462,
          "halstead_effort": 14469.71557099493,
          "lines_of_code": 252,
          "logical_lines_of_code": 181,
          "comments": 37,
          "maintainability_index": -21.68730902340323,
          "max_nesting_depth": 5,
          "complexity_score": 1.0
        }
      },
      "in_archive": false
    },
    {
      "id": "4387bfa1-ee61-4891-a6ab-39fef27cf870",
      "code": "\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Crossover solver for the Synergistic Dependency Selection problem.\n\n    Reads JSON from stdin with \"requirements\" and \"catalog\", and prints JSON\n    with \"selection\": {\"variables\": [...] }.\n\n    Strategy:\n    - Parse inputs robustly.\n    - Build adjacency map for interactions for efficient marginal gain computation.\n    - Precompute transitive ancestor closure for precedence.\n    - For each candidate, consider adding its closure (itself + ancestors).\n    - Greedily add the closure with maximum marginal gain while respecting\n      mutex, groups, and cardinality. Tie-break in favor of larger closures to\n      satisfy minimum cardinality.\n    - If minimum cardinality not reached, add best feasible closures even if negative.\n    - Trim if needed by approximate item scores.\n    \"\"\"\n    import re\n    from collections import defaultdict, deque\n\n    data = json.load(sys.stdin)\n    requirements = data.get(\"requirements\", {}) or {}\n    catalog = data.get(\"catalog\", {}) or {}\n\n    weights = list(requirements.get(\"weights\", []) or [])\n    raw_interactions = requirements.get(\"interactions\", {}) or {}\n    card_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)]) or [0, len(weights)]\n    min_card = int(card_bounds[0]) if len(card_bounds) > 0 else 0\n    max_card = int(card_bounds[1]) if len(card_bounds) > 1 else len(weights)\n    mutex_list = requirements.get(\"mutex\", []) or []\n    groups = requirements.get(\"groups\", {}) or {}\n    precedence = requirements.get(\"precedence\", []) or []\n\n    n = len(weights)\n\n    # Parse interactions into adjacency dict: interactions[u][v] = value\n    interactions = defaultdict(dict)\n    def parse_key(k):\n        # return (u,v) or None\n        try:\n            if isinstance(k, str):\n                parts = re.split(r'\\s*,\\s*|\\s+', k.strip())\n                if len(parts) >= 2:\n                    return int(parts[0]), int(parts[1])\n            elif isinstance(k, (list, tuple)) and len(k) >= 2:\n                return int(k[0]), int(k[1])\n            elif isinstance(k, int):\n                return None\n        except Exception:\n            return None\n        return None\n\n    for k, v in raw_interactions.items():\n        parsed = parse_key(k)\n        try:\n            val = float(v)\n        except Exception:\n            continue\n        if parsed is None:\n            continue\n        u, w = parsed\n        if 0 <= u < n and 0 <= w < n:\n            interactions[u][w] = interactions[u].get(w, 0.0) + val\n            interactions[w][u] = interactions[w].get(u, 0.0) + val\n\n    # Build mutex map for quick conflict checks\n    mutex_map = defaultdict(set)\n    for pair in mutex_list:\n        try:\n            a, b = pair\n            a = int(a); b = int(b)\n            if 0 <= a < n and 0 <= b < n:\n                mutex_map[a].add(b)\n                mutex_map[b].add(a)\n        except Exception:\n            continue\n\n    # Normalize groups: map var -> group name, allow string/int keys\n    var_to_group = {}\n    for gname, vars_list in groups.items():\n        for v in vars_list:\n            try:\n                idx = int(v)\n                if 0 <= idx < n and gname is not None:\n                    # first membership wins\n                    if idx not in var_to_group:\n                        var_to_group[idx] = str(gname)\n            except Exception:\n                continue\n\n    # Build precedence graph (directed: p -> j means p is prerequisite of j)\n    preds = defaultdict(set)\n    succs = defaultdict(set)\n    for entry in precedence:\n        try:\n            a, b = entry\n            a = int(a); b = int(b)\n            if 0 <= a < n and 0 <= b < n:\n                preds[b].add(a)\n                succs[a].add(b)\n        except Exception:\n            continue\n\n    # Precompute transitive ancestor closure for each node using DFS/BFS\n    ancestor_closure = [set() for _ in range(n)]\n    for i in range(n):\n        # BFS/DFS from i to collect all ancestors\n        stack = list(preds.get(i, []))\n        seen = set(stack)\n        while stack:\n            cur = stack.pop()\n            ancestor_closure[i].add(cur)\n            for p in preds.get(cur, []):\n                if p not in seen:\n                    seen.add(p)\n                    stack.append(p)\n\n    # closure for variable i is ancestors + i\n    closures = [set(ancestor_closure[i]) | {i} for i in range(n)]\n\n    # Feasibility check of adding closure (closure is set of vars to ensure present),\n    # given currently selected_set.\n    def feasible_closure(closure, selected_set):\n        # New items that would be added\n        new_items = closure - selected_set\n        # Cardinality check\n        if len(selected_set) + len(new_items) > max_card:\n            return False\n        # Mutex check: none of new items conflict with each other or with selected\n        for v in new_items:\n            # conflicts with selected\n            if any(conflict in selected_set for conflict in mutex_map.get(v, ())) :\n                return False\n            # conflicts with other new items\n            for conflict in mutex_map.get(v, ()):\n                if conflict in new_items:\n                    return False\n        # Group check: cannot create group count >1\n        group_counts = {}\n        for v in selected_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in new_items:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: closures already contain transitive ancestors; but if closure lacks\n        # some ancestor (shouldn't) ensure those ancestors are in selected_set\n        for v in closure:\n            for a in preds.get(v, ()):\n                if a not in closure and a not in selected_set:\n                    return False\n        return True\n\n    # Compute marginal gain for adding closure (new items = closure - selected_set)\n    def marginal_gain(closure, selected_set):\n        new_items = closure - selected_set\n        if not new_items:\n            return 0.0\n        gain = 0.0\n        # weights\n        for i in new_items:\n            if 0 <= i < len(weights):\n                try:\n                    gain += float(weights[i])\n                except Exception:\n                    pass\n        # interactions among new items\n        # iterate edges from each new item to higher-index new items to avoid double count\n        new_list = list(new_items)\n        l = len(new_list)\n        for idx in range(l):\n            u = new_list[idx]\n            # interactions with other new items\n            for v in new_list[idx+1:]:\n                gain += interactions.get(u, {}).get(v, 0.0)\n        # interactions between new items and already selected\n        for u in new_items:\n            for v in selected_set:\n                gain += interactions.get(u, {}).get(v, 0.0)\n        return gain\n\n    # Greedy selection: add closure with best marginal gain while respecting constraints\n    selected_set = set()\n    # Initial heuristic: consider items sorted by weight+abs(interaction_potential)\n    # but main loop will evaluate closures anyway, so we iterate all candidates\n    improved = True\n    while len(selected_set) < max_card and improved:\n        improved = False\n        best_gain = float(\"-inf\")\n        best_closure = None\n        # Evaluate every candidate not yet in selected_set\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closures[i]\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # Tie-breaker: prefer larger closure (helps reach min_card)\n            if (gain > best_gain) or (abs(gain - best_gain) < 1e-12 and best_closure is not None and len(closure - selected_set) > len(best_closure - selected_set)) or (best_closure is None and gain >= best_gain):\n                best_gain = gain\n                best_closure = closure\n        # Accept non-negative gain closures; small negative may be accepted later to meet min_card\n        if best_closure is not None and best_gain > -1e-12:\n            new_items = best_closure - selected_set\n            if new_items:\n                selected_set.update(new_items)\n                improved = True\n        else:\n            break\n\n    # If we haven't met min_card, add best feasible closures even if negative\n    while len(selected_set) < min_card:\n        best_gain = float(\"-inf\")\n        best_closure = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closures[i]\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            if (gain > best_gain) or (abs(gain - best_gain) < 1e-12 and best_closure is not None and len(closure - selected_set) > len(best_closure - selected_set)) or (best_closure is None and gain >= best_gain):\n                best_gain = gain\n                best_closure = closure\n        if best_closure is None:\n            # no feasible closures left\n            break\n        selected_set.update(best_closure - selected_set)\n\n    # Safety trim if we're over max_card (should rarely happen due to checks)\n    if len(selected_set) > max_card:\n        # compute approximate item score = weight + sum interactions with others in selected_set\n        def item_score(i):\n            s = 0.0\n            if 0 <= i < len(weights):\n                try:\n                    s += float(weights[i])\n                except Exception:\n                    pass\n            for j in selected_set:\n                if j == i:\n                    continue\n                s += interactions.get(i, {}).get(j, 0.0)\n            return s\n        sorted_items = sorted(selected_set, key=lambda x: item_score(x), reverse=True)\n        selected_set = set(sorted_items[:max_card])\n\n    result = {\"selection\": {\"variables\": sorted(int(x) for x in selected_set)}}\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n\n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n\n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n\n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n\n    result_str = stdout_capture.getvalue()\n    return result_str\n",
      "language": "python",
      "parent_id": "41c4e403-070f-4e25-9757-64fb47df1aa9",
      "archive_inspiration_ids": [
        "639d15e8-d1f9-4fa7-b731-6db3bcbdb880"
      ],
      "top_k_inspiration_ids": [],
      "island_idx": 0,
      "generation": 6,
      "timestamp": 1764668291.952178,
      "code_diff": "--- a/original.py\n+++ b/original.py\n@@ -1,252 +1,300 @@\n \"\"\"\n Initial solution for Synergistic Dependency Selection (SDS) problem.\n The code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n \"\"\"\n \n import json\n import sys\n import contextlib\n \n # EVOLVE-BLOCK-START\n def solve_sds():\n     \"\"\"\n-    Improved solver for the Synergistic Dependency Selection problem.\n-\n-    - Reads JSON from stdin with \"requirements\" and \"catalog\".\n-    - Produces JSON to stdout with \"selection\": {\"variables\": [...] }.\n-    - Uses a precedence-aware marginal-gain greedy algorithm that:\n-        * when adding an item, also includes its required predecessors (closure),\n-        * computes the marginal objective (weights + pairwise interactions),\n-        * checks mutex/group/cardinality feasibility for the closure before adding.\n+    Crossover solver for the Synergistic Dependency Selection problem.\n+\n+    Reads JSON from stdin with \"requirements\" and \"catalog\", and prints JSON\n+    with \"selection\": {\"variables\": [...] }.\n+\n+    Strategy:\n+    - Parse inputs robustly.\n+    - Build adjacency map for interactions for efficient marginal gain computation.\n+    - Precompute transitive ancestor closure for precedence.\n+    - For each candidate, consider adding its closure (itself + ancestors).\n+    - Greedily add the closure with maximum marginal gain while respecting\n+      mutex, groups, and cardinality. Tie-break in favor of larger closures to\n+      satisfy minimum cardinality.\n+    - If minimum cardinality not reached, add best feasible closures even if negative.\n+    - Trim if needed by approximate item scores.\n     \"\"\"\n     import re\n-\n-    # Read input\n-    input_data = json.load(sys.stdin)\n-    requirements = input_data.get(\"requirements\", {})\n-    catalog = input_data.get(\"catalog\", {})\n-\n-    # Extract constraints\n-    weights = list(requirements.get(\"weights\", []))\n-    interactions_raw = requirements.get(\"interactions\", {})\n-    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n-    min_card, max_card = (cardinality_bounds + [len(weights), len(weights)])[:2]\n-    mutex = [tuple(m) for m in requirements.get(\"mutex\", [])]\n-    groups = requirements.get(\"groups\", {})\n-    precedence = requirements.get(\"precedence\", [])\n+    from collections import defaultdict, deque\n+\n+    data = json.load(sys.stdin)\n+    requirements = data.get(\"requirements\", {}) or {}\n+    catalog = data.get(\"catalog\", {}) or {}\n+\n+    weights = list(requirements.get(\"weights\", []) or [])\n+    raw_interactions = requirements.get(\"interactions\", {}) or {}\n+    card_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)]) or [0, len(weights)]\n+    min_card = int(card_bounds[0]) if len(card_bounds) > 0 else 0\n+    max_card = int(card_bounds[1]) if len(card_bounds) > 1 else len(weights)\n+    mutex_list = requirements.get(\"mutex\", []) or []\n+    groups = requirements.get(\"groups\", {}) or {}\n+    precedence = requirements.get(\"precedence\", []) or []\n \n     n = len(weights)\n \n-    # Parse interactions into dict of tuple->float for quick lookup (undirected)\n-    interactions = {}\n-    for k, v in interactions_raw.items():\n+    # Parse interactions into adjacency dict: interactions[u][v] = value\n+    interactions = defaultdict(dict)\n+    def parse_key(k):\n+        # return (u,v) or None\n         try:\n             if isinstance(k, str):\n-                # allow \"u,v\" or \"u v\"\n                 parts = re.split(r'\\s*,\\s*|\\s+', k.strip())\n                 if len(parts) >= 2:\n-                    u = int(parts[0]); w = int(parts[1])\n-                else:\n-                    continue\n+                    return int(parts[0]), int(parts[1])\n             elif isinstance(k, (list, tuple)) and len(k) >= 2:\n-                u = int(k[0]); w = int(k[1])\n-            else:\n-                continue\n-            interactions[(u, w)] = float(v)\n-            interactions[(w, u)] = float(v)\n+                return int(k[0]), int(k[1])\n+            elif isinstance(k, int):\n+                return None\n         except Exception:\n-            # skip malformed keys\n+            return None\n+        return None\n+\n+    for k, v in raw_interactions.items():\n+        parsed = parse_key(k)\n+        try:\n+            val = float(v)\n+        except Exception:\n             continue\n-\n-    # Build precedence graph: if (p, j) then p is a prerequisite of j\n-    preds = {i: set() for i in range(n)}\n-    succs = {i: set() for i in range(n)}\n+        if parsed is None:\n+            continue\n+        u, w = parsed\n+        if 0 <= u < n and 0 <= w < n:\n+            interactions[u][w] = interactions[u].get(w, 0.0) + val\n+            interactions[w][u] = interactions[w].get(u, 0.0) + val\n+\n+    # Build mutex map for quick conflict checks\n+    mutex_map = defaultdict(set)\n+    for pair in mutex_list:\n+        try:\n+            a, b = pair\n+            a = int(a); b = int(b)\n+            if 0 <= a < n and 0 <= b < n:\n+                mutex_map[a].add(b)\n+                mutex_map[b].add(a)\n+        except Exception:\n+            continue\n+\n+    # Normalize groups: map var -> group name, allow string/int keys\n+    var_to_group = {}\n+    for gname, vars_list in groups.items():\n+        for v in vars_list:\n+            try:\n+                idx = int(v)\n+                if 0 <= idx < n and gname is not None:\n+                    # first membership wins\n+                    if idx not in var_to_group:\n+                        var_to_group[idx] = str(gname)\n+            except Exception:\n+                continue\n+\n+    # Build precedence graph (directed: p -> j means p is prerequisite of j)\n+    preds = defaultdict(set)\n+    succs = defaultdict(set)\n     for entry in precedence:\n         try:\n             a, b = entry\n             a = int(a); b = int(b)\n-            preds[b].add(a)\n-            succs[a].add(b)\n+            if 0 <= a < n and 0 <= b < n:\n+                preds[b].add(a)\n+                succs[a].add(b)\n         except Exception:\n             continue\n \n-    # Precompute ancestors (transitive closure of preds) using DFS/memoization\n-    ancestor_cache = {}\n-\n-    def get_ancestors(i):\n-        if i in ancestor_cache:\n-            return ancestor_cache[i].copy()\n-        res = set()\n-        stack = [i]\n+    # Precompute transitive ancestor closure for each node using DFS/BFS\n+    ancestor_closure = [set() for _ in range(n)]\n+    for i in range(n):\n+        # BFS/DFS from i to collect all ancestors\n+        stack = list(preds.get(i, []))\n+        seen = set(stack)\n         while stack:\n             cur = stack.pop()\n+            ancestor_closure[i].add(cur)\n             for p in preds.get(cur, []):\n-                if p not in res:\n-                    res.add(p)\n+                if p not in seen:\n+                    seen.add(p)\n                     stack.append(p)\n-        ancestor_cache[i] = res.copy()\n-        return res\n-\n-    # Map variable -> group (assume at most one group membership; if multiple, first wins)\n-    var_to_group = {}\n-    for gname, vars_list in groups.items():\n-        for v in vars_list:\n-            try:\n-                var_to_group[int(v)] = gname\n-            except Exception:\n-                pass\n-\n-    # Helper: check feasibility of adding a closure set given current selected_set\n-    def feasible_closure(closure_set, selected_set):\n-        # Cardinality\n-        if len(selected_set) + len(closure_set - selected_set) > max_card:\n+\n+    # closure for variable i is ancestors + i\n+    closures = [set(ancestor_closure[i]) | {i} for i in range(n)]\n+\n+    # Feasibility check of adding closure (closure is set of vars to ensure present),\n+    # given currently selected_set.\n+    def feasible_closure(closure, selected_set):\n+        # New items that would be added\n+        new_items = closure - selected_set\n+        # Cardinality check\n+        if len(selected_set) + len(new_items) > max_card:\n             return False\n-        # Mutex: none of closure can conflict with each other or with selected_set\n-        for a, b in mutex:\n-            if a in closure_set and b in closure_set:\n+        # Mutex check: none of new items conflict with each other or with selected\n+        for v in new_items:\n+            # conflicts with selected\n+            if any(conflict in selected_set for conflict in mutex_map.get(v, ())) :\n                 return False\n-            if (a in closure_set and b in selected_set) or (b in closure_set and a in selected_set):\n-                return False\n-        # Group: ensure at most one per group overall\n-        # Build per-group counts\n+            # conflicts with other new items\n+            for conflict in mutex_map.get(v, ()):\n+                if conflict in new_items:\n+                    return False\n+        # Group check: cannot create group count >1\n         group_counts = {}\n         for v in selected_set:\n             g = var_to_group.get(v)\n             if g is not None:\n                 group_counts[g] = group_counts.get(g, 0) + 1\n-        for v in closure_set:\n+        for v in new_items:\n             g = var_to_group.get(v)\n             if g is not None:\n                 group_counts[g] = group_counts.get(g, 0) + 1\n                 if group_counts[g] > 1:\n                     return False\n-        # Precedence: closure itself must include ancestors for each element\n-        for v in closure_set:\n-            if not get_ancestors(v).issubset(closure_set.union(selected_set)):\n-                return False\n+        # Precedence: closures already contain transitive ancestors; but if closure lacks\n+        # some ancestor (shouldn't) ensure those ancestors are in selected_set\n+        for v in closure:\n+            for a in preds.get(v, ()):\n+                if a not in closure and a not in selected_set:\n+                    return False\n         return True\n \n-    # Compute marginal gain of adding closure_set (items that will be newly included)\n-    def marginal_gain(closure_set, selected_set):\n-        new_items = set(closure_set) - set(selected_set)\n+    # Compute marginal gain for adding closure (new items = closure - selected_set)\n+    def marginal_gain(closure, selected_set):\n+        new_items = closure - selected_set\n+        if not new_items:\n+            return 0.0\n         gain = 0.0\n+        # weights\n         for i in new_items:\n-            if i < len(weights):\n-                gain += float(weights[i])\n+            if 0 <= i < len(weights):\n+                try:\n+                    gain += float(weights[i])\n+                except Exception:\n+                    pass\n         # interactions among new items\n+        # iterate edges from each new item to higher-index new items to avoid double count\n         new_list = list(new_items)\n-        for i in range(len(new_list)):\n-            for j in range(i + 1, len(new_list)):\n-                gain += interactions.get((new_list[i], new_list[j]), 0.0)\n+        l = len(new_list)\n+        for idx in range(l):\n+            u = new_list[idx]\n+            # interactions with other new items\n+            for v in new_list[idx+1:]:\n+                gain += interactions.get(u, {}).get(v, 0.0)\n         # interactions between new items and already selected\n-        for i in new_items:\n-            for j in selected_set:\n-                gain += interactions.get((i, j), 0.0)\n+        for u in new_items:\n+            for v in selected_set:\n+                gain += interactions.get(u, {}).get(v, 0.0)\n         return gain\n \n-    # Greedy loop: at each step try to add an item (and its ancestors) with max marginal gain\n+    # Greedy selection: add closure with best marginal gain while respecting constraints\n     selected_set = set()\n-    # Keep iterating while we can still add and haven't reached max_card\n+    # Initial heuristic: consider items sorted by weight+abs(interaction_potential)\n+    # but main loop will evaluate closures anyway, so we iterate all candidates\n     improved = True\n     while len(selected_set) < max_card and improved:\n         improved = False\n         best_gain = float(\"-inf\")\n         best_closure = None\n-        # Consider candidates not already selected\n+        # Evaluate every candidate not yet in selected_set\n         for i in range(n):\n             if i in selected_set:\n                 continue\n-            # closure includes i and its ancestors\n-            closure = get_ancestors(i).union({i})\n-            # Only consider closures that are feasible\n+            closure = closures[i]\n             if not feasible_closure(closure, selected_set):\n                 continue\n             gain = marginal_gain(closure, selected_set)\n-            # Prefer closures that add more items when gain is equal (to help reach min_card)\n-            if gain > best_gain or (abs(gain - best_gain) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n+            # Tie-breaker: prefer larger closure (helps reach min_card)\n+            if (gain > best_gain) or (abs(gain - best_gain) < 1e-12 and best_closure is not None and len(closure - selected_set) > len(best_closure - selected_set)) or (best_closure is None and gain >= best_gain):\n                 best_gain = gain\n                 best_closure = closure\n-        # If we found a positive-gain move, take it\n+        # Accept non-negative gain closures; small negative may be accepted later to meet min_card\n         if best_closure is not None and best_gain > -1e-12:\n-            to_add = set(best_closure) - selected_set\n-            if to_add:\n-                selected_set.update(to_add)\n+            new_items = best_closure - selected_set\n+            if new_items:\n+                selected_set.update(new_items)\n                 improved = True\n         else:\n-            # No non-negative gain move; stop greedy improvements\n             break\n \n-    # If we still haven't met minimum cardinality, greedily add best feasible closures regardless of gain\n+    # If we haven't met min_card, add best feasible closures even if negative\n     while len(selected_set) < min_card:\n         best_gain = float(\"-inf\")\n         best_closure = None\n         for i in range(n):\n             if i in selected_set:\n                 continue\n-            closure = get_ancestors(i).union({i})\n+            closure = closures[i]\n             if not feasible_closure(closure, selected_set):\n                 continue\n             gain = marginal_gain(closure, selected_set)\n-            # choose closure that gives best gain (even if negative), tie-breaker favors larger closures\n-            if gain > best_gain or (abs(gain - best_gain) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n+            if (gain > best_gain) or (abs(gain - best_gain) < 1e-12 and best_closure is not None and len(closure - selected_set) > len(best_closure - selected_set)) or (best_closure is None and gain >= best_gain):\n                 best_gain = gain\n                 best_closure = closure\n         if best_closure is None:\n-            # No feasible closure remains; break to avoid infinite loop\n+            # no feasible closures left\n             break\n-        selected_set.update(set(best_closure) - selected_set)\n-\n-    # Final trim if over max_card (shouldn't happen due to checks) - keep highest-weight items\n+        selected_set.update(best_closure - selected_set)\n+\n+    # Safety trim if we're over max_card (should rarely happen due to checks)\n     if len(selected_set) > max_card:\n-        # score items by marginal contribution relative to selected (approx): weight + interactions with others\n+        # compute approximate item score = weight + sum interactions with others in selected_set\n         def item_score(i):\n-            s = float(weights[i]) if i < len(weights) else 0.0\n+            s = 0.0\n+            if 0 <= i < len(weights):\n+                try:\n+                    s += float(weights[i])\n+                except Exception:\n+                    pass\n             for j in selected_set:\n                 if j == i:\n                     continue\n-                s += interactions.get((i, j), 0.0)\n+                s += interactions.get(i, {}).get(j, 0.0)\n             return s\n-        sorted_items = sorted(selected_set, key=item_score, reverse=True)\n+        sorted_items = sorted(selected_set, key=lambda x: item_score(x), reverse=True)\n         selected_set = set(sorted_items[:max_card])\n \n-    result = {\n-        \"selection\": {\n-            \"variables\": sorted(int(x) for x in selected_set)\n-        }\n-    }\n+    result = {\"selection\": {\"variables\": sorted(int(x) for x in selected_set)}}\n     print(json.dumps(result))\n # EVOLVE-BLOCK-END\n \n \n # This part remains fixed (not evolved)\n def run_sds(problem_data=None):\n     \"\"\"\n     Main function called by the evaluator.\n     Can accept problem_data as parameter or read from stdin.\n     Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n     \"\"\"\n     import sys\n     import json\n     import io\n \n     if problem_data is None:\n         # Read from stdin (for compatibility)\n         input_data = json.load(sys.stdin)\n     else:\n         # Use provided problem data\n         input_data = problem_data\n \n     # Capture stdout from solve_sds\n     stdout_capture = io.StringIO()\n     old_stdin = sys.stdin\n \n     try:\n         # Create mock stdin\n         sys.stdin = io.StringIO(json.dumps(input_data))\n         with contextlib.redirect_stdout(stdout_capture):\n             solve_sds()\n     finally:\n         sys.stdin = old_stdin\n \n     result_str = stdout_capture.getvalue()\n     return result_str\n",
      "combined_score": 0.3993475858389672,
      "public_metrics": {
        "feasible": true,
        "selection_size": 10,
        "raw_score": 122.54942718671678
      },
      "private_metrics": {
        "selection": [
          3,
          4,
          5,
          6,
          7,
          9,
          10,
          11,
          13,
          14
        ],
        "raw_score": 122.54942718671678,
        "normalized_fitness": 0.3993475858389672
      },
      "text_feedback": "",
      "correct": true,
      "children_count": 0,
      "complexity": 1.0,
      "embedding": [
        0.026669849,
        -0.00067730556,
        0.014312417,
        -0.021975473,
        0.014891672,
        0.03436911,
        0.03458633,
        -2.3275309e-06,
        -0.010686042,
        0.021239337,
        0.030748768,
        -0.0721172,
        -0.005988648,
        0.023085712,
        0.0014752892,
        -0.029831614,
        0.04817468,
        0.0137210945,
        -0.02749046,
        0.0006757971,
        0.027128426,
        0.018946454,
        0.051650207,
        0.020985913,
        0.016750114,
        0.0021450524,
        0.04991244,
        0.073613614,
        0.030121243,
        -0.03984789,
        0.017220758,
        -0.007500141,
        -0.033138193,
        -0.00851987,
        -0.029373039,
        0.034007076,
        0.005186139,
        0.03540694,
        -0.030483276,
        0.0013817637,
        0.004531461,
        -0.03234172,
        -0.011108414,
        0.01638808,
        -0.011591127,
        -0.012351398,
        0.009165498,
        -0.0051650205,
        0.017932758,
        -0.019067133,
        -0.027804224,
        0.021818591,
        0.012049704,
        -0.0029837647,
        -0.041320164,
        -0.032848567,
        0.015410587,
        0.010505024,
        -0.0112652965,
        -0.003336748,
        0.030507412,
        -0.023689102,
        0.04684722,
        0.009515464,
        -0.013165976,
        0.029011004,
        0.026838798,
        0.0037017993,
        -0.030531548,
        -0.015905367,
        -0.04465088,
        0.0031165108,
        0.0070174285,
        -0.020104963,
        0.013322857,
        0.018946454,
        0.018463742,
        0.04397508,
        -0.001829781,
        -0.023315,
        -0.0381584,
        -0.019320557,
        0.011428212,
        -0.027780088,
        -0.045761116,
        -0.06878649,
        0.00021703193,
        0.04074091,
        -0.048464306,
        -0.060821738,
        -0.0070475983,
        -0.00033865278,
        -0.07231029,
        0.012345364,
        0.031376295,
        -0.04042715,
        0.033355415,
        -0.03893074,
        0.025921647,
        0.0017422894,
        0.008803464,
        -0.025776831,
        0.021758253,
        -0.019863607,
        -0.003282443,
        0.017088013,
        0.033862263,
        0.01099377,
        0.008019056,
        -0.014179671,
        -0.05816682,
        0.02430456,
        0.021106591,
        0.037892908,
        0.009189634,
        -0.057635836,
        -0.047474746,
        -0.03854457,
        -0.00017498317,
        -0.0014617129,
        -0.031472836,
        -0.005946411,
        -0.015857097,
        0.036420636,
        -0.02804558,
        0.01116272,
        0.042189047,
        -0.072793,
        -0.029228223,
        -0.011524754,
        0.018620623,
        0.007844074,
        -0.011102381,
        -0.01985154,
        -0.06333184,
        -0.0148313325,
        -0.026911207,
        -0.0079345815,
        -0.024485577,
        0.007904412,
        0.015736418,
        0.010848957,
        0.024594188,
        0.025245849,
        -0.04018579,
        -0.022603,
        -0.005035292,
        0.026163002,
        -0.09499776,
        0.061352722,
        0.045736983,
        -0.041609794,
        -0.0024904932,
        0.0026820698,
        0.047812644,
        -0.045206,
        -0.035841383,
        0.020491133,
        0.058746077,
        -0.03424843,
        -0.011675602,
        0.017498318,
        -0.009684414,
        -0.004950817,
        0.03885833,
        -0.043371692,
        -0.035503484,
        0.058456447,
        -0.030338462,
        -0.014614112,
        -0.023652898,
        -0.09311519,
        -0.022784017,
        0.03243826,
        -0.013865909,
        -0.042382132,
        -0.016134655,
        -0.040644366,
        0.008984481,
        -0.025825104,
        -0.043178607,
        -0.028962733,
        -0.015941571,
        -0.05642906,
        -0.02804558,
        -0.06009767,
        -0.001113255,
        -0.0056929872,
        -0.0020183404,
        -0.0033850193,
        -0.018922318,
        0.015941571,
        0.01968259,
        -0.012526382,
        0.0076992596,
        -0.031810734,
        0.059856314,
        0.019332623,
        -0.0141314,
        0.01677425,
        0.010360211,
        0.0063718013,
        0.037917044,
        -0.018210318,
        0.0008892464,
        -0.031134937,
        -0.0558498,
        -0.0032673583,
        -0.017787945,
        -0.044361252,
        0.043347556,
        -0.034055345,
        -0.0039914264,
        0.04865739,
        0.046002474,
        -0.0021224252,
        -0.0051258,
        0.012218653,
        0.008133701,
        0.0597115,
        -0.03118321,
        0.01880164,
        0.007976819,
        -0.008706922,
        0.003659562,
        0.027949037,
        -0.008592278,
        -0.049526274,
        0.017172487,
        -0.043613046,
        0.00010493334,
        0.01716042,
        -0.011536822,
        0.026573308,
        0.0031225446,
        -0.026042324,
        -0.018572353,
        0.014348621,
        0.015953638,
        -0.01445723,
        0.035382804,
        -0.021070387,
        0.015036485,
        0.021649642,
        0.011965229,
        2.263892e-05,
        -0.03984789,
        -0.019598115,
        -0.0068665813,
        -0.020153236,
        0.02127554,
        -0.012351398,
        0.020430794,
        -0.01830686,
        -0.0028842054,
        -0.03238999,
        -0.016943198,
        -0.040620234,
        0.013129772,
        0.035648298,
        -0.05773238,
        0.0036474941,
        0.007379463,
        -0.031955548,
        -0.055222277,
        -0.008893972,
        0.008912074,
        -0.0110239405,
        -0.024883814,
        -0.013250451,
        0.004265969,
        0.052905258,
        -0.049357325,
        0.021046253,
        -0.04735407,
        -0.010275736,
        -0.01638808,
        0.0692692,
        -0.017751742,
        -0.023085712,
        -0.048126407,
        0.022409914,
        0.023761509,
        -0.0036414603,
        0.034055345,
        0.010764482,
        -0.0027122393,
        0.020466998,
        -0.010396414,
        0.028142123,
        -0.014867536,
        -0.03695162,
        0.033669177,
        -0.039244503,
        -0.020382524,
        -0.005524038,
        0.00028189638,
        0.027321512,
        -6.142324e-05,
        0.012272958,
        0.08355749,
        0.0012542976,
        -0.02446144,
        -0.007988887,
        -0.017920692,
        -0.017739674,
        0.041633926,
        -0.030266056,
        0.041151214,
        0.03316233,
        -0.046992034,
        -0.0043383758,
        0.0072225817,
        0.0010725262,
        -0.022506457,
        -0.020732488,
        0.067483164,
        -0.03646891,
        0.04052369,
        -0.021553101,
        -0.022590932,
        0.023785643,
        0.03234172,
        -0.013660756,
        0.007904412,
        -0.050684784,
        -0.013540077,
        -0.026669849,
        -0.002568934,
        -0.013286654,
        -0.032534804,
        0.0057955636,
        0.022989169,
        0.040982265,
        -0.005955462,
        -0.05575326,
        0.028069714,
        0.0065588523,
        0.011470449,
        -0.009382718,
        -0.038254943,
        0.0155674685,
        -0.035527617,
        -0.030314326,
        -0.0015386451,
        -0.03156938,
        -0.01996015,
        0.084909074,
        0.060773466,
        -0.031859007,
        0.006582988,
        -0.004519393,
        -0.01710008,
        0.047136847,
        -0.0060972585,
        0.0072768866,
        -0.01798103,
        -0.025318256,
        -0.010788618,
        -0.032679617,
        0.025269983,
        -0.010631736,
        -0.022578863,
        0.0126229245,
        0.014638248,
        0.015929503,
        -0.039485857,
        0.026018187,
        0.013226314,
        -0.012586721,
        0.045230135,
        0.046147287,
        -0.043106202,
        0.023435678,
        -0.06236642,
        -0.017848283,
        -0.005714106,
        0.0128642805,
        0.02359256,
        0.05773238,
        0.00056153006,
        0.014650316,
        -0.033476092,
        -0.0072949883,
        0.009298244,
        0.008073362,
        -0.029638529,
        -0.013781434,
        -0.03325887,
        -0.027635274,
        0.02463039,
        -0.035551753,
        0.027635274,
        -0.005714106,
        -0.0018961539,
        0.008477633,
        0.027297376,
        0.014529637,
        0.020744557,
        0.032848567,
        -0.0035660365,
        0.0016593232,
        -0.014867536,
        -0.03704816,
        -0.029059274,
        -0.0023260694,
        0.037072297,
        0.049212508,
        0.008646582,
        -0.018113775,
        0.03613101,
        0.0048542744,
        0.028552428,
        -0.008507803,
        0.00016329248,
        -0.016557029,
        -0.028383479,
        0.044723287,
        0.027176697,
        0.062173333,
        -0.010227465,
        -0.014493434,
        0.033041652,
        -0.026525036,
        -0.007862175,
        0.02359256,
        0.031738326,
        -0.026790528,
        0.0558498,
        0.022313371,
        0.0011901873,
        0.038785927,
        0.054015495,
        0.017558657,
        0.0049206475,
        0.06888303,
        0.046533458,
        0.033065785,
        0.023194322,
        -0.015000282,
        -0.007445836,
        0.032872703,
        0.02512517,
        -0.021082455,
        -0.013757298,
        0.017631063,
        0.031810734,
        -0.023725305,
        0.016134655,
        -0.004145291,
        -0.0033427821,
        -0.011168754,
        0.016798384,
        -0.025583748,
        -0.0120074665,
        0.021239337,
        0.023652898,
        -0.034658737,
        0.06888303,
        -0.005505936,
        0.0402582,
        0.058794346,
        -0.031714194,
        0.0044319015,
        0.0023713238,
        0.032486532,
        0.019260217,
        0.017558657,
        0.001176611,
        0.045712847,
        0.033017516,
        -0.008670718,
        -0.044626743,
        0.009424956,
        -0.020660082,
        -0.03161765,
        0.03876179,
        0.013552145,
        -0.0018343064,
        0.012266924,
        -0.018125843,
        -0.017389707,
        -0.002813307,
        0.032848567,
        0.046267964,
        0.051553663,
        -0.009050854,
        -0.04240627,
        -0.02710429,
        0.005653767,
        0.024618322,
        0.008175938,
        0.009618041,
        -0.012134179,
        -0.005831767,
        -0.031738326,
        -0.0062511233,
        0.020587675,
        -0.026163002,
        -0.019441234,
        0.00046687323,
        -0.021818591,
        -0.039292775,
        0.047909185,
        0.03475528,
        0.003973325,
        0.0018101708,
        -0.01247811,
        -0.005400343,
        0.01462618,
        -0.0112713305,
        0.019586047,
        -0.025245849,
        0.026331952,
        0.01886198,
        0.0027197816,
        -0.036010332,
        -0.039389316,
        -0.013829704,
        -0.00013529141,
        -0.013684891,
        -0.030314326,
        -0.04327515,
        0.010891194,
        -0.007385497,
        -0.027249103,
        0.022047881,
        -0.08577796,
        -0.04636451,
        -0.01798103,
        -0.0006539242,
        0.002502561,
        -0.04255108,
        0.065504044,
        -0.028793784,
        -0.00033639008,
        -0.0300247,
        0.0005004368,
        -0.03622755,
        0.013105636,
        -0.01770347,
        -0.0075785816,
        -0.017075945,
        -0.01787242,
        0.025342392,
        -0.01451757,
        0.057153124,
        -0.0023894254,
        0.0032492566,
        0.0036293925,
        -0.032317583,
        -0.02265127,
        -0.004968919,
        0.015265774,
        -0.035720702,
        0.017510386,
        -0.0346346,
        -0.030821174,
        -0.0017724589,
        -0.05898743,
        0.005840818,
        -0.00031414005,
        0.021565167,
        0.019429166,
        -0.01600191,
        0.003472511,
        0.050539967,
        0.025101034,
        -0.020201506,
        0.019537777,
        -0.0075242766,
        -0.017425912,
        0.0077113276,
        -0.06087001,
        0.039992705,
        0.022952966,
        -0.019815337,
        -0.02693534,
        -0.029107546,
        -3.2950764e-05,
        -0.013552145,
        -0.01671391,
        -0.015555401,
        -0.0122548565,
        -0.06840032,
        0.022047881,
        -0.0127436025,
        0.010118854,
        0.011959195,
        0.021709982,
        -0.018427538,
        0.0013877976,
        0.028528292,
        0.0008945261,
        0.0062209535,
        -0.0022446117,
        -0.0026473748,
        -0.0067278016,
        -0.0069932933,
        0.012924619,
        0.016581165,
        -0.029445445,
        0.019453302,
        0.014541705,
        -0.043806132,
        -0.032896835,
        0.044675015,
        0.02183066,
        0.009563736,
        0.019827403,
        -0.011060144,
        -0.03156938,
        0.011223059,
        0.015495062,
        -0.025632018,
        0.007856141,
        -0.02149276,
        0.047740236,
        0.01088516,
        -0.02727324,
        0.021890998,
        -0.017450046,
        -0.006196818,
        0.024763137,
        0.038085993,
        -0.0019172726,
        0.0010725262,
        0.013890044,
        -0.0061244112,
        0.00042916133,
        -0.03123148,
        0.00047592405,
        -0.015531265,
        0.0018237471,
        -0.010040414,
        0.005192173,
        0.008006989,
        0.005122783,
        -0.021022117,
        0.018620623,
        0.005315868,
        0.022059947,
        -0.0005494623,
        -0.014565841,
        0.028769648,
        0.012218653,
        -0.005379224,
        0.005258546,
        0.021323811,
        -0.007005361,
        -0.02727324,
        -0.0081819715,
        -0.005379224,
        -0.018632691,
        0.057104856,
        0.036034465,
        0.011349771,
        -0.04646105,
        -0.004971936,
        0.011150652,
        0.014408959,
        -0.01699147,
        0.020816963,
        0.043419965,
        0.023399474,
        0.017920692,
        0.03678267,
        0.048054002,
        0.008706922,
        0.0035147483,
        -0.036661994,
        0.008869837,
        0.04537495,
        -0.018705098,
        -0.019911878,
        -0.011367872,
        0.040547825,
        0.009630108,
        -0.030338462,
        0.00879743,
        -0.03376572,
        0.011591127,
        -0.007819938,
        0.015639875,
        0.008537972,
        -0.035817247,
        0.0015258231,
        -0.01017316,
        0.012242788,
        0.010028346,
        0.012876349,
        0.004317257,
        -0.009714583,
        -0.017956894,
        0.037579145,
        0.024171814,
        0.024545915,
        0.048633255,
        -0.0149520105,
        -0.08915695,
        0.0036052568,
        0.00851987,
        0.014783061,
        -0.01088516,
        -0.009726651,
        -0.04366132,
        -0.03902728,
        0.004778851,
        0.029228223,
        -0.009141362,
        -0.021903066,
        0.002793697,
        -0.014203806,
        -0.010921364,
        -0.010619668,
        0.0070174285,
        0.018125843,
        0.01710008,
        0.0250769,
        -0.029976428,
        -0.050008986,
        -0.03738606,
        -0.021154862,
        0.008839668,
        -0.06767625,
        -0.028190393,
        -0.0136004165,
        0.044602606,
        -0.021722049,
        0.0006399708,
        -0.0016276452,
        -0.004281054,
        -0.0363965,
        0.018753368,
        -0.015350249,
        -0.027707681,
        -0.025800968,
        -0.012755671,
        -0.048198815,
        0.019839471,
        -0.010812754,
        -0.018101707,
        0.015265774,
        0.008381091,
        -0.03381399,
        0.0020334253,
        0.010999804,
        0.028576562,
        -0.028600698,
        0.031593513,
        -0.006335598,
        0.0077233952,
        -0.012803941,
        -0.015096825,
        0.02490795,
        0.007554446,
        0.013383196,
        -0.008459532,
        -0.024123542,
        0.010541228,
        -0.0128642805,
        -0.0072165476,
        -0.048319492,
        0.01190489,
        0.024473509,
        0.025487205,
        0.00868882,
        -0.017425912,
        0.014855469,
        0.033958804,
        0.020201506,
        0.008544006,
        -0.0020590692,
        0.0113859745,
        0.0013651705,
        -0.02359256,
        -0.003035053,
        -0.034707006,
        0.017353503,
        0.019586047,
        0.016303604,
        0.012224686,
        -0.011060144,
        0.01901886,
        0.006420072,
        -0.0025674256,
        -0.00056944956,
        -0.008381091,
        0.02623541,
        -0.040137522,
        -0.042309724,
        0.009883532,
        -0.00023456797,
        0.02688707,
        -0.01080672,
        0.041151214,
        -0.0332106,
        -0.11633364,
        0.0036022398,
        0.0026202223,
        -0.037096433,
        0.013057365,
        -0.019368827,
        0.006938988,
        0.020322183,
        -0.015434723,
        -0.009195668,
        -0.037579145,
        -0.03193141,
        -0.005753326,
        0.022084083,
        -0.009376684,
        -0.01886198,
        -0.024811408,
        0.008151802,
        0.020189438,
        -0.033065785,
        -0.014915807,
        0.025728561,
        -0.008773294,
        -0.0023456796,
        -0.050829597,
        0.0077656326,
        -0.0052404446,
        0.034827687,
        0.0028902392,
        0.009056888,
        0.011506652,
        0.011566991,
        0.001611052,
        0.036541313,
        -0.01215228,
        0.0077595985,
        0.013515942,
        -0.009443058,
        -0.0102817705,
        0.007693226,
        0.014976147,
        -0.018258588,
        0.024666594,
        -0.05724967,
        0.0048542744,
        0.016098453,
        -0.031690057,
        0.005285699,
        0.00956977,
        0.03704816,
        0.0118807545,
        0.022723677,
        -0.019163676,
        -0.021504829,
        -0.022096151,
        0.041875284,
        -0.001769442,
        0.026983613,
        0.00032507651,
        0.030917717,
        -0.040813316,
        -0.006697632,
        0.044723287,
        -0.021878932,
        -0.018680962,
        0.011977296,
        -0.021299677,
        -0.016231198,
        -0.013672823,
        0.03308992,
        -0.011434246,
        -0.012206585,
        -0.012562585,
        -0.015084757,
        -0.050105527,
        0.009081024,
        0.022240965,
        -0.021504829,
        -0.01445723,
        0.0039280704,
        0.042744167,
        -0.0039280704,
        0.000285479,
        0.028286936,
        -0.004887461,
        0.033620905,
        0.0068364115,
        0.05642906,
        0.0003944664,
        0.045761116,
        -0.022168558,
        -0.02529412,
        0.013069433,
        -0.009581838,
        -0.031521108,
        0.03557589,
        0.0074880733,
        -0.031134937,
        0.030145377,
        -0.020394592,
        0.01808964,
        0.041271895,
        0.009249973,
        0.002997341,
        0.008592278,
        0.03420016,
        -0.05816682,
        0.017667267,
        -0.01737764,
        0.034055345,
        -0.01253845,
        -0.002882697,
        -0.032196905,
        0.032752022,
        -0.011102381,
        -0.037820503,
        0.0069329543,
        0.0064381743,
        0.006329564,
        0.010233499,
        0.0028087816,
        0.024256289,
        -0.041489113,
        0.030097106,
        -0.022771949,
        0.033693314,
        0.0040909857,
        -0.008079396,
        -0.004576715,
        0.0033759684,
        0.017908623,
        0.0031949515,
        -0.012828077,
        0.036589585,
        0.00879743,
        0.041199487,
        0.023435678,
        -0.004468105,
        -0.013540077,
        0.01374523,
        0.036589585,
        0.0067278016,
        -0.021951338,
        -0.0060278685,
        -0.0074699717,
        0.010686042,
        0.030386733,
        -0.02408734,
        -0.06280086,
        0.022494389,
        -0.013576281,
        -0.03811013,
        0.0069269203,
        0.013310789,
        0.024811408,
        0.05459475,
        0.0026881036,
        -0.021082455,
        0.007988887,
        -0.042599354,
        0.009117227,
        0.026549172,
        -0.009189634,
        -0.027369782,
        0.04568871,
        0.035020772,
        -0.0003501549,
        -0.015084757,
        0.00034525237,
        0.005644716,
        -0.030097106,
        -0.019875675,
        -0.023061575,
        -0.023616694,
        -0.005309834,
        0.013540077,
        -0.01605018,
        0.015881231,
        0.02821453,
        0.025390662,
        -0.002166171,
        0.04216491,
        0.00015556155,
        0.0058800383,
        0.017920692,
        -0.044023354,
        -0.0042146808,
        -0.003955223,
        -0.0019474421,
        -0.018017232,
        0.03140043,
        0.018886115,
        -0.001826764,
        0.050781325,
        0.022385778,
        0.027514596,
        -0.015639875,
        0.008839668,
        0.026814664,
        -0.039051417,
        -0.008948278,
        0.0029837647,
        0.02413561,
        -0.05107095,
        0.019211946,
        0.046726543,
        -0.003719901,
        0.0111446185,
        -0.021758253,
        -0.008544006,
        0.010945499,
        0.014433095,
        -0.030555682,
        0.016738046,
        -0.0032371888,
        0.023085712,
        0.029397173,
        -0.004510342,
        -0.04074091,
        -0.018656828,
        -0.009732685,
        -0.029904021,
        0.014191739,
        -0.0106498385,
        -0.021420354,
        0.028431749,
        0.0014089163,
        0.016943198,
        0.0023517136,
        0.01017316,
        0.0065588523,
        0.0077897683,
        -0.008863803,
        -0.0022762897,
        0.030386733,
        -0.020334251,
        0.010124888,
        0.001769442,
        -0.005255529,
        0.032848567,
        0.031979684,
        -0.019453302,
        -0.014541705,
        -0.0026850866,
        0.019453302,
        -0.042792436,
        0.014602045,
        0.012104008,
        0.004208647,
        -0.017232826,
        -0.028455885,
        -0.0016819504,
        0.031545244,
        -0.030555682,
        0.040161654,
        -0.028552428,
        0.03226931,
        0.040789183,
        0.00445302,
        -0.021420354,
        -0.0048060035,
        -0.012164348,
        -0.003415189,
        -0.021758253,
        -0.028648969,
        -0.02529412,
        -0.021951338,
        0.007566514,
        0.010179194,
        0.003656545,
        0.021999609,
        0.025004493,
        -0.019972218,
        -0.0066795303,
        -0.00844143,
        -0.003460443,
        -0.00901465,
        -0.012405704,
        0.004760749,
        -0.013202179,
        -0.010384346,
        0.02512517,
        -0.010022312,
        0.038061857,
        0.031303886,
        -0.04052369,
        0.05329143,
        -0.013081501,
        0.044916373,
        -0.028986868,
        0.0041814945,
        -0.000821365,
        -0.02034632,
        -0.009714583,
        -0.018186182,
        0.0073553273,
        0.001211306,
        -0.0250769,
        -0.0036354263,
        -0.028552428,
        0.0017091029,
        0.041633926,
        0.020092895,
        -0.049478002,
        0.028166257,
        0.0026941376,
        -0.059470143,
        0.008157836,
        -0.020768693,
        -0.03161765,
        0.007494107,
        0.001129094,
        0.008133701,
        0.015000282,
        0.017848283,
        -0.0024723916,
        0.014746858,
        0.025414798,
        -0.013938315,
        0.03827908,
        0.013455603,
        0.02705602,
        0.0016713911,
        -0.01798103,
        -0.025366526,
        0.01346767,
        0.028600698,
        -0.0003297905,
        0.009388752,
        -0.04189942,
        0.013877976,
        0.035165586,
        0.028069714,
        -0.03084531,
        -0.014372756,
        0.0016804419,
        -0.046605863,
        -0.006613157,
        -0.010794652,
        -0.017353503,
        -0.014107265,
        -0.016834589,
        -0.0075242766,
        0.0025598833,
        0.00021854042,
        -0.005336987,
        -0.015989842,
        0.0068424456,
        -0.026331952,
        0.018632691,
        0.075641006,
        0.0046762745,
        -0.033041652,
        0.009497363,
        0.025414798,
        -0.0035750873,
        -0.017824149,
        0.004887461,
        0.0012625941,
        -0.05696004,
        -0.0027348665,
        0.006175699,
        0.012924619,
        0.024039067,
        0.024497645,
        -0.004790919,
        0.002080188,
        0.016738046,
        0.0035901722,
        -0.032027956,
        0.019284353,
        0.0040698675,
        0.002160137,
        0.01297289,
        0.015470927,
        0.017800013,
        0.017956894,
        -0.019405032,
        -0.007120005,
        0.007138107,
        0.010782584,
        0.00069653866,
        -0.023315,
        -0.013395264,
        -0.0134797385,
        -0.017256962,
        -0.024401102,
        -0.0035087143,
        -0.022530593,
        -0.03183487,
        -0.024111474,
        -0.01880164,
        -0.023182254,
        0.010601567,
        0.053918954,
        0.012206585,
        -0.023870118,
        0.016581165,
        -0.009328414,
        -0.0077113276,
        -0.0021691879,
        0.012755671,
        -0.027442189,
        -0.03490009,
        0.009986109,
        -0.017015606,
        0.0071682762,
        0.019489506,
        0.011011872,
        0.00024493874,
        -0.026525036,
        -0.022409914,
        0.029807478,
        0.052374274,
        0.012333297,
        -0.03210036,
        0.012333297,
        -0.0036474941,
        -0.027345646,
        0.03931691,
        -0.033524364,
        0.0023170186,
        -0.004148308,
        0.0036082738,
        -0.009497363,
        0.060676925,
        0.007005361,
        0.013045297,
        -0.0076389206,
        -0.012453975,
        -0.01918781,
        0.019598115,
        -0.023109848,
        -0.03243826,
        -0.005249495,
        -4.7092723e-05,
        0.008278514,
        0.021782389,
        -0.03579311,
        0.015072688,
        -0.022627134,
        -0.014553773,
        -0.031883143,
        0.008326786,
        -0.0011864161,
        -0.02116693,
        0.029445445,
        0.031038394,
        -0.041658062,
        0.004293122,
        -0.017836217,
        0.00020854676,
        0.020744557,
        0.0071743103,
        -0.0603873,
        -0.004827122,
        -0.053194884,
        0.013310789,
        0.012526382,
        0.008749159,
        -0.012212619,
        0.016267402,
        -0.02413561,
        0.017462114,
        -0.030579818,
        0.02325466,
        -0.019308489,
        -0.025994053,
        -0.011283398,
        -0.028745512,
        0.016979402,
        -0.00830265,
        0.007101903,
        -0.004087969,
        0.0026881036,
        0.01901886,
        -0.014819264,
        0.0072768866,
        -0.023459813,
        0.020696286,
        0.0120014325,
        -0.007928548,
        0.036372364,
        0.0149520105,
        -0.0042508845,
        -0.007186378,
        -0.027949037,
        0.001636696,
        -0.013926247,
        0.0052917325,
        -0.03084531,
        -0.016207062,
        -0.036010332,
        0.027587002,
        -0.029276496,
        0.025849238,
        -0.013648688,
        -0.0027801206,
        0.026090594,
        0.04438539,
        0.020901438,
        -0.021299677,
        -0.011283398,
        -0.0021676796,
        -0.0062752585,
        0.0013206705,
        0.016376011,
        -0.02094971,
        0.0005102419,
        -0.012025568,
        -0.009961973,
        0.011210991,
        0.007898378,
        -0.031134937,
        -0.0077656326,
        0.0074156662,
        -0.0020454929,
        0.009889566,
        0.011675602,
        0.010655872,
        -0.004353461,
        -0.033838127,
        0.033572633,
        -0.015531265,
        -0.017341437,
        0.03902728,
        0.021456558,
        -0.02688707,
        -0.022771949,
        -0.0012377043,
        0.015108892,
        0.024208017,
        0.01918781,
        -0.007819938,
        0.010040414,
        -0.015072688,
        0.005457665,
        -0.018415472,
        0.00434441,
        -0.008725023,
        0.002413561,
        -0.007898378,
        -0.0071743103,
        -0.01512096,
        0.022663338,
        0.013781434,
        -0.017088013,
        -0.039485857,
        -0.018270656,
        0.046750676,
        -0.015289909,
        0.0026156968,
        0.0031859006,
        0.0023290864,
        0.0029068326,
        -0.015748486,
        0.016858723,
        0.00791648,
        0.03316233,
        0.013310789,
        0.08249552,
        -0.017341437,
        0.005889089,
        -0.003066731,
        0.008652616,
        0.017546589,
        -0.002451273,
        0.0019414081,
        -0.011283398,
        0.027369782,
        -0.0014798146,
        -0.039075553,
        -0.024980357,
        0.005466716,
        -0.057925466,
        0.006981225,
        -0.010239533,
        -0.008869837,
        -0.010891194,
        -0.0069088186,
        0.019453302,
        0.012755671,
        0.007138107,
        0.00296868,
        -0.010492956,
        -0.012719466,
        -0.06878649,
        0.029590258,
        0.015157163,
        -0.0062149195,
        -0.03885833,
        0.026356086,
        0.028311072,
        0.00078289886,
        -0.0022189678,
        0.018994726,
        0.007982853,
        0.026211273,
        -0.0031134938,
        -0.014565841,
        -0.005059427,
        -0.0025991036,
        -0.02430456,
        -0.024183882,
        -0.013081501,
        -0.033307143,
        0.0018780521,
        -0.026090594,
        -0.004256918,
        0.0049236645,
        -0.021915134,
        0.0056688515,
        -0.02903514,
        0.012695331,
        0.006196818,
        -0.011180822,
        -0.025463069,
        -0.03282443,
        -0.01346767,
        0.005083563,
        0.014288281,
        0.009913702,
        -0.040765047,
        -0.013877976,
        0.011947127,
        -0.0017151368,
        0.015989842,
        -0.015048553,
        0.024606254,
        -0.0026850866,
        0.042744167,
        -0.0005238182,
        -0.04228559,
        0.005451631,
        0.006139496,
        0.0031798666,
        -0.0067459033,
        -0.0036082738,
        0.011995398,
        0.0020454929,
        0.025752697,
        -0.008037158,
        0.009666312,
        -0.005222343,
        -0.015060621,
        0.005680919,
        0.013865909,
        -0.004419834,
        0.041802876,
        -0.00279068,
        -0.029107546,
        0.015362316,
        0.019405032,
        -0.027731817,
        -0.011705771,
        -0.0067157336,
        0.012755671,
        0.016906995,
        -0.039051417,
        0.019067133,
        -0.023773577,
        0.017003538,
        -0.017993098,
        -0.005889089,
        -0.007554446,
        0.02144449,
        0.035672434,
        0.018548217,
        -0.029952293,
        0.039872028,
        -0.037965316,
        0.015458859,
        0.013890044,
        -0.005952445,
        -0.018512012,
        -0.014119332,
        -0.017920692,
        -0.0014519078,
        0.04448193,
        -0.012067805,
        0.030917717,
        -0.005771428,
        0.016026046,
        0.011313567,
        0.03755501,
        0.005988648,
        0.013093568,
        0.009581838,
        -0.015482994,
        -0.0034634601,
        0.014203806,
        0.009334448,
        -0.006582988,
        0.016834589,
        -0.009388752,
        0.026404358,
        0.02243405,
        0.00054795376,
        -0.005813665,
        0.009382718,
        -0.036082737,
        -0.022578863,
        -0.0070355306,
        -0.029566122,
        -0.014674451,
        0.005258546,
        -0.030097106,
        -0.017775876,
        -0.04537495,
        0.029686801,
        -0.02589751,
        -0.008869837,
        -0.020937642,
        -0.0028268835,
        0.024473509,
        0.034562193,
        -0.022168558,
        -0.010661906,
        0.014083128,
        -0.03579311,
        0.051215764,
        0.033476092,
        0.004760749,
        0.00879743,
        -0.004576715,
        -0.008188006,
        -0.0152054345,
        -0.00082061073,
        -0.016677707,
        -0.02166171,
        0.0059222756,
        0.0132383825,
        0.0077113276,
        -0.0075122085,
        0.014372756,
        -0.009105159,
        0.010553296,
        -0.018898183,
        -0.01303323
      ],
      "embedding_pca_2d": [],
      "embedding_pca_3d": [],
      "embedding_cluster_id": null,
      "migration_history": [],
      "metadata": {
        "compute_time": 2.013352155685425,
        "patch_type": "cross",
        "api_costs": 0.00771525,
        "num_applied": 1,
        "patch_name": "sds_precedence_marginal_crossover",
        "patch_description": "This program is a crossover of the improved precedence-aware marginal-gain greedy solver and the simpler baseline greedy. It combines the robust parsing and transitive-closure handling from the improved version with faster interaction adjacency structures and quick feasibility checks derived from the baseline. Key enhancements:\n- Parses interactions into an adjacency map for O(deg) access.\n- Precomputes full ancestor closures for each variable to ensure precedence is respected cheaply.\n- Builds fast lookup structures for mutex and group constraints.\n- Uses a marginal-gain greedy loop that considers adding a variable plus its entire ancestor closure; tie-breakers favor larger closures when gains are equal to help reach minimum cardinality.\n- Includes a fallback phase that forces additions (best feasible closures even if negative gain) to satisfy minimum cardinality.\n- Lightweight final trimming by item marginal contribution if over max_card.\n\nThe program keeps the required input/output format (JSON in stdin, JSON out with selection.variables) and preserves the EVOLVE-BLOCK markers for evolution.",
        "error_attempt": null,
        "novelty_attempt": 1,
        "resample_attempt": 1,
        "patch_attempt": 1,
        "model_name": "gpt-5-mini",
        "temperature": 1.0,
        "max_output_tokens": 8192,
        "llm_result": {
          "content": "<NAME>\nsds_precedence_marginal_crossover\n</NAME>\n\n<DESCRIPTION>\nThis program is a crossover of the improved precedence-aware marginal-gain greedy solver and the simpler baseline greedy. It combines the robust parsing and transitive-closure handling from the improved version with faster interaction adjacency structures and quick feasibility checks derived from the baseline. Key enhancements:\n- Parses interactions into an adjacency map for O(deg) access.\n- Precomputes full ancestor closures for each variable to ensure precedence is respected cheaply.\n- Builds fast lookup structures for mutex and group constraints.\n- Uses a marginal-gain greedy loop that considers adding a variable plus its entire ancestor closure; tie-breakers favor larger closures when gains are equal to help reach minimum cardinality.\n- Includes a fallback phase that forces additions (best feasible closures even if negative gain) to satisfy minimum cardinality.\n- Lightweight final trimming by item marginal contribution if over max_card.\n\nThe program keeps the required input/output format (JSON in stdin, JSON out with selection.variables) and preserves the EVOLVE-BLOCK markers for evolution.\n</DESCRIPTION>\n\n<CODE>\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Crossover solver for the Synergistic Dependency Selection problem.\n\n    Reads JSON from stdin with \"requirements\" and \"catalog\", and prints JSON\n    with \"selection\": {\"variables\": [...] }.\n\n    Strategy:\n    - Parse inputs robustly.\n    - Build adjacency map for interactions for efficient marginal gain computation.\n    - Precompute transitive ancestor closure for precedence.\n    - For each candidate, consider adding its closure (itself + ancestors).\n    - Greedily add the closure with maximum marginal gain while respecting\n      mutex, groups, and cardinality. Tie-break in favor of larger closures to\n      satisfy minimum cardinality.\n    - If minimum cardinality not reached, add best feasible closures even if negative.\n    - Trim if needed by approximate item scores.\n    \"\"\"\n    import re\n    from collections import defaultdict, deque\n\n    data = json.load(sys.stdin)\n    requirements = data.get(\"requirements\", {}) or {}\n    catalog = data.get(\"catalog\", {}) or {}\n\n    weights = list(requirements.get(\"weights\", []) or [])\n    raw_interactions = requirements.get(\"interactions\", {}) or {}\n    card_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)]) or [0, len(weights)]\n    min_card = int(card_bounds[0]) if len(card_bounds) > 0 else 0\n    max_card = int(card_bounds[1]) if len(card_bounds) > 1 else len(weights)\n    mutex_list = requirements.get(\"mutex\", []) or []\n    groups = requirements.get(\"groups\", {}) or {}\n    precedence = requirements.get(\"precedence\", []) or []\n\n    n = len(weights)\n\n    # Parse interactions into adjacency dict: interactions[u][v] = value\n    interactions = defaultdict(dict)\n    def parse_key(k):\n        # return (u,v) or None\n        try:\n            if isinstance(k, str):\n                parts = re.split(r'\\s*,\\s*|\\s+', k.strip())\n                if len(parts) >= 2:\n                    return int(parts[0]), int(parts[1])\n            elif isinstance(k, (list, tuple)) and len(k) >= 2:\n                return int(k[0]), int(k[1])\n            elif isinstance(k, int):\n                return None\n        except Exception:\n            return None\n        return None\n\n    for k, v in raw_interactions.items():\n        parsed = parse_key(k)\n        try:\n            val = float(v)\n        except Exception:\n            continue\n        if parsed is None:\n            continue\n        u, w = parsed\n        if 0 <= u < n and 0 <= w < n:\n            interactions[u][w] = interactions[u].get(w, 0.0) + val\n            interactions[w][u] = interactions[w].get(u, 0.0) + val\n\n    # Build mutex map for quick conflict checks\n    mutex_map = defaultdict(set)\n    for pair in mutex_list:\n        try:\n            a, b = pair\n            a = int(a); b = int(b)\n            if 0 <= a < n and 0 <= b < n:\n                mutex_map[a].add(b)\n                mutex_map[b].add(a)\n        except Exception:\n            continue\n\n    # Normalize groups: map var -> group name, allow string/int keys\n    var_to_group = {}\n    for gname, vars_list in groups.items():\n        for v in vars_list:\n            try:\n                idx = int(v)\n                if 0 <= idx < n and gname is not None:\n                    # first membership wins\n                    if idx not in var_to_group:\n                        var_to_group[idx] = str(gname)\n            except Exception:\n                continue\n\n    # Build precedence graph (directed: p -> j means p is prerequisite of j)\n    preds = defaultdict(set)\n    succs = defaultdict(set)\n    for entry in precedence:\n        try:\n            a, b = entry\n            a = int(a); b = int(b)\n            if 0 <= a < n and 0 <= b < n:\n                preds[b].add(a)\n                succs[a].add(b)\n        except Exception:\n            continue\n\n    # Precompute transitive ancestor closure for each node using DFS/BFS\n    ancestor_closure = [set() for _ in range(n)]\n    for i in range(n):\n        # BFS/DFS from i to collect all ancestors\n        stack = list(preds.get(i, []))\n        seen = set(stack)\n        while stack:\n            cur = stack.pop()\n            ancestor_closure[i].add(cur)\n            for p in preds.get(cur, []):\n                if p not in seen:\n                    seen.add(p)\n                    stack.append(p)\n\n    # closure for variable i is ancestors + i\n    closures = [set(ancestor_closure[i]) | {i} for i in range(n)]\n\n    # Feasibility check of adding closure (closure is set of vars to ensure present),\n    # given currently selected_set.\n    def feasible_closure(closure, selected_set):\n        # New items that would be added\n        new_items = closure - selected_set\n        # Cardinality check\n        if len(selected_set) + len(new_items) > max_card:\n            return False\n        # Mutex check: none of new items conflict with each other or with selected\n        for v in new_items:\n            # conflicts with selected\n            if any(conflict in selected_set for conflict in mutex_map.get(v, ())) :\n                return False\n            # conflicts with other new items\n            for conflict in mutex_map.get(v, ()):\n                if conflict in new_items:\n                    return False\n        # Group check: cannot create group count >1\n        group_counts = {}\n        for v in selected_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in new_items:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: closures already contain transitive ancestors; but if closure lacks\n        # some ancestor (shouldn't) ensure those ancestors are in selected_set\n        for v in closure:\n            for a in preds.get(v, ()):\n                if a not in closure and a not in selected_set:\n                    return False\n        return True\n\n    # Compute marginal gain for adding closure (new items = closure - selected_set)\n    def marginal_gain(closure, selected_set):\n        new_items = closure - selected_set\n        if not new_items:\n            return 0.0\n        gain = 0.0\n        # weights\n        for i in new_items:\n            if 0 <= i < len(weights):\n                try:\n                    gain += float(weights[i])\n                except Exception:\n                    pass\n        # interactions among new items\n        # iterate edges from each new item to higher-index new items to avoid double count\n        new_list = list(new_items)\n        l = len(new_list)\n        for idx in range(l):\n            u = new_list[idx]\n            # interactions with other new items\n            for v in new_list[idx+1:]:\n                gain += interactions.get(u, {}).get(v, 0.0)\n        # interactions between new items and already selected\n        for u in new_items:\n            for v in selected_set:\n                gain += interactions.get(u, {}).get(v, 0.0)\n        return gain\n\n    # Greedy selection: add closure with best marginal gain while respecting constraints\n    selected_set = set()\n    # Initial heuristic: consider items sorted by weight+abs(interaction_potential)\n    # but main loop will evaluate closures anyway, so we iterate all candidates\n    improved = True\n    while len(selected_set) < max_card and improved:\n        improved = False\n        best_gain = float(\"-inf\")\n        best_closure = None\n        # Evaluate every candidate not yet in selected_set\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closures[i]\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # Tie-breaker: prefer larger closure (helps reach min_card)\n            if (gain > best_gain) or (abs(gain - best_gain) < 1e-12 and best_closure is not None and len(closure - selected_set) > len(best_closure - selected_set)) or (best_closure is None and gain >= best_gain):\n                best_gain = gain\n                best_closure = closure\n        # Accept non-negative gain closures; small negative may be accepted later to meet min_card\n        if best_closure is not None and best_gain > -1e-12:\n            new_items = best_closure - selected_set\n            if new_items:\n                selected_set.update(new_items)\n                improved = True\n        else:\n            break\n\n    # If we haven't met min_card, add best feasible closures even if negative\n    while len(selected_set) < min_card:\n        best_gain = float(\"-inf\")\n        best_closure = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closures[i]\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            if (gain > best_gain) or (abs(gain - best_gain) < 1e-12 and best_closure is not None and len(closure - selected_set) > len(best_closure - selected_set)) or (best_closure is None and gain >= best_gain):\n                best_gain = gain\n                best_closure = closure\n        if best_closure is None:\n            # no feasible closures left\n            break\n        selected_set.update(best_closure - selected_set)\n\n    # Safety trim if we're over max_card (should rarely happen due to checks)\n    if len(selected_set) > max_card:\n        # compute approximate item score = weight + sum interactions with others in selected_set\n        def item_score(i):\n            s = 0.0\n            if 0 <= i < len(weights):\n                try:\n                    s += float(weights[i])\n                except Exception:\n                    pass\n            for j in selected_set:\n                if j == i:\n                    continue\n                s += interactions.get(i, {}).get(j, 0.0)\n            return s\n        sorted_items = sorted(selected_set, key=lambda x: item_score(x), reverse=True)\n        selected_set = set(sorted_items[:max_card])\n\n    result = {\"selection\": {\"variables\": sorted(int(x) for x in selected_set)}}\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n\n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n\n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n\n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n\n    result_str = stdout_capture.getvalue()\n    return result_str\n\n```",
          "msg": "Here are the performance metrics of a set of prioviously implemented programs:\n\n# Prior programs\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    This is a greedy baseline - evolution will improve this.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    # Simple greedy: select items with highest weights first\n    # This is a baseline - evolution will find better strategies\n    n = len(weights)\n    selected = []\n    \n    # Create score list (weight + interaction potential)\n    scores = []\n    for i in range(n):\n        score = weights[i] if i < len(weights) else 0.0\n        # Add potential interaction value\n        for k, v in interactions.items():\n            try:\n                u, w = map(int, k.split(\",\"))\n                if u == i or w == i:\n                    score += abs(v) * 0.5  # Potential value\n            except:\n                pass\n        scores.append((score, i))\n    \n    # Sort by score descending\n    scores.sort(reverse=True)\n    \n    # Greedy selection respecting constraints\n    selected_set = set()\n    for score, i in scores:\n        if len(selected_set) >= cardinality_bounds[1]:\n            break\n            \n        # Check mutex constraints\n        can_add = True\n        for a, b in mutex:\n            if (a == i and b in selected_set) or (b == i and a in selected_set):\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n            \n        # Check group constraints (at most one per group)\n        for grp_vars in groups.values():\n            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n        \n        # Check precedence (if j selected, i must be selected)\n        precedence_ok = True\n        for pred_i, pred_j in precedence:\n            if pred_j == i and pred_i not in selected_set:\n                precedence_ok = False\n                break\n        \n        if not precedence_ok:\n            continue\n        \n        # Add if we meet minimum cardinality or have room\n        if len(selected_set) < cardinality_bounds[1]:\n            selected_set.add(i)\n            selected.append(i)\n    \n    # Ensure minimum cardinality\n    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n        for i in range(n):\n            if i not in selected_set:\n                selected_set.add(i)\n                selected.append(i)\n                break\n    \n    # Output result\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n    \n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n    \n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n    \n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n    \n    result_str = stdout_capture.getvalue()\n    return result_str\n\n\n```\n\nPerformance metrics:\nCombined score to maximize: 0.35\nfeasible: True; selection_size: 10; raw_score: 106.51\n\n\n# Current program\n\nHere is the current program we are trying to improve (you will need to propose a new program with the same inputs and outputs as the original program, but with improved internal implementation):\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Improved solver for the Synergistic Dependency Selection problem.\n\n    - Reads JSON from stdin with \"requirements\" and \"catalog\".\n    - Produces JSON to stdout with \"selection\": {\"variables\": [...] }.\n    - Uses a precedence-aware marginal-gain greedy algorithm that:\n        * when adding an item, also includes its required predecessors (closure),\n        * computes the marginal objective (weights + pairwise interactions),\n        * checks mutex/group/cardinality feasibility for the closure before adding.\n    \"\"\"\n    import re\n\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n\n    # Extract constraints\n    weights = list(requirements.get(\"weights\", []))\n    interactions_raw = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    min_card, max_card = (cardinality_bounds + [len(weights), len(weights)])[:2]\n    mutex = [tuple(m) for m in requirements.get(\"mutex\", [])]\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n\n    n = len(weights)\n\n    # Parse interactions into dict of tuple->float for quick lookup (undirected)\n    interactions = {}\n    for k, v in interactions_raw.items():\n        try:\n            if isinstance(k, str):\n                # allow \"u,v\" or \"u v\"\n                parts = re.split(r'\\s*,\\s*|\\s+', k.strip())\n                if len(parts) >= 2:\n                    u = int(parts[0]); w = int(parts[1])\n                else:\n                    continue\n            elif isinstance(k, (list, tuple)) and len(k) >= 2:\n                u = int(k[0]); w = int(k[1])\n            else:\n                continue\n            interactions[(u, w)] = float(v)\n            interactions[(w, u)] = float(v)\n        except Exception:\n            # skip malformed keys\n            continue\n\n    # Build precedence graph: if (p, j) then p is a prerequisite of j\n    preds = {i: set() for i in range(n)}\n    succs = {i: set() for i in range(n)}\n    for entry in precedence:\n        try:\n            a, b = entry\n            a = int(a); b = int(b)\n            preds[b].add(a)\n            succs[a].add(b)\n        except Exception:\n            continue\n\n    # Precompute ancestors (transitive closure of preds) using DFS/memoization\n    ancestor_cache = {}\n\n    def get_ancestors(i):\n        if i in ancestor_cache:\n            return ancestor_cache[i].copy()\n        res = set()\n        stack = [i]\n        while stack:\n            cur = stack.pop()\n            for p in preds.get(cur, []):\n                if p not in res:\n                    res.add(p)\n                    stack.append(p)\n        ancestor_cache[i] = res.copy()\n        return res\n\n    # Map variable -> group (assume at most one group membership; if multiple, first wins)\n    var_to_group = {}\n    for gname, vars_list in groups.items():\n        for v in vars_list:\n            try:\n                var_to_group[int(v)] = gname\n            except Exception:\n                pass\n\n    # Helper: check feasibility of adding a closure set given current selected_set\n    def feasible_closure(closure_set, selected_set):\n        # Cardinality\n        if len(selected_set) + len(closure_set - selected_set) > max_card:\n            return False\n        # Mutex: none of closure can conflict with each other or with selected_set\n        for a, b in mutex:\n            if a in closure_set and b in closure_set:\n                return False\n            if (a in closure_set and b in selected_set) or (b in closure_set and a in selected_set):\n                return False\n        # Group: ensure at most one per group overall\n        # Build per-group counts\n        group_counts = {}\n        for v in selected_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in closure_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: closure itself must include ancestors for each element\n        for v in closure_set:\n            if not get_ancestors(v).issubset(closure_set.union(selected_set)):\n                return False\n        return True\n\n    # Compute marginal gain of adding closure_set (items that will be newly included)\n    def marginal_gain(closure_set, selected_set):\n        new_items = set(closure_set) - set(selected_set)\n        gain = 0.0\n        for i in new_items:\n            if i < len(weights):\n                gain += float(weights[i])\n        # interactions among new items\n        new_list = list(new_items)\n        for i in range(len(new_list)):\n            for j in range(i + 1, len(new_list)):\n                gain += interactions.get((new_list[i], new_list[j]), 0.0)\n        # interactions between new items and already selected\n        for i in new_items:\n            for j in selected_set:\n                gain += interactions.get((i, j), 0.0)\n        return gain\n\n    # Greedy loop: at each step try to add an item (and its ancestors) with max marginal gain\n    selected_set = set()\n    # Keep iterating while we can still add and haven't reached max_card\n    improved = True\n    while len(selected_set) < max_card and improved:\n        improved = False\n        best_gain = float(\"-inf\")\n        best_closure = None\n        # Consider candidates not already selected\n        for i in range(n):\n            if i in selected_set:\n                continue\n            # closure includes i and its ancestors\n            closure = get_ancestors(i).union({i})\n            # Only consider closures that are feasible\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # Prefer closures that add more items when gain is equal (to help reach min_card)\n            if gain > best_gain or (abs(gain - best_gain) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_gain = gain\n                best_closure = closure\n        # If we found a positive-gain move, take it\n        if best_closure is not None and best_gain > -1e-12:\n            to_add = set(best_closure) - selected_set\n            if to_add:\n                selected_set.update(to_add)\n                improved = True\n        else:\n            # No non-negative gain move; stop greedy improvements\n            break\n\n    # If we still haven't met minimum cardinality, greedily add best feasible closures regardless of gain\n    while len(selected_set) < min_card:\n        best_gain = float(\"-inf\")\n        best_closure = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = get_ancestors(i).union({i})\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # choose closure that gives best gain (even if negative), tie-breaker favors larger closures\n            if gain > best_gain or (abs(gain - best_gain) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_gain = gain\n                best_closure = closure\n        if best_closure is None:\n            # No feasible closure remains; break to avoid infinite loop\n            break\n        selected_set.update(set(best_closure) - selected_set)\n\n    # Final trim if over max_card (shouldn't happen due to checks) - keep highest-weight items\n    if len(selected_set) > max_card:\n        # score items by marginal contribution relative to selected (approx): weight + interactions with others\n        def item_score(i):\n            s = float(weights[i]) if i < len(weights) else 0.0\n            for j in selected_set:\n                if j == i:\n                    continue\n                s += interactions.get((i, j), 0.0)\n            return s\n        sorted_items = sorted(selected_set, key=item_score, reverse=True)\n        selected_set = set(sorted_items[:max_card])\n\n    result = {\n        \"selection\": {\n            \"variables\": sorted(int(x) for x in selected_set)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n\n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n\n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n\n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n\n    result_str = stdout_capture.getvalue()\n    return result_str\n\n```\n\nHere are the performance metrics of the program:\n\nCombined score to maximize: 0.40\nfeasible: True; selection_size: 10; raw_score: 122.55\n\n# Task\n\nPerform a cross-over between the code script above and the one below. Aim to combine the best parts of both code implementations that improves the score.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs as the original program, but with improved internal implementation.\n\n\n# Crossover Inspiration Programs\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    This is a greedy baseline - evolution will improve this.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    # Simple greedy: select items with highest weights first\n    # This is a baseline - evolution will find better strategies\n    n = len(weights)\n    selected = []\n    \n    # Create score list (weight + interaction potential)\n    scores = []\n    for i in range(n):\n        score = weights[i] if i < len(weights) else 0.0\n        # Add potential interaction value\n        for k, v in interactions.items():\n            try:\n                u, w = map(int, k.split(\",\"))\n                if u == i or w == i:\n                    score += abs(v) * 0.5  # Potential value\n            except:\n                pass\n        scores.append((score, i))\n    \n    # Sort by score descending\n    scores.sort(reverse=True)\n    \n    # Greedy selection respecting constraints\n    selected_set = set()\n    for score, i in scores:\n        if len(selected_set) >= cardinality_bounds[1]:\n            break\n            \n        # Check mutex constraints\n        can_add = True\n        for a, b in mutex:\n            if (a == i and b in selected_set) or (b == i and a in selected_set):\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n            \n        # Check group constraints (at most one per group)\n        for grp_vars in groups.values():\n            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n        \n        # Check precedence (if j selected, i must be selected)\n        precedence_ok = True\n        for pred_i, pred_j in precedence:\n            if pred_j == i and pred_i not in selected_set:\n                precedence_ok = False\n                break\n        \n        if not precedence_ok:\n            continue\n        \n        # Add if we meet minimum cardinality or have room\n        if len(selected_set) < cardinality_bounds[1]:\n            selected_set.add(i)\n            selected.append(i)\n    \n    # Ensure minimum cardinality\n    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n        for i in range(n):\n            if i not in selected_set:\n                selected_set.add(i)\n                selected.append(i)\n                break\n    \n    # Output result\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n    \n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n    \n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n    \n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n    \n    result_str = stdout_capture.getvalue()\n    return result_str\n\n\n```\n\nPerformance metrics: Combined score to maximize: 0.35\nfeasible: True; selection_size: 10; raw_score: 106.51\n\n",
          "system_msg": "You are an expert algorithmist specializing in combinatorial optimization, particularly the Synergistic Dependency Selection (SDS) problem.\n\nThe SDS problem requires selecting a subset of variables that:\n1. Satisfies cardinality bounds (min/max number of items)\n2. Respects mutex constraints (cannot select both items in a mutex pair)\n3. Respects group constraints (at most one item per group)\n4. Satisfies precedence constraints (if j is selected, i must be selected)\n5. Maximizes the objective: sum of selected item weights + pairwise interaction values\n\nKey strategies to explore:\n1. Greedy selection with constraint-aware ordering\n2. Dynamic programming for small instances\n3. Constraint satisfaction with backtracking\n4. Weighted scoring that accounts for interactions\n5. Precedence-aware selection ordering\n6. Group-aware selection that maximizes diversity\n\nThe code should read JSON from stdin with \"requirements\" and \"catalog\", and output JSON to stdout with \"selection\" containing \"variables\" list.\n\nBe creative and find efficient solutions that maximize the objective while respecting all constraints.\nYou are given multiple code scripts implementing the same algorithm.\nYou are tasked with generating a new code snippet that combines these code scripts in a way that is more efficient. \nI.e. perform crossover between the code scripts.\nProvide the complete new program code.\nYou MUST repond using a short summary name, description and the full code:\n\n<NAME>\nA shortened name summarizing the code you are proposing. Lowercase, no spaces, underscores allowed.\n</NAME>\n\n<DESCRIPTION>\nA description and argumentation process of the code you are proposing.\n</DESCRIPTION>\n\n<CODE>\n```{language}\n# The new rewritten program here.\n```\n</CODE>\n\n* Keep the markers \"EVOLVE-BLOCK-START\" and \"EVOLVE-BLOCK-END\" in the code. Do not change the code outside of these markers.\n* Make sure your rewritten program maintains the same inputs and outputs as the original program, but with improved internal implementation.\n* Make sure the file still runs after your changes.\n* Use the <NAME>, <DESCRIPTION>, and <CODE> delimiters to structure your response. It will be parsed afterwards.",
          "new_msg_history": [
            {
              "role": "user",
              "content": "Here are the performance metrics of a set of prioviously implemented programs:\n\n# Prior programs\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    This is a greedy baseline - evolution will improve this.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    # Simple greedy: select items with highest weights first\n    # This is a baseline - evolution will find better strategies\n    n = len(weights)\n    selected = []\n    \n    # Create score list (weight + interaction potential)\n    scores = []\n    for i in range(n):\n        score = weights[i] if i < len(weights) else 0.0\n        # Add potential interaction value\n        for k, v in interactions.items():\n            try:\n                u, w = map(int, k.split(\",\"))\n                if u == i or w == i:\n                    score += abs(v) * 0.5  # Potential value\n            except:\n                pass\n        scores.append((score, i))\n    \n    # Sort by score descending\n    scores.sort(reverse=True)\n    \n    # Greedy selection respecting constraints\n    selected_set = set()\n    for score, i in scores:\n        if len(selected_set) >= cardinality_bounds[1]:\n            break\n            \n        # Check mutex constraints\n        can_add = True\n        for a, b in mutex:\n            if (a == i and b in selected_set) or (b == i and a in selected_set):\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n            \n        # Check group constraints (at most one per group)\n        for grp_vars in groups.values():\n            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n        \n        # Check precedence (if j selected, i must be selected)\n        precedence_ok = True\n        for pred_i, pred_j in precedence:\n            if pred_j == i and pred_i not in selected_set:\n                precedence_ok = False\n                break\n        \n        if not precedence_ok:\n            continue\n        \n        # Add if we meet minimum cardinality or have room\n        if len(selected_set) < cardinality_bounds[1]:\n            selected_set.add(i)\n            selected.append(i)\n    \n    # Ensure minimum cardinality\n    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n        for i in range(n):\n            if i not in selected_set:\n                selected_set.add(i)\n                selected.append(i)\n                break\n    \n    # Output result\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n    \n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n    \n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n    \n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n    \n    result_str = stdout_capture.getvalue()\n    return result_str\n\n\n```\n\nPerformance metrics:\nCombined score to maximize: 0.35\nfeasible: True; selection_size: 10; raw_score: 106.51\n\n\n# Current program\n\nHere is the current program we are trying to improve (you will need to propose a new program with the same inputs and outputs as the original program, but with improved internal implementation):\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Improved solver for the Synergistic Dependency Selection problem.\n\n    - Reads JSON from stdin with \"requirements\" and \"catalog\".\n    - Produces JSON to stdout with \"selection\": {\"variables\": [...] }.\n    - Uses a precedence-aware marginal-gain greedy algorithm that:\n        * when adding an item, also includes its required predecessors (closure),\n        * computes the marginal objective (weights + pairwise interactions),\n        * checks mutex/group/cardinality feasibility for the closure before adding.\n    \"\"\"\n    import re\n\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n\n    # Extract constraints\n    weights = list(requirements.get(\"weights\", []))\n    interactions_raw = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    min_card, max_card = (cardinality_bounds + [len(weights), len(weights)])[:2]\n    mutex = [tuple(m) for m in requirements.get(\"mutex\", [])]\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n\n    n = len(weights)\n\n    # Parse interactions into dict of tuple->float for quick lookup (undirected)\n    interactions = {}\n    for k, v in interactions_raw.items():\n        try:\n            if isinstance(k, str):\n                # allow \"u,v\" or \"u v\"\n                parts = re.split(r'\\s*,\\s*|\\s+', k.strip())\n                if len(parts) >= 2:\n                    u = int(parts[0]); w = int(parts[1])\n                else:\n                    continue\n            elif isinstance(k, (list, tuple)) and len(k) >= 2:\n                u = int(k[0]); w = int(k[1])\n            else:\n                continue\n            interactions[(u, w)] = float(v)\n            interactions[(w, u)] = float(v)\n        except Exception:\n            # skip malformed keys\n            continue\n\n    # Build precedence graph: if (p, j) then p is a prerequisite of j\n    preds = {i: set() for i in range(n)}\n    succs = {i: set() for i in range(n)}\n    for entry in precedence:\n        try:\n            a, b = entry\n            a = int(a); b = int(b)\n            preds[b].add(a)\n            succs[a].add(b)\n        except Exception:\n            continue\n\n    # Precompute ancestors (transitive closure of preds) using DFS/memoization\n    ancestor_cache = {}\n\n    def get_ancestors(i):\n        if i in ancestor_cache:\n            return ancestor_cache[i].copy()\n        res = set()\n        stack = [i]\n        while stack:\n            cur = stack.pop()\n            for p in preds.get(cur, []):\n                if p not in res:\n                    res.add(p)\n                    stack.append(p)\n        ancestor_cache[i] = res.copy()\n        return res\n\n    # Map variable -> group (assume at most one group membership; if multiple, first wins)\n    var_to_group = {}\n    for gname, vars_list in groups.items():\n        for v in vars_list:\n            try:\n                var_to_group[int(v)] = gname\n            except Exception:\n                pass\n\n    # Helper: check feasibility of adding a closure set given current selected_set\n    def feasible_closure(closure_set, selected_set):\n        # Cardinality\n        if len(selected_set) + len(closure_set - selected_set) > max_card:\n            return False\n        # Mutex: none of closure can conflict with each other or with selected_set\n        for a, b in mutex:\n            if a in closure_set and b in closure_set:\n                return False\n            if (a in closure_set and b in selected_set) or (b in closure_set and a in selected_set):\n                return False\n        # Group: ensure at most one per group overall\n        # Build per-group counts\n        group_counts = {}\n        for v in selected_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in closure_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: closure itself must include ancestors for each element\n        for v in closure_set:\n            if not get_ancestors(v).issubset(closure_set.union(selected_set)):\n                return False\n        return True\n\n    # Compute marginal gain of adding closure_set (items that will be newly included)\n    def marginal_gain(closure_set, selected_set):\n        new_items = set(closure_set) - set(selected_set)\n        gain = 0.0\n        for i in new_items:\n            if i < len(weights):\n                gain += float(weights[i])\n        # interactions among new items\n        new_list = list(new_items)\n        for i in range(len(new_list)):\n            for j in range(i + 1, len(new_list)):\n                gain += interactions.get((new_list[i], new_list[j]), 0.0)\n        # interactions between new items and already selected\n        for i in new_items:\n            for j in selected_set:\n                gain += interactions.get((i, j), 0.0)\n        return gain\n\n    # Greedy loop: at each step try to add an item (and its ancestors) with max marginal gain\n    selected_set = set()\n    # Keep iterating while we can still add and haven't reached max_card\n    improved = True\n    while len(selected_set) < max_card and improved:\n        improved = False\n        best_gain = float(\"-inf\")\n        best_closure = None\n        # Consider candidates not already selected\n        for i in range(n):\n            if i in selected_set:\n                continue\n            # closure includes i and its ancestors\n            closure = get_ancestors(i).union({i})\n            # Only consider closures that are feasible\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # Prefer closures that add more items when gain is equal (to help reach min_card)\n            if gain > best_gain or (abs(gain - best_gain) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_gain = gain\n                best_closure = closure\n        # If we found a positive-gain move, take it\n        if best_closure is not None and best_gain > -1e-12:\n            to_add = set(best_closure) - selected_set\n            if to_add:\n                selected_set.update(to_add)\n                improved = True\n        else:\n            # No non-negative gain move; stop greedy improvements\n            break\n\n    # If we still haven't met minimum cardinality, greedily add best feasible closures regardless of gain\n    while len(selected_set) < min_card:\n        best_gain = float(\"-inf\")\n        best_closure = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = get_ancestors(i).union({i})\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # choose closure that gives best gain (even if negative), tie-breaker favors larger closures\n            if gain > best_gain or (abs(gain - best_gain) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_gain = gain\n                best_closure = closure\n        if best_closure is None:\n            # No feasible closure remains; break to avoid infinite loop\n            break\n        selected_set.update(set(best_closure) - selected_set)\n\n    # Final trim if over max_card (shouldn't happen due to checks) - keep highest-weight items\n    if len(selected_set) > max_card:\n        # score items by marginal contribution relative to selected (approx): weight + interactions with others\n        def item_score(i):\n            s = float(weights[i]) if i < len(weights) else 0.0\n            for j in selected_set:\n                if j == i:\n                    continue\n                s += interactions.get((i, j), 0.0)\n            return s\n        sorted_items = sorted(selected_set, key=item_score, reverse=True)\n        selected_set = set(sorted_items[:max_card])\n\n    result = {\n        \"selection\": {\n            \"variables\": sorted(int(x) for x in selected_set)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n\n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n\n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n\n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n\n    result_str = stdout_capture.getvalue()\n    return result_str\n\n```\n\nHere are the performance metrics of the program:\n\nCombined score to maximize: 0.40\nfeasible: True; selection_size: 10; raw_score: 122.55\n\n# Task\n\nPerform a cross-over between the code script above and the one below. Aim to combine the best parts of both code implementations that improves the score.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs as the original program, but with improved internal implementation.\n\n\n# Crossover Inspiration Programs\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    This is a greedy baseline - evolution will improve this.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    # Simple greedy: select items with highest weights first\n    # This is a baseline - evolution will find better strategies\n    n = len(weights)\n    selected = []\n    \n    # Create score list (weight + interaction potential)\n    scores = []\n    for i in range(n):\n        score = weights[i] if i < len(weights) else 0.0\n        # Add potential interaction value\n        for k, v in interactions.items():\n            try:\n                u, w = map(int, k.split(\",\"))\n                if u == i or w == i:\n                    score += abs(v) * 0.5  # Potential value\n            except:\n                pass\n        scores.append((score, i))\n    \n    # Sort by score descending\n    scores.sort(reverse=True)\n    \n    # Greedy selection respecting constraints\n    selected_set = set()\n    for score, i in scores:\n        if len(selected_set) >= cardinality_bounds[1]:\n            break\n            \n        # Check mutex constraints\n        can_add = True\n        for a, b in mutex:\n            if (a == i and b in selected_set) or (b == i and a in selected_set):\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n            \n        # Check group constraints (at most one per group)\n        for grp_vars in groups.values():\n            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n        \n        # Check precedence (if j selected, i must be selected)\n        precedence_ok = True\n        for pred_i, pred_j in precedence:\n            if pred_j == i and pred_i not in selected_set:\n                precedence_ok = False\n                break\n        \n        if not precedence_ok:\n            continue\n        \n        # Add if we meet minimum cardinality or have room\n        if len(selected_set) < cardinality_bounds[1]:\n            selected_set.add(i)\n            selected.append(i)\n    \n    # Ensure minimum cardinality\n    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n        for i in range(n):\n            if i not in selected_set:\n                selected_set.add(i)\n                selected.append(i)\n                break\n    \n    # Output result\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n    \n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n    \n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n    \n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n    \n    result_str = stdout_capture.getvalue()\n    return result_str\n\n\n```\n\nPerformance metrics: Combined score to maximize: 0.35\nfeasible: True; selection_size: 10; raw_score: 106.51\n\n"
            },
            {
              "role": "assistant",
              "content": "<NAME>\nsds_precedence_marginal_crossover\n</NAME>\n\n<DESCRIPTION>\nThis program is a crossover of the improved precedence-aware marginal-gain greedy solver and the simpler baseline greedy. It combines the robust parsing and transitive-closure handling from the improved version with faster interaction adjacency structures and quick feasibility checks derived from the baseline. Key enhancements:\n- Parses interactions into an adjacency map for O(deg) access.\n- Precomputes full ancestor closures for each variable to ensure precedence is respected cheaply.\n- Builds fast lookup structures for mutex and group constraints.\n- Uses a marginal-gain greedy loop that considers adding a variable plus its entire ancestor closure; tie-breakers favor larger closures when gains are equal to help reach minimum cardinality.\n- Includes a fallback phase that forces additions (best feasible closures even if negative gain) to satisfy minimum cardinality.\n- Lightweight final trimming by item marginal contribution if over max_card.\n\nThe program keeps the required input/output format (JSON in stdin, JSON out with selection.variables) and preserves the EVOLVE-BLOCK markers for evolution.\n</DESCRIPTION>\n\n<CODE>\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Crossover solver for the Synergistic Dependency Selection problem.\n\n    Reads JSON from stdin with \"requirements\" and \"catalog\", and prints JSON\n    with \"selection\": {\"variables\": [...] }.\n\n    Strategy:\n    - Parse inputs robustly.\n    - Build adjacency map for interactions for efficient marginal gain computation.\n    - Precompute transitive ancestor closure for precedence.\n    - For each candidate, consider adding its closure (itself + ancestors).\n    - Greedily add the closure with maximum marginal gain while respecting\n      mutex, groups, and cardinality. Tie-break in favor of larger closures to\n      satisfy minimum cardinality.\n    - If minimum cardinality not reached, add best feasible closures even if negative.\n    - Trim if needed by approximate item scores.\n    \"\"\"\n    import re\n    from collections import defaultdict, deque\n\n    data = json.load(sys.stdin)\n    requirements = data.get(\"requirements\", {}) or {}\n    catalog = data.get(\"catalog\", {}) or {}\n\n    weights = list(requirements.get(\"weights\", []) or [])\n    raw_interactions = requirements.get(\"interactions\", {}) or {}\n    card_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)]) or [0, len(weights)]\n    min_card = int(card_bounds[0]) if len(card_bounds) > 0 else 0\n    max_card = int(card_bounds[1]) if len(card_bounds) > 1 else len(weights)\n    mutex_list = requirements.get(\"mutex\", []) or []\n    groups = requirements.get(\"groups\", {}) or {}\n    precedence = requirements.get(\"precedence\", []) or []\n\n    n = len(weights)\n\n    # Parse interactions into adjacency dict: interactions[u][v] = value\n    interactions = defaultdict(dict)\n    def parse_key(k):\n        # return (u,v) or None\n        try:\n            if isinstance(k, str):\n                parts = re.split(r'\\s*,\\s*|\\s+', k.strip())\n                if len(parts) >= 2:\n                    return int(parts[0]), int(parts[1])\n            elif isinstance(k, (list, tuple)) and len(k) >= 2:\n                return int(k[0]), int(k[1])\n            elif isinstance(k, int):\n                return None\n        except Exception:\n            return None\n        return None\n\n    for k, v in raw_interactions.items():\n        parsed = parse_key(k)\n        try:\n            val = float(v)\n        except Exception:\n            continue\n        if parsed is None:\n            continue\n        u, w = parsed\n        if 0 <= u < n and 0 <= w < n:\n            interactions[u][w] = interactions[u].get(w, 0.0) + val\n            interactions[w][u] = interactions[w].get(u, 0.0) + val\n\n    # Build mutex map for quick conflict checks\n    mutex_map = defaultdict(set)\n    for pair in mutex_list:\n        try:\n            a, b = pair\n            a = int(a); b = int(b)\n            if 0 <= a < n and 0 <= b < n:\n                mutex_map[a].add(b)\n                mutex_map[b].add(a)\n        except Exception:\n            continue\n\n    # Normalize groups: map var -> group name, allow string/int keys\n    var_to_group = {}\n    for gname, vars_list in groups.items():\n        for v in vars_list:\n            try:\n                idx = int(v)\n                if 0 <= idx < n and gname is not None:\n                    # first membership wins\n                    if idx not in var_to_group:\n                        var_to_group[idx] = str(gname)\n            except Exception:\n                continue\n\n    # Build precedence graph (directed: p -> j means p is prerequisite of j)\n    preds = defaultdict(set)\n    succs = defaultdict(set)\n    for entry in precedence:\n        try:\n            a, b = entry\n            a = int(a); b = int(b)\n            if 0 <= a < n and 0 <= b < n:\n                preds[b].add(a)\n                succs[a].add(b)\n        except Exception:\n            continue\n\n    # Precompute transitive ancestor closure for each node using DFS/BFS\n    ancestor_closure = [set() for _ in range(n)]\n    for i in range(n):\n        # BFS/DFS from i to collect all ancestors\n        stack = list(preds.get(i, []))\n        seen = set(stack)\n        while stack:\n            cur = stack.pop()\n            ancestor_closure[i].add(cur)\n            for p in preds.get(cur, []):\n                if p not in seen:\n                    seen.add(p)\n                    stack.append(p)\n\n    # closure for variable i is ancestors + i\n    closures = [set(ancestor_closure[i]) | {i} for i in range(n)]\n\n    # Feasibility check of adding closure (closure is set of vars to ensure present),\n    # given currently selected_set.\n    def feasible_closure(closure, selected_set):\n        # New items that would be added\n        new_items = closure - selected_set\n        # Cardinality check\n        if len(selected_set) + len(new_items) > max_card:\n            return False\n        # Mutex check: none of new items conflict with each other or with selected\n        for v in new_items:\n            # conflicts with selected\n            if any(conflict in selected_set for conflict in mutex_map.get(v, ())) :\n                return False\n            # conflicts with other new items\n            for conflict in mutex_map.get(v, ()):\n                if conflict in new_items:\n                    return False\n        # Group check: cannot create group count >1\n        group_counts = {}\n        for v in selected_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in new_items:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: closures already contain transitive ancestors; but if closure lacks\n        # some ancestor (shouldn't) ensure those ancestors are in selected_set\n        for v in closure:\n            for a in preds.get(v, ()):\n                if a not in closure and a not in selected_set:\n                    return False\n        return True\n\n    # Compute marginal gain for adding closure (new items = closure - selected_set)\n    def marginal_gain(closure, selected_set):\n        new_items = closure - selected_set\n        if not new_items:\n            return 0.0\n        gain = 0.0\n        # weights\n        for i in new_items:\n            if 0 <= i < len(weights):\n                try:\n                    gain += float(weights[i])\n                except Exception:\n                    pass\n        # interactions among new items\n        # iterate edges from each new item to higher-index new items to avoid double count\n        new_list = list(new_items)\n        l = len(new_list)\n        for idx in range(l):\n            u = new_list[idx]\n            # interactions with other new items\n            for v in new_list[idx+1:]:\n                gain += interactions.get(u, {}).get(v, 0.0)\n        # interactions between new items and already selected\n        for u in new_items:\n            for v in selected_set:\n                gain += interactions.get(u, {}).get(v, 0.0)\n        return gain\n\n    # Greedy selection: add closure with best marginal gain while respecting constraints\n    selected_set = set()\n    # Initial heuristic: consider items sorted by weight+abs(interaction_potential)\n    # but main loop will evaluate closures anyway, so we iterate all candidates\n    improved = True\n    while len(selected_set) < max_card and improved:\n        improved = False\n        best_gain = float(\"-inf\")\n        best_closure = None\n        # Evaluate every candidate not yet in selected_set\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closures[i]\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # Tie-breaker: prefer larger closure (helps reach min_card)\n            if (gain > best_gain) or (abs(gain - best_gain) < 1e-12 and best_closure is not None and len(closure - selected_set) > len(best_closure - selected_set)) or (best_closure is None and gain >= best_gain):\n                best_gain = gain\n                best_closure = closure\n        # Accept non-negative gain closures; small negative may be accepted later to meet min_card\n        if best_closure is not None and best_gain > -1e-12:\n            new_items = best_closure - selected_set\n            if new_items:\n                selected_set.update(new_items)\n                improved = True\n        else:\n            break\n\n    # If we haven't met min_card, add best feasible closures even if negative\n    while len(selected_set) < min_card:\n        best_gain = float(\"-inf\")\n        best_closure = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closures[i]\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            if (gain > best_gain) or (abs(gain - best_gain) < 1e-12 and best_closure is not None and len(closure - selected_set) > len(best_closure - selected_set)) or (best_closure is None and gain >= best_gain):\n                best_gain = gain\n                best_closure = closure\n        if best_closure is None:\n            # no feasible closures left\n            break\n        selected_set.update(best_closure - selected_set)\n\n    # Safety trim if we're over max_card (should rarely happen due to checks)\n    if len(selected_set) > max_card:\n        # compute approximate item score = weight + sum interactions with others in selected_set\n        def item_score(i):\n            s = 0.0\n            if 0 <= i < len(weights):\n                try:\n                    s += float(weights[i])\n                except Exception:\n                    pass\n            for j in selected_set:\n                if j == i:\n                    continue\n                s += interactions.get(i, {}).get(j, 0.0)\n            return s\n        sorted_items = sorted(selected_set, key=lambda x: item_score(x), reverse=True)\n        selected_set = set(sorted_items[:max_card])\n\n    result = {\"selection\": {\"variables\": sorted(int(x) for x in selected_set)}}\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n\n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n\n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n\n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n\n    result_str = stdout_capture.getvalue()\n    return result_str\n\n```"
            }
          ],
          "model_name": "gpt-5-mini",
          "kwargs": {
            "temperature": 1.0,
            "max_output_tokens": 8192
          },
          "input_tokens": 4701,
          "output_tokens": 3270,
          "cost": 0.00771525,
          "input_cost": 0.0011752499999999999,
          "output_cost": 0.00654,
          "thought": "",
          "model_posteriors": {
            "gpt-5-mini": 1.0
          }
        },
        "diff_summary": {
          "added": 48,
          "deleted": 0,
          "modified": 120
        },
        "embed_cost": 4.508e-05,
        "novelty_cost": 0.0,
        "stdout_log": "Evaluating program: sds_dataset_output/problem_0/gen_6/main.py\nSaving results to: sds_dataset_output/problem_0/gen_6/results\nRun 1/1 completed in 0.00 seconds\nCorrectness and error status saved to sds_dataset_output/problem_0/gen_6/results/correct.json\nMetrics saved to sds_dataset_output/problem_0/gen_6/results/metrics.json\nEvaluation and Validation completed successfully.\nMetrics:\n  combined_score: 0.3993475858389672\n  public:\n    feasible: True\n    selection_size: 10\n    raw_score: 122.54942718671678\n  private:\n    selection: [3, 4, 5, 6, 7, 9, 10, 11, 13, 14]\n    raw_score: 122.54942718671678\n    normalized_fitness: 0.3993475858389672\n  execution_time_mean: 0.0006457919998865691\n  execution_time_std: 0.0\n  num_valid_runs: 1\n  num_invalid_runs: 0\n  all_validation_errors: []\n",
        "stderr_log": "",
        "code_analysis_metrics": {
          "cyclomatic_complexity": 65,
          "average_cyclomatic_complexity": 32.5,
          "halstead_volume": 2175.512454274525,
          "halstead_difficulty": 12.34108527131783,
          "halstead_effort": 26848.184707015847,
          "lines_of_code": 300,
          "logical_lines_of_code": 216,
          "comments": 42,
          "maintainability_index": -34.909988501355926,
          "max_nesting_depth": 6,
          "complexity_score": 1.0
        }
      },
      "in_archive": false
    },
    {
      "id": "53281c24-286f-4d71-b488-5d83b2cc485d",
      "code": "\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Improved solver for the Synergistic Dependency Selection problem.\n\n    - Reads JSON from stdin with \"requirements\" and \"catalog\".\n    - Produces JSON to stdout with \"selection\": {\"variables\": [...] }.\n    - Uses a precedence-aware marginal-gain greedy algorithm that:\n        * when adding an item, also includes its required predecessors (closure),\n        * computes the marginal objective (weights + pairwise interactions),\n        * checks mutex/group/cardinality feasibility for the closure before adding.\n    - Adds a lightweight one-step lookahead: when evaluating a candidate closure,\n      also consider the best single subsequent closure that would be feasible after\n      adding the candidate. A discounted portion of that subsequent gain is added\n      to the candidate score to prefer moves that enable strong follow-ups.\n    \"\"\"\n    import re\n\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n\n    # Extract constraints\n    weights = list(requirements.get(\"weights\", []))\n    interactions_raw = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    min_card, max_card = (cardinality_bounds + [len(weights), len(weights)])[:2]\n    mutex = [tuple(m) for m in requirements.get(\"mutex\", [])]\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n\n    n = len(weights)\n\n    # Parse interactions into dict of tuple->float for quick lookup (undirected)\n    interactions = {}\n    for k, v in interactions_raw.items():\n        try:\n            if isinstance(k, str):\n                # allow \"u,v\" or \"u v\"\n                parts = re.split(r'\\s*,\\s*|\\s+', k.strip())\n                if len(parts) >= 2:\n                    u = int(parts[0]); w = int(parts[1])\n                else:\n                    continue\n            elif isinstance(k, (list, tuple)) and len(k) >= 2:\n                u = int(k[0]); w = int(k[1])\n            else:\n                continue\n            interactions[(u, w)] = float(v)\n            interactions[(w, u)] = float(v)\n        except Exception:\n            # skip malformed keys\n            continue\n\n    # Build precedence graph: if (p, j) then p is a prerequisite of j\n    preds = {i: set() for i in range(n)}\n    succs = {i: set() for i in range(n)}\n    for entry in precedence:\n        try:\n            a, b = entry\n            a = int(a); b = int(b)\n            preds[b].add(a)\n            succs[a].add(b)\n        except Exception:\n            continue\n\n    # Precompute ancestors (transitive closure of preds) using DFS/memoization\n    ancestor_cache = {}\n\n    def get_ancestors(i):\n        if i in ancestor_cache:\n            return ancestor_cache[i].copy()\n        res = set()\n        stack = [i]\n        while stack:\n            cur = stack.pop()\n            for p in preds.get(cur, []):\n                if p not in res:\n                    res.add(p)\n                    stack.append(p)\n        ancestor_cache[i] = res.copy()\n        return res\n\n    # Precompute closures (ancestors + self) and cache them for fast reuse\n    closure_cache = {i: get_ancestors(i).union({i}) for i in range(n)}\n\n    # Map variable -> group (assume at most one group membership; if multiple, first wins)\n    var_to_group = {}\n    for gname, vars_list in groups.items():\n        for v in vars_list:\n            try:\n                var_to_group[int(v)] = gname\n            except Exception:\n                pass\n\n    # Helper: check feasibility of adding a closure set given current selected_set\n    def feasible_closure(closure_set, selected_set):\n        # Cardinality\n        if len(selected_set) + len(closure_set - selected_set) > max_card:\n            return False\n        # Mutex: none of closure can conflict with each other or with selected_set\n        for a, b in mutex:\n            if a in closure_set and b in closure_set:\n                return False\n            if (a in closure_set and b in selected_set) or (b in closure_set and a in selected_set):\n                return False\n        # Group: ensure at most one per group overall\n        # Build per-group counts\n        group_counts = {}\n        for v in selected_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in closure_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: closure itself must include ancestors for each element (or they are already selected)\n        for v in closure_set:\n            if not get_ancestors(v).issubset(closure_set.union(selected_set)):\n                return False\n        return True\n\n    # Compute marginal gain of adding closure_set (items that will be newly included)\n    def marginal_gain(closure_set, selected_set):\n        new_items = set(closure_set) - set(selected_set)\n        if not new_items:\n            return 0.0\n        gain = 0.0\n        for i in new_items:\n            if 0 <= i < len(weights):\n                gain += float(weights[i])\n        # interactions among new items\n        new_list = list(new_items)\n        for a in range(len(new_list)):\n            for b in range(a + 1, len(new_list)):\n                gain += interactions.get((new_list[a], new_list[b]), 0.0)\n        # interactions between new items and already selected\n        for i in new_items:\n            for j in selected_set:\n                gain += interactions.get((i, j), 0.0)\n        return gain\n\n    # Greedy loop: at each step try to add an item (and its ancestors) with max marginal gain\n    # Enhanced with small one-step lookahead: for each candidate closure consider the best\n    # subsequent single-closure gain and add a discounted fraction to the candidate score.\n    selected_set = set()\n    improved = True\n    LOOKAHEAD_DISCOUNT = 0.5  # weight of the best next-step gain when scoring current candidate\n    while len(selected_set) < max_card and improved:\n        improved = False\n        best_score = float(\"-inf\")\n        best_gain = float(\"-inf\")\n        best_closure = None\n        # Consider candidates not already selected\n        for i in range(n):\n            if i in selected_set:\n                continue\n            # closure includes i and its ancestors (cached)\n            closure = closure_cache.get(i, {i})\n            # Only consider closures that are feasible\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # quick capacity pruning: if closure would add more items than remaining slots, skip\n            if len(closure - selected_set) > (max_card - len(selected_set)):\n                continue\n            # Compute one-step lookahead: best feasible single closure after adding this closure\n            lookahead_best = 0.0\n            if len(selected_set) + len(closure - selected_set) < max_card:\n                # simulate new selected set\n                sim_selected = selected_set.union(closure)\n                # find best single candidate (could be more expensive, so limit exploration)\n                # We will search all but with a cheap break if we find strong positive gains.\n                for j in range(n):\n                    if j in sim_selected:\n                        continue\n                    closure_j = closure_cache.get(j, {j})\n                    if not feasible_closure(closure_j, sim_selected):\n                        continue\n                    gain_j = marginal_gain(closure_j, sim_selected)\n                    if gain_j > lookahead_best:\n                        lookahead_best = gain_j\n                        # small optimization: if it's very large, we can accept it\n                        if lookahead_best > abs(gain) * 2 + 1e-9:\n                            break\n            total_score = gain + LOOKAHEAD_DISCOUNT * max(0.0, lookahead_best)\n            # Prefer closures that add more items when scores equal (helps reach min_card)\n            if (total_score > best_score) or (abs(total_score - best_score) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_score = total_score\n                best_gain = gain\n                best_closure = closure\n        # If we found a non-negative-gain move, take it\n        if best_closure is not None and best_gain > -1e-12:\n            to_add = set(best_closure) - selected_set\n            if to_add:\n                selected_set.update(to_add)\n                improved = True\n        else:\n            # No non-negative gain move; stop greedy improvements\n            break\n\n    # If we still haven't met minimum cardinality, greedily add best feasible closures regardless of gain\n    # Use same closure cache and prefer closures that may enable good follow-ups.\n    while len(selected_set) < min_card:\n        best_score = float(\"-inf\")\n        best_gain = float(\"-inf\")\n        best_closure = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closure_cache.get(i, {i})\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # lookahead as before (but smaller budget)\n            lookahead_best = 0.0\n            if len(selected_set) + len(closure - selected_set) < max_card:\n                sim_selected = selected_set.union(closure)\n                for j in range(n):\n                    if j in sim_selected:\n                        continue\n                    closure_j = closure_cache.get(j, {j})\n                    if not feasible_closure(closure_j, sim_selected):\n                        continue\n                    gain_j = marginal_gain(closure_j, sim_selected)\n                    if gain_j > lookahead_best:\n                        lookahead_best = gain_j\n            total_score = gain + LOOKAHEAD_DISCOUNT * max(0.0, lookahead_best)\n            if (total_score > best_score) or (abs(total_score - best_score) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_score = total_score\n                best_gain = gain\n                best_closure = closure\n        if best_closure is None:\n            # No feasible closure remains; break to avoid infinite loop\n            break\n        selected_set.update(set(best_closure) - selected_set)\n\n    # Final trim if over max_card (shouldn't happen due to checks) - keep highest-weight items\n    if len(selected_set) > max_card:\n        # score items by marginal contribution relative to selected (approx): weight + interactions with others\n        def item_score(i):\n            s = float(weights[i]) if i < len(weights) else 0.0\n            for j in selected_set:\n                if j == i:\n                    continue\n                s += interactions.get((i, j), 0.0)\n            return s\n        sorted_items = sorted(selected_set, key=item_score, reverse=True)\n        selected_set = set(sorted_items[:max_card])\n\n    result = {\n        \"selection\": {\n            \"variables\": sorted(int(x) for x in selected_set)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n\n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n\n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n\n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n\n    result_str = stdout_capture.getvalue()\n    return result_str",
      "language": "python",
      "parent_id": "41c4e403-070f-4e25-9757-64fb47df1aa9",
      "archive_inspiration_ids": [
        "4387bfa1-ee61-4891-a6ab-39fef27cf870",
        "639d15e8-d1f9-4fa7-b731-6db3bcbdb880"
      ],
      "top_k_inspiration_ids": [],
      "island_idx": 0,
      "generation": 7,
      "timestamp": 1764668373.0219982,
      "code_diff": "--- a/original.py\n+++ b/original.py\n@@ -1,252 +1,304 @@\n \"\"\"\n Initial solution for Synergistic Dependency Selection (SDS) problem.\n The code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n \"\"\"\n \n import json\n import sys\n import contextlib\n \n # EVOLVE-BLOCK-START\n def solve_sds():\n     \"\"\"\n     Improved solver for the Synergistic Dependency Selection problem.\n \n     - Reads JSON from stdin with \"requirements\" and \"catalog\".\n     - Produces JSON to stdout with \"selection\": {\"variables\": [...] }.\n     - Uses a precedence-aware marginal-gain greedy algorithm that:\n         * when adding an item, also includes its required predecessors (closure),\n         * computes the marginal objective (weights + pairwise interactions),\n         * checks mutex/group/cardinality feasibility for the closure before adding.\n+    - Adds a lightweight one-step lookahead: when evaluating a candidate closure,\n+      also consider the best single subsequent closure that would be feasible after\n+      adding the candidate. A discounted portion of that subsequent gain is added\n+      to the candidate score to prefer moves that enable strong follow-ups.\n     \"\"\"\n     import re\n \n     # Read input\n     input_data = json.load(sys.stdin)\n     requirements = input_data.get(\"requirements\", {})\n     catalog = input_data.get(\"catalog\", {})\n \n     # Extract constraints\n     weights = list(requirements.get(\"weights\", []))\n     interactions_raw = requirements.get(\"interactions\", {})\n     cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n     min_card, max_card = (cardinality_bounds + [len(weights), len(weights)])[:2]\n     mutex = [tuple(m) for m in requirements.get(\"mutex\", [])]\n     groups = requirements.get(\"groups\", {})\n     precedence = requirements.get(\"precedence\", [])\n \n     n = len(weights)\n \n     # Parse interactions into dict of tuple->float for quick lookup (undirected)\n     interactions = {}\n     for k, v in interactions_raw.items():\n         try:\n             if isinstance(k, str):\n                 # allow \"u,v\" or \"u v\"\n                 parts = re.split(r'\\s*,\\s*|\\s+', k.strip())\n                 if len(parts) >= 2:\n                     u = int(parts[0]); w = int(parts[1])\n                 else:\n                     continue\n             elif isinstance(k, (list, tuple)) and len(k) >= 2:\n                 u = int(k[0]); w = int(k[1])\n             else:\n                 continue\n             interactions[(u, w)] = float(v)\n             interactions[(w, u)] = float(v)\n         except Exception:\n             # skip malformed keys\n             continue\n \n     # Build precedence graph: if (p, j) then p is a prerequisite of j\n     preds = {i: set() for i in range(n)}\n     succs = {i: set() for i in range(n)}\n     for entry in precedence:\n         try:\n             a, b = entry\n             a = int(a); b = int(b)\n             preds[b].add(a)\n             succs[a].add(b)\n         except Exception:\n             continue\n \n     # Precompute ancestors (transitive closure of preds) using DFS/memoization\n     ancestor_cache = {}\n \n     def get_ancestors(i):\n         if i in ancestor_cache:\n             return ancestor_cache[i].copy()\n         res = set()\n         stack = [i]\n         while stack:\n             cur = stack.pop()\n             for p in preds.get(cur, []):\n                 if p not in res:\n                     res.add(p)\n                     stack.append(p)\n         ancestor_cache[i] = res.copy()\n         return res\n+\n+    # Precompute closures (ancestors + self) and cache them for fast reuse\n+    closure_cache = {i: get_ancestors(i).union({i}) for i in range(n)}\n \n     # Map variable -> group (assume at most one group membership; if multiple, first wins)\n     var_to_group = {}\n     for gname, vars_list in groups.items():\n         for v in vars_list:\n             try:\n                 var_to_group[int(v)] = gname\n             except Exception:\n                 pass\n \n     # Helper: check feasibility of adding a closure set given current selected_set\n     def feasible_closure(closure_set, selected_set):\n         # Cardinality\n         if len(selected_set) + len(closure_set - selected_set) > max_card:\n             return False\n         # Mutex: none of closure can conflict with each other or with selected_set\n         for a, b in mutex:\n             if a in closure_set and b in closure_set:\n                 return False\n             if (a in closure_set and b in selected_set) or (b in closure_set and a in selected_set):\n                 return False\n         # Group: ensure at most one per group overall\n         # Build per-group counts\n         group_counts = {}\n         for v in selected_set:\n             g = var_to_group.get(v)\n             if g is not None:\n                 group_counts[g] = group_counts.get(g, 0) + 1\n         for v in closure_set:\n             g = var_to_group.get(v)\n             if g is not None:\n                 group_counts[g] = group_counts.get(g, 0) + 1\n                 if group_counts[g] > 1:\n                     return False\n-        # Precedence: closure itself must include ancestors for each element\n+        # Precedence: closure itself must include ancestors for each element (or they are already selected)\n         for v in closure_set:\n             if not get_ancestors(v).issubset(closure_set.union(selected_set)):\n                 return False\n         return True\n \n     # Compute marginal gain of adding closure_set (items that will be newly included)\n     def marginal_gain(closure_set, selected_set):\n         new_items = set(closure_set) - set(selected_set)\n+        if not new_items:\n+            return 0.0\n         gain = 0.0\n         for i in new_items:\n-            if i < len(weights):\n+            if 0 <= i < len(weights):\n                 gain += float(weights[i])\n         # interactions among new items\n         new_list = list(new_items)\n-        for i in range(len(new_list)):\n-            for j in range(i + 1, len(new_list)):\n-                gain += interactions.get((new_list[i], new_list[j]), 0.0)\n+        for a in range(len(new_list)):\n+            for b in range(a + 1, len(new_list)):\n+                gain += interactions.get((new_list[a], new_list[b]), 0.0)\n         # interactions between new items and already selected\n         for i in new_items:\n             for j in selected_set:\n                 gain += interactions.get((i, j), 0.0)\n         return gain\n \n     # Greedy loop: at each step try to add an item (and its ancestors) with max marginal gain\n+    # Enhanced with small one-step lookahead: for each candidate closure consider the best\n+    # subsequent single-closure gain and add a discounted fraction to the candidate score.\n     selected_set = set()\n-    # Keep iterating while we can still add and haven't reached max_card\n     improved = True\n+    LOOKAHEAD_DISCOUNT = 0.5  # weight of the best next-step gain when scoring current candidate\n     while len(selected_set) < max_card and improved:\n         improved = False\n+        best_score = float(\"-inf\")\n         best_gain = float(\"-inf\")\n         best_closure = None\n         # Consider candidates not already selected\n         for i in range(n):\n             if i in selected_set:\n                 continue\n-            # closure includes i and its ancestors\n-            closure = get_ancestors(i).union({i})\n+            # closure includes i and its ancestors (cached)\n+            closure = closure_cache.get(i, {i})\n             # Only consider closures that are feasible\n             if not feasible_closure(closure, selected_set):\n                 continue\n             gain = marginal_gain(closure, selected_set)\n-            # Prefer closures that add more items when gain is equal (to help reach min_card)\n-            if gain > best_gain or (abs(gain - best_gain) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n+            # quick capacity pruning: if closure would add more items than remaining slots, skip\n+            if len(closure - selected_set) > (max_card - len(selected_set)):\n+                continue\n+            # Compute one-step lookahead: best feasible single closure after adding this closure\n+            lookahead_best = 0.0\n+            if len(selected_set) + len(closure - selected_set) < max_card:\n+                # simulate new selected set\n+                sim_selected = selected_set.union(closure)\n+                # find best single candidate (could be more expensive, so limit exploration)\n+                # We will search all but with a cheap break if we find strong positive gains.\n+                for j in range(n):\n+                    if j in sim_selected:\n+                        continue\n+                    closure_j = closure_cache.get(j, {j})\n+                    if not feasible_closure(closure_j, sim_selected):\n+                        continue\n+                    gain_j = marginal_gain(closure_j, sim_selected)\n+                    if gain_j > lookahead_best:\n+                        lookahead_best = gain_j\n+                        # small optimization: if it's very large, we can accept it\n+                        if lookahead_best > abs(gain) * 2 + 1e-9:\n+                            break\n+            total_score = gain + LOOKAHEAD_DISCOUNT * max(0.0, lookahead_best)\n+            # Prefer closures that add more items when scores equal (helps reach min_card)\n+            if (total_score > best_score) or (abs(total_score - best_score) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n+                best_score = total_score\n                 best_gain = gain\n                 best_closure = closure\n-        # If we found a positive-gain move, take it\n+        # If we found a non-negative-gain move, take it\n         if best_closure is not None and best_gain > -1e-12:\n             to_add = set(best_closure) - selected_set\n             if to_add:\n                 selected_set.update(to_add)\n                 improved = True\n         else:\n             # No non-negative gain move; stop greedy improvements\n             break\n \n     # If we still haven't met minimum cardinality, greedily add best feasible closures regardless of gain\n+    # Use same closure cache and prefer closures that may enable good follow-ups.\n     while len(selected_set) < min_card:\n+        best_score = float(\"-inf\")\n         best_gain = float(\"-inf\")\n         best_closure = None\n         for i in range(n):\n             if i in selected_set:\n                 continue\n-            closure = get_ancestors(i).union({i})\n+            closure = closure_cache.get(i, {i})\n             if not feasible_closure(closure, selected_set):\n                 continue\n             gain = marginal_gain(closure, selected_set)\n-            # choose closure that gives best gain (even if negative), tie-breaker favors larger closures\n-            if gain > best_gain or (abs(gain - best_gain) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n+            # lookahead as before (but smaller budget)\n+            lookahead_best = 0.0\n+            if len(selected_set) + len(closure - selected_set) < max_card:\n+                sim_selected = selected_set.union(closure)\n+                for j in range(n):\n+                    if j in sim_selected:\n+                        continue\n+                    closure_j = closure_cache.get(j, {j})\n+                    if not feasible_closure(closure_j, sim_selected):\n+                        continue\n+                    gain_j = marginal_gain(closure_j, sim_selected)\n+                    if gain_j > lookahead_best:\n+                        lookahead_best = gain_j\n+            total_score = gain + LOOKAHEAD_DISCOUNT * max(0.0, lookahead_best)\n+            if (total_score > best_score) or (abs(total_score - best_score) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n+                best_score = total_score\n                 best_gain = gain\n                 best_closure = closure\n         if best_closure is None:\n             # No feasible closure remains; break to avoid infinite loop\n             break\n         selected_set.update(set(best_closure) - selected_set)\n \n     # Final trim if over max_card (shouldn't happen due to checks) - keep highest-weight items\n     if len(selected_set) > max_card:\n         # score items by marginal contribution relative to selected (approx): weight + interactions with others\n         def item_score(i):\n             s = float(weights[i]) if i < len(weights) else 0.0\n             for j in selected_set:\n                 if j == i:\n                     continue\n                 s += interactions.get((i, j), 0.0)\n             return s\n         sorted_items = sorted(selected_set, key=item_score, reverse=True)\n         selected_set = set(sorted_items[:max_card])\n \n     result = {\n         \"selection\": {\n             \"variables\": sorted(int(x) for x in selected_set)\n         }\n     }\n     print(json.dumps(result))\n # EVOLVE-BLOCK-END\n \n \n # This part remains fixed (not evolved)\n def run_sds(problem_data=None):\n     \"\"\"\n     Main function called by the evaluator.\n     Can accept problem_data as parameter or read from stdin.\n     Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n     \"\"\"\n     import sys\n     import json\n     import io\n \n     if problem_data is None:\n         # Read from stdin (for compatibility)\n         input_data = json.load(sys.stdin)\n     else:\n         # Use provided problem data\n         input_data = problem_data\n \n     # Capture stdout from solve_sds\n     stdout_capture = io.StringIO()\n     old_stdin = sys.stdin\n \n     try:\n         # Create mock stdin\n         sys.stdin = io.StringIO(json.dumps(input_data))\n         with contextlib.redirect_stdout(stdout_capture):\n             solve_sds()\n     finally:\n         sys.stdin = old_stdin\n \n     result_str = stdout_capture.getvalue()\n     return result_str",
      "combined_score": 0.3993475858389672,
      "public_metrics": {
        "feasible": true,
        "selection_size": 10,
        "raw_score": 122.54942718671678
      },
      "private_metrics": {
        "selection": [
          3,
          4,
          5,
          6,
          7,
          9,
          10,
          11,
          13,
          14
        ],
        "raw_score": 122.54942718671678,
        "normalized_fitness": 0.3993475858389672
      },
      "text_feedback": "",
      "correct": true,
      "children_count": 0,
      "complexity": 1.0,
      "embedding": [
        0.027552547,
        0.0025905645,
        0.009803274,
        -0.020231647,
        0.01853666,
        0.030557843,
        0.032529317,
        0.0006172125,
        -0.013079045,
        0.033611223,
        0.03875629,
        -0.05871145,
        -0.019390166,
        0.030702097,
        0.0034110101,
        -0.02371779,
        0.048469402,
        0.00020755321,
        -0.010969328,
        0.0015973145,
        0.034789298,
        0.01333149,
        0.037385873,
        0.03264953,
        0.016781569,
        -0.007753662,
        0.0354144,
        0.08107085,
        0.033346757,
        -0.035534613,
        0.020724516,
        -0.008186424,
        -0.029451894,
        0.005027859,
        -0.025460862,
        0.040559467,
        0.003417021,
        0.034140155,
        -0.04957535,
        -0.018091878,
        -0.0039429474,
        -0.027624674,
        -0.022732053,
        0.018680915,
        -0.018320281,
        -0.019378144,
        0.00417135,
        0.00896179,
        0.02076058,
        -0.013668084,
        -0.034212284,
        0.0333708,
        0.023128754,
        -0.0022659926,
        -0.018368365,
        -0.04519964,
        -0.0044538477,
        0.015182752,
        -0.0054576164,
        -0.0022584794,
        0.0250281,
        -0.038083103,
        0.04568049,
        0.007501217,
        -0.021842487,
        0.0069843065,
        0.012099319,
        0.0035552643,
        -0.020916855,
        -0.01170262,
        -0.038900543,
        -0.008372753,
        0.013151173,
        -0.02422268,
        -0.0047874353,
        0.03163975,
        0.03490951,
        0.03817927,
        0.0077837147,
        -0.03772247,
        -0.049719606,
        -0.026927447,
        -0.00585131,
        -0.019895054,
        -0.057461247,
        -0.07034795,
        -0.003973,
        0.024282787,
        -0.047050904,
        -0.06294291,
        -0.009352479,
        -0.0042615086,
        -0.071069226,
        0.013319469,
        0.02280418,
        -0.03755417,
        0.029427852,
        -0.018452514,
        0.013451702,
        0.0037626298,
        0.007501217,
        -0.037121408,
        0.018500598,
        -0.04342051,
        0.010939275,
        0.022407481,
        0.036087587,
        0.009911464,
        0.006930211,
        -0.0221911,
        -0.04354072,
        0.030413589,
        -0.0020075373,
        0.041376907,
        0.02675915,
        -0.06404886,
        -0.036592476,
        -0.015819876,
        -0.010981349,
        -0.0018993466,
        -0.022070888,
        -0.004742356,
        -0.018404428,
        0.0598174,
        -0.014437439,
        0.027600633,
        0.030101039,
        -0.07568536,
        -0.024511188,
        0.013391596,
        0.052268095,
        0.011540334,
        -0.00015693277,
        -0.035558656,
        -0.05818252,
        -0.021962699,
        -0.033010162,
        -0.013992655,
        -0.012099319,
        0.012069266,
        0.021229407,
        -0.00013223299,
        0.012586176,
        0.027841056,
        -0.055730198,
        -0.025364693,
        0.0026296335,
        0.0019038545,
        -0.095111586,
        0.04895025,
        0.038563948,
        -0.03502972,
        -0.006419311,
        0.0043396465,
        0.050585132,
        -0.055634025,
        -0.045127515,
        0.01506254,
        0.053662553,
        -0.030846352,
        -0.01536307,
        0.01333149,
        -0.015579451,
        -0.009075992,
        0.051642995,
        -0.021950677,
        -0.036400136,
        0.047964513,
        -0.03560674,
        -0.01862081,
        -0.016096361,
        -0.082465306,
        -0.0053434153,
        0.024294807,
        -0.003927921,
        -0.037794594,
        -0.002247961,
        -0.018656874,
        -0.0029196444,
        -0.023140773,
        -0.050200455,
        -0.025821498,
        -0.014281163,
        -0.045776658,
        -0.023886086,
        -0.04017479,
        -0.012742452,
        0.0063471836,
        0.0035763015,
        0.022623863,
        -0.022106953,
        0.013812337,
        0.010981349,
        -0.0053945053,
        0.0067018084,
        -0.023273008,
        0.05241235,
        0.0382514,
        -0.016108382,
        0.022335354,
        0.012886707,
        -0.007513238,
        0.024859803,
        -0.0152669,
        -0.017382627,
        -0.016264658,
        -0.056403384,
        -0.01474999,
        -0.022732053,
        -0.04067968,
        0.02829786,
        -0.036376096,
        -0.011101561,
        0.05322979,
        0.052989367,
        0.016012214,
        -0.0014943831,
        -0.00330883,
        -0.006653724,
        0.056739975,
        -0.023693748,
        0.010151887,
        0.00052742934,
        -0.0019399181,
        0.00092788495,
        0.034861427,
        -0.015711684,
        -0.041689456,
        0.008553071,
        -0.043684974,
        0.00023629135,
        0.0014718433,
        -0.016805612,
        0.042266473,
        -0.0014117375,
        -0.013091067,
        -0.026831277,
        0.01485818,
        0.010097792,
        -0.010542576,
        0.036568433,
        -0.014269142,
        0.014160952,
        0.0065395227,
        0.012039213,
        -0.0018452513,
        -0.04272328,
        -0.021722274,
        -0.000171114,
        -0.004435816,
        0.026206175,
        -0.025917666,
        0.031182945,
        -0.021734295,
        -0.016709441,
        -0.035173975,
        -0.0141128665,
        -0.018344322,
        -0.005655966,
        0.04382923,
        -0.046954732,
        -0.00046431812,
        0.03551057,
        -0.031014647,
        -0.051065978,
        -0.015639557,
        0.018356344,
        0.003991032,
        -0.0007851334,
        0.0069963275,
        -0.004519964,
        0.03661652,
        -0.047507707,
        0.021337597,
        -0.048108768,
        0.0070384014,
        -0.015339027,
        0.06803989,
        -0.028826794,
        -0.009689072,
        -0.04834919,
        0.0053163674,
        0.04467071,
        0.008967801,
        0.041160524,
        0.004763393,
        -0.011438154,
        0.0045440067,
        -0.0013568909,
        0.03579908,
        -0.0038107145,
        -0.038828414,
        0.028105522,
        -0.049479183,
        -0.03276974,
        -0.030678054,
        -0.0032877931,
        0.016204553,
        0.0022614847,
        0.0144735025,
        0.07977256,
        -0.0075432914,
        -0.01160645,
        -0.01780337,
        -0.023549493,
        -0.0029692317,
        0.03858799,
        -0.03796289,
        0.029572107,
        0.033322714,
        -0.019558461,
        -0.008709346,
        0.005496685,
        0.013475744,
        -0.026542768,
        -0.020207606,
        0.061981212,
        -0.033418883,
        0.04301179,
        0.0051841345,
        -0.03563078,
        0.008108287,
        0.03447675,
        -0.021902593,
        0.009304394,
        -0.05625913,
        -0.010464438,
        -0.003057888,
        -0.00064914377,
        -0.024054384,
        -0.027841056,
        0.0128145795,
        0.02534065,
        0.033442926,
        -0.01383638,
        -0.04904642,
        0.022347376,
        0.0008993346,
        0.014317227,
        0.0023321093,
        -0.03440462,
        0.009755189,
        -0.02798531,
        -0.038275443,
        0.0063051097,
        -0.031014647,
        -0.023850024,
        0.08895674,
        0.055537857,
        -0.030004868,
        0.009148119,
        -0.00015336397,
        -0.01047646,
        0.041040312,
        -0.0073148888,
        0.0075733443,
        -0.020928876,
        -0.014810096,
        -0.0016408913,
        -0.030269334,
        0.028418073,
        -0.01098736,
        -0.016240615,
        0.009448648,
        -0.0060226116,
        0.024294807,
        -0.03906884,
        0.036159713,
        0.017767306,
        -0.013824359,
        0.049719606,
        0.046041124,
        -0.02208291,
        0.024955973,
        -0.07924363,
        -0.0072187195,
        0.0033028196,
        0.021505894,
        0.01465382,
        0.04558432,
        -0.0009699591,
        0.015555409,
        -0.0388765,
        0.0019774844,
        0.012321711,
        0.0012464463,
        -0.024787676,
        -0.0043606837,
        -0.02330907,
        -0.022708012,
        0.031711876,
        -0.023068648,
        0.018236132,
        0.0025755381,
        -0.010055718,
        0.014197015,
        0.0181039,
        0.02299652,
        0.02606192,
        0.03813119,
        0.010879169,
        0.017454755,
        -0.010945286,
        -0.042915616,
        -0.024667464,
        -0.0030428616,
        0.04904642,
        0.046762396,
        -0.0044598584,
        -0.015387112,
        0.032721657,
        0.017659115,
        0.038275443,
        -0.00671383,
        0.013884464,
        -0.01301894,
        -0.030389545,
        0.035270147,
        0.021505894,
        0.075781524,
        -0.009821305,
        -0.019678675,
        0.033563137,
        -0.034861427,
        -0.0036033492,
        0.021890571,
        0.043083914,
        -0.023934172,
        0.060394414,
        0.007080476,
        -0.0036153703,
        0.04760388,
        0.053951062,
        0.0085650915,
        -0.0015477272,
        0.05048896,
        0.024691507,
        0.028562326,
        0.012706389,
        -0.013908506,
        -0.017887518,
        0.009100034,
        0.024583315,
        -0.019570483,
        -0.020279733,
        0.008066213,
        0.027239997,
        -0.018596768,
        0.02574937,
        0.019113678,
        0.0015184254,
        -0.0008016625,
        0.02118132,
        -0.016817633,
        -0.010764968,
        0.018632831,
        0.040150747,
        -0.034789298,
        0.06400077,
        -0.008535039,
        0.05741316,
        0.03702524,
        -0.0333708,
        0.00040947148,
        0.0036123649,
        0.038155228,
        0.027648717,
        0.015110625,
        -0.028466158,
        0.049911946,
        0.02411449,
        0.00023666701,
        -0.05250852,
        -0.0034621002,
        -0.019690694,
        -0.03276974,
        0.032601442,
        0.004141297,
        0.019630589,
        -0.0035041743,
        -0.005701045,
        -0.018055815,
        0.014786053,
        0.03072614,
        0.024583315,
        0.049911946,
        -0.0054876693,
        -0.049286842,
        -0.030245293,
        0.0016453991,
        0.020808665,
        0.006431332,
        0.013752231,
        -0.011906981,
        -0.010608693,
        -0.031759962,
        -0.012958833,
        0.016721463,
        -0.018296238,
        -0.012610219,
        0.016108382,
        -0.021457808,
        -0.050729387,
        0.0528932,
        0.017935602,
        -0.00997758,
        0.0045680488,
        -0.018356344,
        -0.0046942714,
        -0.0060406434,
        -0.006563565,
        0.019871013,
        -0.017322522,
        0.02238344,
        0.02299652,
        0.0008354721,
        -0.02808148,
        -0.041280735,
        -0.014665841,
        0.008006107,
        -0.008486954,
        -0.03707332,
        -0.02574937,
        0.011017413,
        -0.0076454715,
        -0.019522399,
        0.023068648,
        -0.075204514,
        -0.046329632,
        -0.009646998,
        0.0075973864,
        -0.01607232,
        -0.0639046,
        0.07395431,
        -0.037578214,
        0.005373468,
        -0.031182945,
        -0.027817013,
        -0.029259555,
        0.010205983,
        -0.011991128,
        -0.0037716457,
        -0.020520156,
        -0.01607232,
        0.028225733,
        -0.020099415,
        0.067222446,
        0.005664982,
        -0.00033659308,
        -0.00065628137,
        -0.02403034,
        -0.036688644,
        -0.007164624,
        0.010398322,
        -0.018813148,
        -0.0043516676,
        -0.032168683,
        -0.020267712,
        -0.009232267,
        -0.045872826,
        0.0055808336,
        -0.0033028196,
        0.023056626,
        0.010031676,
        -0.016456997,
        -0.0118048005,
        0.046161335,
        0.02971636,
        -0.022311313,
        0.015254879,
        0.009130087,
        -0.0201475,
        0.006299099,
        -0.0500562,
        0.051258318,
        0.021505894,
        -0.012502029,
        -0.025773413,
        -0.0064974483,
        0.00012387452,
        -0.008667272,
        -0.022563757,
        -0.011738683,
        -0.0070143593,
        -0.07347346,
        0.011738683,
        -0.0052923253,
        0.016408913,
        0.021349618,
        0.01791156,
        -0.018837191,
        -0.0014996424,
        0.020135479,
        0.0033809573,
        -0.017106142,
        -0.004081191,
        -0.01568764,
        -0.0075733443,
        -0.011642514,
        0.019318039,
        0.008114297,
        -0.0362078,
        0.021049088,
        0.021433767,
        -0.04498326,
        -0.007952011,
        0.05207576,
        0.026422556,
        0.012267616,
        0.017827412,
        -0.010897201,
        -0.034621004,
        0.013595956,
        -0.001770119,
        -0.0443822,
        0.0035793066,
        -0.016493062,
        0.044598583,
        0.006743883,
        -0.032385062,
        0.016360829,
        -0.012946812,
        0.0035011692,
        0.02952402,
        0.055489775,
        0.007459143,
        -0.012321711,
        0.009719125,
        -0.018789107,
        -0.0207726,
        -0.01709412,
        0.00023328605,
        -0.016240615,
        0.013752231,
        -0.0057040504,
        -0.0023381198,
        0.024643421,
        -0.0015567429,
        0.00027573586,
        0.01638487,
        0.006257025,
        0.011684588,
        0.0015281927,
        -0.028369987,
        0.026085963,
        0.014100846,
        -0.014617757,
        -0.0059204316,
        0.016805612,
        -0.0033929783,
        -0.032625485,
        -0.021301534,
        -0.005719077,
        -0.015699662,
        0.05039279,
        0.03957373,
        -0.0031194966,
        -0.024475126,
        -0.018368365,
        0.005048896,
        -0.00554477,
        -0.02330907,
        0.014100846,
        0.041641373,
        0.006082718,
        0.0221911,
        0.032000385,
        0.03899671,
        0.0010398321,
        -0.004090207,
        -0.038083103,
        -0.013583935,
        0.031303156,
        -0.0069001582,
        -0.0018963413,
        -0.024715548,
        0.031423368,
        0.0012862664,
        -0.045512192,
        0.023236943,
        -0.019546442,
        0.022780139,
        -0.008637219,
        0.011648525,
        0.018476555,
        -0.035775036,
        -0.0027273055,
        -0.0037235608,
        0.01119773,
        0.016348807,
        0.013247342,
        0.0052051716,
        -0.0027062683,
        -0.022708012,
        0.030101039,
        0.021421745,
        0.021493873,
        0.04806068,
        -0.0072127087,
        -0.096650295,
        0.00013993407,
        0.0044929166,
        0.015327007,
        -0.016096361,
        0.003236703,
        -0.036376096,
        -0.020796644,
        0.017983688,
        0.035198018,
        -0.003326862,
        -0.004384726,
        0.0021728284,
        -0.010716883,
        -0.01333149,
        -0.018091878,
        0.009208225,
        0.026903404,
        0.031423368,
        0.03673673,
        -0.025388734,
        -0.055008925,
        -0.034669086,
        -0.019245911,
        0.009592903,
        -0.062702484,
        -0.030605927,
        -0.006275057,
        0.037193537,
        -0.0014192507,
        0.006665745,
        0.00681601,
        -0.0057731722,
        -0.04060755,
        0.016372848,
        -0.003855794,
        -0.02647064,
        -0.042987745,
        -0.011221773,
        -0.046762396,
        0.02870658,
        -0.016048277,
        -0.012526071,
        0.025388734,
        0.00763345,
        -0.03377952,
        -0.014774032,
        0.011329964,
        0.017755285,
        -0.030052952,
        0.03793885,
        -0.025557032,
        0.007507228,
        -0.0013230813,
        -0.006136813,
        0.027336167,
        0.005403521,
        0.019293996,
        0.00019684684,
        -0.025965752,
        0.010572629,
        -0.017418692,
        -0.020411966,
        -0.041569244,
        -0.005385489,
        0.020628348,
        0.027648717,
        0.004189382,
        -0.022263227,
        0.013728189,
        0.027239997,
        0.03582312,
        0.0037926827,
        0.003936937,
        0.0102240145,
        -0.0016664362,
        -0.027023615,
        -0.00026671996,
        -0.03329867,
        0.0035041743,
        0.015567429,
        0.016012214,
        -0.0023591567,
        -0.004423795,
        0.0270717,
        0.023561515,
        -0.004051138,
        0.0107950205,
        -0.013259363,
        0.033202503,
        -0.040487338,
        -0.031519536,
        0.00254248,
        0.009634977,
        0.032913994,
        -0.015735727,
        0.0506813,
        -0.040030535,
        -0.10905616,
        -0.0099655595,
        0.0034049996,
        -0.034548875,
        0.0102721,
        -0.016408913,
        0.003979011,
        0.016841674,
        -0.007921958,
        -0.01069284,
        -0.03288995,
        -0.03248123,
        0.00011326207,
        0.036087587,
        -0.0044899113,
        -0.019558461,
        -0.029596148,
        0.0034891479,
        0.027624674,
        -0.03236102,
        -0.010837095,
        0.012934791,
        -0.0069121793,
        0.007489196,
        -0.040992226,
        0.003927921,
        0.0054305685,
        0.028129565,
        -0.006166866,
        0.002707771,
        0.008456901,
        -0.007952011,
        -0.007615418,
        0.037121408,
        -0.024306828,
        -0.00090985314,
        0.011251826,
        -0.0052983356,
        -0.014497545,
        0.017382627,
        0.023321092,
        -0.024643421,
        0.023128754,
        -0.063519925,
        0.0056439447,
        0.015928065,
        -0.016949866,
        -0.0037626298,
        0.0039128945,
        0.05371064,
        -0.0001795664,
        0.028321903,
        -0.016745506,
        -0.02798531,
        -0.021001004,
        0.01515871,
        0.009082003,
        0.009851358,
        -0.01179879,
        0.03346697,
        -0.028105522,
        -0.015375091,
        0.042218387,
        -0.012502029,
        -0.0291153,
        0.010734915,
        -0.02940381,
        -0.021746317,
        0.0007532021,
        0.02228727,
        -0.020375902,
        0.00091285846,
        -0.018392408,
        -0.016372848,
        -0.03765034,
        0.032745697,
        0.022311313,
        -0.014677863,
        -0.01057864,
        0.01353585,
        0.0506813,
        -0.0098754,
        0.010392311,
        0.029644232,
        -0.00029226497,
        0.02625426,
        0.016769547,
        0.045151558,
        0.0018617804,
        0.058326773,
        -0.020916855,
        -0.029932741,
        0.01699795,
        0.0060797124,
        -0.037506085,
        0.039116923,
        0.015964128,
        -0.038083103,
        0.019774843,
        -0.0039429474,
        0.021782381,
        0.058038265,
        0.0055537857,
        -0.0041563236,
        0.008450891,
        0.029692318,
        -0.056499552,
        0.016108382,
        -0.0029737398,
        0.037001196,
        0.0008662764,
        0.01414893,
        -0.035991415,
        0.0313272,
        -0.013644041,
        -0.032385062,
        0.0083427,
        0.015254879,
        0.0065575545,
        0.013644041,
        0.00044816468,
        0.032288894,
        -0.038443737,
        0.034645043,
        -0.013788295,
        0.034789298,
        0.0017460766,
        -0.0052171927,
        -0.012730431,
        0.021481851,
        0.014076803,
        -0.0049797744,
        -0.010710873,
        0.05659572,
        0.003185613,
        0.026278302,
        0.03784268,
        -0.01200315,
        -0.013367553,
        0.028971046,
        0.020532178,
        0.0080722235,
        -0.005667987,
        -0.0026506705,
        -0.017322522,
        0.0043095937,
        0.040896058,
        -0.036159713,
        -0.058134433,
        0.037578214,
        -0.0100677395,
        -0.030654013,
        0.011822832,
        0.011269857,
        0.018692937,
        0.044406243,
        -0.0015101609,
        -0.024739591,
        -0.004387731,
        -0.04870983,
        0.0041533182,
        0.02584554,
        0.0054065264,
        -0.038515866,
        0.04293966,
        0.024763634,
        -0.010632735,
        -0.023838002,
        0.002883581,
        0.008709346,
        -0.04202605,
        -0.015314985,
        -0.02625426,
        -0.0051540816,
        -0.009148119,
        0.0035432433,
        -0.024390977,
        0.012267616,
        0.026326386,
        0.027648717,
        -0.0012351763,
        0.04231456,
        0.0013140654,
        0.0031976341,
        0.033130378,
        -0.042987745,
        -0.011636504,
        -0.007182656,
        -0.004628155,
        -0.019402187,
        0.030894436,
        0.019245911,
        -0.006419311,
        0.048613656,
        0.004498927,
        0.031495497,
        -0.004030101,
        0.009761199,
        0.03935735,
        -0.025100227,
        -0.012321711,
        0.0029737398,
        0.018380387,
        -0.06154845,
        0.01699795,
        0.060009737,
        -7.250275e-05,
        -0.0033839624,
        -0.022671947,
        -0.01404074,
        0.010392311,
        0.012910749,
        -0.015988171,
        0.007651482,
        -0.014810096,
        0.02635043,
        0.03447675,
        -0.00087754626,
        -0.04277136,
        -0.03327463,
        -0.021529935,
        -0.017526882,
        0.025172353,
        -0.002380194,
        0.00063261465,
        0.026783193,
        0.017635074,
        0.01455765,
        0.009190193,
        0.0060797124,
        -0.0020105427,
        0.012862664,
        -0.001025557,
        -0.0037986932,
        0.024138533,
        -0.024174595,
        -0.0069121793,
        -0.0103863,
        -0.00095568394,
        0.034933552,
        0.025124269,
        -0.019402187,
        -0.0008760436,
        -0.010722893,
        0.022455567,
        -0.027913183,
        0.014918286,
        0.02035186,
        0.014533608,
        -0.011149646,
        -0.03644822,
        -0.002549993,
        0.022732053,
        -0.032938037,
        0.027456379,
        -0.024739591,
        0.030870393,
        0.039549686,
        0.006936222,
        -0.0071405815,
        0.00061570987,
        -0.005523733,
        -0.0068099992,
        -0.0139565915,
        -0.037193537,
        -0.016673379,
        -0.01679359,
        0.017430713,
        0.013211278,
        0.00045718055,
        0.014377333,
        0.025532989,
        -0.022635885,
        0.0041773603,
        -0.01515871,
        -0.012538092,
        -0.008156371,
        -0.0045229695,
        0.015699662,
        -0.031519536,
        -0.015014456,
        0.029692318,
        0.008156371,
        0.042290516,
        0.03243315,
        -0.044526454,
        0.02868254,
        -0.009929496,
        0.048253022,
        -0.028249776,
        -0.0051120073,
        0.016132426,
        -0.008697324,
        -0.0064373426,
        -0.016925823,
        -0.00045905885,
        0.010326195,
        -0.02411449,
        0.0010879169,
        -0.035462484,
        -0.008877642,
        0.025076184,
        0.016420934,
        -0.040559467,
        0.031711876,
        0.005616897,
        -0.0639046,
        0.0014665842,
        -0.013451702,
        -0.022046847,
        0.0035282166,
        -0.0039038786,
        0.0017085104,
        0.012610219,
        0.004901637,
        -0.010644756,
        0.0064253216,
        0.005728093,
        -0.0102721,
        0.036688644,
        0.0077656833,
        0.031086775,
        -0.0039940374,
        -0.024907887,
        -0.02685532,
        0.006419311,
        0.031591665,
        0.00080842443,
        0.01191299,
        -0.03702524,
        0.013319469,
        0.026638938,
        0.031351242,
        -0.02685532,
        -0.030605927,
        -0.00032645022,
        -0.05933655,
        -0.0016919812,
        -0.01109555,
        -0.01108954,
        -0.022768117,
        -0.026302345,
        -0.007284836,
        -0.0034440684,
        -0.009893432,
        -0.0041473075,
        -0.016240615,
        0.014461481,
        -0.019582504,
        0.0232129,
        0.07707982,
        0.0070143593,
        -0.023609601,
        0.0076995664,
        0.00528932,
        0.008523017,
        -0.021590041,
        -0.00072277355,
        0.009989602,
        -0.04649793,
        0.0014575683,
        0.0053494256,
        0.0008159377,
        0.021746317,
        0.024691507,
        -0.017442735,
        -0.0051240283,
        0.028850835,
        0.013042982,
        -0.0299087,
        0.0069061685,
        0.01301894,
        0.0056920294,
        0.01800773,
        0.0062630353,
        0.027865099,
        0.023922151,
        -0.006025617,
        0.013523829,
        0.012171446,
        0.010290131,
        -0.0039699953,
        -0.029475937,
        -0.0010112819,
        -0.026182134,
        0.00077085826,
        -0.01853666,
        0.018043794,
        -0.01363202,
        -0.048108768,
        -0.021373661,
        -0.008661261,
        -0.033202503,
        0.023729812,
        0.061740786,
        0.020784622,
        -0.017671136,
        0.018813148,
        0.0023185853,
        -0.0047573824,
        -0.004285551,
        0.016637314,
        -0.025605116,
        -0.04214626,
        -0.003795688,
        -0.019654632,
        0.00534041,
        0.015411154,
        -0.0006758158,
        -0.00564695,
        -0.028369987,
        -0.02441502,
        0.018188048,
        0.047050904,
        0.023381198,
        -0.023369176,
        0.024980014,
        -0.009292373,
        -0.02870658,
        0.037121408,
        -0.03938139,
        -0.0030699093,
        -0.0048385253,
        0.012123361,
        -0.006299099,
        0.04916663,
        0.011636504,
        0.018608788,
        0.0014688381,
        -0.017142205,
        -0.011618472,
        0.014810096,
        -0.025605116,
        -0.03928522,
        -0.01495435,
        0.003459095,
        0.0063231415,
        0.02441502,
        -0.03793885,
        0.021734295,
        -0.04224243,
        -0.030149123,
        -0.018560704,
        0.008498975,
        0.010909222,
        -0.02341726,
        0.026182134,
        0.015230836,
        -0.045969,
        -0.01230969,
        -0.0221911,
        -0.018680915,
        0.01771922,
        0.0017896533,
        -0.057461247,
        0.0069001582,
        -0.04366093,
        0.006269046,
        0.00916615,
        -0.008432859,
        0.001872299,
        0.014209037,
        -0.014593714,
        0.022936413,
        -0.023970235,
        0.024739591,
        -0.028105522,
        -0.018344322,
        -0.01964261,
        -0.038515866,
        0.023176838,
        -0.003591328,
        0.000277802,
        -0.008066213,
        -0.0011908483,
        0.016420934,
        -0.0015229334,
        -0.016913801,
        -0.02299652,
        0.025460862,
        0.0045410013,
        -0.0036364074,
        0.035558656,
        0.025172353,
        0.005658971,
        -0.009580881,
        -0.012087298,
        0.0014981397,
        -0.02340524,
        0.008601155,
        -0.021289513,
        -0.018043794,
        -0.042963702,
        0.03875629,
        -0.040823933,
        0.018200068,
        -0.02035186,
        -0.014822116,
        0.024595337,
        0.042891573,
        0.0089798225,
        -0.015928065,
        -0.013403617,
        0.0015702668,
        -0.010211994,
        0.0007791228,
        0.026735106,
        -0.012345754,
        0.0008452393,
        -0.018584747,
        -0.015627535,
        0.01841645,
        0.013367553,
        -0.024330871,
        0.0051540816,
        0.009899443,
        0.009941517,
        0.007705577,
        0.019630589,
        0.016865717,
        0.00844488,
        -0.029043173,
        0.02177036,
        -0.009592903,
        -0.021710254,
        0.038563948,
        0.015218816,
        -0.017418692,
        -0.011323953,
        0.0056108865,
        0.0058332784,
        0.025677243,
        0.010963317,
        -0.015819876,
        0.02359758,
        -0.021085152,
        0.014641799,
        -0.018404428,
        -0.005950485,
        -0.0021983734,
        0.008120308,
        -0.010584651,
        -0.0191257,
        -0.0118829375,
        0.017971667,
        0.025316607,
        -0.001498891,
        -0.04072776,
        -0.010416354,
        0.045872826,
        -0.00620894,
        0.002879073,
        0.0042194347,
        -0.0034651055,
        0.0020315796,
        -0.016240615,
        0.019366123,
        0.01098736,
        0.024691507,
        0.00610676,
        0.069434345,
        -0.009821305,
        0.002422268,
        0.005586844,
        0.011456186,
        0.018729001,
        -0.0034380578,
        0.0118829375,
        0.0059715216,
        0.011768737,
        0.00096695375,
        -0.053277876,
        -0.019858992,
        0.0034500791,
        -0.04883004,
        0.014641799,
        0.007284836,
        -0.010560608,
        -0.007284836,
        0.00056987914,
        0.028249776,
        0.0007163873,
        0.016829655,
        -0.0032186713,
        0.0024658449,
        -0.013583935,
        -0.052989367,
        0.042915616,
        0.019245911,
        -0.0075853653,
        -0.037217576,
        0.013788295,
        0.031591665,
        0.009178172,
        0.008931737,
        0.040992226,
        0.007915948,
        0.021842487,
        0.0060586752,
        -0.020123458,
        -0.016805612,
        -0.0035252115,
        -0.010133856,
        -0.044117734,
        -0.011329964,
        -0.036688644,
        0.00044027576,
        -0.017599009,
        0.0028670516,
        0.009496734,
        -0.01851262,
        0.0038738258,
        -0.032192722,
        0.007603397,
        -0.0006664242,
        -0.01201517,
        -0.023248965,
        -0.027119786,
        -0.015242858,
        -0.008510997,
        0.007411058,
        0.017995708,
        -0.041809667,
        -0.008060202,
        0.013523829,
        0.0006754401,
        0.007681535,
        -0.023056626,
        0.026783193,
        0.0007171386,
        0.053614467,
        -0.001023303,
        -0.045295812,
        -0.0040240902,
        0.02046005,
        0.01221352,
        -0.010939275,
        -0.0005969268,
        0.022972478,
        0.01169661,
        0.04132882,
        -0.012586176,
        -0.0062269717,
        -0.014737968,
        -0.004294567,
        0.00042186835,
        0.017839434,
        -0.009184183,
        0.031110818,
        -0.00038016986,
        -0.027095743,
        0.014160952,
        0.016661357,
        -0.030101039,
        -0.009845347,
        -0.015206794,
        0.01353585,
        0.021722274,
        -0.022551736,
        0.029932741,
        -0.007459143,
        0.01821209,
        -0.023681726,
        0.00037059048,
        -0.009941517,
        0.031351242,
        0.019354101,
        0.019690694,
        -0.03243315,
        0.03613567,
        -0.029740402,
        0.026134048,
        0.01465382,
        -0.013511808,
        -0.003368936,
        -0.013067024,
        -0.015579451,
        -0.0020075373,
        0.04589687,
        -0.006461385,
        0.044887092,
        -0.011113582,
        0.011420122,
        0.015940087,
        0.03267357,
        0.011474217,
        -0.0022870298,
        0.023946194,
        -0.017334543,
        0.0027152842,
        0.005157087,
        0.01699795,
        -0.007356963,
        0.011438154,
        -0.0126342615,
        0.02279216,
        -0.0015041503,
        -0.0034019942,
        -0.0030774225,
        0.00605567,
        -0.01435329,
        -0.026999574,
        -0.014064782,
        -0.04195392,
        -0.009761199,
        0.005169108,
        -0.030269334,
        -0.021662168,
        -0.050104283,
        0.024907887,
        -0.043925397,
        -0.014713926,
        -0.020195585,
        -0.006858084,
        0.020628348,
        0.025484905,
        -0.018524641,
        -0.0014515576,
        0.009003865,
        -0.032625485,
        0.04568049,
        0.023946194,
        0.0080481805,
        0.01769518,
        -0.01761103,
        -0.0049737636,
        -0.010909222,
        0.0031104807,
        0.00022596064,
        -0.005995564,
        0.0044929166,
        0.019991225,
        -0.0008865621,
        -0.01515871,
        0.011540334,
        -0.0041803657,
        0.0019203838,
        -0.013704146,
        -0.018680915
      ],
      "embedding_pca_2d": [],
      "embedding_pca_3d": [],
      "embedding_cluster_id": null,
      "migration_history": [],
      "metadata": {
        "compute_time": 2.0112199783325195,
        "patch_type": "diff",
        "api_costs": 0.013108749999999999,
        "num_applied": 1,
        "patch_name": "lookahead_closure_greedy",
        "patch_description": "Improve the greedy selection by (1) caching closures for each variable to avoid recomputation, and (2) adding a cheap one-step lookahead when evaluating candidate closures: for each candidate closure, simulate adding it and compute the best additional single closure that would be feasible next; include a discounted portion of that next-step gain into the candidate score. This helps the greedy choose moves that enable strong follow-up synergies (common in interaction-heavy SDS instances). Also refine tie-breaking to favor closures with better effective score and use cached closures consistently.",
        "error_attempt": null,
        "novelty_attempt": 1,
        "resample_attempt": 1,
        "patch_attempt": 1,
        "model_name": "gpt-5-mini",
        "temperature": 1.0,
        "max_output_tokens": 8192,
        "llm_result": {
          "content": "<NAME>\nlookahead_closure_greedy\n</NAME>\n\n<DESCRIPTION>\nImprove the greedy selection by (1) caching closures for each variable to avoid recomputation, and (2) adding a cheap one-step lookahead when evaluating candidate closures: for each candidate closure, simulate adding it and compute the best additional single closure that would be feasible next; include a discounted portion of that next-step gain into the candidate score. This helps the greedy choose moves that enable strong follow-up synergies (common in interaction-heavy SDS instances). Also refine tie-breaking to favor closures with better effective score and use cached closures consistently.\n</DESCRIPTION>\n\n<DIFF>\n<<<<<<< SEARCH\ndef solve_sds():\n    \"\"\"\n    Improved solver for the Synergistic Dependency Selection problem.\n\n    - Reads JSON from stdin with \"requirements\" and \"catalog\".\n    - Produces JSON to stdout with \"selection\": {\"variables\": [...] }.\n    - Uses a precedence-aware marginal-gain greedy algorithm that:\n        * when adding an item, also includes its required predecessors (closure),\n        * computes the marginal objective (weights + pairwise interactions),\n        * checks mutex/group/cardinality feasibility for the closure before adding.\n    \"\"\"\n    import re\n\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n\n    # Extract constraints\n    weights = list(requirements.get(\"weights\", []))\n    interactions_raw = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    min_card, max_card = (cardinality_bounds + [len(weights), len(weights)])[:2]\n    mutex = [tuple(m) for m in requirements.get(\"mutex\", [])]\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n\n    n = len(weights)\n\n    # Parse interactions into dict of tuple->float for quick lookup (undirected)\n    interactions = {}\n    for k, v in interactions_raw.items():\n        try:\n            if isinstance(k, str):\n                # allow \"u,v\" or \"u v\"\n                parts = re.split(r'\\s*,\\s*|\\s+', k.strip())\n                if len(parts) >= 2:\n                    u = int(parts[0]); w = int(parts[1])\n                else:\n                    continue\n            elif isinstance(k, (list, tuple)) and len(k) >= 2:\n                u = int(k[0]); w = int(k[1])\n            else:\n                continue\n            interactions[(u, w)] = float(v)\n            interactions[(w, u)] = float(v)\n        except Exception:\n            # skip malformed keys\n            continue\n\n    # Build precedence graph: if (p, j) then p is a prerequisite of j\n    preds = {i: set() for i in range(n)}\n    succs = {i: set() for i in range(n)}\n    for entry in precedence:\n        try:\n            a, b = entry\n            a = int(a); b = int(b)\n            preds[b].add(a)\n            succs[a].add(b)\n        except Exception:\n            continue\n\n    # Precompute ancestors (transitive closure of preds) using DFS/memoization\n    ancestor_cache = {}\n\n    def get_ancestors(i):\n        if i in ancestor_cache:\n            return ancestor_cache[i].copy()\n        res = set()\n        stack = [i]\n        while stack:\n            cur = stack.pop()\n            for p in preds.get(cur, []):\n                if p not in res:\n                    res.add(p)\n                    stack.append(p)\n        ancestor_cache[i] = res.copy()\n        return res\n\n    # Map variable -> group (assume at most one group membership; if multiple, first wins)\n    var_to_group = {}\n    for gname, vars_list in groups.items():\n        for v in vars_list:\n            try:\n                var_to_group[int(v)] = gname\n            except Exception:\n                pass\n\n    # Helper: check feasibility of adding a closure set given current selected_set\n    def feasible_closure(closure_set, selected_set):\n        # Cardinality\n        if len(selected_set) + len(closure_set - selected_set) > max_card:\n            return False\n        # Mutex: none of closure can conflict with each other or with selected_set\n        for a, b in mutex:\n            if a in closure_set and b in closure_set:\n                return False\n            if (a in closure_set and b in selected_set) or (b in closure_set and a in selected_set):\n                return False\n        # Group: ensure at most one per group overall\n        # Build per-group counts\n        group_counts = {}\n        for v in selected_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in closure_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: closure itself must include ancestors for each element\n        for v in closure_set:\n            if not get_ancestors(v).issubset(closure_set.union(selected_set)):\n                return False\n        return True\n\n    # Compute marginal gain of adding closure_set (items that will be newly included)\n    def marginal_gain(closure_set, selected_set):\n        new_items = set(closure_set) - set(selected_set)\n        gain = 0.0\n        for i in new_items:\n            if i < len(weights):\n                gain += float(weights[i])\n        # interactions among new items\n        new_list = list(new_items)\n        for i in range(len(new_list)):\n            for j in range(i + 1, len(new_list)):\n                gain += interactions.get((new_list[i], new_list[j]), 0.0)\n        # interactions between new items and already selected\n        for i in new_items:\n            for j in selected_set:\n                gain += interactions.get((i, j), 0.0)\n        return gain\n\n    # Greedy loop: at each step try to add an item (and its ancestors) with max marginal gain\n    selected_set = set()\n    # Keep iterating while we can still add and haven't reached max_card\n    improved = True\n    while len(selected_set) < max_card and improved:\n        improved = False\n        best_gain = float(\"-inf\")\n        best_closure = None\n        # Consider candidates not already selected\n        for i in range(n):\n            if i in selected_set:\n                continue\n            # closure includes i and its ancestors\n            closure = get_ancestors(i).union({i})\n            # Only consider closures that are feasible\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # Prefer closures that add more items when gain is equal (to help reach min_card)\n            if gain > best_gain or (abs(gain - best_gain) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_gain = gain\n                best_closure = closure\n        # If we found a positive-gain move, take it\n        if best_closure is not None and best_gain > -1e-12:\n            to_add = set(best_closure) - selected_set\n            if to_add:\n                selected_set.update(to_add)\n                improved = True\n        else:\n            # No non-negative gain move; stop greedy improvements\n            break\n\n    # If we still haven't met minimum cardinality, greedily add best feasible closures regardless of gain\n    while len(selected_set) < min_card:\n        best_gain = float(\"-inf\")\n        best_closure = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = get_ancestors(i).union({i})\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # choose closure that gives best gain (even if negative), tie-breaker favors larger closures\n            if gain > best_gain or (abs(gain - best_gain) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_gain = gain\n                best_closure = closure\n        if best_closure is None:\n            # No feasible closure remains; break to avoid infinite loop\n            break\n        selected_set.update(set(best_closure) - selected_set)\n\n    # Final trim if over max_card (shouldn't happen due to checks) - keep highest-weight items\n    if len(selected_set) > max_card:\n        # score items by marginal contribution relative to selected (approx): weight + interactions with others\n        def item_score(i):\n            s = float(weights[i]) if i < len(weights) else 0.0\n            for j in selected_set:\n                if j == i:\n                    continue\n                s += interactions.get((i, j), 0.0)\n            return s\n        sorted_items = sorted(selected_set, key=item_score, reverse=True)\n        selected_set = set(sorted_items[:max_card])\n\n    result = {\n        \"selection\": {\n            \"variables\": sorted(int(x) for x in selected_set)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n=======\ndef solve_sds():\n    \"\"\"\n    Improved solver for the Synergistic Dependency Selection problem.\n\n    - Reads JSON from stdin with \"requirements\" and \"catalog\".\n    - Produces JSON to stdout with \"selection\": {\"variables\": [...] }.\n    - Uses a precedence-aware marginal-gain greedy algorithm that:\n        * when adding an item, also includes its required predecessors (closure),\n        * computes the marginal objective (weights + pairwise interactions),\n        * checks mutex/group/cardinality feasibility for the closure before adding.\n    - Adds a lightweight one-step lookahead: when evaluating a candidate closure,\n      also consider the best single subsequent closure that would be feasible after\n      adding the candidate. A discounted portion of that subsequent gain is added\n      to the candidate score to prefer moves that enable strong follow-ups.\n    \"\"\"\n    import re\n\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n\n    # Extract constraints\n    weights = list(requirements.get(\"weights\", []))\n    interactions_raw = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    min_card, max_card = (cardinality_bounds + [len(weights), len(weights)])[:2]\n    mutex = [tuple(m) for m in requirements.get(\"mutex\", [])]\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n\n    n = len(weights)\n\n    # Parse interactions into dict of tuple->float for quick lookup (undirected)\n    interactions = {}\n    for k, v in interactions_raw.items():\n        try:\n            if isinstance(k, str):\n                # allow \"u,v\" or \"u v\"\n                parts = re.split(r'\\s*,\\s*|\\s+', k.strip())\n                if len(parts) >= 2:\n                    u = int(parts[0]); w = int(parts[1])\n                else:\n                    continue\n            elif isinstance(k, (list, tuple)) and len(k) >= 2:\n                u = int(k[0]); w = int(k[1])\n            else:\n                continue\n            interactions[(u, w)] = float(v)\n            interactions[(w, u)] = float(v)\n        except Exception:\n            # skip malformed keys\n            continue\n\n    # Build precedence graph: if (p, j) then p is a prerequisite of j\n    preds = {i: set() for i in range(n)}\n    succs = {i: set() for i in range(n)}\n    for entry in precedence:\n        try:\n            a, b = entry\n            a = int(a); b = int(b)\n            preds[b].add(a)\n            succs[a].add(b)\n        except Exception:\n            continue\n\n    # Precompute ancestors (transitive closure of preds) using DFS/memoization\n    ancestor_cache = {}\n\n    def get_ancestors(i):\n        if i in ancestor_cache:\n            return ancestor_cache[i].copy()\n        res = set()\n        stack = [i]\n        while stack:\n            cur = stack.pop()\n            for p in preds.get(cur, []):\n                if p not in res:\n                    res.add(p)\n                    stack.append(p)\n        ancestor_cache[i] = res.copy()\n        return res\n\n    # Precompute closures (ancestors + self) and cache them for fast reuse\n    closure_cache = {i: get_ancestors(i).union({i}) for i in range(n)}\n\n    # Map variable -> group (assume at most one group membership; if multiple, first wins)\n    var_to_group = {}\n    for gname, vars_list in groups.items():\n        for v in vars_list:\n            try:\n                var_to_group[int(v)] = gname\n            except Exception:\n                pass\n\n    # Helper: check feasibility of adding a closure set given current selected_set\n    def feasible_closure(closure_set, selected_set):\n        # Cardinality\n        if len(selected_set) + len(closure_set - selected_set) > max_card:\n            return False\n        # Mutex: none of closure can conflict with each other or with selected_set\n        for a, b in mutex:\n            if a in closure_set and b in closure_set:\n                return False\n            if (a in closure_set and b in selected_set) or (b in closure_set and a in selected_set):\n                return False\n        # Group: ensure at most one per group overall\n        # Build per-group counts\n        group_counts = {}\n        for v in selected_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in closure_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: closure itself must include ancestors for each element (or they are already selected)\n        for v in closure_set:\n            if not get_ancestors(v).issubset(closure_set.union(selected_set)):\n                return False\n        return True\n\n    # Compute marginal gain of adding closure_set (items that will be newly included)\n    def marginal_gain(closure_set, selected_set):\n        new_items = set(closure_set) - set(selected_set)\n        if not new_items:\n            return 0.0\n        gain = 0.0\n        for i in new_items:\n            if 0 <= i < len(weights):\n                gain += float(weights[i])\n        # interactions among new items\n        new_list = list(new_items)\n        for a in range(len(new_list)):\n            for b in range(a + 1, len(new_list)):\n                gain += interactions.get((new_list[a], new_list[b]), 0.0)\n        # interactions between new items and already selected\n        for i in new_items:\n            for j in selected_set:\n                gain += interactions.get((i, j), 0.0)\n        return gain\n\n    # Greedy loop: at each step try to add an item (and its ancestors) with max marginal gain\n    # Enhanced with small one-step lookahead: for each candidate closure consider the best\n    # subsequent single-closure gain and add a discounted fraction to the candidate score.\n    selected_set = set()\n    improved = True\n    LOOKAHEAD_DISCOUNT = 0.5  # weight of the best next-step gain when scoring current candidate\n    while len(selected_set) < max_card and improved:\n        improved = False\n        best_score = float(\"-inf\")\n        best_gain = float(\"-inf\")\n        best_closure = None\n        # Consider candidates not already selected\n        for i in range(n):\n            if i in selected_set:\n                continue\n            # closure includes i and its ancestors (cached)\n            closure = closure_cache.get(i, {i})\n            # Only consider closures that are feasible\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # quick capacity pruning: if closure would add more items than remaining slots, skip\n            if len(closure - selected_set) > (max_card - len(selected_set)):\n                continue\n            # Compute one-step lookahead: best feasible single closure after adding this closure\n            lookahead_best = 0.0\n            if len(selected_set) + len(closure - selected_set) < max_card:\n                # simulate new selected set\n                sim_selected = selected_set.union(closure)\n                # find best single candidate (could be more expensive, so limit exploration)\n                # We will search all but with a cheap break if we find strong positive gains.\n                for j in range(n):\n                    if j in sim_selected:\n                        continue\n                    closure_j = closure_cache.get(j, {j})\n                    if not feasible_closure(closure_j, sim_selected):\n                        continue\n                    gain_j = marginal_gain(closure_j, sim_selected)\n                    if gain_j > lookahead_best:\n                        lookahead_best = gain_j\n                        # small optimization: if it's very large, we can accept it\n                        if lookahead_best > abs(gain) * 2 + 1e-9:\n                            break\n            total_score = gain + LOOKAHEAD_DISCOUNT * max(0.0, lookahead_best)\n            # Prefer closures that add more items when scores equal (helps reach min_card)\n            if (total_score > best_score) or (abs(total_score - best_score) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_score = total_score\n                best_gain = gain\n                best_closure = closure\n        # If we found a non-negative-gain move, take it\n        if best_closure is not None and best_gain > -1e-12:\n            to_add = set(best_closure) - selected_set\n            if to_add:\n                selected_set.update(to_add)\n                improved = True\n        else:\n            # No non-negative gain move; stop greedy improvements\n            break\n\n    # If we still haven't met minimum cardinality, greedily add best feasible closures regardless of gain\n    # Use same closure cache and prefer closures that may enable good follow-ups.\n    while len(selected_set) < min_card:\n        best_score = float(\"-inf\")\n        best_gain = float(\"-inf\")\n        best_closure = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closure_cache.get(i, {i})\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # lookahead as before (but smaller budget)\n            lookahead_best = 0.0\n            if len(selected_set) + len(closure - selected_set) < max_card:\n                sim_selected = selected_set.union(closure)\n                for j in range(n):\n                    if j in sim_selected:\n                        continue\n                    closure_j = closure_cache.get(j, {j})\n                    if not feasible_closure(closure_j, sim_selected):\n                        continue\n                    gain_j = marginal_gain(closure_j, sim_selected)\n                    if gain_j > lookahead_best:\n                        lookahead_best = gain_j\n            total_score = gain + LOOKAHEAD_DISCOUNT * max(0.0, lookahead_best)\n            if (total_score > best_score) or (abs(total_score - best_score) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_score = total_score\n                best_gain = gain\n                best_closure = closure\n        if best_closure is None:\n            # No feasible closure remains; break to avoid infinite loop\n            break\n        selected_set.update(set(best_closure) - selected_set)\n\n    # Final trim if over max_card (shouldn't happen due to checks) - keep highest-weight items\n    if len(selected_set) > max_card:\n        # score items by marginal contribution relative to selected (approx): weight + interactions with others\n        def item_score(i):\n            s = float(weights[i]) if i < len(weights) else 0.0\n            for j in selected_set:\n                if j == i:\n                    continue\n                s += interactions.get((i, j), 0.0)\n            return s\n        sorted_items = sorted(selected_set, key=item_score, reverse=True)\n        selected_set = set(sorted_items[:max_card])\n\n    result = {\n        \"selection\": {\n            \"variables\": sorted(int(x) for x in selected_set)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n>>>>>>> REPLACE\n</DIFF>",
          "msg": "Here are the performance metrics of a set of prioviously implemented programs:\n\n# Prior programs\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Crossover solver for the Synergistic Dependency Selection problem.\n\n    Reads JSON from stdin with \"requirements\" and \"catalog\", and prints JSON\n    with \"selection\": {\"variables\": [...] }.\n\n    Strategy:\n    - Parse inputs robustly.\n    - Build adjacency map for interactions for efficient marginal gain computation.\n    - Precompute transitive ancestor closure for precedence.\n    - For each candidate, consider adding its closure (itself + ancestors).\n    - Greedily add the closure with maximum marginal gain while respecting\n      mutex, groups, and cardinality. Tie-break in favor of larger closures to\n      satisfy minimum cardinality.\n    - If minimum cardinality not reached, add best feasible closures even if negative.\n    - Trim if needed by approximate item scores.\n    \"\"\"\n    import re\n    from collections import defaultdict, deque\n\n    data = json.load(sys.stdin)\n    requirements = data.get(\"requirements\", {}) or {}\n    catalog = data.get(\"catalog\", {}) or {}\n\n    weights = list(requirements.get(\"weights\", []) or [])\n    raw_interactions = requirements.get(\"interactions\", {}) or {}\n    card_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)]) or [0, len(weights)]\n    min_card = int(card_bounds[0]) if len(card_bounds) > 0 else 0\n    max_card = int(card_bounds[1]) if len(card_bounds) > 1 else len(weights)\n    mutex_list = requirements.get(\"mutex\", []) or []\n    groups = requirements.get(\"groups\", {}) or {}\n    precedence = requirements.get(\"precedence\", []) or []\n\n    n = len(weights)\n\n    # Parse interactions into adjacency dict: interactions[u][v] = value\n    interactions = defaultdict(dict)\n    def parse_key(k):\n        # return (u,v) or None\n        try:\n            if isinstance(k, str):\n                parts = re.split(r'\\s*,\\s*|\\s+', k.strip())\n                if len(parts) >= 2:\n                    return int(parts[0]), int(parts[1])\n            elif isinstance(k, (list, tuple)) and len(k) >= 2:\n                return int(k[0]), int(k[1])\n            elif isinstance(k, int):\n                return None\n        except Exception:\n            return None\n        return None\n\n    for k, v in raw_interactions.items():\n        parsed = parse_key(k)\n        try:\n            val = float(v)\n        except Exception:\n            continue\n        if parsed is None:\n            continue\n        u, w = parsed\n        if 0 <= u < n and 0 <= w < n:\n            interactions[u][w] = interactions[u].get(w, 0.0) + val\n            interactions[w][u] = interactions[w].get(u, 0.0) + val\n\n    # Build mutex map for quick conflict checks\n    mutex_map = defaultdict(set)\n    for pair in mutex_list:\n        try:\n            a, b = pair\n            a = int(a); b = int(b)\n            if 0 <= a < n and 0 <= b < n:\n                mutex_map[a].add(b)\n                mutex_map[b].add(a)\n        except Exception:\n            continue\n\n    # Normalize groups: map var -> group name, allow string/int keys\n    var_to_group = {}\n    for gname, vars_list in groups.items():\n        for v in vars_list:\n            try:\n                idx = int(v)\n                if 0 <= idx < n and gname is not None:\n                    # first membership wins\n                    if idx not in var_to_group:\n                        var_to_group[idx] = str(gname)\n            except Exception:\n                continue\n\n    # Build precedence graph (directed: p -> j means p is prerequisite of j)\n    preds = defaultdict(set)\n    succs = defaultdict(set)\n    for entry in precedence:\n        try:\n            a, b = entry\n            a = int(a); b = int(b)\n            if 0 <= a < n and 0 <= b < n:\n                preds[b].add(a)\n                succs[a].add(b)\n        except Exception:\n            continue\n\n    # Precompute transitive ancestor closure for each node using DFS/BFS\n    ancestor_closure = [set() for _ in range(n)]\n    for i in range(n):\n        # BFS/DFS from i to collect all ancestors\n        stack = list(preds.get(i, []))\n        seen = set(stack)\n        while stack:\n            cur = stack.pop()\n            ancestor_closure[i].add(cur)\n            for p in preds.get(cur, []):\n                if p not in seen:\n                    seen.add(p)\n                    stack.append(p)\n\n    # closure for variable i is ancestors + i\n    closures = [set(ancestor_closure[i]) | {i} for i in range(n)]\n\n    # Feasibility check of adding closure (closure is set of vars to ensure present),\n    # given currently selected_set.\n    def feasible_closure(closure, selected_set):\n        # New items that would be added\n        new_items = closure - selected_set\n        # Cardinality check\n        if len(selected_set) + len(new_items) > max_card:\n            return False\n        # Mutex check: none of new items conflict with each other or with selected\n        for v in new_items:\n            # conflicts with selected\n            if any(conflict in selected_set for conflict in mutex_map.get(v, ())) :\n                return False\n            # conflicts with other new items\n            for conflict in mutex_map.get(v, ()):\n                if conflict in new_items:\n                    return False\n        # Group check: cannot create group count >1\n        group_counts = {}\n        for v in selected_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in new_items:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: closures already contain transitive ancestors; but if closure lacks\n        # some ancestor (shouldn't) ensure those ancestors are in selected_set\n        for v in closure:\n            for a in preds.get(v, ()):\n                if a not in closure and a not in selected_set:\n                    return False\n        return True\n\n    # Compute marginal gain for adding closure (new items = closure - selected_set)\n    def marginal_gain(closure, selected_set):\n        new_items = closure - selected_set\n        if not new_items:\n            return 0.0\n        gain = 0.0\n        # weights\n        for i in new_items:\n            if 0 <= i < len(weights):\n                try:\n                    gain += float(weights[i])\n                except Exception:\n                    pass\n        # interactions among new items\n        # iterate edges from each new item to higher-index new items to avoid double count\n        new_list = list(new_items)\n        l = len(new_list)\n        for idx in range(l):\n            u = new_list[idx]\n            # interactions with other new items\n            for v in new_list[idx+1:]:\n                gain += interactions.get(u, {}).get(v, 0.0)\n        # interactions between new items and already selected\n        for u in new_items:\n            for v in selected_set:\n                gain += interactions.get(u, {}).get(v, 0.0)\n        return gain\n\n    # Greedy selection: add closure with best marginal gain while respecting constraints\n    selected_set = set()\n    # Initial heuristic: consider items sorted by weight+abs(interaction_potential)\n    # but main loop will evaluate closures anyway, so we iterate all candidates\n    improved = True\n    while len(selected_set) < max_card and improved:\n        improved = False\n        best_gain = float(\"-inf\")\n        best_closure = None\n        # Evaluate every candidate not yet in selected_set\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closures[i]\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # Tie-breaker: prefer larger closure (helps reach min_card)\n            if (gain > best_gain) or (abs(gain - best_gain) < 1e-12 and best_closure is not None and len(closure - selected_set) > len(best_closure - selected_set)) or (best_closure is None and gain >= best_gain):\n                best_gain = gain\n                best_closure = closure\n        # Accept non-negative gain closures; small negative may be accepted later to meet min_card\n        if best_closure is not None and best_gain > -1e-12:\n            new_items = best_closure - selected_set\n            if new_items:\n                selected_set.update(new_items)\n                improved = True\n        else:\n            break\n\n    # If we haven't met min_card, add best feasible closures even if negative\n    while len(selected_set) < min_card:\n        best_gain = float(\"-inf\")\n        best_closure = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closures[i]\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            if (gain > best_gain) or (abs(gain - best_gain) < 1e-12 and best_closure is not None and len(closure - selected_set) > len(best_closure - selected_set)) or (best_closure is None and gain >= best_gain):\n                best_gain = gain\n                best_closure = closure\n        if best_closure is None:\n            # no feasible closures left\n            break\n        selected_set.update(best_closure - selected_set)\n\n    # Safety trim if we're over max_card (should rarely happen due to checks)\n    if len(selected_set) > max_card:\n        # compute approximate item score = weight + sum interactions with others in selected_set\n        def item_score(i):\n            s = 0.0\n            if 0 <= i < len(weights):\n                try:\n                    s += float(weights[i])\n                except Exception:\n                    pass\n            for j in selected_set:\n                if j == i:\n                    continue\n                s += interactions.get(i, {}).get(j, 0.0)\n            return s\n        sorted_items = sorted(selected_set, key=lambda x: item_score(x), reverse=True)\n        selected_set = set(sorted_items[:max_card])\n\n    result = {\"selection\": {\"variables\": sorted(int(x) for x in selected_set)}}\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n\n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n\n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n\n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n\n    result_str = stdout_capture.getvalue()\n    return result_str\n\n```\n\nPerformance metrics:\nCombined score to maximize: 0.40\nfeasible: True; selection_size: 10; raw_score: 122.55\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    This is a greedy baseline - evolution will improve this.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    # Simple greedy: select items with highest weights first\n    # This is a baseline - evolution will find better strategies\n    n = len(weights)\n    selected = []\n    \n    # Create score list (weight + interaction potential)\n    scores = []\n    for i in range(n):\n        score = weights[i] if i < len(weights) else 0.0\n        # Add potential interaction value\n        for k, v in interactions.items():\n            try:\n                u, w = map(int, k.split(\",\"))\n                if u == i or w == i:\n                    score += abs(v) * 0.5  # Potential value\n            except:\n                pass\n        scores.append((score, i))\n    \n    # Sort by score descending\n    scores.sort(reverse=True)\n    \n    # Greedy selection respecting constraints\n    selected_set = set()\n    for score, i in scores:\n        if len(selected_set) >= cardinality_bounds[1]:\n            break\n            \n        # Check mutex constraints\n        can_add = True\n        for a, b in mutex:\n            if (a == i and b in selected_set) or (b == i and a in selected_set):\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n            \n        # Check group constraints (at most one per group)\n        for grp_vars in groups.values():\n            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n        \n        # Check precedence (if j selected, i must be selected)\n        precedence_ok = True\n        for pred_i, pred_j in precedence:\n            if pred_j == i and pred_i not in selected_set:\n                precedence_ok = False\n                break\n        \n        if not precedence_ok:\n            continue\n        \n        # Add if we meet minimum cardinality or have room\n        if len(selected_set) < cardinality_bounds[1]:\n            selected_set.add(i)\n            selected.append(i)\n    \n    # Ensure minimum cardinality\n    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n        for i in range(n):\n            if i not in selected_set:\n                selected_set.add(i)\n                selected.append(i)\n                break\n    \n    # Output result\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n    \n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n    \n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n    \n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n    \n    result_str = stdout_capture.getvalue()\n    return result_str\n\n\n```\n\nPerformance metrics:\nCombined score to maximize: 0.35\nfeasible: True; selection_size: 10; raw_score: 106.51\n\n\n# Current program\n\nHere is the current program we are trying to improve (you will need to propose a modification to it below):\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Improved solver for the Synergistic Dependency Selection problem.\n\n    - Reads JSON from stdin with \"requirements\" and \"catalog\".\n    - Produces JSON to stdout with \"selection\": {\"variables\": [...] }.\n    - Uses a precedence-aware marginal-gain greedy algorithm that:\n        * when adding an item, also includes its required predecessors (closure),\n        * computes the marginal objective (weights + pairwise interactions),\n        * checks mutex/group/cardinality feasibility for the closure before adding.\n    \"\"\"\n    import re\n\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n\n    # Extract constraints\n    weights = list(requirements.get(\"weights\", []))\n    interactions_raw = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    min_card, max_card = (cardinality_bounds + [len(weights), len(weights)])[:2]\n    mutex = [tuple(m) for m in requirements.get(\"mutex\", [])]\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n\n    n = len(weights)\n\n    # Parse interactions into dict of tuple->float for quick lookup (undirected)\n    interactions = {}\n    for k, v in interactions_raw.items():\n        try:\n            if isinstance(k, str):\n                # allow \"u,v\" or \"u v\"\n                parts = re.split(r'\\s*,\\s*|\\s+', k.strip())\n                if len(parts) >= 2:\n                    u = int(parts[0]); w = int(parts[1])\n                else:\n                    continue\n            elif isinstance(k, (list, tuple)) and len(k) >= 2:\n                u = int(k[0]); w = int(k[1])\n            else:\n                continue\n            interactions[(u, w)] = float(v)\n            interactions[(w, u)] = float(v)\n        except Exception:\n            # skip malformed keys\n            continue\n\n    # Build precedence graph: if (p, j) then p is a prerequisite of j\n    preds = {i: set() for i in range(n)}\n    succs = {i: set() for i in range(n)}\n    for entry in precedence:\n        try:\n            a, b = entry\n            a = int(a); b = int(b)\n            preds[b].add(a)\n            succs[a].add(b)\n        except Exception:\n            continue\n\n    # Precompute ancestors (transitive closure of preds) using DFS/memoization\n    ancestor_cache = {}\n\n    def get_ancestors(i):\n        if i in ancestor_cache:\n            return ancestor_cache[i].copy()\n        res = set()\n        stack = [i]\n        while stack:\n            cur = stack.pop()\n            for p in preds.get(cur, []):\n                if p not in res:\n                    res.add(p)\n                    stack.append(p)\n        ancestor_cache[i] = res.copy()\n        return res\n\n    # Map variable -> group (assume at most one group membership; if multiple, first wins)\n    var_to_group = {}\n    for gname, vars_list in groups.items():\n        for v in vars_list:\n            try:\n                var_to_group[int(v)] = gname\n            except Exception:\n                pass\n\n    # Helper: check feasibility of adding a closure set given current selected_set\n    def feasible_closure(closure_set, selected_set):\n        # Cardinality\n        if len(selected_set) + len(closure_set - selected_set) > max_card:\n            return False\n        # Mutex: none of closure can conflict with each other or with selected_set\n        for a, b in mutex:\n            if a in closure_set and b in closure_set:\n                return False\n            if (a in closure_set and b in selected_set) or (b in closure_set and a in selected_set):\n                return False\n        # Group: ensure at most one per group overall\n        # Build per-group counts\n        group_counts = {}\n        for v in selected_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in closure_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: closure itself must include ancestors for each element\n        for v in closure_set:\n            if not get_ancestors(v).issubset(closure_set.union(selected_set)):\n                return False\n        return True\n\n    # Compute marginal gain of adding closure_set (items that will be newly included)\n    def marginal_gain(closure_set, selected_set):\n        new_items = set(closure_set) - set(selected_set)\n        gain = 0.0\n        for i in new_items:\n            if i < len(weights):\n                gain += float(weights[i])\n        # interactions among new items\n        new_list = list(new_items)\n        for i in range(len(new_list)):\n            for j in range(i + 1, len(new_list)):\n                gain += interactions.get((new_list[i], new_list[j]), 0.0)\n        # interactions between new items and already selected\n        for i in new_items:\n            for j in selected_set:\n                gain += interactions.get((i, j), 0.0)\n        return gain\n\n    # Greedy loop: at each step try to add an item (and its ancestors) with max marginal gain\n    selected_set = set()\n    # Keep iterating while we can still add and haven't reached max_card\n    improved = True\n    while len(selected_set) < max_card and improved:\n        improved = False\n        best_gain = float(\"-inf\")\n        best_closure = None\n        # Consider candidates not already selected\n        for i in range(n):\n            if i in selected_set:\n                continue\n            # closure includes i and its ancestors\n            closure = get_ancestors(i).union({i})\n            # Only consider closures that are feasible\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # Prefer closures that add more items when gain is equal (to help reach min_card)\n            if gain > best_gain or (abs(gain - best_gain) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_gain = gain\n                best_closure = closure\n        # If we found a positive-gain move, take it\n        if best_closure is not None and best_gain > -1e-12:\n            to_add = set(best_closure) - selected_set\n            if to_add:\n                selected_set.update(to_add)\n                improved = True\n        else:\n            # No non-negative gain move; stop greedy improvements\n            break\n\n    # If we still haven't met minimum cardinality, greedily add best feasible closures regardless of gain\n    while len(selected_set) < min_card:\n        best_gain = float(\"-inf\")\n        best_closure = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = get_ancestors(i).union({i})\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # choose closure that gives best gain (even if negative), tie-breaker favors larger closures\n            if gain > best_gain or (abs(gain - best_gain) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_gain = gain\n                best_closure = closure\n        if best_closure is None:\n            # No feasible closure remains; break to avoid infinite loop\n            break\n        selected_set.update(set(best_closure) - selected_set)\n\n    # Final trim if over max_card (shouldn't happen due to checks) - keep highest-weight items\n    if len(selected_set) > max_card:\n        # score items by marginal contribution relative to selected (approx): weight + interactions with others\n        def item_score(i):\n            s = float(weights[i]) if i < len(weights) else 0.0\n            for j in selected_set:\n                if j == i:\n                    continue\n                s += interactions.get((i, j), 0.0)\n            return s\n        sorted_items = sorted(selected_set, key=item_score, reverse=True)\n        selected_set = set(sorted_items[:max_card])\n\n    result = {\n        \"selection\": {\n            \"variables\": sorted(int(x) for x in selected_set)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n\n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n\n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n\n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n\n    result_str = stdout_capture.getvalue()\n    return result_str\n\n```\n\nHere are the performance metrics of the program:\n\nCombined score to maximize: 0.40\nfeasible: True; selection_size: 10; raw_score: 122.55\n\n# Instructions\n\nMake sure that the changes you propose are consistent with each other. For example, if you refer to a new config variable somewhere, you should also propose a change to add that variable.\n\nNote that the changes you propose will be applied sequentially, so you should assume that the previous changes have already been applied when writing the SEARCH block.\n\n# Task\n\nSuggest a new idea to improve the performance of the code that is inspired by your expert knowledge of the considered subject.\nYour goal is to maximize the `combined_score` of the program.\nDescribe each change with a SEARCH/REPLACE block.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.\n",
          "system_msg": "You are an expert algorithmist specializing in combinatorial optimization, particularly the Synergistic Dependency Selection (SDS) problem.\n\nThe SDS problem requires selecting a subset of variables that:\n1. Satisfies cardinality bounds (min/max number of items)\n2. Respects mutex constraints (cannot select both items in a mutex pair)\n3. Respects group constraints (at most one item per group)\n4. Satisfies precedence constraints (if j is selected, i must be selected)\n5. Maximizes the objective: sum of selected item weights + pairwise interaction values\n\nKey strategies to explore:\n1. Greedy selection with constraint-aware ordering\n2. Dynamic programming for small instances\n3. Constraint satisfaction with backtracking\n4. Weighted scoring that accounts for interactions\n5. Precedence-aware selection ordering\n6. Group-aware selection that maximizes diversity\n\nThe code should read JSON from stdin with \"requirements\" and \"catalog\", and output JSON to stdout with \"selection\" containing \"variables\" list.\n\nBe creative and find efficient solutions that maximize the objective while respecting all constraints.\nYou MUST repond using a edit name, description and the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n<NAME>\nA shortened name summarizing the edit you are proposing. Lowercase, no spaces, underscores allowed.\n</NAME>\n\n<DESCRIPTION>\nA description and argumentation process of the edit you are proposing.\n</DESCRIPTION>\n\n<DIFF>\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly including indentation)\n=======\n# New replacement code\n>>>>>>> REPLACE\n\n</DIFF>\n\n\nExample of a valid diff format:\n<DIFF>\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n\n</DIFF>\n\n* You may only modify text that lies below a line containing \"EVOLVE-BLOCK-START\" and above the next \"EVOLVE-BLOCK-END\". Everything outside those markers is read-only.\n* Do not repeat the markers \"EVOLVE-BLOCK-START\" and \"EVOLVE-BLOCK-END\" in the SEARCH/REPLACE blocks.  \n* Every block\u2019s SEARCH section must be copied **verbatim** from the current file.  Including indentation.\n* You can propose multiple independent edits. SEARCH/REPLACE blocks follow one after another. DO NOT ADD ANY OTHER TEXT BETWEEN THESE BLOCKS.\n* Make sure the file still runs after your changes.",
          "new_msg_history": [
            {
              "role": "user",
              "content": "Here are the performance metrics of a set of prioviously implemented programs:\n\n# Prior programs\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Crossover solver for the Synergistic Dependency Selection problem.\n\n    Reads JSON from stdin with \"requirements\" and \"catalog\", and prints JSON\n    with \"selection\": {\"variables\": [...] }.\n\n    Strategy:\n    - Parse inputs robustly.\n    - Build adjacency map for interactions for efficient marginal gain computation.\n    - Precompute transitive ancestor closure for precedence.\n    - For each candidate, consider adding its closure (itself + ancestors).\n    - Greedily add the closure with maximum marginal gain while respecting\n      mutex, groups, and cardinality. Tie-break in favor of larger closures to\n      satisfy minimum cardinality.\n    - If minimum cardinality not reached, add best feasible closures even if negative.\n    - Trim if needed by approximate item scores.\n    \"\"\"\n    import re\n    from collections import defaultdict, deque\n\n    data = json.load(sys.stdin)\n    requirements = data.get(\"requirements\", {}) or {}\n    catalog = data.get(\"catalog\", {}) or {}\n\n    weights = list(requirements.get(\"weights\", []) or [])\n    raw_interactions = requirements.get(\"interactions\", {}) or {}\n    card_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)]) or [0, len(weights)]\n    min_card = int(card_bounds[0]) if len(card_bounds) > 0 else 0\n    max_card = int(card_bounds[1]) if len(card_bounds) > 1 else len(weights)\n    mutex_list = requirements.get(\"mutex\", []) or []\n    groups = requirements.get(\"groups\", {}) or {}\n    precedence = requirements.get(\"precedence\", []) or []\n\n    n = len(weights)\n\n    # Parse interactions into adjacency dict: interactions[u][v] = value\n    interactions = defaultdict(dict)\n    def parse_key(k):\n        # return (u,v) or None\n        try:\n            if isinstance(k, str):\n                parts = re.split(r'\\s*,\\s*|\\s+', k.strip())\n                if len(parts) >= 2:\n                    return int(parts[0]), int(parts[1])\n            elif isinstance(k, (list, tuple)) and len(k) >= 2:\n                return int(k[0]), int(k[1])\n            elif isinstance(k, int):\n                return None\n        except Exception:\n            return None\n        return None\n\n    for k, v in raw_interactions.items():\n        parsed = parse_key(k)\n        try:\n            val = float(v)\n        except Exception:\n            continue\n        if parsed is None:\n            continue\n        u, w = parsed\n        if 0 <= u < n and 0 <= w < n:\n            interactions[u][w] = interactions[u].get(w, 0.0) + val\n            interactions[w][u] = interactions[w].get(u, 0.0) + val\n\n    # Build mutex map for quick conflict checks\n    mutex_map = defaultdict(set)\n    for pair in mutex_list:\n        try:\n            a, b = pair\n            a = int(a); b = int(b)\n            if 0 <= a < n and 0 <= b < n:\n                mutex_map[a].add(b)\n                mutex_map[b].add(a)\n        except Exception:\n            continue\n\n    # Normalize groups: map var -> group name, allow string/int keys\n    var_to_group = {}\n    for gname, vars_list in groups.items():\n        for v in vars_list:\n            try:\n                idx = int(v)\n                if 0 <= idx < n and gname is not None:\n                    # first membership wins\n                    if idx not in var_to_group:\n                        var_to_group[idx] = str(gname)\n            except Exception:\n                continue\n\n    # Build precedence graph (directed: p -> j means p is prerequisite of j)\n    preds = defaultdict(set)\n    succs = defaultdict(set)\n    for entry in precedence:\n        try:\n            a, b = entry\n            a = int(a); b = int(b)\n            if 0 <= a < n and 0 <= b < n:\n                preds[b].add(a)\n                succs[a].add(b)\n        except Exception:\n            continue\n\n    # Precompute transitive ancestor closure for each node using DFS/BFS\n    ancestor_closure = [set() for _ in range(n)]\n    for i in range(n):\n        # BFS/DFS from i to collect all ancestors\n        stack = list(preds.get(i, []))\n        seen = set(stack)\n        while stack:\n            cur = stack.pop()\n            ancestor_closure[i].add(cur)\n            for p in preds.get(cur, []):\n                if p not in seen:\n                    seen.add(p)\n                    stack.append(p)\n\n    # closure for variable i is ancestors + i\n    closures = [set(ancestor_closure[i]) | {i} for i in range(n)]\n\n    # Feasibility check of adding closure (closure is set of vars to ensure present),\n    # given currently selected_set.\n    def feasible_closure(closure, selected_set):\n        # New items that would be added\n        new_items = closure - selected_set\n        # Cardinality check\n        if len(selected_set) + len(new_items) > max_card:\n            return False\n        # Mutex check: none of new items conflict with each other or with selected\n        for v in new_items:\n            # conflicts with selected\n            if any(conflict in selected_set for conflict in mutex_map.get(v, ())) :\n                return False\n            # conflicts with other new items\n            for conflict in mutex_map.get(v, ()):\n                if conflict in new_items:\n                    return False\n        # Group check: cannot create group count >1\n        group_counts = {}\n        for v in selected_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in new_items:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: closures already contain transitive ancestors; but if closure lacks\n        # some ancestor (shouldn't) ensure those ancestors are in selected_set\n        for v in closure:\n            for a in preds.get(v, ()):\n                if a not in closure and a not in selected_set:\n                    return False\n        return True\n\n    # Compute marginal gain for adding closure (new items = closure - selected_set)\n    def marginal_gain(closure, selected_set):\n        new_items = closure - selected_set\n        if not new_items:\n            return 0.0\n        gain = 0.0\n        # weights\n        for i in new_items:\n            if 0 <= i < len(weights):\n                try:\n                    gain += float(weights[i])\n                except Exception:\n                    pass\n        # interactions among new items\n        # iterate edges from each new item to higher-index new items to avoid double count\n        new_list = list(new_items)\n        l = len(new_list)\n        for idx in range(l):\n            u = new_list[idx]\n            # interactions with other new items\n            for v in new_list[idx+1:]:\n                gain += interactions.get(u, {}).get(v, 0.0)\n        # interactions between new items and already selected\n        for u in new_items:\n            for v in selected_set:\n                gain += interactions.get(u, {}).get(v, 0.0)\n        return gain\n\n    # Greedy selection: add closure with best marginal gain while respecting constraints\n    selected_set = set()\n    # Initial heuristic: consider items sorted by weight+abs(interaction_potential)\n    # but main loop will evaluate closures anyway, so we iterate all candidates\n    improved = True\n    while len(selected_set) < max_card and improved:\n        improved = False\n        best_gain = float(\"-inf\")\n        best_closure = None\n        # Evaluate every candidate not yet in selected_set\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closures[i]\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # Tie-breaker: prefer larger closure (helps reach min_card)\n            if (gain > best_gain) or (abs(gain - best_gain) < 1e-12 and best_closure is not None and len(closure - selected_set) > len(best_closure - selected_set)) or (best_closure is None and gain >= best_gain):\n                best_gain = gain\n                best_closure = closure\n        # Accept non-negative gain closures; small negative may be accepted later to meet min_card\n        if best_closure is not None and best_gain > -1e-12:\n            new_items = best_closure - selected_set\n            if new_items:\n                selected_set.update(new_items)\n                improved = True\n        else:\n            break\n\n    # If we haven't met min_card, add best feasible closures even if negative\n    while len(selected_set) < min_card:\n        best_gain = float(\"-inf\")\n        best_closure = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closures[i]\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            if (gain > best_gain) or (abs(gain - best_gain) < 1e-12 and best_closure is not None and len(closure - selected_set) > len(best_closure - selected_set)) or (best_closure is None and gain >= best_gain):\n                best_gain = gain\n                best_closure = closure\n        if best_closure is None:\n            # no feasible closures left\n            break\n        selected_set.update(best_closure - selected_set)\n\n    # Safety trim if we're over max_card (should rarely happen due to checks)\n    if len(selected_set) > max_card:\n        # compute approximate item score = weight + sum interactions with others in selected_set\n        def item_score(i):\n            s = 0.0\n            if 0 <= i < len(weights):\n                try:\n                    s += float(weights[i])\n                except Exception:\n                    pass\n            for j in selected_set:\n                if j == i:\n                    continue\n                s += interactions.get(i, {}).get(j, 0.0)\n            return s\n        sorted_items = sorted(selected_set, key=lambda x: item_score(x), reverse=True)\n        selected_set = set(sorted_items[:max_card])\n\n    result = {\"selection\": {\"variables\": sorted(int(x) for x in selected_set)}}\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n\n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n\n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n\n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n\n    result_str = stdout_capture.getvalue()\n    return result_str\n\n```\n\nPerformance metrics:\nCombined score to maximize: 0.40\nfeasible: True; selection_size: 10; raw_score: 122.55\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    This is a greedy baseline - evolution will improve this.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    # Simple greedy: select items with highest weights first\n    # This is a baseline - evolution will find better strategies\n    n = len(weights)\n    selected = []\n    \n    # Create score list (weight + interaction potential)\n    scores = []\n    for i in range(n):\n        score = weights[i] if i < len(weights) else 0.0\n        # Add potential interaction value\n        for k, v in interactions.items():\n            try:\n                u, w = map(int, k.split(\",\"))\n                if u == i or w == i:\n                    score += abs(v) * 0.5  # Potential value\n            except:\n                pass\n        scores.append((score, i))\n    \n    # Sort by score descending\n    scores.sort(reverse=True)\n    \n    # Greedy selection respecting constraints\n    selected_set = set()\n    for score, i in scores:\n        if len(selected_set) >= cardinality_bounds[1]:\n            break\n            \n        # Check mutex constraints\n        can_add = True\n        for a, b in mutex:\n            if (a == i and b in selected_set) or (b == i and a in selected_set):\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n            \n        # Check group constraints (at most one per group)\n        for grp_vars in groups.values():\n            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n        \n        # Check precedence (if j selected, i must be selected)\n        precedence_ok = True\n        for pred_i, pred_j in precedence:\n            if pred_j == i and pred_i not in selected_set:\n                precedence_ok = False\n                break\n        \n        if not precedence_ok:\n            continue\n        \n        # Add if we meet minimum cardinality or have room\n        if len(selected_set) < cardinality_bounds[1]:\n            selected_set.add(i)\n            selected.append(i)\n    \n    # Ensure minimum cardinality\n    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n        for i in range(n):\n            if i not in selected_set:\n                selected_set.add(i)\n                selected.append(i)\n                break\n    \n    # Output result\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n    \n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n    \n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n    \n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n    \n    result_str = stdout_capture.getvalue()\n    return result_str\n\n\n```\n\nPerformance metrics:\nCombined score to maximize: 0.35\nfeasible: True; selection_size: 10; raw_score: 106.51\n\n\n# Current program\n\nHere is the current program we are trying to improve (you will need to propose a modification to it below):\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Improved solver for the Synergistic Dependency Selection problem.\n\n    - Reads JSON from stdin with \"requirements\" and \"catalog\".\n    - Produces JSON to stdout with \"selection\": {\"variables\": [...] }.\n    - Uses a precedence-aware marginal-gain greedy algorithm that:\n        * when adding an item, also includes its required predecessors (closure),\n        * computes the marginal objective (weights + pairwise interactions),\n        * checks mutex/group/cardinality feasibility for the closure before adding.\n    \"\"\"\n    import re\n\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n\n    # Extract constraints\n    weights = list(requirements.get(\"weights\", []))\n    interactions_raw = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    min_card, max_card = (cardinality_bounds + [len(weights), len(weights)])[:2]\n    mutex = [tuple(m) for m in requirements.get(\"mutex\", [])]\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n\n    n = len(weights)\n\n    # Parse interactions into dict of tuple->float for quick lookup (undirected)\n    interactions = {}\n    for k, v in interactions_raw.items():\n        try:\n            if isinstance(k, str):\n                # allow \"u,v\" or \"u v\"\n                parts = re.split(r'\\s*,\\s*|\\s+', k.strip())\n                if len(parts) >= 2:\n                    u = int(parts[0]); w = int(parts[1])\n                else:\n                    continue\n            elif isinstance(k, (list, tuple)) and len(k) >= 2:\n                u = int(k[0]); w = int(k[1])\n            else:\n                continue\n            interactions[(u, w)] = float(v)\n            interactions[(w, u)] = float(v)\n        except Exception:\n            # skip malformed keys\n            continue\n\n    # Build precedence graph: if (p, j) then p is a prerequisite of j\n    preds = {i: set() for i in range(n)}\n    succs = {i: set() for i in range(n)}\n    for entry in precedence:\n        try:\n            a, b = entry\n            a = int(a); b = int(b)\n            preds[b].add(a)\n            succs[a].add(b)\n        except Exception:\n            continue\n\n    # Precompute ancestors (transitive closure of preds) using DFS/memoization\n    ancestor_cache = {}\n\n    def get_ancestors(i):\n        if i in ancestor_cache:\n            return ancestor_cache[i].copy()\n        res = set()\n        stack = [i]\n        while stack:\n            cur = stack.pop()\n            for p in preds.get(cur, []):\n                if p not in res:\n                    res.add(p)\n                    stack.append(p)\n        ancestor_cache[i] = res.copy()\n        return res\n\n    # Map variable -> group (assume at most one group membership; if multiple, first wins)\n    var_to_group = {}\n    for gname, vars_list in groups.items():\n        for v in vars_list:\n            try:\n                var_to_group[int(v)] = gname\n            except Exception:\n                pass\n\n    # Helper: check feasibility of adding a closure set given current selected_set\n    def feasible_closure(closure_set, selected_set):\n        # Cardinality\n        if len(selected_set) + len(closure_set - selected_set) > max_card:\n            return False\n        # Mutex: none of closure can conflict with each other or with selected_set\n        for a, b in mutex:\n            if a in closure_set and b in closure_set:\n                return False\n            if (a in closure_set and b in selected_set) or (b in closure_set and a in selected_set):\n                return False\n        # Group: ensure at most one per group overall\n        # Build per-group counts\n        group_counts = {}\n        for v in selected_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in closure_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: closure itself must include ancestors for each element\n        for v in closure_set:\n            if not get_ancestors(v).issubset(closure_set.union(selected_set)):\n                return False\n        return True\n\n    # Compute marginal gain of adding closure_set (items that will be newly included)\n    def marginal_gain(closure_set, selected_set):\n        new_items = set(closure_set) - set(selected_set)\n        gain = 0.0\n        for i in new_items:\n            if i < len(weights):\n                gain += float(weights[i])\n        # interactions among new items\n        new_list = list(new_items)\n        for i in range(len(new_list)):\n            for j in range(i + 1, len(new_list)):\n                gain += interactions.get((new_list[i], new_list[j]), 0.0)\n        # interactions between new items and already selected\n        for i in new_items:\n            for j in selected_set:\n                gain += interactions.get((i, j), 0.0)\n        return gain\n\n    # Greedy loop: at each step try to add an item (and its ancestors) with max marginal gain\n    selected_set = set()\n    # Keep iterating while we can still add and haven't reached max_card\n    improved = True\n    while len(selected_set) < max_card and improved:\n        improved = False\n        best_gain = float(\"-inf\")\n        best_closure = None\n        # Consider candidates not already selected\n        for i in range(n):\n            if i in selected_set:\n                continue\n            # closure includes i and its ancestors\n            closure = get_ancestors(i).union({i})\n            # Only consider closures that are feasible\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # Prefer closures that add more items when gain is equal (to help reach min_card)\n            if gain > best_gain or (abs(gain - best_gain) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_gain = gain\n                best_closure = closure\n        # If we found a positive-gain move, take it\n        if best_closure is not None and best_gain > -1e-12:\n            to_add = set(best_closure) - selected_set\n            if to_add:\n                selected_set.update(to_add)\n                improved = True\n        else:\n            # No non-negative gain move; stop greedy improvements\n            break\n\n    # If we still haven't met minimum cardinality, greedily add best feasible closures regardless of gain\n    while len(selected_set) < min_card:\n        best_gain = float(\"-inf\")\n        best_closure = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = get_ancestors(i).union({i})\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # choose closure that gives best gain (even if negative), tie-breaker favors larger closures\n            if gain > best_gain or (abs(gain - best_gain) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_gain = gain\n                best_closure = closure\n        if best_closure is None:\n            # No feasible closure remains; break to avoid infinite loop\n            break\n        selected_set.update(set(best_closure) - selected_set)\n\n    # Final trim if over max_card (shouldn't happen due to checks) - keep highest-weight items\n    if len(selected_set) > max_card:\n        # score items by marginal contribution relative to selected (approx): weight + interactions with others\n        def item_score(i):\n            s = float(weights[i]) if i < len(weights) else 0.0\n            for j in selected_set:\n                if j == i:\n                    continue\n                s += interactions.get((i, j), 0.0)\n            return s\n        sorted_items = sorted(selected_set, key=item_score, reverse=True)\n        selected_set = set(sorted_items[:max_card])\n\n    result = {\n        \"selection\": {\n            \"variables\": sorted(int(x) for x in selected_set)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n\n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n\n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n\n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n\n    result_str = stdout_capture.getvalue()\n    return result_str\n\n```\n\nHere are the performance metrics of the program:\n\nCombined score to maximize: 0.40\nfeasible: True; selection_size: 10; raw_score: 122.55\n\n# Instructions\n\nMake sure that the changes you propose are consistent with each other. For example, if you refer to a new config variable somewhere, you should also propose a change to add that variable.\n\nNote that the changes you propose will be applied sequentially, so you should assume that the previous changes have already been applied when writing the SEARCH block.\n\n# Task\n\nSuggest a new idea to improve the performance of the code that is inspired by your expert knowledge of the considered subject.\nYour goal is to maximize the `combined_score` of the program.\nDescribe each change with a SEARCH/REPLACE block.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.\n"
            },
            {
              "role": "assistant",
              "content": "<NAME>\nlookahead_closure_greedy\n</NAME>\n\n<DESCRIPTION>\nImprove the greedy selection by (1) caching closures for each variable to avoid recomputation, and (2) adding a cheap one-step lookahead when evaluating candidate closures: for each candidate closure, simulate adding it and compute the best additional single closure that would be feasible next; include a discounted portion of that next-step gain into the candidate score. This helps the greedy choose moves that enable strong follow-up synergies (common in interaction-heavy SDS instances). Also refine tie-breaking to favor closures with better effective score and use cached closures consistently.\n</DESCRIPTION>\n\n<DIFF>\n<<<<<<< SEARCH\ndef solve_sds():\n    \"\"\"\n    Improved solver for the Synergistic Dependency Selection problem.\n\n    - Reads JSON from stdin with \"requirements\" and \"catalog\".\n    - Produces JSON to stdout with \"selection\": {\"variables\": [...] }.\n    - Uses a precedence-aware marginal-gain greedy algorithm that:\n        * when adding an item, also includes its required predecessors (closure),\n        * computes the marginal objective (weights + pairwise interactions),\n        * checks mutex/group/cardinality feasibility for the closure before adding.\n    \"\"\"\n    import re\n\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n\n    # Extract constraints\n    weights = list(requirements.get(\"weights\", []))\n    interactions_raw = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    min_card, max_card = (cardinality_bounds + [len(weights), len(weights)])[:2]\n    mutex = [tuple(m) for m in requirements.get(\"mutex\", [])]\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n\n    n = len(weights)\n\n    # Parse interactions into dict of tuple->float for quick lookup (undirected)\n    interactions = {}\n    for k, v in interactions_raw.items():\n        try:\n            if isinstance(k, str):\n                # allow \"u,v\" or \"u v\"\n                parts = re.split(r'\\s*,\\s*|\\s+', k.strip())\n                if len(parts) >= 2:\n                    u = int(parts[0]); w = int(parts[1])\n                else:\n                    continue\n            elif isinstance(k, (list, tuple)) and len(k) >= 2:\n                u = int(k[0]); w = int(k[1])\n            else:\n                continue\n            interactions[(u, w)] = float(v)\n            interactions[(w, u)] = float(v)\n        except Exception:\n            # skip malformed keys\n            continue\n\n    # Build precedence graph: if (p, j) then p is a prerequisite of j\n    preds = {i: set() for i in range(n)}\n    succs = {i: set() for i in range(n)}\n    for entry in precedence:\n        try:\n            a, b = entry\n            a = int(a); b = int(b)\n            preds[b].add(a)\n            succs[a].add(b)\n        except Exception:\n            continue\n\n    # Precompute ancestors (transitive closure of preds) using DFS/memoization\n    ancestor_cache = {}\n\n    def get_ancestors(i):\n        if i in ancestor_cache:\n            return ancestor_cache[i].copy()\n        res = set()\n        stack = [i]\n        while stack:\n            cur = stack.pop()\n            for p in preds.get(cur, []):\n                if p not in res:\n                    res.add(p)\n                    stack.append(p)\n        ancestor_cache[i] = res.copy()\n        return res\n\n    # Map variable -> group (assume at most one group membership; if multiple, first wins)\n    var_to_group = {}\n    for gname, vars_list in groups.items():\n        for v in vars_list:\n            try:\n                var_to_group[int(v)] = gname\n            except Exception:\n                pass\n\n    # Helper: check feasibility of adding a closure set given current selected_set\n    def feasible_closure(closure_set, selected_set):\n        # Cardinality\n        if len(selected_set) + len(closure_set - selected_set) > max_card:\n            return False\n        # Mutex: none of closure can conflict with each other or with selected_set\n        for a, b in mutex:\n            if a in closure_set and b in closure_set:\n                return False\n            if (a in closure_set and b in selected_set) or (b in closure_set and a in selected_set):\n                return False\n        # Group: ensure at most one per group overall\n        # Build per-group counts\n        group_counts = {}\n        for v in selected_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in closure_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: closure itself must include ancestors for each element\n        for v in closure_set:\n            if not get_ancestors(v).issubset(closure_set.union(selected_set)):\n                return False\n        return True\n\n    # Compute marginal gain of adding closure_set (items that will be newly included)\n    def marginal_gain(closure_set, selected_set):\n        new_items = set(closure_set) - set(selected_set)\n        gain = 0.0\n        for i in new_items:\n            if i < len(weights):\n                gain += float(weights[i])\n        # interactions among new items\n        new_list = list(new_items)\n        for i in range(len(new_list)):\n            for j in range(i + 1, len(new_list)):\n                gain += interactions.get((new_list[i], new_list[j]), 0.0)\n        # interactions between new items and already selected\n        for i in new_items:\n            for j in selected_set:\n                gain += interactions.get((i, j), 0.0)\n        return gain\n\n    # Greedy loop: at each step try to add an item (and its ancestors) with max marginal gain\n    selected_set = set()\n    # Keep iterating while we can still add and haven't reached max_card\n    improved = True\n    while len(selected_set) < max_card and improved:\n        improved = False\n        best_gain = float(\"-inf\")\n        best_closure = None\n        # Consider candidates not already selected\n        for i in range(n):\n            if i in selected_set:\n                continue\n            # closure includes i and its ancestors\n            closure = get_ancestors(i).union({i})\n            # Only consider closures that are feasible\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # Prefer closures that add more items when gain is equal (to help reach min_card)\n            if gain > best_gain or (abs(gain - best_gain) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_gain = gain\n                best_closure = closure\n        # If we found a positive-gain move, take it\n        if best_closure is not None and best_gain > -1e-12:\n            to_add = set(best_closure) - selected_set\n            if to_add:\n                selected_set.update(to_add)\n                improved = True\n        else:\n            # No non-negative gain move; stop greedy improvements\n            break\n\n    # If we still haven't met minimum cardinality, greedily add best feasible closures regardless of gain\n    while len(selected_set) < min_card:\n        best_gain = float(\"-inf\")\n        best_closure = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = get_ancestors(i).union({i})\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # choose closure that gives best gain (even if negative), tie-breaker favors larger closures\n            if gain > best_gain or (abs(gain - best_gain) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_gain = gain\n                best_closure = closure\n        if best_closure is None:\n            # No feasible closure remains; break to avoid infinite loop\n            break\n        selected_set.update(set(best_closure) - selected_set)\n\n    # Final trim if over max_card (shouldn't happen due to checks) - keep highest-weight items\n    if len(selected_set) > max_card:\n        # score items by marginal contribution relative to selected (approx): weight + interactions with others\n        def item_score(i):\n            s = float(weights[i]) if i < len(weights) else 0.0\n            for j in selected_set:\n                if j == i:\n                    continue\n                s += interactions.get((i, j), 0.0)\n            return s\n        sorted_items = sorted(selected_set, key=item_score, reverse=True)\n        selected_set = set(sorted_items[:max_card])\n\n    result = {\n        \"selection\": {\n            \"variables\": sorted(int(x) for x in selected_set)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n=======\ndef solve_sds():\n    \"\"\"\n    Improved solver for the Synergistic Dependency Selection problem.\n\n    - Reads JSON from stdin with \"requirements\" and \"catalog\".\n    - Produces JSON to stdout with \"selection\": {\"variables\": [...] }.\n    - Uses a precedence-aware marginal-gain greedy algorithm that:\n        * when adding an item, also includes its required predecessors (closure),\n        * computes the marginal objective (weights + pairwise interactions),\n        * checks mutex/group/cardinality feasibility for the closure before adding.\n    - Adds a lightweight one-step lookahead: when evaluating a candidate closure,\n      also consider the best single subsequent closure that would be feasible after\n      adding the candidate. A discounted portion of that subsequent gain is added\n      to the candidate score to prefer moves that enable strong follow-ups.\n    \"\"\"\n    import re\n\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n\n    # Extract constraints\n    weights = list(requirements.get(\"weights\", []))\n    interactions_raw = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    min_card, max_card = (cardinality_bounds + [len(weights), len(weights)])[:2]\n    mutex = [tuple(m) for m in requirements.get(\"mutex\", [])]\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n\n    n = len(weights)\n\n    # Parse interactions into dict of tuple->float for quick lookup (undirected)\n    interactions = {}\n    for k, v in interactions_raw.items():\n        try:\n            if isinstance(k, str):\n                # allow \"u,v\" or \"u v\"\n                parts = re.split(r'\\s*,\\s*|\\s+', k.strip())\n                if len(parts) >= 2:\n                    u = int(parts[0]); w = int(parts[1])\n                else:\n                    continue\n            elif isinstance(k, (list, tuple)) and len(k) >= 2:\n                u = int(k[0]); w = int(k[1])\n            else:\n                continue\n            interactions[(u, w)] = float(v)\n            interactions[(w, u)] = float(v)\n        except Exception:\n            # skip malformed keys\n            continue\n\n    # Build precedence graph: if (p, j) then p is a prerequisite of j\n    preds = {i: set() for i in range(n)}\n    succs = {i: set() for i in range(n)}\n    for entry in precedence:\n        try:\n            a, b = entry\n            a = int(a); b = int(b)\n            preds[b].add(a)\n            succs[a].add(b)\n        except Exception:\n            continue\n\n    # Precompute ancestors (transitive closure of preds) using DFS/memoization\n    ancestor_cache = {}\n\n    def get_ancestors(i):\n        if i in ancestor_cache:\n            return ancestor_cache[i].copy()\n        res = set()\n        stack = [i]\n        while stack:\n            cur = stack.pop()\n            for p in preds.get(cur, []):\n                if p not in res:\n                    res.add(p)\n                    stack.append(p)\n        ancestor_cache[i] = res.copy()\n        return res\n\n    # Precompute closures (ancestors + self) and cache them for fast reuse\n    closure_cache = {i: get_ancestors(i).union({i}) for i in range(n)}\n\n    # Map variable -> group (assume at most one group membership; if multiple, first wins)\n    var_to_group = {}\n    for gname, vars_list in groups.items():\n        for v in vars_list:\n            try:\n                var_to_group[int(v)] = gname\n            except Exception:\n                pass\n\n    # Helper: check feasibility of adding a closure set given current selected_set\n    def feasible_closure(closure_set, selected_set):\n        # Cardinality\n        if len(selected_set) + len(closure_set - selected_set) > max_card:\n            return False\n        # Mutex: none of closure can conflict with each other or with selected_set\n        for a, b in mutex:\n            if a in closure_set and b in closure_set:\n                return False\n            if (a in closure_set and b in selected_set) or (b in closure_set and a in selected_set):\n                return False\n        # Group: ensure at most one per group overall\n        # Build per-group counts\n        group_counts = {}\n        for v in selected_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in closure_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: closure itself must include ancestors for each element (or they are already selected)\n        for v in closure_set:\n            if not get_ancestors(v).issubset(closure_set.union(selected_set)):\n                return False\n        return True\n\n    # Compute marginal gain of adding closure_set (items that will be newly included)\n    def marginal_gain(closure_set, selected_set):\n        new_items = set(closure_set) - set(selected_set)\n        if not new_items:\n            return 0.0\n        gain = 0.0\n        for i in new_items:\n            if 0 <= i < len(weights):\n                gain += float(weights[i])\n        # interactions among new items\n        new_list = list(new_items)\n        for a in range(len(new_list)):\n            for b in range(a + 1, len(new_list)):\n                gain += interactions.get((new_list[a], new_list[b]), 0.0)\n        # interactions between new items and already selected\n        for i in new_items:\n            for j in selected_set:\n                gain += interactions.get((i, j), 0.0)\n        return gain\n\n    # Greedy loop: at each step try to add an item (and its ancestors) with max marginal gain\n    # Enhanced with small one-step lookahead: for each candidate closure consider the best\n    # subsequent single-closure gain and add a discounted fraction to the candidate score.\n    selected_set = set()\n    improved = True\n    LOOKAHEAD_DISCOUNT = 0.5  # weight of the best next-step gain when scoring current candidate\n    while len(selected_set) < max_card and improved:\n        improved = False\n        best_score = float(\"-inf\")\n        best_gain = float(\"-inf\")\n        best_closure = None\n        # Consider candidates not already selected\n        for i in range(n):\n            if i in selected_set:\n                continue\n            # closure includes i and its ancestors (cached)\n            closure = closure_cache.get(i, {i})\n            # Only consider closures that are feasible\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # quick capacity pruning: if closure would add more items than remaining slots, skip\n            if len(closure - selected_set) > (max_card - len(selected_set)):\n                continue\n            # Compute one-step lookahead: best feasible single closure after adding this closure\n            lookahead_best = 0.0\n            if len(selected_set) + len(closure - selected_set) < max_card:\n                # simulate new selected set\n                sim_selected = selected_set.union(closure)\n                # find best single candidate (could be more expensive, so limit exploration)\n                # We will search all but with a cheap break if we find strong positive gains.\n                for j in range(n):\n                    if j in sim_selected:\n                        continue\n                    closure_j = closure_cache.get(j, {j})\n                    if not feasible_closure(closure_j, sim_selected):\n                        continue\n                    gain_j = marginal_gain(closure_j, sim_selected)\n                    if gain_j > lookahead_best:\n                        lookahead_best = gain_j\n                        # small optimization: if it's very large, we can accept it\n                        if lookahead_best > abs(gain) * 2 + 1e-9:\n                            break\n            total_score = gain + LOOKAHEAD_DISCOUNT * max(0.0, lookahead_best)\n            # Prefer closures that add more items when scores equal (helps reach min_card)\n            if (total_score > best_score) or (abs(total_score - best_score) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_score = total_score\n                best_gain = gain\n                best_closure = closure\n        # If we found a non-negative-gain move, take it\n        if best_closure is not None and best_gain > -1e-12:\n            to_add = set(best_closure) - selected_set\n            if to_add:\n                selected_set.update(to_add)\n                improved = True\n        else:\n            # No non-negative gain move; stop greedy improvements\n            break\n\n    # If we still haven't met minimum cardinality, greedily add best feasible closures regardless of gain\n    # Use same closure cache and prefer closures that may enable good follow-ups.\n    while len(selected_set) < min_card:\n        best_score = float(\"-inf\")\n        best_gain = float(\"-inf\")\n        best_closure = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closure_cache.get(i, {i})\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # lookahead as before (but smaller budget)\n            lookahead_best = 0.0\n            if len(selected_set) + len(closure - selected_set) < max_card:\n                sim_selected = selected_set.union(closure)\n                for j in range(n):\n                    if j in sim_selected:\n                        continue\n                    closure_j = closure_cache.get(j, {j})\n                    if not feasible_closure(closure_j, sim_selected):\n                        continue\n                    gain_j = marginal_gain(closure_j, sim_selected)\n                    if gain_j > lookahead_best:\n                        lookahead_best = gain_j\n            total_score = gain + LOOKAHEAD_DISCOUNT * max(0.0, lookahead_best)\n            if (total_score > best_score) or (abs(total_score - best_score) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_score = total_score\n                best_gain = gain\n                best_closure = closure\n        if best_closure is None:\n            # No feasible closure remains; break to avoid infinite loop\n            break\n        selected_set.update(set(best_closure) - selected_set)\n\n    # Final trim if over max_card (shouldn't happen due to checks) - keep highest-weight items\n    if len(selected_set) > max_card:\n        # score items by marginal contribution relative to selected (approx): weight + interactions with others\n        def item_score(i):\n            s = float(weights[i]) if i < len(weights) else 0.0\n            for j in selected_set:\n                if j == i:\n                    continue\n                s += interactions.get((i, j), 0.0)\n            return s\n        sorted_items = sorted(selected_set, key=item_score, reverse=True)\n        selected_set = set(sorted_items[:max_card])\n\n    result = {\n        \"selection\": {\n            \"variables\": sorted(int(x) for x in selected_set)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n>>>>>>> REPLACE\n</DIFF>"
            }
          ],
          "model_name": "gpt-5-mini",
          "kwargs": {
            "temperature": 1.0,
            "max_output_tokens": 8192
          },
          "input_tokens": 6467,
          "output_tokens": 5746,
          "cost": 0.013108749999999999,
          "input_cost": 0.00161675,
          "output_cost": 0.011491999999999999,
          "thought": "",
          "model_posteriors": {
            "gpt-5-mini": 1.0
          }
        },
        "diff_summary": {
          "added": 52,
          "deleted": 0,
          "modified": 14
        },
        "embed_cost": 4.93e-05,
        "novelty_cost": 0.0,
        "stdout_log": "Evaluating program: sds_dataset_output/problem_0/gen_7/main.py\nSaving results to: sds_dataset_output/problem_0/gen_7/results\nRun 1/1 completed in 0.00 seconds\nCorrectness and error status saved to sds_dataset_output/problem_0/gen_7/results/correct.json\nMetrics saved to sds_dataset_output/problem_0/gen_7/results/metrics.json\nEvaluation and Validation completed successfully.\nMetrics:\n  combined_score: 0.3993475858389672\n  public:\n    feasible: True\n    selection_size: 10\n    raw_score: 122.54942718671678\n  private:\n    selection: [3, 4, 5, 6, 7, 9, 10, 11, 13, 14]\n    raw_score: 122.54942718671678\n    normalized_fitness: 0.3993475858389672\n  execution_time_mean: 0.0013125000000400178\n  execution_time_std: 0.0\n  num_valid_runs: 1\n  num_invalid_runs: 0\n  all_validation_errors: []\n",
        "stderr_log": "",
        "code_analysis_metrics": {
          "cyclomatic_complexity": 53,
          "average_cyclomatic_complexity": 26.5,
          "halstead_volume": 1939.0474735919279,
          "halstead_difficulty": 12.100840336134453,
          "halstead_effort": 23464.103882120806,
          "lines_of_code": 304,
          "logical_lines_of_code": 220,
          "comments": 47,
          "maintainability_index": -31.59631424958843,
          "max_nesting_depth": 7,
          "complexity_score": 1.0
        }
      },
      "in_archive": false
    },
    {
      "id": "972b85bc-56fa-48c1-9186-361443d36313",
      "code": "\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\nModular solver for Synergistic Dependency Selection (SDS).\nThe EVOLVE block contains the evolved solver implementation.\n\"\"\"\nimport json\nimport sys\n\ndef solve_sds():\n    import re\n    from collections import defaultdict, deque\n\n    # ---------- Parsing ----------\n    data = json.load(sys.stdin)\n    requirements = data.get(\"requirements\", {}) or {}\n    catalog = data.get(\"catalog\", {}) or {}\n\n    weights = list(requirements.get(\"weights\", []) or [])\n    raw_interactions = requirements.get(\"interactions\", {}) or {}\n    card_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)]) or [0, len(weights)]\n    min_card = int(card_bounds[0]) if len(card_bounds) > 0 else 0\n    max_card = int(card_bounds[1]) if len(card_bounds) > 1 else len(weights)\n    mutex_list = requirements.get(\"mutex\", []) or []\n    groups = requirements.get(\"groups\", {}) or {}\n    precedence = requirements.get(\"precedence\", []) or []\n\n    n = len(weights)\n\n    # ---------- Preprocessing ----------\n    # Build interaction adjacency: interactions[u][v] = value\n    interactions = defaultdict(dict)\n    def parse_interaction_key(k):\n        try:\n            if isinstance(k, str):\n                parts = re.split(r'\\s*,\\s*|\\s+', k.strip())\n                if len(parts) >= 2:\n                    return int(parts[0]), int(parts[1])\n            elif isinstance(k, (list, tuple)) and len(k) >= 2:\n                return int(k[0]), int(k[1])\n        except Exception:\n            return None\n        return None\n\n    for k, v in raw_interactions.items():\n        parsed = parse_interaction_key(k)\n        try:\n            val = float(v)\n        except Exception:\n            continue\n        if parsed is None:\n            continue\n        u, w = parsed\n        if 0 <= u < n and 0 <= w < n:\n            interactions[u][w] = interactions[u].get(w, 0.0) + val\n            interactions[w][u] = interactions[w].get(u, 0.0) + val\n\n    # Mutex map\n    mutex_map = defaultdict(set)\n    for pair in mutex_list:\n        try:\n            a, b = pair\n            a = int(a); b = int(b)\n            if 0 <= a < n and 0 <= b < n:\n                mutex_map[a].add(b); mutex_map[b].add(a)\n        except Exception:\n            continue\n\n    # Group map: variable -> group (first membership wins)\n    var_to_group = {}\n    for gname, vars_list in groups.items():\n        for v in vars_list:\n            try:\n                idx = int(v)\n                if 0 <= idx < n and idx not in var_to_group:\n                    var_to_group[idx] = str(gname)\n            except Exception:\n                continue\n\n    # Precedence graph\n    preds = defaultdict(set)\n    succs = defaultdict(set)\n    for entry in precedence:\n        try:\n            a, b = entry\n            a = int(a); b = int(b)\n            if 0 <= a < n and 0 <= b < n:\n                preds[b].add(a)\n                succs[a].add(b)\n        except Exception:\n            continue\n\n    # Compute transitive ancestors (closure of preds) using iterative DFS per node with memoization\n    ancestor_cache = {}\n    def compute_ancestors(i):\n        if i in ancestor_cache:\n            return ancestor_cache[i]\n        res = set()\n        stack = list(preds.get(i, []))\n        seen = set(stack)\n        while stack:\n            cur = stack.pop()\n            res.add(cur)\n            for p in preds.get(cur, ()):\n                if p not in seen:\n                    seen.add(p)\n                    stack.append(p)\n        ancestor_cache[i] = res\n        return res\n\n    closures = [None] * n\n    closure_sizes = [0] * n\n    closure_base_weight = [0.0] * n  # sum of weights in closure (may include out-of-range indices protection)\n    for i in range(n):\n        anc = compute_ancestors(i)\n        c = set(anc)\n        c.add(i)\n        closures[i] = c\n        closure_sizes[i] = len(c)\n        s = 0.0\n        for v in c:\n            if 0 <= v < len(weights):\n                try:\n                    s += float(weights[v])\n                except Exception:\n                    pass\n        closure_base_weight[i] = s\n\n    # Utility functions for interactions and scoring\n    def interaction(u, v):\n        return interactions.get(u, {}).get(v, 0.0)\n\n    def total_score(selected_set):\n        # Sum weights\n        s = 0.0\n        for i in selected_set:\n            if 0 <= i < len(weights):\n                try:\n                    s += float(weights[i])\n                except Exception:\n                    pass\n        # Pairwise interactions (each pair counted once)\n        sel_list = list(selected_set)\n        L = len(sel_list)\n        for a in range(L):\n            u = sel_list[a]\n            for b in range(a+1, L):\n                v = sel_list[b]\n                s += interaction(u, v)\n        return s\n\n    # Feasibility check for closure given a base selected_set\n    def feasible_closure(closure_set, selected_set):\n        # new items to add\n        new_items = closure_set - selected_set\n        # cardinality\n        if len(selected_set) + len(new_items) > max_card:\n            return False\n        # mutex: none of closure can conflict with selected or each other\n        for v in new_items:\n            for c in mutex_map.get(v, ()):\n                if c in selected_set or c in new_items:\n                    return False\n        # group counts\n        group_counts = {}\n        for v in selected_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in new_items:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # precedence: closure must provide ancestors for each of its elements or they already in selected_set\n        for v in closure_set:\n            for a in preds.get(v, ()):\n                if a not in closure_set and a not in selected_set:\n                    return False\n        return True\n\n    # Compute marginal_gain for adding closure to selected_set (exact)\n    def marginal_gain(closure_set, selected_set):\n        new_items = closure_set - selected_set\n        if not new_items:\n            return 0.0\n        gain = 0.0\n        for i in new_items:\n            if 0 <= i < len(weights):\n                try:\n                    gain += float(weights[i])\n                except Exception:\n                    pass\n        # interactions among new items\n        new_list = list(new_items)\n        L = len(new_list)\n        for a in range(L):\n            u = new_list[a]\n            for b in range(a+1, L):\n                v = new_list[b]\n                gain += interaction(u, v)\n        # interactions between new_items and selected_set\n        for u in new_items:\n            for v in selected_set:\n                gain += interaction(u, v)\n        return gain\n\n    # ---------- Greedy selection (closure-based) ----------\n    selected_set = set()\n    current_score = 0.0\n\n    LOOKAHEAD_DISCOUNT = 0.45  # a tuned discount factor\n\n    # Pre-rank candidates by a simple heuristic to limit expensive lookahead:\n    # heuristic = closure_base_weight + sum(max interaction with closure) approx\n    # We'll rank on-the-fly each iteration based on marginal_gain estimate without lookahead.\n    while len(selected_set) < max_card:\n        best_score = float(\"-inf\")\n        best_closure = None\n        best_gain = 0.0\n\n        # Evaluate all candidates but compute a cheap marginal first, then do lookahead for top-K\n        candidate_estimates = []\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closures[i]\n            # Quick capacity pruning\n            new_items = closure - selected_set\n            if len(selected_set) + len(new_items) > max_card:\n                continue\n            if not feasible_closure(closure, selected_set):\n                continue\n            # cheap marginal (weights sum + approx interactions with selected): use marginal_gain\n            mg = marginal_gain(closure, selected_set)\n            candidate_estimates.append((mg, i, closure))\n\n        if not candidate_estimates:\n            break\n\n        # Sort descending by mg and prefer larger closures when tie\n        candidate_estimates.sort(key=lambda x: (x[0], len(x[2] - selected_set)), reverse=True)\n\n        # Limit lookahead to top_k candidates to control cost\n        top_k = min(12, len(candidate_estimates))\n        for idx in range(top_k):\n            mg, i, closure = candidate_estimates[idx]\n            # compute lookahead: best single closure after simulating adding this closure\n            total_score_candidate = mg\n            # if there is still capacity for one more closure\n            if len(selected_set) + len(closure - selected_set) < max_card:\n                sim_selected = selected_set.union(closure)\n                best_follow = 0.0\n                # consider a smaller subset of candidates for follow-up (next best excluding those in sim_selected)\n                follow_k = min(10, n)\n                # follow-up list reuse candidate_estimates order: evaluate top follow_k that are not in sim_selected\n                fcount = 0\n                for mg2, j, closure_j in candidate_estimates:\n                    if j in sim_selected:\n                        continue\n                    if not feasible_closure(closure_j, sim_selected):\n                        continue\n                    g2 = marginal_gain(closure_j, sim_selected)\n                    if g2 > best_follow:\n                        best_follow = g2\n                    fcount += 1\n                    if fcount >= follow_k:\n                        break\n                if best_follow > 0:\n                    total_score_candidate += LOOKAHEAD_DISCOUNT * best_follow\n            # choose best by total_score_candidate, tie-breaker larger closure\n            if (total_score_candidate > best_score) or (abs(total_score_candidate - best_score) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_score = total_score_candidate\n                best_closure = closure\n                best_gain = mg\n\n        # Accept if non-negative gain (small negative tolerances avoided)\n        if best_closure is None:\n            break\n        if best_gain > -1e-12:\n            to_add = best_closure - selected_set\n            if to_add:\n                selected_set.update(to_add)\n                current_score = total_score(selected_set)\n                # continue greedy\n                continue\n            else:\n                # nothing new to add\n                break\n        else:\n            break\n\n    # If min_card not reached, add best feasible closures regardless of sign (prefer larger)\n    while len(selected_set) < min_card:\n        best_gain = float(\"-inf\")\n        best_closure = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closures[i]\n            if not feasible_closure(closure, selected_set):\n                continue\n            mg = marginal_gain(closure, selected_set)\n            if (mg > best_gain) or (abs(mg - best_gain) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_gain = mg\n                best_closure = closure\n        if best_closure is None:\n            break\n        selected_set.update(best_closure - selected_set)\n        current_score = total_score(selected_set)\n\n    # ---------- Local improvement: removable-item swaps ----------\n    # Identify removable items: selected items that have no selected successors (safe to remove alone)\n    # We'll attempt limited number of simulated swaps: remove up to need_slots removable items to add a new closure if net score improves.\n    improvement = True\n    max_local_iters = 200\n    iter_count = 0\n    while improvement and iter_count < max_local_iters:\n        improvement = False\n        iter_count += 1\n        # update removable set\n        removable = set()\n        for v in selected_set:\n            # if no successor in selected_set, it's removable\n            if not any((succ in selected_set) for succ in succs.get(v, ())):\n                removable.add(v)\n        # prepare list of candidate closures not already satisfied\n        candidates = []\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closures[i]\n            # compute new_items\n            new_items = closure - selected_set\n            if not new_items:\n                continue\n            candidates.append((i, closure, new_items))\n        # sort candidates by marginal_gain descending to try promising first\n        candidates.sort(key=lambda x: marginal_gain(x[1], selected_set), reverse=True)\n        # try top some candidates\n        tried = 0\n        for i, closure, new_items in candidates:\n            if tried >= 60:\n                break\n            tried += 1\n            slots_avail = max_card - len(selected_set)\n            need_slots = max(0, len(new_items) - slots_avail)\n            if need_slots == 0:\n                # can add directly if feasible\n                if feasible_closure(closure, selected_set):\n                    mg = marginal_gain(closure, selected_set)\n                    if mg > 1e-12:\n                        selected_set.update(closure - selected_set)\n                        current_score = total_score(selected_set)\n                        improvement = True\n                        break\n                continue\n            # need to remove need_slots items from removable to make room\n            if len(removable) < need_slots:\n                continue\n            # compute individual removal scores relative to current selected_set (loss if removed)\n            removal_scores = []\n            for r in removable:\n                # compute score contribution of r in current selected_set\n                # contribution = weight(r) + interactions(r, others in selected_set)\n                contrib = 0.0\n                if 0 <= r < len(weights):\n                    try:\n                        contrib += float(weights[r])\n                    except Exception:\n                        pass\n                for o in selected_set:\n                    if o == r:\n                        continue\n                    contrib += interaction(r, o)\n                removal_scores.append((contrib, r))\n            # choose candidates to remove with smallest contribution (min loss)\n            removal_scores.sort(key=lambda x: x[0])\n            # try a few small removal combinations (greedy pick lowest need_slots)\n            removals = set([x[1] for x in removal_scores[:need_slots]])\n            # Ensure none of removals are in closure (we don't want to remove items that the closure will re-add - though allowed, it's wasteful)\n            if removals & closure:\n                # prefer next best set that doesn't intersect closure if possible\n                alt = []\n                for cval, rv in removal_scores:\n                    if rv not in closure:\n                        alt.append(rv)\n                        if len(alt) >= need_slots:\n                            break\n                if len(alt) < need_slots:\n                    # can't find non-intersecting removals; skip this candidate\n                    continue\n                removals = set(alt[:need_slots])\n            # simulate new selected\n            sim_selected = set(selected_set) - removals\n            if not feasible_closure(closure, sim_selected):\n                continue\n            sim_after = sim_selected.union(closure)\n            # compute delta\n            sim_score = total_score(sim_after)\n            delta = sim_score - current_score\n            if delta > 1e-9:\n                # perform swap\n                selected_set = sim_after\n                current_score = sim_score\n                improvement = True\n                break\n        # continue loop until no improvements\n    # ---------- Final safety trim ----------\n    if len(selected_set) > max_card:\n        # keep top-scoring items by approximate contribution\n        def item_contribution(i, sel):\n            s = 0.0\n            if 0 <= i < len(weights):\n                try:\n                    s += float(weights[i])\n                except Exception:\n                    pass\n            for j in sel:\n                if j == i: continue\n                s += interaction(i, j)\n            return s\n        sorted_items = sorted(selected_set, key=lambda x: item_contribution(x, selected_set), reverse=True)\n        selected_set = set(sorted_items[:max_card])\n        current_score = total_score(selected_set)\n\n    # Ensure final feasibility: if constraints violated (very unlikely), fallback to greedy simple trim\n    def validate_and_fix(sel):\n        # fix group conflicts: keep highest contribution per group\n        sel = set(sel)\n        groups_rev = {}\n        for v in list(sel):\n            g = var_to_group.get(v)\n            if g is None: continue\n            groups_rev.setdefault(g, []).append(v)\n        for g, members in groups_rev.items():\n            if len(members) <= 1:\n                continue\n            # sort members by contribution and keep best\n            members.sort(key=lambda x: (weights[x] if 0<=x<len(weights) else 0.0) + sum(interaction(x,y) for y in sel if y!=x), reverse=True)\n            for rm in members[1:]:\n                sel.discard(rm)\n        # fix mutex conflicts by dropping the lower-contributing member\n        for a in range(n):\n            for b in mutex_map.get(a, ()):\n                if a < b and a in sel and b in sel:\n                    # drop the one with smaller contribution\n                    ca = (weights[a] if 0<=a<len(weights) else 0.0) + sum(interaction(a,y) for y in sel if y!=a)\n                    cb = (weights[b] if 0<=b<len(weights) else 0.0) + sum(interaction(b,y) for y in sel if y!=b)\n                    if ca >= cb:\n                        sel.discard(b)\n                    else:\n                        sel.discard(a)\n        # enforce precedence: if some selected lacks its ancestors, add ancestors if feasible, otherwise drop the descendant\n        changed = True\n        while changed:\n            changed = False\n            for v in list(sel):\n                for a in preds.get(v, ()):\n                    if a not in sel:\n                        # try to add ancestor if feasible\n                        if len(sel) < max_card and (a not in sel) and feasible_closure({a}, sel):\n                            sel.add(a)\n                            changed = True\n                        else:\n                            # cannot add ancestor: drop v\n                            sel.discard(v)\n                            changed = True\n                            break\n        # enforce cardinality <= max_card by dropping lowest contribution items\n        while len(sel) > max_card:\n            contribs = [( (weights[x] if 0<=x<len(weights) else 0.0) + sum(interaction(x,y) for y in sel if y!=x), x) for x in sel]\n            contribs.sort()\n            sel.discard(contribs[0][1])\n        return sel\n\n    selected_set = validate_and_fix(selected_set)\n\n    result = {\"selection\": {\"variables\": sorted(int(x) for x in selected_set)}}\n    print(json.dumps(result))\n\n\nif __name__ == \"__main__\":\n    solve_sds()\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n\n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n\n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n\n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n\n    result_str = stdout_capture.getvalue()\n    return result_str",
      "language": "python",
      "parent_id": "53281c24-286f-4d71-b488-5d83b2cc485d",
      "archive_inspiration_ids": [
        "41c4e403-070f-4e25-9757-64fb47df1aa9",
        "4387bfa1-ee61-4891-a6ab-39fef27cf870",
        "639d15e8-d1f9-4fa7-b731-6db3bcbdb880"
      ],
      "top_k_inspiration_ids": [],
      "island_idx": 0,
      "generation": 8,
      "timestamp": 1764668469.261725,
      "code_diff": "--- a/original.py\n+++ b/original.py\n@@ -1,304 +1,527 @@\n \"\"\"\n Initial solution for Synergistic Dependency Selection (SDS) problem.\n The code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n \"\"\"\n \n import json\n import sys\n import contextlib\n \n # EVOLVE-BLOCK-START\n+Modular solver for Synergistic Dependency Selection (SDS).\n+The EVOLVE block contains the evolved solver implementation.\n+\"\"\"\n+import json\n+import sys\n+\n def solve_sds():\n-    \"\"\"\n-    Improved solver for the Synergistic Dependency Selection problem.\n-\n-    - Reads JSON from stdin with \"requirements\" and \"catalog\".\n-    - Produces JSON to stdout with \"selection\": {\"variables\": [...] }.\n-    - Uses a precedence-aware marginal-gain greedy algorithm that:\n-        * when adding an item, also includes its required predecessors (closure),\n-        * computes the marginal objective (weights + pairwise interactions),\n-        * checks mutex/group/cardinality feasibility for the closure before adding.\n-    - Adds a lightweight one-step lookahead: when evaluating a candidate closure,\n-      also consider the best single subsequent closure that would be feasible after\n-      adding the candidate. A discounted portion of that subsequent gain is added\n-      to the candidate score to prefer moves that enable strong follow-ups.\n-    \"\"\"\n     import re\n-\n-    # Read input\n-    input_data = json.load(sys.stdin)\n-    requirements = input_data.get(\"requirements\", {})\n-    catalog = input_data.get(\"catalog\", {})\n-\n-    # Extract constraints\n-    weights = list(requirements.get(\"weights\", []))\n-    interactions_raw = requirements.get(\"interactions\", {})\n-    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n-    min_card, max_card = (cardinality_bounds + [len(weights), len(weights)])[:2]\n-    mutex = [tuple(m) for m in requirements.get(\"mutex\", [])]\n-    groups = requirements.get(\"groups\", {})\n-    precedence = requirements.get(\"precedence\", [])\n+    from collections import defaultdict, deque\n+\n+    # ---------- Parsing ----------\n+    data = json.load(sys.stdin)\n+    requirements = data.get(\"requirements\", {}) or {}\n+    catalog = data.get(\"catalog\", {}) or {}\n+\n+    weights = list(requirements.get(\"weights\", []) or [])\n+    raw_interactions = requirements.get(\"interactions\", {}) or {}\n+    card_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)]) or [0, len(weights)]\n+    min_card = int(card_bounds[0]) if len(card_bounds) > 0 else 0\n+    max_card = int(card_bounds[1]) if len(card_bounds) > 1 else len(weights)\n+    mutex_list = requirements.get(\"mutex\", []) or []\n+    groups = requirements.get(\"groups\", {}) or {}\n+    precedence = requirements.get(\"precedence\", []) or []\n \n     n = len(weights)\n \n-    # Parse interactions into dict of tuple->float for quick lookup (undirected)\n-    interactions = {}\n-    for k, v in interactions_raw.items():\n+    # ---------- Preprocessing ----------\n+    # Build interaction adjacency: interactions[u][v] = value\n+    interactions = defaultdict(dict)\n+    def parse_interaction_key(k):\n         try:\n             if isinstance(k, str):\n-                # allow \"u,v\" or \"u v\"\n                 parts = re.split(r'\\s*,\\s*|\\s+', k.strip())\n                 if len(parts) >= 2:\n-                    u = int(parts[0]); w = int(parts[1])\n-                else:\n-                    continue\n+                    return int(parts[0]), int(parts[1])\n             elif isinstance(k, (list, tuple)) and len(k) >= 2:\n-                u = int(k[0]); w = int(k[1])\n-            else:\n-                continue\n-            interactions[(u, w)] = float(v)\n-            interactions[(w, u)] = float(v)\n+                return int(k[0]), int(k[1])\n         except Exception:\n-            # skip malformed keys\n+            return None\n+        return None\n+\n+    for k, v in raw_interactions.items():\n+        parsed = parse_interaction_key(k)\n+        try:\n+            val = float(v)\n+        except Exception:\n             continue\n-\n-    # Build precedence graph: if (p, j) then p is a prerequisite of j\n-    preds = {i: set() for i in range(n)}\n-    succs = {i: set() for i in range(n)}\n+        if parsed is None:\n+            continue\n+        u, w = parsed\n+        if 0 <= u < n and 0 <= w < n:\n+            interactions[u][w] = interactions[u].get(w, 0.0) + val\n+            interactions[w][u] = interactions[w].get(u, 0.0) + val\n+\n+    # Mutex map\n+    mutex_map = defaultdict(set)\n+    for pair in mutex_list:\n+        try:\n+            a, b = pair\n+            a = int(a); b = int(b)\n+            if 0 <= a < n and 0 <= b < n:\n+                mutex_map[a].add(b); mutex_map[b].add(a)\n+        except Exception:\n+            continue\n+\n+    # Group map: variable -> group (first membership wins)\n+    var_to_group = {}\n+    for gname, vars_list in groups.items():\n+        for v in vars_list:\n+            try:\n+                idx = int(v)\n+                if 0 <= idx < n and idx not in var_to_group:\n+                    var_to_group[idx] = str(gname)\n+            except Exception:\n+                continue\n+\n+    # Precedence graph\n+    preds = defaultdict(set)\n+    succs = defaultdict(set)\n     for entry in precedence:\n         try:\n             a, b = entry\n             a = int(a); b = int(b)\n-            preds[b].add(a)\n-            succs[a].add(b)\n+            if 0 <= a < n and 0 <= b < n:\n+                preds[b].add(a)\n+                succs[a].add(b)\n         except Exception:\n             continue\n \n-    # Precompute ancestors (transitive closure of preds) using DFS/memoization\n+    # Compute transitive ancestors (closure of preds) using iterative DFS per node with memoization\n     ancestor_cache = {}\n-\n-    def get_ancestors(i):\n+    def compute_ancestors(i):\n         if i in ancestor_cache:\n-            return ancestor_cache[i].copy()\n+            return ancestor_cache[i]\n         res = set()\n-        stack = [i]\n+        stack = list(preds.get(i, []))\n+        seen = set(stack)\n         while stack:\n             cur = stack.pop()\n-            for p in preds.get(cur, []):\n-                if p not in res:\n-                    res.add(p)\n+            res.add(cur)\n+            for p in preds.get(cur, ()):\n+                if p not in seen:\n+                    seen.add(p)\n                     stack.append(p)\n-        ancestor_cache[i] = res.copy()\n+        ancestor_cache[i] = res\n         return res\n \n-    # Precompute closures (ancestors + self) and cache them for fast reuse\n-    closure_cache = {i: get_ancestors(i).union({i}) for i in range(n)}\n-\n-    # Map variable -> group (assume at most one group membership; if multiple, first wins)\n-    var_to_group = {}\n-    for gname, vars_list in groups.items():\n-        for v in vars_list:\n-            try:\n-                var_to_group[int(v)] = gname\n-            except Exception:\n-                pass\n-\n-    # Helper: check feasibility of adding a closure set given current selected_set\n+    closures = [None] * n\n+    closure_sizes = [0] * n\n+    closure_base_weight = [0.0] * n  # sum of weights in closure (may include out-of-range indices protection)\n+    for i in range(n):\n+        anc = compute_ancestors(i)\n+        c = set(anc)\n+        c.add(i)\n+        closures[i] = c\n+        closure_sizes[i] = len(c)\n+        s = 0.0\n+        for v in c:\n+            if 0 <= v < len(weights):\n+                try:\n+                    s += float(weights[v])\n+                except Exception:\n+                    pass\n+        closure_base_weight[i] = s\n+\n+    # Utility functions for interactions and scoring\n+    def interaction(u, v):\n+        return interactions.get(u, {}).get(v, 0.0)\n+\n+    def total_score(selected_set):\n+        # Sum weights\n+        s = 0.0\n+        for i in selected_set:\n+            if 0 <= i < len(weights):\n+                try:\n+                    s += float(weights[i])\n+                except Exception:\n+                    pass\n+        # Pairwise interactions (each pair counted once)\n+        sel_list = list(selected_set)\n+        L = len(sel_list)\n+        for a in range(L):\n+            u = sel_list[a]\n+            for b in range(a+1, L):\n+                v = sel_list[b]\n+                s += interaction(u, v)\n+        return s\n+\n+    # Feasibility check for closure given a base selected_set\n     def feasible_closure(closure_set, selected_set):\n-        # Cardinality\n-        if len(selected_set) + len(closure_set - selected_set) > max_card:\n+        # new items to add\n+        new_items = closure_set - selected_set\n+        # cardinality\n+        if len(selected_set) + len(new_items) > max_card:\n             return False\n-        # Mutex: none of closure can conflict with each other or with selected_set\n-        for a, b in mutex:\n-            if a in closure_set and b in closure_set:\n-                return False\n-            if (a in closure_set and b in selected_set) or (b in closure_set and a in selected_set):\n-                return False\n-        # Group: ensure at most one per group overall\n-        # Build per-group counts\n+        # mutex: none of closure can conflict with selected or each other\n+        for v in new_items:\n+            for c in mutex_map.get(v, ()):\n+                if c in selected_set or c in new_items:\n+                    return False\n+        # group counts\n         group_counts = {}\n         for v in selected_set:\n             g = var_to_group.get(v)\n             if g is not None:\n                 group_counts[g] = group_counts.get(g, 0) + 1\n-        for v in closure_set:\n+        for v in new_items:\n             g = var_to_group.get(v)\n             if g is not None:\n                 group_counts[g] = group_counts.get(g, 0) + 1\n                 if group_counts[g] > 1:\n                     return False\n-        # Precedence: closure itself must include ancestors for each element (or they are already selected)\n+        # precedence: closure must provide ancestors for each of its elements or they already in selected_set\n         for v in closure_set:\n-            if not get_ancestors(v).issubset(closure_set.union(selected_set)):\n-                return False\n+            for a in preds.get(v, ()):\n+                if a not in closure_set and a not in selected_set:\n+                    return False\n         return True\n \n-    # Compute marginal gain of adding closure_set (items that will be newly included)\n+    # Compute marginal_gain for adding closure to selected_set (exact)\n     def marginal_gain(closure_set, selected_set):\n-        new_items = set(closure_set) - set(selected_set)\n+        new_items = closure_set - selected_set\n         if not new_items:\n             return 0.0\n         gain = 0.0\n         for i in new_items:\n             if 0 <= i < len(weights):\n-                gain += float(weights[i])\n+                try:\n+                    gain += float(weights[i])\n+                except Exception:\n+                    pass\n         # interactions among new items\n         new_list = list(new_items)\n-        for a in range(len(new_list)):\n-            for b in range(a + 1, len(new_list)):\n-                gain += interactions.get((new_list[a], new_list[b]), 0.0)\n-        # interactions between new items and already selected\n-        for i in new_items:\n-            for j in selected_set:\n-                gain += interactions.get((i, j), 0.0)\n+        L = len(new_list)\n+        for a in range(L):\n+            u = new_list[a]\n+            for b in range(a+1, L):\n+                v = new_list[b]\n+                gain += interaction(u, v)\n+        # interactions between new_items and selected_set\n+        for u in new_items:\n+            for v in selected_set:\n+                gain += interaction(u, v)\n         return gain\n \n-    # Greedy loop: at each step try to add an item (and its ancestors) with max marginal gain\n-    # Enhanced with small one-step lookahead: for each candidate closure consider the best\n-    # subsequent single-closure gain and add a discounted fraction to the candidate score.\n+    # ---------- Greedy selection (closure-based) ----------\n     selected_set = set()\n-    improved = True\n-    LOOKAHEAD_DISCOUNT = 0.5  # weight of the best next-step gain when scoring current candidate\n-    while len(selected_set) < max_card and improved:\n-        improved = False\n+    current_score = 0.0\n+\n+    LOOKAHEAD_DISCOUNT = 0.45  # a tuned discount factor\n+\n+    # Pre-rank candidates by a simple heuristic to limit expensive lookahead:\n+    # heuristic = closure_base_weight + sum(max interaction with closure) approx\n+    # We'll rank on-the-fly each iteration based on marginal_gain estimate without lookahead.\n+    while len(selected_set) < max_card:\n         best_score = float(\"-inf\")\n-        best_gain = float(\"-inf\")\n         best_closure = None\n-        # Consider candidates not already selected\n+        best_gain = 0.0\n+\n+        # Evaluate all candidates but compute a cheap marginal first, then do lookahead for top-K\n+        candidate_estimates = []\n         for i in range(n):\n             if i in selected_set:\n                 continue\n-            # closure includes i and its ancestors (cached)\n-            closure = closure_cache.get(i, {i})\n-            # Only consider closures that are feasible\n+            closure = closures[i]\n+            # Quick capacity pruning\n+            new_items = closure - selected_set\n+            if len(selected_set) + len(new_items) > max_card:\n+                continue\n             if not feasible_closure(closure, selected_set):\n                 continue\n-            gain = marginal_gain(closure, selected_set)\n-            # quick capacity pruning: if closure would add more items than remaining slots, skip\n-            if len(closure - selected_set) > (max_card - len(selected_set)):\n-                continue\n-            # Compute one-step lookahead: best feasible single closure after adding this closure\n-            lookahead_best = 0.0\n+            # cheap marginal (weights sum + approx interactions with selected): use marginal_gain\n+            mg = marginal_gain(closure, selected_set)\n+            candidate_estimates.append((mg, i, closure))\n+\n+        if not candidate_estimates:\n+            break\n+\n+        # Sort descending by mg and prefer larger closures when tie\n+        candidate_estimates.sort(key=lambda x: (x[0], len(x[2] - selected_set)), reverse=True)\n+\n+        # Limit lookahead to top_k candidates to control cost\n+        top_k = min(12, len(candidate_estimates))\n+        for idx in range(top_k):\n+            mg, i, closure = candidate_estimates[idx]\n+            # compute lookahead: best single closure after simulating adding this closure\n+            total_score_candidate = mg\n+            # if there is still capacity for one more closure\n             if len(selected_set) + len(closure - selected_set) < max_card:\n-                # simulate new selected set\n                 sim_selected = selected_set.union(closure)\n-                # find best single candidate (could be more expensive, so limit exploration)\n-                # We will search all but with a cheap break if we find strong positive gains.\n-                for j in range(n):\n+                best_follow = 0.0\n+                # consider a smaller subset of candidates for follow-up (next best excluding those in sim_selected)\n+                follow_k = min(10, n)\n+                # follow-up list reuse candidate_estimates order: evaluate top follow_k that are not in sim_selected\n+                fcount = 0\n+                for mg2, j, closure_j in candidate_estimates:\n                     if j in sim_selected:\n                         continue\n-                    closure_j = closure_cache.get(j, {j})\n                     if not feasible_closure(closure_j, sim_selected):\n                         continue\n-                    gain_j = marginal_gain(closure_j, sim_selected)\n-                    if gain_j > lookahead_best:\n-                        lookahead_best = gain_j\n-                        # small optimization: if it's very large, we can accept it\n-                        if lookahead_best > abs(gain) * 2 + 1e-9:\n-                            break\n-            total_score = gain + LOOKAHEAD_DISCOUNT * max(0.0, lookahead_best)\n-            # Prefer closures that add more items when scores equal (helps reach min_card)\n-            if (total_score > best_score) or (abs(total_score - best_score) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n-                best_score = total_score\n-                best_gain = gain\n+                    g2 = marginal_gain(closure_j, sim_selected)\n+                    if g2 > best_follow:\n+                        best_follow = g2\n+                    fcount += 1\n+                    if fcount >= follow_k:\n+                        break\n+                if best_follow > 0:\n+                    total_score_candidate += LOOKAHEAD_DISCOUNT * best_follow\n+            # choose best by total_score_candidate, tie-breaker larger closure\n+            if (total_score_candidate > best_score) or (abs(total_score_candidate - best_score) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n+                best_score = total_score_candidate\n                 best_closure = closure\n-        # If we found a non-negative-gain move, take it\n-        if best_closure is not None and best_gain > -1e-12:\n-            to_add = set(best_closure) - selected_set\n+                best_gain = mg\n+\n+        # Accept if non-negative gain (small negative tolerances avoided)\n+        if best_closure is None:\n+            break\n+        if best_gain > -1e-12:\n+            to_add = best_closure - selected_set\n             if to_add:\n                 selected_set.update(to_add)\n-                improved = True\n+                current_score = total_score(selected_set)\n+                # continue greedy\n+                continue\n+            else:\n+                # nothing new to add\n+                break\n         else:\n-            # No non-negative gain move; stop greedy improvements\n             break\n \n-    # If we still haven't met minimum cardinality, greedily add best feasible closures regardless of gain\n-    # Use same closure cache and prefer closures that may enable good follow-ups.\n+    # If min_card not reached, add best feasible closures regardless of sign (prefer larger)\n     while len(selected_set) < min_card:\n-        best_score = float(\"-inf\")\n         best_gain = float(\"-inf\")\n         best_closure = None\n         for i in range(n):\n             if i in selected_set:\n                 continue\n-            closure = closure_cache.get(i, {i})\n+            closure = closures[i]\n             if not feasible_closure(closure, selected_set):\n                 continue\n-            gain = marginal_gain(closure, selected_set)\n-            # lookahead as before (but smaller budget)\n-            lookahead_best = 0.0\n-            if len(selected_set) + len(closure - selected_set) < max_card:\n-                sim_selected = selected_set.union(closure)\n-                for j in range(n):\n-                    if j in sim_selected:\n-                        continue\n-                    closure_j = closure_cache.get(j, {j})\n-                    if not feasible_closure(closure_j, sim_selected):\n-                        continue\n-                    gain_j = marginal_gain(closure_j, sim_selected)\n-                    if gain_j > lookahead_best:\n-                        lookahead_best = gain_j\n-            total_score = gain + LOOKAHEAD_DISCOUNT * max(0.0, lookahead_best)\n-            if (total_score > best_score) or (abs(total_score - best_score) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n-                best_score = total_score\n-                best_gain = gain\n+            mg = marginal_gain(closure, selected_set)\n+            if (mg > best_gain) or (abs(mg - best_gain) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n+                best_gain = mg\n                 best_closure = closure\n         if best_closure is None:\n-            # No feasible closure remains; break to avoid infinite loop\n             break\n-        selected_set.update(set(best_closure) - selected_set)\n-\n-    # Final trim if over max_card (shouldn't happen due to checks) - keep highest-weight items\n+        selected_set.update(best_closure - selected_set)\n+        current_score = total_score(selected_set)\n+\n+    # ---------- Local improvement: removable-item swaps ----------\n+    # Identify removable items: selected items that have no selected successors (safe to remove alone)\n+    # We'll attempt limited number of simulated swaps: remove up to need_slots removable items to add a new closure if net score improves.\n+    improvement = True\n+    max_local_iters = 200\n+    iter_count = 0\n+    while improvement and iter_count < max_local_iters:\n+        improvement = False\n+        iter_count += 1\n+        # update removable set\n+        removable = set()\n+        for v in selected_set:\n+            # if no successor in selected_set, it's removable\n+            if not any((succ in selected_set) for succ in succs.get(v, ())):\n+                removable.add(v)\n+        # prepare list of candidate closures not already satisfied\n+        candidates = []\n+        for i in range(n):\n+            if i in selected_set:\n+                continue\n+            closure = closures[i]\n+            # compute new_items\n+            new_items = closure - selected_set\n+            if not new_items:\n+                continue\n+            candidates.append((i, closure, new_items))\n+        # sort candidates by marginal_gain descending to try promising first\n+        candidates.sort(key=lambda x: marginal_gain(x[1], selected_set), reverse=True)\n+        # try top some candidates\n+        tried = 0\n+        for i, closure, new_items in candidates:\n+            if tried >= 60:\n+                break\n+            tried += 1\n+            slots_avail = max_card - len(selected_set)\n+            need_slots = max(0, len(new_items) - slots_avail)\n+            if need_slots == 0:\n+                # can add directly if feasible\n+                if feasible_closure(closure, selected_set):\n+                    mg = marginal_gain(closure, selected_set)\n+                    if mg > 1e-12:\n+                        selected_set.update(closure - selected_set)\n+                        current_score = total_score(selected_set)\n+                        improvement = True\n+                        break\n+                continue\n+            # need to remove need_slots items from removable to make room\n+            if len(removable) < need_slots:\n+                continue\n+            # compute individual removal scores relative to current selected_set (loss if removed)\n+            removal_scores = []\n+            for r in removable:\n+                # compute score contribution of r in current selected_set\n+                # contribution = weight(r) + interactions(r, others in selected_set)\n+                contrib = 0.0\n+                if 0 <= r < len(weights):\n+                    try:\n+                        contrib += float(weights[r])\n+                    except Exception:\n+                        pass\n+                for o in selected_set:\n+                    if o == r:\n+                        continue\n+                    contrib += interaction(r, o)\n+                removal_scores.append((contrib, r))\n+            # choose candidates to remove with smallest contribution (min loss)\n+            removal_scores.sort(key=lambda x: x[0])\n+            # try a few small removal combinations (greedy pick lowest need_slots)\n+            removals = set([x[1] for x in removal_scores[:need_slots]])\n+            # Ensure none of removals are in closure (we don't want to remove items that the closure will re-add - though allowed, it's wasteful)\n+            if removals & closure:\n+                # prefer next best set that doesn't intersect closure if possible\n+                alt = []\n+                for cval, rv in removal_scores:\n+                    if rv not in closure:\n+                        alt.append(rv)\n+                        if len(alt) >= need_slots:\n+                            break\n+                if len(alt) < need_slots:\n+                    # can't find non-intersecting removals; skip this candidate\n+                    continue\n+                removals = set(alt[:need_slots])\n+            # simulate new selected\n+            sim_selected = set(selected_set) - removals\n+            if not feasible_closure(closure, sim_selected):\n+                continue\n+            sim_after = sim_selected.union(closure)\n+            # compute delta\n+            sim_score = total_score(sim_after)\n+            delta = sim_score - current_score\n+            if delta > 1e-9:\n+                # perform swap\n+                selected_set = sim_after\n+                current_score = sim_score\n+                improvement = True\n+                break\n+        # continue loop until no improvements\n+    # ---------- Final safety trim ----------\n     if len(selected_set) > max_card:\n-        # score items by marginal contribution relative to selected (approx): weight + interactions with others\n-        def item_score(i):\n-            s = float(weights[i]) if i < len(weights) else 0.0\n-            for j in selected_set:\n-                if j == i:\n-                    continue\n-                s += interactions.get((i, j), 0.0)\n+        # keep top-scoring items by approximate contribution\n+        def item_contribution(i, sel):\n+            s = 0.0\n+            if 0 <= i < len(weights):\n+                try:\n+                    s += float(weights[i])\n+                except Exception:\n+                    pass\n+            for j in sel:\n+                if j == i: continue\n+                s += interaction(i, j)\n             return s\n-        sorted_items = sorted(selected_set, key=item_score, reverse=True)\n+        sorted_items = sorted(selected_set, key=lambda x: item_contribution(x, selected_set), reverse=True)\n         selected_set = set(sorted_items[:max_card])\n-\n-    result = {\n-        \"selection\": {\n-            \"variables\": sorted(int(x) for x in selected_set)\n-        }\n-    }\n+        current_score = total_score(selected_set)\n+\n+    # Ensure final feasibility: if constraints violated (very unlikely), fallback to greedy simple trim\n+    def validate_and_fix(sel):\n+        # fix group conflicts: keep highest contribution per group\n+        sel = set(sel)\n+        groups_rev = {}\n+        for v in list(sel):\n+            g = var_to_group.get(v)\n+            if g is None: continue\n+            groups_rev.setdefault(g, []).append(v)\n+        for g, members in groups_rev.items():\n+            if len(members) <= 1:\n+                continue\n+            # sort members by contribution and keep best\n+            members.sort(key=lambda x: (weights[x] if 0<=x<len(weights) else 0.0) + sum(interaction(x,y) for y in sel if y!=x), reverse=True)\n+            for rm in members[1:]:\n+                sel.discard(rm)\n+        # fix mutex conflicts by dropping the lower-contributing member\n+        for a in range(n):\n+            for b in mutex_map.get(a, ()):\n+                if a < b and a in sel and b in sel:\n+                    # drop the one with smaller contribution\n+                    ca = (weights[a] if 0<=a<len(weights) else 0.0) + sum(interaction(a,y) for y in sel if y!=a)\n+                    cb = (weights[b] if 0<=b<len(weights) else 0.0) + sum(interaction(b,y) for y in sel if y!=b)\n+                    if ca >= cb:\n+                        sel.discard(b)\n+                    else:\n+                        sel.discard(a)\n+        # enforce precedence: if some selected lacks its ancestors, add ancestors if feasible, otherwise drop the descendant\n+        changed = True\n+        while changed:\n+            changed = False\n+            for v in list(sel):\n+                for a in preds.get(v, ()):\n+                    if a not in sel:\n+                        # try to add ancestor if feasible\n+                        if len(sel) < max_card and (a not in sel) and feasible_closure({a}, sel):\n+                            sel.add(a)\n+                            changed = True\n+                        else:\n+                            # cannot add ancestor: drop v\n+                            sel.discard(v)\n+                            changed = True\n+                            break\n+        # enforce cardinality <= max_card by dropping lowest contribution items\n+        while len(sel) > max_card:\n+            contribs = [( (weights[x] if 0<=x<len(weights) else 0.0) + sum(interaction(x,y) for y in sel if y!=x), x) for x in sel]\n+            contribs.sort()\n+            sel.discard(contribs[0][1])\n+        return sel\n+\n+    selected_set = validate_and_fix(selected_set)\n+\n+    result = {\"selection\": {\"variables\": sorted(int(x) for x in selected_set)}}\n     print(json.dumps(result))\n+\n+\n+if __name__ == \"__main__\":\n+    solve_sds()\n # EVOLVE-BLOCK-END\n \n \n # This part remains fixed (not evolved)\n def run_sds(problem_data=None):\n     \"\"\"\n     Main function called by the evaluator.\n     Can accept problem_data as parameter or read from stdin.\n     Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n     \"\"\"\n     import sys\n     import json\n     import io\n \n     if problem_data is None:\n         # Read from stdin (for compatibility)\n         input_data = json.load(sys.stdin)\n     else:\n         # Use provided problem data\n         input_data = problem_data\n \n     # Capture stdout from solve_sds\n     stdout_capture = io.StringIO()\n     old_stdin = sys.stdin\n \n     try:\n         # Create mock stdin\n         sys.stdin = io.StringIO(json.dumps(input_data))\n         with contextlib.redirect_stdout(stdout_capture):\n             solve_sds()\n     finally:\n         sys.stdin = old_stdin\n \n     result_str = stdout_capture.getvalue()\n     return result_str",
      "combined_score": 0.0,
      "public_metrics": {},
      "private_metrics": {},
      "text_feedback": "",
      "correct": false,
      "children_count": 0,
      "complexity": 0.93,
      "embedding": [
        0.041210406,
        0.0023007786,
        0.038957138,
        -0.011768585,
        -0.0053549097,
        0.027012091,
        0.028722405,
        -0.013024172,
        -0.021541804,
        0.038251292,
        0.059670933,
        -0.074385054,
        -0.017659664,
        0.015338524,
        0.047563,
        0.000268509,
        0.04416952,
        -0.01195862,
        -0.011924685,
        0.0033306994,
        0.042513505,
        0.01632942,
        0.067869574,
        0.029998353,
        0.027704362,
        -0.00894521,
        0.027324291,
        0.04357227,
        0.041074667,
        -0.031735815,
        0.05869361,
        0.0046320986,
        -0.032821726,
        -0.01615296,
        -0.038197,
        0.038739953,
        -0.0017883633,
        0.03578084,
        -0.05744481,
        0.008999506,
        0.013791098,
        -0.048594616,
        -0.025179613,
        0.026048344,
        -0.03214303,
        -0.000637974,
        0.0038006962,
        -0.0032713136,
        0.03580799,
        -0.015175638,
        -0.008660158,
        0.02866811,
        0.022451255,
        0.021256752,
        -0.006963419,
        -0.034830667,
        -0.03176296,
        0.026998518,
        0.00326283,
        -0.0014074454,
        0.037029643,
        -0.01958716,
        0.025573257,
        0.018732004,
        -0.012834137,
        -0.01079805,
        -0.024745248,
        0.037518304,
        -0.007038075,
        -0.012345476,
        -0.07476512,
        0.008924849,
        0.05559876,
        -0.02915677,
        -0.022491978,
        0.007988249,
        0.05242246,
        0.042214878,
        -0.0012165621,
        -0.030677048,
        -0.01336352,
        -0.012264033,
        0.022804178,
        -0.029645432,
        -0.04308361,
        -0.07688266,
        -0.024813117,
        0.009895384,
        -0.053888444,
        -0.05141799,
        -0.03518359,
        -0.006277936,
        -0.053969886,
        0.029048178,
        0.032360215,
        -0.015514986,
        0.028478075,
        -0.018189047,
        0.023767926,
        0.00057858817,
        0.017686812,
        -0.037735485,
        0.011191693,
        -0.03255025,
        0.03092138,
        0.011022019,
        0.029591136,
        0.0027843495,
        -0.0105537195,
        -0.010662311,
        -0.031980146,
        0.024378752,
        -0.017523926,
        0.018867742,
        0.02302136,
        -0.03977157,
        -0.036323797,
        -0.023387857,
        -0.018501246,
        -0.018745577,
        -0.018555542,
        -0.0030286799,
        -0.015175638,
        0.06482902,
        0.0055313706,
        0.03263169,
        0.023971535,
        -0.040694598,
        -0.029618284,
        0.018555542,
        0.02139249,
        0.016560176,
        0.03580799,
        -0.028885292,
        -0.048241697,
        -0.0013421209,
        -0.059236567,
        -0.01307168,
        -0.013444963,
        0.026984943,
        0.018161898,
        0.040694598,
        0.009956467,
        0.03857707,
        -0.034179118,
        0.004923938,
        -0.0026808484,
        0.0146598285,
        -0.08546137,
        0.031002823,
        0.03857707,
        -0.006152377,
        -0.0031983538,
        -0.0012920671,
        0.03906573,
        -0.073570624,
        -0.030622752,
        0.0431922,
        0.04427811,
        -0.0121147195,
        -0.0044318833,
        0.009841089,
        -0.032495953,
        -0.013139551,
        0.011639632,
        -0.020605203,
        -0.044441,
        0.017673237,
        -0.05220528,
        -0.010227946,
        0.00022757518,
        -0.052341018,
        7.873931e-06,
        -0.0053379424,
        0.00084115856,
        -0.02839663,
        0.008049332,
        -0.019369977,
        -0.010988085,
        -0.029401101,
        -0.050657853,
        -0.026781335,
        -0.040667452,
        -0.02828804,
        -0.03151863,
        -8.632162e-05,
        -0.010336537,
        -0.020998847,
        -0.024636656,
        -0.0025739537,
        -0.0026214623,
        0.008123988,
        0.027351439,
        0.016546603,
        0.026374118,
        0.0060539665,
        0.049979158,
        0.035617955,
        -0.017551072,
        0.027120683,
        0.0018172079,
        -0.024378752,
        0.02728357,
        -0.032333065,
        0.01414402,
        -0.049463347,
        -0.058747906,
        0.00513094,
        -0.004825527,
        -0.032685988,
        0.052558202,
        -0.024650231,
        0.0026808484,
        0.0312743,
        0.0064713643,
        0.012630529,
        -0.0044250963,
        0.011456384,
        0.0071670273,
        0.090076506,
        -0.024052978,
        0.022872047,
        0.032115884,
        -0.007662475,
        0.0071466663,
        0.039120026,
        -0.010689459,
        -0.03618806,
        -0.0022939916,
        -0.037355416,
        -0.0029217852,
        -0.0053277616,
        -0.028613813,
        0.008327597,
        -0.00769641,
        -0.0015270655,
        -0.016980968,
        -0.0055449447,
        0.01445622,
        0.0077982144,
        0.03029698,
        0.017768255,
        0.02170469,
        0.015162064,
        0.025939753,
        -0.0011919595,
        -0.0394458,
        -0.020700222,
        -0.013913264,
        0.015501412,
        0.039825868,
        -0.025356075,
        0.051363695,
        -0.018949186,
        -0.014374777,
        -0.020225134,
        0.0021497689,
        -0.025383221,
        -0.03844133,
        0.048866097,
        -0.07824005,
        -0.015039898,
        -0.009298132,
        -0.03344613,
        -0.041753363,
        -0.009338854,
        0.01532495,
        0.018175473,
        0.0017374612,
        -0.017483203,
        -0.0048017725,
        0.032088738,
        -0.06108262,
        -0.0012488002,
        -0.04593413,
        -0.01865056,
        -0.0007287496,
        0.04118326,
        -0.02416157,
        -0.035455067,
        -0.04940905,
        -0.0085990755,
        0.049517643,
        0.010112567,
        0.020917404,
        -0.0026978157,
        -0.019437848,
        0.016478734,
        -0.004513327,
        0.031871554,
        -0.0020055461,
        -0.03265884,
        0.034722075,
        -0.028613813,
        -0.017700385,
        -0.04294787,
        -0.004252029,
        0.023415005,
        -0.020252282,
        0.01220295,
        0.07997751,
        0.0073095537,
        -0.020048672,
        0.01833836,
        -0.028613813,
        0.005891079,
        0.041318998,
        0.02246483,
        0.029102474,
        0.024935283,
        -0.048105955,
        -0.010343323,
        -0.004778018,
        0.015895056,
        -0.03629665,
        -0.024052978,
        0.059127975,
        0.014374777,
        0.053345487,
        -0.054458547,
        -0.043110754,
        -0.0244059,
        0.032224476,
        -0.02759577,
        0.009080949,
        -0.017808978,
        -0.0026027984,
        -0.004109503,
        0.0058842925,
        -0.0146734025,
        0.008958784,
        -0.0036785312,
        0.019980803,
        0.02697137,
        -0.02201689,
        -0.04593413,
        -0.0005488952,
        0.002728357,
        0.010696245,
        0.018216195,
        -0.016967393,
        0.00652566,
        -0.011245989,
        -0.04490251,
        -0.013132763,
        0.0030897625,
        -0.011531041,
        0.051988095,
        0.049761973,
        -0.014239037,
        0.004095929,
        -0.021419639,
        -0.029754022,
        0.041861955,
        -0.01057408,
        -0.007879658,
        -0.023184247,
        -0.0061421967,
        -0.029102474,
        -0.007248471,
        0.014469794,
        -0.0035801202,
        0.0029217852,
        0.007594606,
        0.014157594,
        0.03179011,
        -0.025464665,
        0.03529218,
        0.010044698,
        -0.004923938,
        0.044766773,
        0.050603557,
        -0.016410863,
        0.022559848,
        -0.07671977,
        -0.01675021,
        -0.0042689964,
        0.033717606,
        0.012752693,
        0.048214547,
        0.013125977,
        0.018514821,
        -0.071018726,
        -0.02621123,
        0.010119354,
        0.036595277,
        -0.004995201,
        -0.011469958,
        -0.042649243,
        -0.03214303,
        0.03480352,
        -0.041644774,
        0.018528394,
        -0.0015686356,
        0.0253425,
        -0.0022278188,
        0.032251623,
        0.01746963,
        0.037518304,
        0.061897054,
        0.00047466287,
        0.018311212,
        -0.022709161,
        -0.03556366,
        -0.021921873,
        0.023591464,
        0.056413192,
        0.025749717,
        -0.0031220005,
        -0.013180272,
        0.057119038,
        -0.02038802,
        0.017374612,
        -0.0259669,
        0.027337866,
        -0.026618449,
        -0.020808812,
        0.02978117,
        0.024595935,
        0.07411358,
        -0.014157594,
        -0.04406093,
        0.02170469,
        -0.043870896,
        -0.01389969,
        0.022139056,
        0.01639729,
        -0.010662311,
        0.05171662,
        -0.0028963343,
        0.0072620446,
        0.060485367,
        0.061354097,
        0.01844695,
        -0.0043538334,
        0.03477637,
        0.037816927,
        0.039988756,
        -0.002514568,
        -0.0056162076,
        -0.0068208924,
        -0.013967559,
        0.0031423615,
        -0.000509446,
        -0.033744752,
        -0.011055954,
        0.029455397,
        -0.032685988,
        0.023700057,
        0.01989936,
        0.04816025,
        0.009610333,
        0.033989083,
        -0.00074147515,
        -0.01570502,
        -0.011449598,
        0.06558916,
        -0.0007542007,
        0.03515644,
        0.010390832,
        0.026591301,
        0.052883975,
        -0.01840623,
        0.011035593,
        -0.0009976828,
        0.017537499,
        0.034206267,
        0.018379081,
        -0.0197229,
        0.050277784,
        0.026998518,
        -0.023062082,
        -0.018039733,
        0.01989936,
        -0.013648572,
        -0.032468807,
        0.021365343,
        -0.0040857485,
        0.023672909,
        0.02741931,
        -0.017686812,
        -0.024175143,
        0.0034104462,
        0.03415197,
        0.05798777,
        0.041346148,
        0.004004305,
        -0.04745441,
        -0.018392656,
        0.012589807,
        0.040504564,
        0.016275125,
        0.016858803,
        -0.016057942,
        0.022790603,
        -0.01336352,
        0.014904159,
        0.030975675,
        -0.01615296,
        -0.016424438,
        0.032523103,
        -0.0043606204,
        -0.03352757,
        0.030704197,
        0.014822716,
        -0.0005548338,
        0.007757493,
        -0.012026489,
        0.0008916366,
        0.00037985755,
        -0.02953684,
        0.030459866,
        -0.024541639,
        0.031192858,
        0.041536182,
        0.002109047,
        -0.022206925,
        -0.03770834,
        -0.020062247,
        0.000823767,
        -0.010669097,
        -0.040667452,
        -0.01733389,
        0.009019867,
        0.008877341,
        -0.040667452,
        -0.0038549919,
        -0.07959744,
        -0.053372636,
        -0.0070177144,
        -0.0077167707,
        -0.007974675,
        -0.038712807,
        0.06960704,
        -0.036106616,
        0.005032529,
        -0.017523926,
        -0.023835795,
        -0.004167192,
        0.012501576,
        0.013994707,
        0.01095415,
        -9.978949e-05,
        -0.011449598,
        0.013465324,
        -0.002903121,
        0.033934787,
        0.009664628,
        0.005456714,
        -0.013730016,
        -0.009732497,
        -0.030731345,
        0.0076149665,
        -0.016628046,
        -0.029129623,
        0.020645926,
        -0.027310718,
        -0.004869642,
        -0.0004895093,
        -0.011022019,
        -0.011659994,
        -0.009047015,
        0.039500095,
        -0.007506375,
        -0.03165437,
        -0.018012585,
        0.037844077,
        0.049273312,
        -0.022763455,
        0.03567225,
        -0.00792038,
        -0.026170509,
        -0.0018579296,
        -0.05983382,
        0.04053171,
        0.007676049,
        -0.01003791,
        -0.013187059,
        -0.013390668,
        -0.012576233,
        -0.03255025,
        -0.026577726,
        -0.0062066726,
        -0.017116707,
        -0.09333424,
        0.025410369,
        -0.004024666,
        0.03407053,
        0.004903577,
        -0.0053956313,
        -0.008565141,
        0.0012403165,
        0.027229274,
        0.025125317,
        0.0028929408,
        -0.020605203,
        -0.0038074832,
        -0.0030812789,
        -0.021243177,
        0.019193517,
        -0.0062270337,
        -0.03455919,
        0.027256422,
        0.007737132,
        -0.020659499,
        -0.008470124,
        0.04596128,
        0.013953985,
        0.0072891926,
        0.0069125164,
        -0.01833836,
        -0.017306741,
        -0.010994871,
        -0.0020802026,
        -0.03265884,
        -0.0011987464,
        -0.0073638493,
        0.049246166,
        0.035373624,
        -0.0481874,
        -0.014225463,
        -0.0016577144,
        0.0049205446,
        0.020374447,
        0.030188387,
        0.0050800378,
        -0.019017056,
        0.009318493,
        -0.015677873,
        0.011761798,
        -0.017836126,
        0.0045676227,
        -0.03591658,
        0.011626058,
        -0.018514821,
        0.02246483,
        0.017768255,
        -0.012813776,
        -0.025817588,
        0.027826527,
        0.0083886795,
        0.010893067,
        0.01057408,
        -0.010003976,
        0.020347299,
        0.023048509,
        -0.028559519,
        0.024338031,
        0.009929319,
        0.009399937,
        -0.03966298,
        -0.032115884,
        0.0093727885,
        -0.022234073,
        0.044766773,
        0.014510515,
        -0.006739449,
        -0.03857707,
        -0.014781994,
        -0.010187224,
        -0.011347793,
        -0.012637315,
        0.012508363,
        0.0050698575,
        0.022247648,
        0.015039898,
        0.016166532,
        0.02967258,
        0.0099632535,
        0.0012428616,
        -0.005975916,
        0.0044488506,
        0.04015164,
        -0.021093864,
        0.0053616967,
        -0.017659664,
        0.0312743,
        -0.017320316,
        -0.03092138,
        0.039581537,
        -0.023903664,
        0.001986882,
        -0.03168152,
        0.017727533,
        0.019817917,
        -0.017971864,
        0.007031288,
        -0.021338195,
        0.00014348053,
        0.002806407,
        0.0074317185,
        0.0074724406,
        -0.0070041404,
        -0.0022736308,
        0.024650231,
        0.022396961,
        0.010994871,
        0.045581207,
        0.0057587335,
        -0.101207115,
        -0.014686977,
        0.008775536,
        0.0018867742,
        -0.027962266,
        -0.022044038,
        -0.038848545,
        -0.017836126,
        0.021799708,
        0.039337207,
        -0.026862778,
        0.008429402,
        0.008979145,
        -0.0350207,
        0.0050359224,
        -0.030324128,
        0.0101465015,
        0.01407615,
        0.019166369,
        0.021297473,
        -0.02853237,
        -0.04343653,
        -0.00042142766,
        -0.038984284,
        -0.008035758,
        -0.047481555,
        -0.028505223,
        0.011069528,
        0.04365371,
        0.008802684,
        0.013825033,
        0.004513327,
        0.0013692687,
        -0.005266679,
        0.0009824121,
        -0.014510515,
        -0.016763786,
        -0.036160912,
        -0.017252447,
        -0.04305646,
        0.012840924,
        -0.027663639,
        -0.0061286227,
        0.01958716,
        0.0018715035,
        -0.026292674,
        -0.016695917,
        0.0042825704,
        0.044793922,
        -0.076611176,
        0.043708008,
        -0.006895549,
        0.01144281,
        -0.000254723,
        -0.004055207,
        -0.0005298069,
        0.027473604,
        -0.0040925355,
        0.019641455,
        -0.010804837,
        0.016614472,
        0.0064510033,
        -0.004940905,
        -0.05109222,
        0.006271149,
        0.032333065,
        0.035482217,
        0.009053801,
        -0.030514162,
        0.016438011,
        0.029808318,
        0.011381728,
        -0.0018256917,
        -0.009854662,
        0.01771396,
        0.022030465,
        -0.042024843,
        0.020618778,
        -0.014877011,
        -0.020930978,
        0.014103298,
        -0.0025671667,
        -0.011612484,
        -0.0052836468,
        -0.00079322566,
        0.008185071,
        0.01360785,
        0.022994213,
        -0.00059894903,
        0.03453204,
        -0.04077604,
        -0.0469386,
        0.010920215,
        -0.005606027,
        0.020347299,
        -0.010078632,
        0.031382892,
        -0.016383717,
        -0.1239027,
        -0.005748553,
        0.012420133,
        -0.041780513,
        0.014727699,
        -0.002996442,
        -0.0042893575,
        0.0055381577,
        0.0053549097,
        -0.019057777,
        -0.033934787,
        -0.035617955,
        0.017686812,
        0.017496778,
        0.024799544,
        -0.03903858,
        -0.0055890596,
        0.022627717,
        0.016180107,
        -0.025369648,
        -0.0076217535,
        0.018419804,
        0.005975916,
        -0.004947692,
        -0.024799544,
        -0.00050265907,
        0.007486014,
        0.022437682,
        -0.0045167203,
        0.036215205,
        0.017361037,
        -0.010784476,
        0.003712466,
        0.031464335,
        -0.03116571,
        -0.012718759,
        0.025261058,
        0.011150972,
        -0.0045269006,
        0.013594276,
        0.040640302,
        -0.008171497,
        0.028233744,
        -0.03730112,
        0.013994707,
        -0.013573916,
        -0.012040063,
        -0.006186312,
        -0.010241519,
        0.04305646,
        -0.0016551693,
        0.005633175,
        -0.0036785312,
        -0.016614472,
        -0.013092041,
        0.012664463,
        0.0058503575,
        0.0078117885,
        -0.023767926,
        0.011612484,
        -0.005840177,
        0.005690864,
        0.047617294,
        -0.0056297816,
        -0.023686482,
        0.019845065,
        -0.016940247,
        0.0046185246,
        -0.020876681,
        0.012182589,
        -0.014062576,
        -0.006732662,
        -0.0394458,
        -0.008361532,
        -0.013926838,
        0.01934283,
        0.011639632,
        -0.00089757517,
        -0.005646749,
        -0.014999176,
        0.041346148,
        -0.012019702,
        0.020184413,
        0.026604874,
        0.010085419,
        0.027880821,
        0.014021855,
        0.040341675,
        -0.003261133,
        0.04968053,
        -0.019057777,
        -0.010872706,
        0.0076081795,
        0.005718012,
        -0.0275279,
        0.022586996,
        -0.0038957137,
        -0.023265691,
        0.019682178,
        -0.0029726876,
        0.021188881,
        0.045635503,
        0.01126635,
        0.0038651724,
        -0.021718265,
        0.028803848,
        -0.032713138,
        -0.0029591136,
        -0.018460525,
        0.051255103,
        -0.013811459,
        0.016451586,
        -0.042350616,
        0.0400702,
        -0.011951832,
        0.0052361377,
        -0.0111441845,
        6.532447e-05,
        0.017225299,
        -0.0131124025,
        -0.005181842,
        0.041101817,
        -0.026917074,
        0.031844407,
        -0.015487838,
        0.025831161,
        -0.016098663,
        -0.0044488506,
        -0.018243343,
        0.025600405,
        0.040477417,
        0.0035970877,
        -0.013180272,
        0.07286478,
        -0.011571763,
        0.020985274,
        0.039120026,
        -0.012603381,
        -0.0063763466,
        0.009888598,
        0.02891244,
        0.007506375,
        -0.020089395,
        -0.024840266,
        -0.006328838,
        0.012331902,
        0.028613813,
        -0.01041798,
        -0.051879507,
        0.011022019,
        -0.01833836,
        -0.028803848,
        -0.0071670273,
        0.032876022,
        0.016180107,
        0.050114896,
        -0.00024772395,
        -0.049083278,
        -0.028179448,
        -0.03295747,
        0.047237225,
        0.040341675,
        -0.0060505727,
        -0.02184043,
        0.023387857,
        0.0071127317,
        -0.020483037,
        -0.014972028,
        0.0123386895,
        0.028423779,
        -0.04392519,
        -0.038848545,
        -0.017171003,
        -0.0059691295,
        0.006895549,
        0.027120683,
        -0.0029268756,
        -0.011544615,
        -0.016831655,
        0.0146734025,
        0.0053175814,
        0.044468146,
        0.00513094,
        0.01920709,
        0.04530973,
        -0.023387857,
        0.017279595,
        0.0014897372,
        -0.013926838,
        -0.0069905664,
        0.019858638,
        0.038115554,
        -0.017306741,
        0.055137243,
        0.0046185246,
        0.010764115,
        -0.013804672,
        0.007390997,
        0.022546273,
        -0.020740943,
        -0.0026995125,
        -0.011381728,
        0.032604545,
        -0.046911452,
        -0.012793415,
        0.08899059,
        0.0019953656,
        -0.013994707,
        -0.0017281291,
        -0.00038982587,
        -0.010499423,
        0.019560013,
        -0.0041570114,
        0.003047344,
        -0.015229933,
        0.019682178,
        0.016628046,
        -0.0015983286,
        -0.055408724,
        -0.031464335,
        -0.020428743,
        -0.0269035,
        0.04129185,
        -0.0011223932,
        -0.0003393479,
        0.027134256,
        -0.01639729,
        0.01594935,
        0.007655688,
        0.016275125,
        0.0078253625,
        0.0074588666,
        -0.018609839,
        -0.010058272,
        0.020225134,
        -0.038061257,
        0.0032424692,
        -0.015202785,
        -0.0023092623,
        0.049110427,
        0.024419473,
        0.00012057454,
        0.00018515669,
        -0.009562823,
        0.031627223,
        -0.011178119,
        0.021555377,
        0.01588148,
        0.00776428,
        -0.010641949,
        -0.012155442,
        -0.022858474,
        0.010058272,
        -0.033636164,
        0.026889926,
        -0.0006256727,
        0.006016638,
        0.043246493,
        0.018202621,
        -0.014266185,
        -0.0014702247,
        -0.0042689964,
        0.00049629627,
        -0.01951929,
        -0.011381728,
        -0.012908794,
        -0.015623577,
        0.012175802,
        0.026984943,
        0.005853751,
        -0.0025094775,
        0.019234238,
        -0.019627882,
        0.0072824056,
        -0.008707667,
        0.0033290028,
        -0.008843406,
        0.0012445584,
        -0.0012818866,
        -0.053834148,
        -0.010601228,
        0.025763292,
        -0.004771231,
        0.03054131,
        0.02853237,
        -0.04854032,
        0.031627223,
        -0.023835795,
        0.037464008,
        -0.009080949,
        -0.0024653624,
        0.011809306,
        -0.003042254,
        -0.0024959038,
        -0.0038991072,
        0.0065086926,
        0.0062270337,
        -0.0053752707,
        -0.0018189047,
        -0.022926344,
        0.0068208924,
        0.023795074,
        -0.006949845,
        -0.034097675,
        0.030351276,
        -0.01220295,
        -0.031355746,
        0.0014591959,
        -0.011883963,
        -0.006797138,
        0.013750376,
        0.0005633175,
        0.017659664,
        0.017089559,
        0.00036501107,
        -0.01584076,
        -0.0015635454,
        -0.0019088319,
        -0.016234403,
        0.036215205,
        -0.0015050079,
        0.026984943,
        0.013377094,
        0.0056094206,
        -0.017293168,
        0.022274796,
        0.029998353,
        -0.014877011,
        0.0074656536,
        -0.024867414,
        0.008741601,
        0.025369648,
        0.031844407,
        -0.017999012,
        -0.020917404,
        0.0069430578,
        -0.04368086,
        -0.010994871,
        -0.008273302,
        0.0030201962,
        -0.045011103,
        -0.023224968,
        -0.014944881,
        0.01073018,
        -0.033744752,
        -0.016858803,
        -0.022166204,
        0.017863274,
        -0.011469958,
        0.008531206,
        0.08665588,
        0.022491978,
        -0.026048344,
        -0.0065663815,
        0.015365672,
        0.009047015,
        -0.0318987,
        0.0051614814,
        -0.002675758,
        -0.020102968,
        -0.031600077,
        0.021650394,
        -0.0024365177,
        0.009759645,
        0.015908629,
        0.007058436,
        0.0016424438,
        0.019193517,
        -0.0040789614,
        -0.024297308,
        0.0012657676,
        0.0053481227,
        0.01733389,
        0.0023431971,
        0.018745577,
        0.022071186,
        0.01142245,
        0.0023024755,
        0.016166532,
        0.018202621,
        0.0146462545,
        -0.007051649,
        -0.028939588,
        -0.0051411204,
        -0.010058272,
        -0.010207584,
        -9.973646e-05,
        0.014442646,
        -0.011992554,
        -0.039011434,
        -0.027229274,
        -0.01182288,
        -0.038604215,
        0.026577726,
        0.03491211,
        0.019193517,
        -0.0084022535,
        0.020483037,
        0.011178119,
        0.0023279265,
        -0.019845065,
        0.027188553,
        -0.0032764038,
        -0.029699728,
        -0.01632942,
        -0.03344613,
        0.023985108,
        0.007058436,
        -0.003373118,
        -0.026428413,
        -0.04683001,
        -0.008259728,
        0.02558683,
        0.057716288,
        0.014510515,
        -0.02257342,
        0.008714453,
        -0.016885951,
        -0.027242849,
        0.008768749,
        -0.025831161,
        0.0014651344,
        0.01615296,
        0.013784311,
        0.012467641,
        0.034857813,
        0.0101736495,
        0.02773151,
        -0.014171167,
        -0.012365837,
        -0.018677708,
        0.0042011268,
        -0.017849699,
        -0.024297308,
        -0.02232909,
        -0.0035903007,
        0.0133092245,
        0.022071186,
        -0.030242683,
        -0.0030744919,
        -0.0513094,
        -0.017768255,
        -0.022668438,
        0.003203444,
        0.0070855836,
        -0.010343323,
        0.0024331242,
        0.0146462545,
        -0.03854992,
        -0.014904159,
        -0.0074385055,
        -0.03241451,
        0.03217018,
        -0.0061354097,
        -0.06531768,
        0.0054329596,
        -0.0300255,
        -0.013024172,
        0.003756581,
        0.008361532,
        0.01289522,
        -0.0036547768,
        -0.00754031,
        0.008924849,
        -0.030487014,
        0.046992894,
        -0.021121012,
        -0.017564647,
        -0.031871554,
        -0.02839663,
        0.014293333,
        0.0016916492,
        -0.008775536,
        -0.012243671,
        0.006610497,
        0.017903995,
        0.0023856156,
        -0.0033425768,
        -0.032007292,
        0.009250623,
        0.006349199,
        0.009983615,
        0.04579839,
        -8.838952e-05,
        -0.0033357898,
        -0.017143855,
        0.006322051,
        -0.0055992403,
        -0.022967065,
        0.00064815447,
        -0.01809403,
        -0.02853237,
        -0.03540077,
        0.030188387,
        -0.037735485,
        0.017795403,
        -0.0059487685,
        -0.011965406,
        0.019627882,
        0.050766442,
        0.025179613,
        -0.017618943,
        -0.0052564987,
        0.00825294,
        -0.019288534,
        0.01128671,
        0.01751035,
        -0.013017385,
        0.011212054,
        -0.029075326,
        -0.033337537,
        0.005918227,
        0.007743919,
        0.008483697,
        0.0042418484,
        -0.015379246,
        -0.011843241,
        -0.0052700727,
        0.04142759,
        0.021854004,
        0.006427249,
        -0.025423944,
        0.0027962266,
        -0.01869128,
        5.1087765e-05,
        0.01813475,
        0.009026654,
        -0.02853237,
        -0.034233414,
        0.002299082,
        0.010499423,
        0.031952996,
        0.0056840773,
        -0.011178119,
        0.004075568,
        0.0008462488,
        0.022627717,
        -0.020754516,
        -0.008741601,
        -0.003841418,
        0.0012725546,
        -0.018460525,
        -0.01809403,
        0.0035054637,
        0.013234568,
        0.005449927,
        -0.0051546944,
        -0.042242024,
        -0.014890585,
        0.0612998,
        -0.009209902,
        -0.011150972,
        0.00077965175,
        -0.019369977,
        -0.0056942576,
        -0.019315682,
        0.011117036,
        0.01445622,
        0.048757505,
        0.009135245,
        0.04992486,
        0.0003505888,
        0.031002823,
        0.0127051845,
        0.022247648,
        0.031247154,
        -0.0033900854,
        0.014361203,
        0.024365177,
        0.024636656,
        -0.014619107,
        -0.026686318,
        0.00450654,
        -0.007669262,
        -0.05331834,
        0.012711972,
        -0.0068480405,
        -0.0009332067,
        -0.0025926179,
        0.0057994556,
        0.05481147,
        -0.014972028,
        -0.020550909,
        0.008911275,
        0.0154199675,
        -0.009223475,
        -0.04731867,
        0.025166038,
        -0.010974511,
        0.0017985438,
        -0.022261221,
        0.0026146756,
        0.011755011,
        -0.016695917,
        -0.0031304841,
        0.058422133,
        0.014116872,
        -0.0076285405,
        -0.012596593,
        -0.0078253625,
        -0.020483037,
        0.018840594,
        -0.009868236,
        -0.041536182,
        -0.00064688193,
        -0.032441657,
        0.0020106363,
        -0.007737132,
        0.014849864,
        -0.0016466856,
        0.0015058563,
        -0.009875024,
        -0.025247483,
        -0.0036412028,
        0.0030965495,
        -0.02298064,
        -0.040477417,
        -0.02902103,
        0.0016509275,
        -0.032523103,
        -0.0069702053,
        0.008354745,
        -0.032468807,
        -0.004923938,
        -0.0044250963,
        0.0300255,
        0.006868401,
        -0.036731016,
        0.026686318,
        -0.012535511,
        0.0513094,
        -0.021582525,
        -0.037436858,
        0.0059521617,
        -0.0026469135,
        0.015650725,
        -0.009311706,
        0.0131124025,
        0.015908629,
        0.011395302,
        0.045879833,
        -0.012413345,
        -0.016030794,
        -0.03366331,
        -0.013492472,
        0.00722811,
        0.01715743,
        -0.01305132,
        0.039880164,
        0.018189047,
        -0.017849699,
        0.01514849,
        0.0055822725,
        -0.01695382,
        -0.014252611,
        -0.018677708,
        0.0013022475,
        0.018718429,
        -0.034722075,
        0.012481215,
        -0.011361367,
        0.018311212,
        -0.026876353,
        0.017075986,
        -0.003313732,
        0.014130446,
        0.018365508,
        0.007757493,
        -0.04721008,
        0.054241367,
        -0.027365014,
        0.0146598285,
        0.015895056,
        -0.0018155111,
        0.007655688,
        -0.013967559,
        -0.047563,
        -0.013892902,
        0.04642279,
        -0.031735815,
        0.032197326,
        -0.019057777,
        0.022519127,
        0.032360215,
        0.01989936,
        0.0040212725,
        0.019709324,
        0.01920709,
        -0.012101145,
        0.009766432,
        0.005561912,
        0.012773055,
        -0.0073095537,
        -0.008212219,
        -0.024623083,
        0.009243837,
        0.027880821,
        0.0037260398,
        -0.006362773,
        -0.0093863625,
        -0.01664162,
        -0.026713466,
        0.0034104462,
        -0.02371363,
        -0.011171333,
        0.0012097752,
        0.0011665083,
        -0.025166038,
        -0.040124495,
        0.01965503,
        -0.0438166,
        -0.0048357076,
        0.015094194,
        -0.018636987,
        -0.01289522,
        0.028423779,
        -0.017618943,
        -0.01164642,
        0.012107933,
        -0.03105712,
        0.038875695,
        0.021691117,
        0.019220665,
        0.0154199675,
        -0.013791098,
        -0.01445622,
        0.002037784,
        -0.014374777,
        -0.008673732,
        -0.0084022535,
        0.02773151,
        0.014429072,
        0.00986145,
        -0.0074656536,
        -0.0015143399,
        -0.0044488506,
        0.00450654,
        -0.028206596,
        -0.028586665
      ],
      "embedding_pca_2d": [],
      "embedding_pca_3d": [],
      "embedding_cluster_id": null,
      "migration_history": [],
      "metadata": {
        "compute_time": 2.006330966949463,
        "patch_type": "full",
        "api_costs": 0.0139835,
        "num_applied": 1,
        "patch_name": "modular_greedy_local_search",
        "patch_description": "This redesign restructures the solver into a clear pipeline of small modules (parsing, preprocessing, scoring, selection, local improvement). Key structural changes:\n- Modular functions for parsing, building precedence closures, interaction maps, feasibility and scoring. This improves maintainability and testability.\n- Precomputes transitive closures in a single pass and caches closures, sizes and base weights for fast reuse.\n- Keeps the original precedence-aware closure-based greedy core but uses ranked candidate exploration and a bounded one-step lookahead restricted to top candidates to reduce wasted work.\n- Adds a controlled local-search (removal+add swap) phase that tries beneficial replacements by simulating removals of \"removable\" elements (those without selected successors). This often improves objective while preserving feasibility.\n- Uses clearer dataflow: parse -> preprocess -> greedy -> local_improve -> finalize.\n\nThese changes keep the same input/output contract but typically improve objective value and robustness while keeping runtime reasonable.",
        "error_attempt": null,
        "novelty_attempt": 1,
        "resample_attempt": 1,
        "patch_attempt": 1,
        "model_name": "gpt-5-mini",
        "temperature": 1.0,
        "max_output_tokens": 8192,
        "llm_result": {
          "content": "<NAME>\nmodular_greedy_local_search\n</NAME>\n\n<DESCRIPTION>\nThis redesign restructures the solver into a clear pipeline of small modules (parsing, preprocessing, scoring, selection, local improvement). Key structural changes:\n- Modular functions for parsing, building precedence closures, interaction maps, feasibility and scoring. This improves maintainability and testability.\n- Precomputes transitive closures in a single pass and caches closures, sizes and base weights for fast reuse.\n- Keeps the original precedence-aware closure-based greedy core but uses ranked candidate exploration and a bounded one-step lookahead restricted to top candidates to reduce wasted work.\n- Adds a controlled local-search (removal+add swap) phase that tries beneficial replacements by simulating removals of \"removable\" elements (those without selected successors). This often improves objective while preserving feasibility.\n- Uses clearer dataflow: parse -> preprocess -> greedy -> local_improve -> finalize.\n\nThese changes keep the same input/output contract but typically improve objective value and robustness while keeping runtime reasonable.\n</DESCRIPTION>\n\n<CODE>\n```python\n#!/usr/bin/env python3\n\"\"\"\nEVOLVE-BLOCK-START\nModular solver for Synergistic Dependency Selection (SDS).\nThe EVOLVE block contains the evolved solver implementation.\n\"\"\"\nimport json\nimport sys\n\ndef solve_sds():\n    import re\n    from collections import defaultdict, deque\n\n    # ---------- Parsing ----------\n    data = json.load(sys.stdin)\n    requirements = data.get(\"requirements\", {}) or {}\n    catalog = data.get(\"catalog\", {}) or {}\n\n    weights = list(requirements.get(\"weights\", []) or [])\n    raw_interactions = requirements.get(\"interactions\", {}) or {}\n    card_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)]) or [0, len(weights)]\n    min_card = int(card_bounds[0]) if len(card_bounds) > 0 else 0\n    max_card = int(card_bounds[1]) if len(card_bounds) > 1 else len(weights)\n    mutex_list = requirements.get(\"mutex\", []) or []\n    groups = requirements.get(\"groups\", {}) or {}\n    precedence = requirements.get(\"precedence\", []) or []\n\n    n = len(weights)\n\n    # ---------- Preprocessing ----------\n    # Build interaction adjacency: interactions[u][v] = value\n    interactions = defaultdict(dict)\n    def parse_interaction_key(k):\n        try:\n            if isinstance(k, str):\n                parts = re.split(r'\\s*,\\s*|\\s+', k.strip())\n                if len(parts) >= 2:\n                    return int(parts[0]), int(parts[1])\n            elif isinstance(k, (list, tuple)) and len(k) >= 2:\n                return int(k[0]), int(k[1])\n        except Exception:\n            return None\n        return None\n\n    for k, v in raw_interactions.items():\n        parsed = parse_interaction_key(k)\n        try:\n            val = float(v)\n        except Exception:\n            continue\n        if parsed is None:\n            continue\n        u, w = parsed\n        if 0 <= u < n and 0 <= w < n:\n            interactions[u][w] = interactions[u].get(w, 0.0) + val\n            interactions[w][u] = interactions[w].get(u, 0.0) + val\n\n    # Mutex map\n    mutex_map = defaultdict(set)\n    for pair in mutex_list:\n        try:\n            a, b = pair\n            a = int(a); b = int(b)\n            if 0 <= a < n and 0 <= b < n:\n                mutex_map[a].add(b); mutex_map[b].add(a)\n        except Exception:\n            continue\n\n    # Group map: variable -> group (first membership wins)\n    var_to_group = {}\n    for gname, vars_list in groups.items():\n        for v in vars_list:\n            try:\n                idx = int(v)\n                if 0 <= idx < n and idx not in var_to_group:\n                    var_to_group[idx] = str(gname)\n            except Exception:\n                continue\n\n    # Precedence graph\n    preds = defaultdict(set)\n    succs = defaultdict(set)\n    for entry in precedence:\n        try:\n            a, b = entry\n            a = int(a); b = int(b)\n            if 0 <= a < n and 0 <= b < n:\n                preds[b].add(a)\n                succs[a].add(b)\n        except Exception:\n            continue\n\n    # Compute transitive ancestors (closure of preds) using iterative DFS per node with memoization\n    ancestor_cache = {}\n    def compute_ancestors(i):\n        if i in ancestor_cache:\n            return ancestor_cache[i]\n        res = set()\n        stack = list(preds.get(i, []))\n        seen = set(stack)\n        while stack:\n            cur = stack.pop()\n            res.add(cur)\n            for p in preds.get(cur, ()):\n                if p not in seen:\n                    seen.add(p)\n                    stack.append(p)\n        ancestor_cache[i] = res\n        return res\n\n    closures = [None] * n\n    closure_sizes = [0] * n\n    closure_base_weight = [0.0] * n  # sum of weights in closure (may include out-of-range indices protection)\n    for i in range(n):\n        anc = compute_ancestors(i)\n        c = set(anc)\n        c.add(i)\n        closures[i] = c\n        closure_sizes[i] = len(c)\n        s = 0.0\n        for v in c:\n            if 0 <= v < len(weights):\n                try:\n                    s += float(weights[v])\n                except Exception:\n                    pass\n        closure_base_weight[i] = s\n\n    # Utility functions for interactions and scoring\n    def interaction(u, v):\n        return interactions.get(u, {}).get(v, 0.0)\n\n    def total_score(selected_set):\n        # Sum weights\n        s = 0.0\n        for i in selected_set:\n            if 0 <= i < len(weights):\n                try:\n                    s += float(weights[i])\n                except Exception:\n                    pass\n        # Pairwise interactions (each pair counted once)\n        sel_list = list(selected_set)\n        L = len(sel_list)\n        for a in range(L):\n            u = sel_list[a]\n            for b in range(a+1, L):\n                v = sel_list[b]\n                s += interaction(u, v)\n        return s\n\n    # Feasibility check for closure given a base selected_set\n    def feasible_closure(closure_set, selected_set):\n        # new items to add\n        new_items = closure_set - selected_set\n        # cardinality\n        if len(selected_set) + len(new_items) > max_card:\n            return False\n        # mutex: none of closure can conflict with selected or each other\n        for v in new_items:\n            for c in mutex_map.get(v, ()):\n                if c in selected_set or c in new_items:\n                    return False\n        # group counts\n        group_counts = {}\n        for v in selected_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in new_items:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # precedence: closure must provide ancestors for each of its elements or they already in selected_set\n        for v in closure_set:\n            for a in preds.get(v, ()):\n                if a not in closure_set and a not in selected_set:\n                    return False\n        return True\n\n    # Compute marginal_gain for adding closure to selected_set (exact)\n    def marginal_gain(closure_set, selected_set):\n        new_items = closure_set - selected_set\n        if not new_items:\n            return 0.0\n        gain = 0.0\n        for i in new_items:\n            if 0 <= i < len(weights):\n                try:\n                    gain += float(weights[i])\n                except Exception:\n                    pass\n        # interactions among new items\n        new_list = list(new_items)\n        L = len(new_list)\n        for a in range(L):\n            u = new_list[a]\n            for b in range(a+1, L):\n                v = new_list[b]\n                gain += interaction(u, v)\n        # interactions between new_items and selected_set\n        for u in new_items:\n            for v in selected_set:\n                gain += interaction(u, v)\n        return gain\n\n    # ---------- Greedy selection (closure-based) ----------\n    selected_set = set()\n    current_score = 0.0\n\n    LOOKAHEAD_DISCOUNT = 0.45  # a tuned discount factor\n\n    # Pre-rank candidates by a simple heuristic to limit expensive lookahead:\n    # heuristic = closure_base_weight + sum(max interaction with closure) approx\n    # We'll rank on-the-fly each iteration based on marginal_gain estimate without lookahead.\n    while len(selected_set) < max_card:\n        best_score = float(\"-inf\")\n        best_closure = None\n        best_gain = 0.0\n\n        # Evaluate all candidates but compute a cheap marginal first, then do lookahead for top-K\n        candidate_estimates = []\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closures[i]\n            # Quick capacity pruning\n            new_items = closure - selected_set\n            if len(selected_set) + len(new_items) > max_card:\n                continue\n            if not feasible_closure(closure, selected_set):\n                continue\n            # cheap marginal (weights sum + approx interactions with selected): use marginal_gain\n            mg = marginal_gain(closure, selected_set)\n            candidate_estimates.append((mg, i, closure))\n\n        if not candidate_estimates:\n            break\n\n        # Sort descending by mg and prefer larger closures when tie\n        candidate_estimates.sort(key=lambda x: (x[0], len(x[2] - selected_set)), reverse=True)\n\n        # Limit lookahead to top_k candidates to control cost\n        top_k = min(12, len(candidate_estimates))\n        for idx in range(top_k):\n            mg, i, closure = candidate_estimates[idx]\n            # compute lookahead: best single closure after simulating adding this closure\n            total_score_candidate = mg\n            # if there is still capacity for one more closure\n            if len(selected_set) + len(closure - selected_set) < max_card:\n                sim_selected = selected_set.union(closure)\n                best_follow = 0.0\n                # consider a smaller subset of candidates for follow-up (next best excluding those in sim_selected)\n                follow_k = min(10, n)\n                # follow-up list reuse candidate_estimates order: evaluate top follow_k that are not in sim_selected\n                fcount = 0\n                for mg2, j, closure_j in candidate_estimates:\n                    if j in sim_selected:\n                        continue\n                    if not feasible_closure(closure_j, sim_selected):\n                        continue\n                    g2 = marginal_gain(closure_j, sim_selected)\n                    if g2 > best_follow:\n                        best_follow = g2\n                    fcount += 1\n                    if fcount >= follow_k:\n                        break\n                if best_follow > 0:\n                    total_score_candidate += LOOKAHEAD_DISCOUNT * best_follow\n            # choose best by total_score_candidate, tie-breaker larger closure\n            if (total_score_candidate > best_score) or (abs(total_score_candidate - best_score) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_score = total_score_candidate\n                best_closure = closure\n                best_gain = mg\n\n        # Accept if non-negative gain (small negative tolerances avoided)\n        if best_closure is None:\n            break\n        if best_gain > -1e-12:\n            to_add = best_closure - selected_set\n            if to_add:\n                selected_set.update(to_add)\n                current_score = total_score(selected_set)\n                # continue greedy\n                continue\n            else:\n                # nothing new to add\n                break\n        else:\n            break\n\n    # If min_card not reached, add best feasible closures regardless of sign (prefer larger)\n    while len(selected_set) < min_card:\n        best_gain = float(\"-inf\")\n        best_closure = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closures[i]\n            if not feasible_closure(closure, selected_set):\n                continue\n            mg = marginal_gain(closure, selected_set)\n            if (mg > best_gain) or (abs(mg - best_gain) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_gain = mg\n                best_closure = closure\n        if best_closure is None:\n            break\n        selected_set.update(best_closure - selected_set)\n        current_score = total_score(selected_set)\n\n    # ---------- Local improvement: removable-item swaps ----------\n    # Identify removable items: selected items that have no selected successors (safe to remove alone)\n    # We'll attempt limited number of simulated swaps: remove up to need_slots removable items to add a new closure if net score improves.\n    improvement = True\n    max_local_iters = 200\n    iter_count = 0\n    while improvement and iter_count < max_local_iters:\n        improvement = False\n        iter_count += 1\n        # update removable set\n        removable = set()\n        for v in selected_set:\n            # if no successor in selected_set, it's removable\n            if not any((succ in selected_set) for succ in succs.get(v, ())):\n                removable.add(v)\n        # prepare list of candidate closures not already satisfied\n        candidates = []\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closures[i]\n            # compute new_items\n            new_items = closure - selected_set\n            if not new_items:\n                continue\n            candidates.append((i, closure, new_items))\n        # sort candidates by marginal_gain descending to try promising first\n        candidates.sort(key=lambda x: marginal_gain(x[1], selected_set), reverse=True)\n        # try top some candidates\n        tried = 0\n        for i, closure, new_items in candidates:\n            if tried >= 60:\n                break\n            tried += 1\n            slots_avail = max_card - len(selected_set)\n            need_slots = max(0, len(new_items) - slots_avail)\n            if need_slots == 0:\n                # can add directly if feasible\n                if feasible_closure(closure, selected_set):\n                    mg = marginal_gain(closure, selected_set)\n                    if mg > 1e-12:\n                        selected_set.update(closure - selected_set)\n                        current_score = total_score(selected_set)\n                        improvement = True\n                        break\n                continue\n            # need to remove need_slots items from removable to make room\n            if len(removable) < need_slots:\n                continue\n            # compute individual removal scores relative to current selected_set (loss if removed)\n            removal_scores = []\n            for r in removable:\n                # compute score contribution of r in current selected_set\n                # contribution = weight(r) + interactions(r, others in selected_set)\n                contrib = 0.0\n                if 0 <= r < len(weights):\n                    try:\n                        contrib += float(weights[r])\n                    except Exception:\n                        pass\n                for o in selected_set:\n                    if o == r:\n                        continue\n                    contrib += interaction(r, o)\n                removal_scores.append((contrib, r))\n            # choose candidates to remove with smallest contribution (min loss)\n            removal_scores.sort(key=lambda x: x[0])\n            # try a few small removal combinations (greedy pick lowest need_slots)\n            removals = set([x[1] for x in removal_scores[:need_slots]])\n            # Ensure none of removals are in closure (we don't want to remove items that the closure will re-add - though allowed, it's wasteful)\n            if removals & closure:\n                # prefer next best set that doesn't intersect closure if possible\n                alt = []\n                for cval, rv in removal_scores:\n                    if rv not in closure:\n                        alt.append(rv)\n                        if len(alt) >= need_slots:\n                            break\n                if len(alt) < need_slots:\n                    # can't find non-intersecting removals; skip this candidate\n                    continue\n                removals = set(alt[:need_slots])\n            # simulate new selected\n            sim_selected = set(selected_set) - removals\n            if not feasible_closure(closure, sim_selected):\n                continue\n            sim_after = sim_selected.union(closure)\n            # compute delta\n            sim_score = total_score(sim_after)\n            delta = sim_score - current_score\n            if delta > 1e-9:\n                # perform swap\n                selected_set = sim_after\n                current_score = sim_score\n                improvement = True\n                break\n        # continue loop until no improvements\n    # ---------- Final safety trim ----------\n    if len(selected_set) > max_card:\n        # keep top-scoring items by approximate contribution\n        def item_contribution(i, sel):\n            s = 0.0\n            if 0 <= i < len(weights):\n                try:\n                    s += float(weights[i])\n                except Exception:\n                    pass\n            for j in sel:\n                if j == i: continue\n                s += interaction(i, j)\n            return s\n        sorted_items = sorted(selected_set, key=lambda x: item_contribution(x, selected_set), reverse=True)\n        selected_set = set(sorted_items[:max_card])\n        current_score = total_score(selected_set)\n\n    # Ensure final feasibility: if constraints violated (very unlikely), fallback to greedy simple trim\n    def validate_and_fix(sel):\n        # fix group conflicts: keep highest contribution per group\n        sel = set(sel)\n        groups_rev = {}\n        for v in list(sel):\n            g = var_to_group.get(v)\n            if g is None: continue\n            groups_rev.setdefault(g, []).append(v)\n        for g, members in groups_rev.items():\n            if len(members) <= 1:\n                continue\n            # sort members by contribution and keep best\n            members.sort(key=lambda x: (weights[x] if 0<=x<len(weights) else 0.0) + sum(interaction(x,y) for y in sel if y!=x), reverse=True)\n            for rm in members[1:]:\n                sel.discard(rm)\n        # fix mutex conflicts by dropping the lower-contributing member\n        for a in range(n):\n            for b in mutex_map.get(a, ()):\n                if a < b and a in sel and b in sel:\n                    # drop the one with smaller contribution\n                    ca = (weights[a] if 0<=a<len(weights) else 0.0) + sum(interaction(a,y) for y in sel if y!=a)\n                    cb = (weights[b] if 0<=b<len(weights) else 0.0) + sum(interaction(b,y) for y in sel if y!=b)\n                    if ca >= cb:\n                        sel.discard(b)\n                    else:\n                        sel.discard(a)\n        # enforce precedence: if some selected lacks its ancestors, add ancestors if feasible, otherwise drop the descendant\n        changed = True\n        while changed:\n            changed = False\n            for v in list(sel):\n                for a in preds.get(v, ()):\n                    if a not in sel:\n                        # try to add ancestor if feasible\n                        if len(sel) < max_card and (a not in sel) and feasible_closure({a}, sel):\n                            sel.add(a)\n                            changed = True\n                        else:\n                            # cannot add ancestor: drop v\n                            sel.discard(v)\n                            changed = True\n                            break\n        # enforce cardinality <= max_card by dropping lowest contribution items\n        while len(sel) > max_card:\n            contribs = [( (weights[x] if 0<=x<len(weights) else 0.0) + sum(interaction(x,y) for y in sel if y!=x), x) for x in sel]\n            contribs.sort()\n            sel.discard(contribs[0][1])\n        return sel\n\n    selected_set = validate_and_fix(selected_set)\n\n    result = {\"selection\": {\"variables\": sorted(int(x) for x in selected_set)}}\n    print(json.dumps(result))\n\n\nif __name__ == \"__main__\":\n    solve_sds()\n# EVOLVE-BLOCK-END\n```\n</CODE>",
          "msg": "Here are the performance metrics of a set of prioviously implemented programs:\n\n# Prior programs\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Improved solver for the Synergistic Dependency Selection problem.\n\n    - Reads JSON from stdin with \"requirements\" and \"catalog\".\n    - Produces JSON to stdout with \"selection\": {\"variables\": [...] }.\n    - Uses a precedence-aware marginal-gain greedy algorithm that:\n        * when adding an item, also includes its required predecessors (closure),\n        * computes the marginal objective (weights + pairwise interactions),\n        * checks mutex/group/cardinality feasibility for the closure before adding.\n    \"\"\"\n    import re\n\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n\n    # Extract constraints\n    weights = list(requirements.get(\"weights\", []))\n    interactions_raw = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    min_card, max_card = (cardinality_bounds + [len(weights), len(weights)])[:2]\n    mutex = [tuple(m) for m in requirements.get(\"mutex\", [])]\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n\n    n = len(weights)\n\n    # Parse interactions into dict of tuple->float for quick lookup (undirected)\n    interactions = {}\n    for k, v in interactions_raw.items():\n        try:\n            if isinstance(k, str):\n                # allow \"u,v\" or \"u v\"\n                parts = re.split(r'\\s*,\\s*|\\s+', k.strip())\n                if len(parts) >= 2:\n                    u = int(parts[0]); w = int(parts[1])\n                else:\n                    continue\n            elif isinstance(k, (list, tuple)) and len(k) >= 2:\n                u = int(k[0]); w = int(k[1])\n            else:\n                continue\n            interactions[(u, w)] = float(v)\n            interactions[(w, u)] = float(v)\n        except Exception:\n            # skip malformed keys\n            continue\n\n    # Build precedence graph: if (p, j) then p is a prerequisite of j\n    preds = {i: set() for i in range(n)}\n    succs = {i: set() for i in range(n)}\n    for entry in precedence:\n        try:\n            a, b = entry\n            a = int(a); b = int(b)\n            preds[b].add(a)\n            succs[a].add(b)\n        except Exception:\n            continue\n\n    # Precompute ancestors (transitive closure of preds) using DFS/memoization\n    ancestor_cache = {}\n\n    def get_ancestors(i):\n        if i in ancestor_cache:\n            return ancestor_cache[i].copy()\n        res = set()\n        stack = [i]\n        while stack:\n            cur = stack.pop()\n            for p in preds.get(cur, []):\n                if p not in res:\n                    res.add(p)\n                    stack.append(p)\n        ancestor_cache[i] = res.copy()\n        return res\n\n    # Map variable -> group (assume at most one group membership; if multiple, first wins)\n    var_to_group = {}\n    for gname, vars_list in groups.items():\n        for v in vars_list:\n            try:\n                var_to_group[int(v)] = gname\n            except Exception:\n                pass\n\n    # Helper: check feasibility of adding a closure set given current selected_set\n    def feasible_closure(closure_set, selected_set):\n        # Cardinality\n        if len(selected_set) + len(closure_set - selected_set) > max_card:\n            return False\n        # Mutex: none of closure can conflict with each other or with selected_set\n        for a, b in mutex:\n            if a in closure_set and b in closure_set:\n                return False\n            if (a in closure_set and b in selected_set) or (b in closure_set and a in selected_set):\n                return False\n        # Group: ensure at most one per group overall\n        # Build per-group counts\n        group_counts = {}\n        for v in selected_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in closure_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: closure itself must include ancestors for each element\n        for v in closure_set:\n            if not get_ancestors(v).issubset(closure_set.union(selected_set)):\n                return False\n        return True\n\n    # Compute marginal gain of adding closure_set (items that will be newly included)\n    def marginal_gain(closure_set, selected_set):\n        new_items = set(closure_set) - set(selected_set)\n        gain = 0.0\n        for i in new_items:\n            if i < len(weights):\n                gain += float(weights[i])\n        # interactions among new items\n        new_list = list(new_items)\n        for i in range(len(new_list)):\n            for j in range(i + 1, len(new_list)):\n                gain += interactions.get((new_list[i], new_list[j]), 0.0)\n        # interactions between new items and already selected\n        for i in new_items:\n            for j in selected_set:\n                gain += interactions.get((i, j), 0.0)\n        return gain\n\n    # Greedy loop: at each step try to add an item (and its ancestors) with max marginal gain\n    selected_set = set()\n    # Keep iterating while we can still add and haven't reached max_card\n    improved = True\n    while len(selected_set) < max_card and improved:\n        improved = False\n        best_gain = float(\"-inf\")\n        best_closure = None\n        # Consider candidates not already selected\n        for i in range(n):\n            if i in selected_set:\n                continue\n            # closure includes i and its ancestors\n            closure = get_ancestors(i).union({i})\n            # Only consider closures that are feasible\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # Prefer closures that add more items when gain is equal (to help reach min_card)\n            if gain > best_gain or (abs(gain - best_gain) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_gain = gain\n                best_closure = closure\n        # If we found a positive-gain move, take it\n        if best_closure is not None and best_gain > -1e-12:\n            to_add = set(best_closure) - selected_set\n            if to_add:\n                selected_set.update(to_add)\n                improved = True\n        else:\n            # No non-negative gain move; stop greedy improvements\n            break\n\n    # If we still haven't met minimum cardinality, greedily add best feasible closures regardless of gain\n    while len(selected_set) < min_card:\n        best_gain = float(\"-inf\")\n        best_closure = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = get_ancestors(i).union({i})\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # choose closure that gives best gain (even if negative), tie-breaker favors larger closures\n            if gain > best_gain or (abs(gain - best_gain) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_gain = gain\n                best_closure = closure\n        if best_closure is None:\n            # No feasible closure remains; break to avoid infinite loop\n            break\n        selected_set.update(set(best_closure) - selected_set)\n\n    # Final trim if over max_card (shouldn't happen due to checks) - keep highest-weight items\n    if len(selected_set) > max_card:\n        # score items by marginal contribution relative to selected (approx): weight + interactions with others\n        def item_score(i):\n            s = float(weights[i]) if i < len(weights) else 0.0\n            for j in selected_set:\n                if j == i:\n                    continue\n                s += interactions.get((i, j), 0.0)\n            return s\n        sorted_items = sorted(selected_set, key=item_score, reverse=True)\n        selected_set = set(sorted_items[:max_card])\n\n    result = {\n        \"selection\": {\n            \"variables\": sorted(int(x) for x in selected_set)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n\n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n\n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n\n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n\n    result_str = stdout_capture.getvalue()\n    return result_str\n\n```\n\nPerformance metrics:\nCombined score to maximize: 0.40\nfeasible: True; selection_size: 10; raw_score: 122.55\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Crossover solver for the Synergistic Dependency Selection problem.\n\n    Reads JSON from stdin with \"requirements\" and \"catalog\", and prints JSON\n    with \"selection\": {\"variables\": [...] }.\n\n    Strategy:\n    - Parse inputs robustly.\n    - Build adjacency map for interactions for efficient marginal gain computation.\n    - Precompute transitive ancestor closure for precedence.\n    - For each candidate, consider adding its closure (itself + ancestors).\n    - Greedily add the closure with maximum marginal gain while respecting\n      mutex, groups, and cardinality. Tie-break in favor of larger closures to\n      satisfy minimum cardinality.\n    - If minimum cardinality not reached, add best feasible closures even if negative.\n    - Trim if needed by approximate item scores.\n    \"\"\"\n    import re\n    from collections import defaultdict, deque\n\n    data = json.load(sys.stdin)\n    requirements = data.get(\"requirements\", {}) or {}\n    catalog = data.get(\"catalog\", {}) or {}\n\n    weights = list(requirements.get(\"weights\", []) or [])\n    raw_interactions = requirements.get(\"interactions\", {}) or {}\n    card_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)]) or [0, len(weights)]\n    min_card = int(card_bounds[0]) if len(card_bounds) > 0 else 0\n    max_card = int(card_bounds[1]) if len(card_bounds) > 1 else len(weights)\n    mutex_list = requirements.get(\"mutex\", []) or []\n    groups = requirements.get(\"groups\", {}) or {}\n    precedence = requirements.get(\"precedence\", []) or []\n\n    n = len(weights)\n\n    # Parse interactions into adjacency dict: interactions[u][v] = value\n    interactions = defaultdict(dict)\n    def parse_key(k):\n        # return (u,v) or None\n        try:\n            if isinstance(k, str):\n                parts = re.split(r'\\s*,\\s*|\\s+', k.strip())\n                if len(parts) >= 2:\n                    return int(parts[0]), int(parts[1])\n            elif isinstance(k, (list, tuple)) and len(k) >= 2:\n                return int(k[0]), int(k[1])\n            elif isinstance(k, int):\n                return None\n        except Exception:\n            return None\n        return None\n\n    for k, v in raw_interactions.items():\n        parsed = parse_key(k)\n        try:\n            val = float(v)\n        except Exception:\n            continue\n        if parsed is None:\n            continue\n        u, w = parsed\n        if 0 <= u < n and 0 <= w < n:\n            interactions[u][w] = interactions[u].get(w, 0.0) + val\n            interactions[w][u] = interactions[w].get(u, 0.0) + val\n\n    # Build mutex map for quick conflict checks\n    mutex_map = defaultdict(set)\n    for pair in mutex_list:\n        try:\n            a, b = pair\n            a = int(a); b = int(b)\n            if 0 <= a < n and 0 <= b < n:\n                mutex_map[a].add(b)\n                mutex_map[b].add(a)\n        except Exception:\n            continue\n\n    # Normalize groups: map var -> group name, allow string/int keys\n    var_to_group = {}\n    for gname, vars_list in groups.items():\n        for v in vars_list:\n            try:\n                idx = int(v)\n                if 0 <= idx < n and gname is not None:\n                    # first membership wins\n                    if idx not in var_to_group:\n                        var_to_group[idx] = str(gname)\n            except Exception:\n                continue\n\n    # Build precedence graph (directed: p -> j means p is prerequisite of j)\n    preds = defaultdict(set)\n    succs = defaultdict(set)\n    for entry in precedence:\n        try:\n            a, b = entry\n            a = int(a); b = int(b)\n            if 0 <= a < n and 0 <= b < n:\n                preds[b].add(a)\n                succs[a].add(b)\n        except Exception:\n            continue\n\n    # Precompute transitive ancestor closure for each node using DFS/BFS\n    ancestor_closure = [set() for _ in range(n)]\n    for i in range(n):\n        # BFS/DFS from i to collect all ancestors\n        stack = list(preds.get(i, []))\n        seen = set(stack)\n        while stack:\n            cur = stack.pop()\n            ancestor_closure[i].add(cur)\n            for p in preds.get(cur, []):\n                if p not in seen:\n                    seen.add(p)\n                    stack.append(p)\n\n    # closure for variable i is ancestors + i\n    closures = [set(ancestor_closure[i]) | {i} for i in range(n)]\n\n    # Feasibility check of adding closure (closure is set of vars to ensure present),\n    # given currently selected_set.\n    def feasible_closure(closure, selected_set):\n        # New items that would be added\n        new_items = closure - selected_set\n        # Cardinality check\n        if len(selected_set) + len(new_items) > max_card:\n            return False\n        # Mutex check: none of new items conflict with each other or with selected\n        for v in new_items:\n            # conflicts with selected\n            if any(conflict in selected_set for conflict in mutex_map.get(v, ())) :\n                return False\n            # conflicts with other new items\n            for conflict in mutex_map.get(v, ()):\n                if conflict in new_items:\n                    return False\n        # Group check: cannot create group count >1\n        group_counts = {}\n        for v in selected_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in new_items:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: closures already contain transitive ancestors; but if closure lacks\n        # some ancestor (shouldn't) ensure those ancestors are in selected_set\n        for v in closure:\n            for a in preds.get(v, ()):\n                if a not in closure and a not in selected_set:\n                    return False\n        return True\n\n    # Compute marginal gain for adding closure (new items = closure - selected_set)\n    def marginal_gain(closure, selected_set):\n        new_items = closure - selected_set\n        if not new_items:\n            return 0.0\n        gain = 0.0\n        # weights\n        for i in new_items:\n            if 0 <= i < len(weights):\n                try:\n                    gain += float(weights[i])\n                except Exception:\n                    pass\n        # interactions among new items\n        # iterate edges from each new item to higher-index new items to avoid double count\n        new_list = list(new_items)\n        l = len(new_list)\n        for idx in range(l):\n            u = new_list[idx]\n            # interactions with other new items\n            for v in new_list[idx+1:]:\n                gain += interactions.get(u, {}).get(v, 0.0)\n        # interactions between new items and already selected\n        for u in new_items:\n            for v in selected_set:\n                gain += interactions.get(u, {}).get(v, 0.0)\n        return gain\n\n    # Greedy selection: add closure with best marginal gain while respecting constraints\n    selected_set = set()\n    # Initial heuristic: consider items sorted by weight+abs(interaction_potential)\n    # but main loop will evaluate closures anyway, so we iterate all candidates\n    improved = True\n    while len(selected_set) < max_card and improved:\n        improved = False\n        best_gain = float(\"-inf\")\n        best_closure = None\n        # Evaluate every candidate not yet in selected_set\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closures[i]\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # Tie-breaker: prefer larger closure (helps reach min_card)\n            if (gain > best_gain) or (abs(gain - best_gain) < 1e-12 and best_closure is not None and len(closure - selected_set) > len(best_closure - selected_set)) or (best_closure is None and gain >= best_gain):\n                best_gain = gain\n                best_closure = closure\n        # Accept non-negative gain closures; small negative may be accepted later to meet min_card\n        if best_closure is not None and best_gain > -1e-12:\n            new_items = best_closure - selected_set\n            if new_items:\n                selected_set.update(new_items)\n                improved = True\n        else:\n            break\n\n    # If we haven't met min_card, add best feasible closures even if negative\n    while len(selected_set) < min_card:\n        best_gain = float(\"-inf\")\n        best_closure = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closures[i]\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            if (gain > best_gain) or (abs(gain - best_gain) < 1e-12 and best_closure is not None and len(closure - selected_set) > len(best_closure - selected_set)) or (best_closure is None and gain >= best_gain):\n                best_gain = gain\n                best_closure = closure\n        if best_closure is None:\n            # no feasible closures left\n            break\n        selected_set.update(best_closure - selected_set)\n\n    # Safety trim if we're over max_card (should rarely happen due to checks)\n    if len(selected_set) > max_card:\n        # compute approximate item score = weight + sum interactions with others in selected_set\n        def item_score(i):\n            s = 0.0\n            if 0 <= i < len(weights):\n                try:\n                    s += float(weights[i])\n                except Exception:\n                    pass\n            for j in selected_set:\n                if j == i:\n                    continue\n                s += interactions.get(i, {}).get(j, 0.0)\n            return s\n        sorted_items = sorted(selected_set, key=lambda x: item_score(x), reverse=True)\n        selected_set = set(sorted_items[:max_card])\n\n    result = {\"selection\": {\"variables\": sorted(int(x) for x in selected_set)}}\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n\n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n\n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n\n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n\n    result_str = stdout_capture.getvalue()\n    return result_str\n\n```\n\nPerformance metrics:\nCombined score to maximize: 0.40\nfeasible: True; selection_size: 10; raw_score: 122.55\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    This is a greedy baseline - evolution will improve this.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    # Simple greedy: select items with highest weights first\n    # This is a baseline - evolution will find better strategies\n    n = len(weights)\n    selected = []\n    \n    # Create score list (weight + interaction potential)\n    scores = []\n    for i in range(n):\n        score = weights[i] if i < len(weights) else 0.0\n        # Add potential interaction value\n        for k, v in interactions.items():\n            try:\n                u, w = map(int, k.split(\",\"))\n                if u == i or w == i:\n                    score += abs(v) * 0.5  # Potential value\n            except:\n                pass\n        scores.append((score, i))\n    \n    # Sort by score descending\n    scores.sort(reverse=True)\n    \n    # Greedy selection respecting constraints\n    selected_set = set()\n    for score, i in scores:\n        if len(selected_set) >= cardinality_bounds[1]:\n            break\n            \n        # Check mutex constraints\n        can_add = True\n        for a, b in mutex:\n            if (a == i and b in selected_set) or (b == i and a in selected_set):\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n            \n        # Check group constraints (at most one per group)\n        for grp_vars in groups.values():\n            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n        \n        # Check precedence (if j selected, i must be selected)\n        precedence_ok = True\n        for pred_i, pred_j in precedence:\n            if pred_j == i and pred_i not in selected_set:\n                precedence_ok = False\n                break\n        \n        if not precedence_ok:\n            continue\n        \n        # Add if we meet minimum cardinality or have room\n        if len(selected_set) < cardinality_bounds[1]:\n            selected_set.add(i)\n            selected.append(i)\n    \n    # Ensure minimum cardinality\n    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n        for i in range(n):\n            if i not in selected_set:\n                selected_set.add(i)\n                selected.append(i)\n                break\n    \n    # Output result\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n    \n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n    \n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n    \n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n    \n    result_str = stdout_capture.getvalue()\n    return result_str\n\n\n```\n\nPerformance metrics:\nCombined score to maximize: 0.35\nfeasible: True; selection_size: 10; raw_score: 106.51\n\n\n# Current program\n\nHere is the current program we are trying to improve (you will need to \npropose a new program with the same inputs and outputs as the original \nprogram, but with improved internal implementation):\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Improved solver for the Synergistic Dependency Selection problem.\n\n    - Reads JSON from stdin with \"requirements\" and \"catalog\".\n    - Produces JSON to stdout with \"selection\": {\"variables\": [...] }.\n    - Uses a precedence-aware marginal-gain greedy algorithm that:\n        * when adding an item, also includes its required predecessors (closure),\n        * computes the marginal objective (weights + pairwise interactions),\n        * checks mutex/group/cardinality feasibility for the closure before adding.\n    - Adds a lightweight one-step lookahead: when evaluating a candidate closure,\n      also consider the best single subsequent closure that would be feasible after\n      adding the candidate. A discounted portion of that subsequent gain is added\n      to the candidate score to prefer moves that enable strong follow-ups.\n    \"\"\"\n    import re\n\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n\n    # Extract constraints\n    weights = list(requirements.get(\"weights\", []))\n    interactions_raw = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    min_card, max_card = (cardinality_bounds + [len(weights), len(weights)])[:2]\n    mutex = [tuple(m) for m in requirements.get(\"mutex\", [])]\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n\n    n = len(weights)\n\n    # Parse interactions into dict of tuple->float for quick lookup (undirected)\n    interactions = {}\n    for k, v in interactions_raw.items():\n        try:\n            if isinstance(k, str):\n                # allow \"u,v\" or \"u v\"\n                parts = re.split(r'\\s*,\\s*|\\s+', k.strip())\n                if len(parts) >= 2:\n                    u = int(parts[0]); w = int(parts[1])\n                else:\n                    continue\n            elif isinstance(k, (list, tuple)) and len(k) >= 2:\n                u = int(k[0]); w = int(k[1])\n            else:\n                continue\n            interactions[(u, w)] = float(v)\n            interactions[(w, u)] = float(v)\n        except Exception:\n            # skip malformed keys\n            continue\n\n    # Build precedence graph: if (p, j) then p is a prerequisite of j\n    preds = {i: set() for i in range(n)}\n    succs = {i: set() for i in range(n)}\n    for entry in precedence:\n        try:\n            a, b = entry\n            a = int(a); b = int(b)\n            preds[b].add(a)\n            succs[a].add(b)\n        except Exception:\n            continue\n\n    # Precompute ancestors (transitive closure of preds) using DFS/memoization\n    ancestor_cache = {}\n\n    def get_ancestors(i):\n        if i in ancestor_cache:\n            return ancestor_cache[i].copy()\n        res = set()\n        stack = [i]\n        while stack:\n            cur = stack.pop()\n            for p in preds.get(cur, []):\n                if p not in res:\n                    res.add(p)\n                    stack.append(p)\n        ancestor_cache[i] = res.copy()\n        return res\n\n    # Precompute closures (ancestors + self) and cache them for fast reuse\n    closure_cache = {i: get_ancestors(i).union({i}) for i in range(n)}\n\n    # Map variable -> group (assume at most one group membership; if multiple, first wins)\n    var_to_group = {}\n    for gname, vars_list in groups.items():\n        for v in vars_list:\n            try:\n                var_to_group[int(v)] = gname\n            except Exception:\n                pass\n\n    # Helper: check feasibility of adding a closure set given current selected_set\n    def feasible_closure(closure_set, selected_set):\n        # Cardinality\n        if len(selected_set) + len(closure_set - selected_set) > max_card:\n            return False\n        # Mutex: none of closure can conflict with each other or with selected_set\n        for a, b in mutex:\n            if a in closure_set and b in closure_set:\n                return False\n            if (a in closure_set and b in selected_set) or (b in closure_set and a in selected_set):\n                return False\n        # Group: ensure at most one per group overall\n        # Build per-group counts\n        group_counts = {}\n        for v in selected_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in closure_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: closure itself must include ancestors for each element (or they are already selected)\n        for v in closure_set:\n            if not get_ancestors(v).issubset(closure_set.union(selected_set)):\n                return False\n        return True\n\n    # Compute marginal gain of adding closure_set (items that will be newly included)\n    def marginal_gain(closure_set, selected_set):\n        new_items = set(closure_set) - set(selected_set)\n        if not new_items:\n            return 0.0\n        gain = 0.0\n        for i in new_items:\n            if 0 <= i < len(weights):\n                gain += float(weights[i])\n        # interactions among new items\n        new_list = list(new_items)\n        for a in range(len(new_list)):\n            for b in range(a + 1, len(new_list)):\n                gain += interactions.get((new_list[a], new_list[b]), 0.0)\n        # interactions between new items and already selected\n        for i in new_items:\n            for j in selected_set:\n                gain += interactions.get((i, j), 0.0)\n        return gain\n\n    # Greedy loop: at each step try to add an item (and its ancestors) with max marginal gain\n    # Enhanced with small one-step lookahead: for each candidate closure consider the best\n    # subsequent single-closure gain and add a discounted fraction to the candidate score.\n    selected_set = set()\n    improved = True\n    LOOKAHEAD_DISCOUNT = 0.5  # weight of the best next-step gain when scoring current candidate\n    while len(selected_set) < max_card and improved:\n        improved = False\n        best_score = float(\"-inf\")\n        best_gain = float(\"-inf\")\n        best_closure = None\n        # Consider candidates not already selected\n        for i in range(n):\n            if i in selected_set:\n                continue\n            # closure includes i and its ancestors (cached)\n            closure = closure_cache.get(i, {i})\n            # Only consider closures that are feasible\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # quick capacity pruning: if closure would add more items than remaining slots, skip\n            if len(closure - selected_set) > (max_card - len(selected_set)):\n                continue\n            # Compute one-step lookahead: best feasible single closure after adding this closure\n            lookahead_best = 0.0\n            if len(selected_set) + len(closure - selected_set) < max_card:\n                # simulate new selected set\n                sim_selected = selected_set.union(closure)\n                # find best single candidate (could be more expensive, so limit exploration)\n                # We will search all but with a cheap break if we find strong positive gains.\n                for j in range(n):\n                    if j in sim_selected:\n                        continue\n                    closure_j = closure_cache.get(j, {j})\n                    if not feasible_closure(closure_j, sim_selected):\n                        continue\n                    gain_j = marginal_gain(closure_j, sim_selected)\n                    if gain_j > lookahead_best:\n                        lookahead_best = gain_j\n                        # small optimization: if it's very large, we can accept it\n                        if lookahead_best > abs(gain) * 2 + 1e-9:\n                            break\n            total_score = gain + LOOKAHEAD_DISCOUNT * max(0.0, lookahead_best)\n            # Prefer closures that add more items when scores equal (helps reach min_card)\n            if (total_score > best_score) or (abs(total_score - best_score) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_score = total_score\n                best_gain = gain\n                best_closure = closure\n        # If we found a non-negative-gain move, take it\n        if best_closure is not None and best_gain > -1e-12:\n            to_add = set(best_closure) - selected_set\n            if to_add:\n                selected_set.update(to_add)\n                improved = True\n        else:\n            # No non-negative gain move; stop greedy improvements\n            break\n\n    # If we still haven't met minimum cardinality, greedily add best feasible closures regardless of gain\n    # Use same closure cache and prefer closures that may enable good follow-ups.\n    while len(selected_set) < min_card:\n        best_score = float(\"-inf\")\n        best_gain = float(\"-inf\")\n        best_closure = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closure_cache.get(i, {i})\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # lookahead as before (but smaller budget)\n            lookahead_best = 0.0\n            if len(selected_set) + len(closure - selected_set) < max_card:\n                sim_selected = selected_set.union(closure)\n                for j in range(n):\n                    if j in sim_selected:\n                        continue\n                    closure_j = closure_cache.get(j, {j})\n                    if not feasible_closure(closure_j, sim_selected):\n                        continue\n                    gain_j = marginal_gain(closure_j, sim_selected)\n                    if gain_j > lookahead_best:\n                        lookahead_best = gain_j\n            total_score = gain + LOOKAHEAD_DISCOUNT * max(0.0, lookahead_best)\n            if (total_score > best_score) or (abs(total_score - best_score) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_score = total_score\n                best_gain = gain\n                best_closure = closure\n        if best_closure is None:\n            # No feasible closure remains; break to avoid infinite loop\n            break\n        selected_set.update(set(best_closure) - selected_set)\n\n    # Final trim if over max_card (shouldn't happen due to checks) - keep highest-weight items\n    if len(selected_set) > max_card:\n        # score items by marginal contribution relative to selected (approx): weight + interactions with others\n        def item_score(i):\n            s = float(weights[i]) if i < len(weights) else 0.0\n            for j in selected_set:\n                if j == i:\n                    continue\n                s += interactions.get((i, j), 0.0)\n            return s\n        sorted_items = sorted(selected_set, key=item_score, reverse=True)\n        selected_set = set(sorted_items[:max_card])\n\n    result = {\n        \"selection\": {\n            \"variables\": sorted(int(x) for x in selected_set)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n\n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n\n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n\n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n\n    result_str = stdout_capture.getvalue()\n    return result_str\n```\n\nHere are the performance metrics of the program:\n\nCombined score to maximize: 0.40\nfeasible: True; selection_size: 10; raw_score: 122.55\n\n# Task\n\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs as the original program, but with improved internal implementation.\n",
          "system_msg": "You are an expert algorithmist specializing in combinatorial optimization, particularly the Synergistic Dependency Selection (SDS) problem.\n\nThe SDS problem requires selecting a subset of variables that:\n1. Satisfies cardinality bounds (min/max number of items)\n2. Respects mutex constraints (cannot select both items in a mutex pair)\n3. Respects group constraints (at most one item per group)\n4. Satisfies precedence constraints (if j is selected, i must be selected)\n5. Maximizes the objective: sum of selected item weights + pairwise interaction values\n\nKey strategies to explore:\n1. Greedy selection with constraint-aware ordering\n2. Dynamic programming for small instances\n3. Constraint satisfaction with backtracking\n4. Weighted scoring that accounts for interactions\n5. Precedence-aware selection ordering\n6. Group-aware selection that maximizes diversity\n\nThe code should read JSON from stdin with \"requirements\" and \"catalog\", and output JSON to stdout with \"selection\" containing \"variables\" list.\n\nBe creative and find efficient solutions that maximize the objective while respecting all constraints.\nRedesign the program with a different structural approach while potentially using similar core concepts.\nFocus on changing the overall architecture, data flow, or program organization.\nYou MUST respond using a short summary name, description and the full code:\n\n<NAME>\nA shortened name summarizing the code you are proposing. Lowercase, no spaces, underscores allowed.\n</NAME>\n\n<DESCRIPTION>\nDescribe the structural changes you are making and how they improve the program's performance, maintainability, or efficiency.\n</DESCRIPTION>\n\n<CODE>\n```{language}\n# The structurally redesigned program here.\n```\n</CODE>\n\n* Keep the markers \"EVOLVE-BLOCK-START\" and \"EVOLVE-BLOCK-END\" in the code.\n* Focus on changing the program's structure: modularization, data flow, control flow, or architectural patterns.\n* The core problem-solving approach may be similar but organized differently.\n* Ensure the same inputs and outputs are maintained.\n* Use the <NAME>, <DESCRIPTION>, and <CODE> delimiters to structure your response. It will be parsed afterwards.",
          "new_msg_history": [
            {
              "role": "user",
              "content": "Here are the performance metrics of a set of prioviously implemented programs:\n\n# Prior programs\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Improved solver for the Synergistic Dependency Selection problem.\n\n    - Reads JSON from stdin with \"requirements\" and \"catalog\".\n    - Produces JSON to stdout with \"selection\": {\"variables\": [...] }.\n    - Uses a precedence-aware marginal-gain greedy algorithm that:\n        * when adding an item, also includes its required predecessors (closure),\n        * computes the marginal objective (weights + pairwise interactions),\n        * checks mutex/group/cardinality feasibility for the closure before adding.\n    \"\"\"\n    import re\n\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n\n    # Extract constraints\n    weights = list(requirements.get(\"weights\", []))\n    interactions_raw = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    min_card, max_card = (cardinality_bounds + [len(weights), len(weights)])[:2]\n    mutex = [tuple(m) for m in requirements.get(\"mutex\", [])]\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n\n    n = len(weights)\n\n    # Parse interactions into dict of tuple->float for quick lookup (undirected)\n    interactions = {}\n    for k, v in interactions_raw.items():\n        try:\n            if isinstance(k, str):\n                # allow \"u,v\" or \"u v\"\n                parts = re.split(r'\\s*,\\s*|\\s+', k.strip())\n                if len(parts) >= 2:\n                    u = int(parts[0]); w = int(parts[1])\n                else:\n                    continue\n            elif isinstance(k, (list, tuple)) and len(k) >= 2:\n                u = int(k[0]); w = int(k[1])\n            else:\n                continue\n            interactions[(u, w)] = float(v)\n            interactions[(w, u)] = float(v)\n        except Exception:\n            # skip malformed keys\n            continue\n\n    # Build precedence graph: if (p, j) then p is a prerequisite of j\n    preds = {i: set() for i in range(n)}\n    succs = {i: set() for i in range(n)}\n    for entry in precedence:\n        try:\n            a, b = entry\n            a = int(a); b = int(b)\n            preds[b].add(a)\n            succs[a].add(b)\n        except Exception:\n            continue\n\n    # Precompute ancestors (transitive closure of preds) using DFS/memoization\n    ancestor_cache = {}\n\n    def get_ancestors(i):\n        if i in ancestor_cache:\n            return ancestor_cache[i].copy()\n        res = set()\n        stack = [i]\n        while stack:\n            cur = stack.pop()\n            for p in preds.get(cur, []):\n                if p not in res:\n                    res.add(p)\n                    stack.append(p)\n        ancestor_cache[i] = res.copy()\n        return res\n\n    # Map variable -> group (assume at most one group membership; if multiple, first wins)\n    var_to_group = {}\n    for gname, vars_list in groups.items():\n        for v in vars_list:\n            try:\n                var_to_group[int(v)] = gname\n            except Exception:\n                pass\n\n    # Helper: check feasibility of adding a closure set given current selected_set\n    def feasible_closure(closure_set, selected_set):\n        # Cardinality\n        if len(selected_set) + len(closure_set - selected_set) > max_card:\n            return False\n        # Mutex: none of closure can conflict with each other or with selected_set\n        for a, b in mutex:\n            if a in closure_set and b in closure_set:\n                return False\n            if (a in closure_set and b in selected_set) or (b in closure_set and a in selected_set):\n                return False\n        # Group: ensure at most one per group overall\n        # Build per-group counts\n        group_counts = {}\n        for v in selected_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in closure_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: closure itself must include ancestors for each element\n        for v in closure_set:\n            if not get_ancestors(v).issubset(closure_set.union(selected_set)):\n                return False\n        return True\n\n    # Compute marginal gain of adding closure_set (items that will be newly included)\n    def marginal_gain(closure_set, selected_set):\n        new_items = set(closure_set) - set(selected_set)\n        gain = 0.0\n        for i in new_items:\n            if i < len(weights):\n                gain += float(weights[i])\n        # interactions among new items\n        new_list = list(new_items)\n        for i in range(len(new_list)):\n            for j in range(i + 1, len(new_list)):\n                gain += interactions.get((new_list[i], new_list[j]), 0.0)\n        # interactions between new items and already selected\n        for i in new_items:\n            for j in selected_set:\n                gain += interactions.get((i, j), 0.0)\n        return gain\n\n    # Greedy loop: at each step try to add an item (and its ancestors) with max marginal gain\n    selected_set = set()\n    # Keep iterating while we can still add and haven't reached max_card\n    improved = True\n    while len(selected_set) < max_card and improved:\n        improved = False\n        best_gain = float(\"-inf\")\n        best_closure = None\n        # Consider candidates not already selected\n        for i in range(n):\n            if i in selected_set:\n                continue\n            # closure includes i and its ancestors\n            closure = get_ancestors(i).union({i})\n            # Only consider closures that are feasible\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # Prefer closures that add more items when gain is equal (to help reach min_card)\n            if gain > best_gain or (abs(gain - best_gain) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_gain = gain\n                best_closure = closure\n        # If we found a positive-gain move, take it\n        if best_closure is not None and best_gain > -1e-12:\n            to_add = set(best_closure) - selected_set\n            if to_add:\n                selected_set.update(to_add)\n                improved = True\n        else:\n            # No non-negative gain move; stop greedy improvements\n            break\n\n    # If we still haven't met minimum cardinality, greedily add best feasible closures regardless of gain\n    while len(selected_set) < min_card:\n        best_gain = float(\"-inf\")\n        best_closure = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = get_ancestors(i).union({i})\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # choose closure that gives best gain (even if negative), tie-breaker favors larger closures\n            if gain > best_gain or (abs(gain - best_gain) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_gain = gain\n                best_closure = closure\n        if best_closure is None:\n            # No feasible closure remains; break to avoid infinite loop\n            break\n        selected_set.update(set(best_closure) - selected_set)\n\n    # Final trim if over max_card (shouldn't happen due to checks) - keep highest-weight items\n    if len(selected_set) > max_card:\n        # score items by marginal contribution relative to selected (approx): weight + interactions with others\n        def item_score(i):\n            s = float(weights[i]) if i < len(weights) else 0.0\n            for j in selected_set:\n                if j == i:\n                    continue\n                s += interactions.get((i, j), 0.0)\n            return s\n        sorted_items = sorted(selected_set, key=item_score, reverse=True)\n        selected_set = set(sorted_items[:max_card])\n\n    result = {\n        \"selection\": {\n            \"variables\": sorted(int(x) for x in selected_set)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n\n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n\n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n\n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n\n    result_str = stdout_capture.getvalue()\n    return result_str\n\n```\n\nPerformance metrics:\nCombined score to maximize: 0.40\nfeasible: True; selection_size: 10; raw_score: 122.55\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Crossover solver for the Synergistic Dependency Selection problem.\n\n    Reads JSON from stdin with \"requirements\" and \"catalog\", and prints JSON\n    with \"selection\": {\"variables\": [...] }.\n\n    Strategy:\n    - Parse inputs robustly.\n    - Build adjacency map for interactions for efficient marginal gain computation.\n    - Precompute transitive ancestor closure for precedence.\n    - For each candidate, consider adding its closure (itself + ancestors).\n    - Greedily add the closure with maximum marginal gain while respecting\n      mutex, groups, and cardinality. Tie-break in favor of larger closures to\n      satisfy minimum cardinality.\n    - If minimum cardinality not reached, add best feasible closures even if negative.\n    - Trim if needed by approximate item scores.\n    \"\"\"\n    import re\n    from collections import defaultdict, deque\n\n    data = json.load(sys.stdin)\n    requirements = data.get(\"requirements\", {}) or {}\n    catalog = data.get(\"catalog\", {}) or {}\n\n    weights = list(requirements.get(\"weights\", []) or [])\n    raw_interactions = requirements.get(\"interactions\", {}) or {}\n    card_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)]) or [0, len(weights)]\n    min_card = int(card_bounds[0]) if len(card_bounds) > 0 else 0\n    max_card = int(card_bounds[1]) if len(card_bounds) > 1 else len(weights)\n    mutex_list = requirements.get(\"mutex\", []) or []\n    groups = requirements.get(\"groups\", {}) or {}\n    precedence = requirements.get(\"precedence\", []) or []\n\n    n = len(weights)\n\n    # Parse interactions into adjacency dict: interactions[u][v] = value\n    interactions = defaultdict(dict)\n    def parse_key(k):\n        # return (u,v) or None\n        try:\n            if isinstance(k, str):\n                parts = re.split(r'\\s*,\\s*|\\s+', k.strip())\n                if len(parts) >= 2:\n                    return int(parts[0]), int(parts[1])\n            elif isinstance(k, (list, tuple)) and len(k) >= 2:\n                return int(k[0]), int(k[1])\n            elif isinstance(k, int):\n                return None\n        except Exception:\n            return None\n        return None\n\n    for k, v in raw_interactions.items():\n        parsed = parse_key(k)\n        try:\n            val = float(v)\n        except Exception:\n            continue\n        if parsed is None:\n            continue\n        u, w = parsed\n        if 0 <= u < n and 0 <= w < n:\n            interactions[u][w] = interactions[u].get(w, 0.0) + val\n            interactions[w][u] = interactions[w].get(u, 0.0) + val\n\n    # Build mutex map for quick conflict checks\n    mutex_map = defaultdict(set)\n    for pair in mutex_list:\n        try:\n            a, b = pair\n            a = int(a); b = int(b)\n            if 0 <= a < n and 0 <= b < n:\n                mutex_map[a].add(b)\n                mutex_map[b].add(a)\n        except Exception:\n            continue\n\n    # Normalize groups: map var -> group name, allow string/int keys\n    var_to_group = {}\n    for gname, vars_list in groups.items():\n        for v in vars_list:\n            try:\n                idx = int(v)\n                if 0 <= idx < n and gname is not None:\n                    # first membership wins\n                    if idx not in var_to_group:\n                        var_to_group[idx] = str(gname)\n            except Exception:\n                continue\n\n    # Build precedence graph (directed: p -> j means p is prerequisite of j)\n    preds = defaultdict(set)\n    succs = defaultdict(set)\n    for entry in precedence:\n        try:\n            a, b = entry\n            a = int(a); b = int(b)\n            if 0 <= a < n and 0 <= b < n:\n                preds[b].add(a)\n                succs[a].add(b)\n        except Exception:\n            continue\n\n    # Precompute transitive ancestor closure for each node using DFS/BFS\n    ancestor_closure = [set() for _ in range(n)]\n    for i in range(n):\n        # BFS/DFS from i to collect all ancestors\n        stack = list(preds.get(i, []))\n        seen = set(stack)\n        while stack:\n            cur = stack.pop()\n            ancestor_closure[i].add(cur)\n            for p in preds.get(cur, []):\n                if p not in seen:\n                    seen.add(p)\n                    stack.append(p)\n\n    # closure for variable i is ancestors + i\n    closures = [set(ancestor_closure[i]) | {i} for i in range(n)]\n\n    # Feasibility check of adding closure (closure is set of vars to ensure present),\n    # given currently selected_set.\n    def feasible_closure(closure, selected_set):\n        # New items that would be added\n        new_items = closure - selected_set\n        # Cardinality check\n        if len(selected_set) + len(new_items) > max_card:\n            return False\n        # Mutex check: none of new items conflict with each other or with selected\n        for v in new_items:\n            # conflicts with selected\n            if any(conflict in selected_set for conflict in mutex_map.get(v, ())) :\n                return False\n            # conflicts with other new items\n            for conflict in mutex_map.get(v, ()):\n                if conflict in new_items:\n                    return False\n        # Group check: cannot create group count >1\n        group_counts = {}\n        for v in selected_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in new_items:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: closures already contain transitive ancestors; but if closure lacks\n        # some ancestor (shouldn't) ensure those ancestors are in selected_set\n        for v in closure:\n            for a in preds.get(v, ()):\n                if a not in closure and a not in selected_set:\n                    return False\n        return True\n\n    # Compute marginal gain for adding closure (new items = closure - selected_set)\n    def marginal_gain(closure, selected_set):\n        new_items = closure - selected_set\n        if not new_items:\n            return 0.0\n        gain = 0.0\n        # weights\n        for i in new_items:\n            if 0 <= i < len(weights):\n                try:\n                    gain += float(weights[i])\n                except Exception:\n                    pass\n        # interactions among new items\n        # iterate edges from each new item to higher-index new items to avoid double count\n        new_list = list(new_items)\n        l = len(new_list)\n        for idx in range(l):\n            u = new_list[idx]\n            # interactions with other new items\n            for v in new_list[idx+1:]:\n                gain += interactions.get(u, {}).get(v, 0.0)\n        # interactions between new items and already selected\n        for u in new_items:\n            for v in selected_set:\n                gain += interactions.get(u, {}).get(v, 0.0)\n        return gain\n\n    # Greedy selection: add closure with best marginal gain while respecting constraints\n    selected_set = set()\n    # Initial heuristic: consider items sorted by weight+abs(interaction_potential)\n    # but main loop will evaluate closures anyway, so we iterate all candidates\n    improved = True\n    while len(selected_set) < max_card and improved:\n        improved = False\n        best_gain = float(\"-inf\")\n        best_closure = None\n        # Evaluate every candidate not yet in selected_set\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closures[i]\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # Tie-breaker: prefer larger closure (helps reach min_card)\n            if (gain > best_gain) or (abs(gain - best_gain) < 1e-12 and best_closure is not None and len(closure - selected_set) > len(best_closure - selected_set)) or (best_closure is None and gain >= best_gain):\n                best_gain = gain\n                best_closure = closure\n        # Accept non-negative gain closures; small negative may be accepted later to meet min_card\n        if best_closure is not None and best_gain > -1e-12:\n            new_items = best_closure - selected_set\n            if new_items:\n                selected_set.update(new_items)\n                improved = True\n        else:\n            break\n\n    # If we haven't met min_card, add best feasible closures even if negative\n    while len(selected_set) < min_card:\n        best_gain = float(\"-inf\")\n        best_closure = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closures[i]\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            if (gain > best_gain) or (abs(gain - best_gain) < 1e-12 and best_closure is not None and len(closure - selected_set) > len(best_closure - selected_set)) or (best_closure is None and gain >= best_gain):\n                best_gain = gain\n                best_closure = closure\n        if best_closure is None:\n            # no feasible closures left\n            break\n        selected_set.update(best_closure - selected_set)\n\n    # Safety trim if we're over max_card (should rarely happen due to checks)\n    if len(selected_set) > max_card:\n        # compute approximate item score = weight + sum interactions with others in selected_set\n        def item_score(i):\n            s = 0.0\n            if 0 <= i < len(weights):\n                try:\n                    s += float(weights[i])\n                except Exception:\n                    pass\n            for j in selected_set:\n                if j == i:\n                    continue\n                s += interactions.get(i, {}).get(j, 0.0)\n            return s\n        sorted_items = sorted(selected_set, key=lambda x: item_score(x), reverse=True)\n        selected_set = set(sorted_items[:max_card])\n\n    result = {\"selection\": {\"variables\": sorted(int(x) for x in selected_set)}}\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n\n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n\n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n\n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n\n    result_str = stdout_capture.getvalue()\n    return result_str\n\n```\n\nPerformance metrics:\nCombined score to maximize: 0.40\nfeasible: True; selection_size: 10; raw_score: 122.55\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    This is a greedy baseline - evolution will improve this.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    # Simple greedy: select items with highest weights first\n    # This is a baseline - evolution will find better strategies\n    n = len(weights)\n    selected = []\n    \n    # Create score list (weight + interaction potential)\n    scores = []\n    for i in range(n):\n        score = weights[i] if i < len(weights) else 0.0\n        # Add potential interaction value\n        for k, v in interactions.items():\n            try:\n                u, w = map(int, k.split(\",\"))\n                if u == i or w == i:\n                    score += abs(v) * 0.5  # Potential value\n            except:\n                pass\n        scores.append((score, i))\n    \n    # Sort by score descending\n    scores.sort(reverse=True)\n    \n    # Greedy selection respecting constraints\n    selected_set = set()\n    for score, i in scores:\n        if len(selected_set) >= cardinality_bounds[1]:\n            break\n            \n        # Check mutex constraints\n        can_add = True\n        for a, b in mutex:\n            if (a == i and b in selected_set) or (b == i and a in selected_set):\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n            \n        # Check group constraints (at most one per group)\n        for grp_vars in groups.values():\n            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n        \n        # Check precedence (if j selected, i must be selected)\n        precedence_ok = True\n        for pred_i, pred_j in precedence:\n            if pred_j == i and pred_i not in selected_set:\n                precedence_ok = False\n                break\n        \n        if not precedence_ok:\n            continue\n        \n        # Add if we meet minimum cardinality or have room\n        if len(selected_set) < cardinality_bounds[1]:\n            selected_set.add(i)\n            selected.append(i)\n    \n    # Ensure minimum cardinality\n    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n        for i in range(n):\n            if i not in selected_set:\n                selected_set.add(i)\n                selected.append(i)\n                break\n    \n    # Output result\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n    \n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n    \n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n    \n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n    \n    result_str = stdout_capture.getvalue()\n    return result_str\n\n\n```\n\nPerformance metrics:\nCombined score to maximize: 0.35\nfeasible: True; selection_size: 10; raw_score: 106.51\n\n\n# Current program\n\nHere is the current program we are trying to improve (you will need to \npropose a new program with the same inputs and outputs as the original \nprogram, but with improved internal implementation):\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Improved solver for the Synergistic Dependency Selection problem.\n\n    - Reads JSON from stdin with \"requirements\" and \"catalog\".\n    - Produces JSON to stdout with \"selection\": {\"variables\": [...] }.\n    - Uses a precedence-aware marginal-gain greedy algorithm that:\n        * when adding an item, also includes its required predecessors (closure),\n        * computes the marginal objective (weights + pairwise interactions),\n        * checks mutex/group/cardinality feasibility for the closure before adding.\n    - Adds a lightweight one-step lookahead: when evaluating a candidate closure,\n      also consider the best single subsequent closure that would be feasible after\n      adding the candidate. A discounted portion of that subsequent gain is added\n      to the candidate score to prefer moves that enable strong follow-ups.\n    \"\"\"\n    import re\n\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n\n    # Extract constraints\n    weights = list(requirements.get(\"weights\", []))\n    interactions_raw = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    min_card, max_card = (cardinality_bounds + [len(weights), len(weights)])[:2]\n    mutex = [tuple(m) for m in requirements.get(\"mutex\", [])]\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n\n    n = len(weights)\n\n    # Parse interactions into dict of tuple->float for quick lookup (undirected)\n    interactions = {}\n    for k, v in interactions_raw.items():\n        try:\n            if isinstance(k, str):\n                # allow \"u,v\" or \"u v\"\n                parts = re.split(r'\\s*,\\s*|\\s+', k.strip())\n                if len(parts) >= 2:\n                    u = int(parts[0]); w = int(parts[1])\n                else:\n                    continue\n            elif isinstance(k, (list, tuple)) and len(k) >= 2:\n                u = int(k[0]); w = int(k[1])\n            else:\n                continue\n            interactions[(u, w)] = float(v)\n            interactions[(w, u)] = float(v)\n        except Exception:\n            # skip malformed keys\n            continue\n\n    # Build precedence graph: if (p, j) then p is a prerequisite of j\n    preds = {i: set() for i in range(n)}\n    succs = {i: set() for i in range(n)}\n    for entry in precedence:\n        try:\n            a, b = entry\n            a = int(a); b = int(b)\n            preds[b].add(a)\n            succs[a].add(b)\n        except Exception:\n            continue\n\n    # Precompute ancestors (transitive closure of preds) using DFS/memoization\n    ancestor_cache = {}\n\n    def get_ancestors(i):\n        if i in ancestor_cache:\n            return ancestor_cache[i].copy()\n        res = set()\n        stack = [i]\n        while stack:\n            cur = stack.pop()\n            for p in preds.get(cur, []):\n                if p not in res:\n                    res.add(p)\n                    stack.append(p)\n        ancestor_cache[i] = res.copy()\n        return res\n\n    # Precompute closures (ancestors + self) and cache them for fast reuse\n    closure_cache = {i: get_ancestors(i).union({i}) for i in range(n)}\n\n    # Map variable -> group (assume at most one group membership; if multiple, first wins)\n    var_to_group = {}\n    for gname, vars_list in groups.items():\n        for v in vars_list:\n            try:\n                var_to_group[int(v)] = gname\n            except Exception:\n                pass\n\n    # Helper: check feasibility of adding a closure set given current selected_set\n    def feasible_closure(closure_set, selected_set):\n        # Cardinality\n        if len(selected_set) + len(closure_set - selected_set) > max_card:\n            return False\n        # Mutex: none of closure can conflict with each other or with selected_set\n        for a, b in mutex:\n            if a in closure_set and b in closure_set:\n                return False\n            if (a in closure_set and b in selected_set) or (b in closure_set and a in selected_set):\n                return False\n        # Group: ensure at most one per group overall\n        # Build per-group counts\n        group_counts = {}\n        for v in selected_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in closure_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: closure itself must include ancestors for each element (or they are already selected)\n        for v in closure_set:\n            if not get_ancestors(v).issubset(closure_set.union(selected_set)):\n                return False\n        return True\n\n    # Compute marginal gain of adding closure_set (items that will be newly included)\n    def marginal_gain(closure_set, selected_set):\n        new_items = set(closure_set) - set(selected_set)\n        if not new_items:\n            return 0.0\n        gain = 0.0\n        for i in new_items:\n            if 0 <= i < len(weights):\n                gain += float(weights[i])\n        # interactions among new items\n        new_list = list(new_items)\n        for a in range(len(new_list)):\n            for b in range(a + 1, len(new_list)):\n                gain += interactions.get((new_list[a], new_list[b]), 0.0)\n        # interactions between new items and already selected\n        for i in new_items:\n            for j in selected_set:\n                gain += interactions.get((i, j), 0.0)\n        return gain\n\n    # Greedy loop: at each step try to add an item (and its ancestors) with max marginal gain\n    # Enhanced with small one-step lookahead: for each candidate closure consider the best\n    # subsequent single-closure gain and add a discounted fraction to the candidate score.\n    selected_set = set()\n    improved = True\n    LOOKAHEAD_DISCOUNT = 0.5  # weight of the best next-step gain when scoring current candidate\n    while len(selected_set) < max_card and improved:\n        improved = False\n        best_score = float(\"-inf\")\n        best_gain = float(\"-inf\")\n        best_closure = None\n        # Consider candidates not already selected\n        for i in range(n):\n            if i in selected_set:\n                continue\n            # closure includes i and its ancestors (cached)\n            closure = closure_cache.get(i, {i})\n            # Only consider closures that are feasible\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # quick capacity pruning: if closure would add more items than remaining slots, skip\n            if len(closure - selected_set) > (max_card - len(selected_set)):\n                continue\n            # Compute one-step lookahead: best feasible single closure after adding this closure\n            lookahead_best = 0.0\n            if len(selected_set) + len(closure - selected_set) < max_card:\n                # simulate new selected set\n                sim_selected = selected_set.union(closure)\n                # find best single candidate (could be more expensive, so limit exploration)\n                # We will search all but with a cheap break if we find strong positive gains.\n                for j in range(n):\n                    if j in sim_selected:\n                        continue\n                    closure_j = closure_cache.get(j, {j})\n                    if not feasible_closure(closure_j, sim_selected):\n                        continue\n                    gain_j = marginal_gain(closure_j, sim_selected)\n                    if gain_j > lookahead_best:\n                        lookahead_best = gain_j\n                        # small optimization: if it's very large, we can accept it\n                        if lookahead_best > abs(gain) * 2 + 1e-9:\n                            break\n            total_score = gain + LOOKAHEAD_DISCOUNT * max(0.0, lookahead_best)\n            # Prefer closures that add more items when scores equal (helps reach min_card)\n            if (total_score > best_score) or (abs(total_score - best_score) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_score = total_score\n                best_gain = gain\n                best_closure = closure\n        # If we found a non-negative-gain move, take it\n        if best_closure is not None and best_gain > -1e-12:\n            to_add = set(best_closure) - selected_set\n            if to_add:\n                selected_set.update(to_add)\n                improved = True\n        else:\n            # No non-negative gain move; stop greedy improvements\n            break\n\n    # If we still haven't met minimum cardinality, greedily add best feasible closures regardless of gain\n    # Use same closure cache and prefer closures that may enable good follow-ups.\n    while len(selected_set) < min_card:\n        best_score = float(\"-inf\")\n        best_gain = float(\"-inf\")\n        best_closure = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closure_cache.get(i, {i})\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # lookahead as before (but smaller budget)\n            lookahead_best = 0.0\n            if len(selected_set) + len(closure - selected_set) < max_card:\n                sim_selected = selected_set.union(closure)\n                for j in range(n):\n                    if j in sim_selected:\n                        continue\n                    closure_j = closure_cache.get(j, {j})\n                    if not feasible_closure(closure_j, sim_selected):\n                        continue\n                    gain_j = marginal_gain(closure_j, sim_selected)\n                    if gain_j > lookahead_best:\n                        lookahead_best = gain_j\n            total_score = gain + LOOKAHEAD_DISCOUNT * max(0.0, lookahead_best)\n            if (total_score > best_score) or (abs(total_score - best_score) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_score = total_score\n                best_gain = gain\n                best_closure = closure\n        if best_closure is None:\n            # No feasible closure remains; break to avoid infinite loop\n            break\n        selected_set.update(set(best_closure) - selected_set)\n\n    # Final trim if over max_card (shouldn't happen due to checks) - keep highest-weight items\n    if len(selected_set) > max_card:\n        # score items by marginal contribution relative to selected (approx): weight + interactions with others\n        def item_score(i):\n            s = float(weights[i]) if i < len(weights) else 0.0\n            for j in selected_set:\n                if j == i:\n                    continue\n                s += interactions.get((i, j), 0.0)\n            return s\n        sorted_items = sorted(selected_set, key=item_score, reverse=True)\n        selected_set = set(sorted_items[:max_card])\n\n    result = {\n        \"selection\": {\n            \"variables\": sorted(int(x) for x in selected_set)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n\n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n\n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n\n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n\n    result_str = stdout_capture.getvalue()\n    return result_str\n```\n\nHere are the performance metrics of the program:\n\nCombined score to maximize: 0.40\nfeasible: True; selection_size: 10; raw_score: 122.55\n\n# Task\n\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs as the original program, but with improved internal implementation.\n"
            },
            {
              "role": "assistant",
              "content": "<NAME>\nmodular_greedy_local_search\n</NAME>\n\n<DESCRIPTION>\nThis redesign restructures the solver into a clear pipeline of small modules (parsing, preprocessing, scoring, selection, local improvement). Key structural changes:\n- Modular functions for parsing, building precedence closures, interaction maps, feasibility and scoring. This improves maintainability and testability.\n- Precomputes transitive closures in a single pass and caches closures, sizes and base weights for fast reuse.\n- Keeps the original precedence-aware closure-based greedy core but uses ranked candidate exploration and a bounded one-step lookahead restricted to top candidates to reduce wasted work.\n- Adds a controlled local-search (removal+add swap) phase that tries beneficial replacements by simulating removals of \"removable\" elements (those without selected successors). This often improves objective while preserving feasibility.\n- Uses clearer dataflow: parse -> preprocess -> greedy -> local_improve -> finalize.\n\nThese changes keep the same input/output contract but typically improve objective value and robustness while keeping runtime reasonable.\n</DESCRIPTION>\n\n<CODE>\n```python\n#!/usr/bin/env python3\n\"\"\"\nEVOLVE-BLOCK-START\nModular solver for Synergistic Dependency Selection (SDS).\nThe EVOLVE block contains the evolved solver implementation.\n\"\"\"\nimport json\nimport sys\n\ndef solve_sds():\n    import re\n    from collections import defaultdict, deque\n\n    # ---------- Parsing ----------\n    data = json.load(sys.stdin)\n    requirements = data.get(\"requirements\", {}) or {}\n    catalog = data.get(\"catalog\", {}) or {}\n\n    weights = list(requirements.get(\"weights\", []) or [])\n    raw_interactions = requirements.get(\"interactions\", {}) or {}\n    card_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)]) or [0, len(weights)]\n    min_card = int(card_bounds[0]) if len(card_bounds) > 0 else 0\n    max_card = int(card_bounds[1]) if len(card_bounds) > 1 else len(weights)\n    mutex_list = requirements.get(\"mutex\", []) or []\n    groups = requirements.get(\"groups\", {}) or {}\n    precedence = requirements.get(\"precedence\", []) or []\n\n    n = len(weights)\n\n    # ---------- Preprocessing ----------\n    # Build interaction adjacency: interactions[u][v] = value\n    interactions = defaultdict(dict)\n    def parse_interaction_key(k):\n        try:\n            if isinstance(k, str):\n                parts = re.split(r'\\s*,\\s*|\\s+', k.strip())\n                if len(parts) >= 2:\n                    return int(parts[0]), int(parts[1])\n            elif isinstance(k, (list, tuple)) and len(k) >= 2:\n                return int(k[0]), int(k[1])\n        except Exception:\n            return None\n        return None\n\n    for k, v in raw_interactions.items():\n        parsed = parse_interaction_key(k)\n        try:\n            val = float(v)\n        except Exception:\n            continue\n        if parsed is None:\n            continue\n        u, w = parsed\n        if 0 <= u < n and 0 <= w < n:\n            interactions[u][w] = interactions[u].get(w, 0.0) + val\n            interactions[w][u] = interactions[w].get(u, 0.0) + val\n\n    # Mutex map\n    mutex_map = defaultdict(set)\n    for pair in mutex_list:\n        try:\n            a, b = pair\n            a = int(a); b = int(b)\n            if 0 <= a < n and 0 <= b < n:\n                mutex_map[a].add(b); mutex_map[b].add(a)\n        except Exception:\n            continue\n\n    # Group map: variable -> group (first membership wins)\n    var_to_group = {}\n    for gname, vars_list in groups.items():\n        for v in vars_list:\n            try:\n                idx = int(v)\n                if 0 <= idx < n and idx not in var_to_group:\n                    var_to_group[idx] = str(gname)\n            except Exception:\n                continue\n\n    # Precedence graph\n    preds = defaultdict(set)\n    succs = defaultdict(set)\n    for entry in precedence:\n        try:\n            a, b = entry\n            a = int(a); b = int(b)\n            if 0 <= a < n and 0 <= b < n:\n                preds[b].add(a)\n                succs[a].add(b)\n        except Exception:\n            continue\n\n    # Compute transitive ancestors (closure of preds) using iterative DFS per node with memoization\n    ancestor_cache = {}\n    def compute_ancestors(i):\n        if i in ancestor_cache:\n            return ancestor_cache[i]\n        res = set()\n        stack = list(preds.get(i, []))\n        seen = set(stack)\n        while stack:\n            cur = stack.pop()\n            res.add(cur)\n            for p in preds.get(cur, ()):\n                if p not in seen:\n                    seen.add(p)\n                    stack.append(p)\n        ancestor_cache[i] = res\n        return res\n\n    closures = [None] * n\n    closure_sizes = [0] * n\n    closure_base_weight = [0.0] * n  # sum of weights in closure (may include out-of-range indices protection)\n    for i in range(n):\n        anc = compute_ancestors(i)\n        c = set(anc)\n        c.add(i)\n        closures[i] = c\n        closure_sizes[i] = len(c)\n        s = 0.0\n        for v in c:\n            if 0 <= v < len(weights):\n                try:\n                    s += float(weights[v])\n                except Exception:\n                    pass\n        closure_base_weight[i] = s\n\n    # Utility functions for interactions and scoring\n    def interaction(u, v):\n        return interactions.get(u, {}).get(v, 0.0)\n\n    def total_score(selected_set):\n        # Sum weights\n        s = 0.0\n        for i in selected_set:\n            if 0 <= i < len(weights):\n                try:\n                    s += float(weights[i])\n                except Exception:\n                    pass\n        # Pairwise interactions (each pair counted once)\n        sel_list = list(selected_set)\n        L = len(sel_list)\n        for a in range(L):\n            u = sel_list[a]\n            for b in range(a+1, L):\n                v = sel_list[b]\n                s += interaction(u, v)\n        return s\n\n    # Feasibility check for closure given a base selected_set\n    def feasible_closure(closure_set, selected_set):\n        # new items to add\n        new_items = closure_set - selected_set\n        # cardinality\n        if len(selected_set) + len(new_items) > max_card:\n            return False\n        # mutex: none of closure can conflict with selected or each other\n        for v in new_items:\n            for c in mutex_map.get(v, ()):\n                if c in selected_set or c in new_items:\n                    return False\n        # group counts\n        group_counts = {}\n        for v in selected_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in new_items:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # precedence: closure must provide ancestors for each of its elements or they already in selected_set\n        for v in closure_set:\n            for a in preds.get(v, ()):\n                if a not in closure_set and a not in selected_set:\n                    return False\n        return True\n\n    # Compute marginal_gain for adding closure to selected_set (exact)\n    def marginal_gain(closure_set, selected_set):\n        new_items = closure_set - selected_set\n        if not new_items:\n            return 0.0\n        gain = 0.0\n        for i in new_items:\n            if 0 <= i < len(weights):\n                try:\n                    gain += float(weights[i])\n                except Exception:\n                    pass\n        # interactions among new items\n        new_list = list(new_items)\n        L = len(new_list)\n        for a in range(L):\n            u = new_list[a]\n            for b in range(a+1, L):\n                v = new_list[b]\n                gain += interaction(u, v)\n        # interactions between new_items and selected_set\n        for u in new_items:\n            for v in selected_set:\n                gain += interaction(u, v)\n        return gain\n\n    # ---------- Greedy selection (closure-based) ----------\n    selected_set = set()\n    current_score = 0.0\n\n    LOOKAHEAD_DISCOUNT = 0.45  # a tuned discount factor\n\n    # Pre-rank candidates by a simple heuristic to limit expensive lookahead:\n    # heuristic = closure_base_weight + sum(max interaction with closure) approx\n    # We'll rank on-the-fly each iteration based on marginal_gain estimate without lookahead.\n    while len(selected_set) < max_card:\n        best_score = float(\"-inf\")\n        best_closure = None\n        best_gain = 0.0\n\n        # Evaluate all candidates but compute a cheap marginal first, then do lookahead for top-K\n        candidate_estimates = []\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closures[i]\n            # Quick capacity pruning\n            new_items = closure - selected_set\n            if len(selected_set) + len(new_items) > max_card:\n                continue\n            if not feasible_closure(closure, selected_set):\n                continue\n            # cheap marginal (weights sum + approx interactions with selected): use marginal_gain\n            mg = marginal_gain(closure, selected_set)\n            candidate_estimates.append((mg, i, closure))\n\n        if not candidate_estimates:\n            break\n\n        # Sort descending by mg and prefer larger closures when tie\n        candidate_estimates.sort(key=lambda x: (x[0], len(x[2] - selected_set)), reverse=True)\n\n        # Limit lookahead to top_k candidates to control cost\n        top_k = min(12, len(candidate_estimates))\n        for idx in range(top_k):\n            mg, i, closure = candidate_estimates[idx]\n            # compute lookahead: best single closure after simulating adding this closure\n            total_score_candidate = mg\n            # if there is still capacity for one more closure\n            if len(selected_set) + len(closure - selected_set) < max_card:\n                sim_selected = selected_set.union(closure)\n                best_follow = 0.0\n                # consider a smaller subset of candidates for follow-up (next best excluding those in sim_selected)\n                follow_k = min(10, n)\n                # follow-up list reuse candidate_estimates order: evaluate top follow_k that are not in sim_selected\n                fcount = 0\n                for mg2, j, closure_j in candidate_estimates:\n                    if j in sim_selected:\n                        continue\n                    if not feasible_closure(closure_j, sim_selected):\n                        continue\n                    g2 = marginal_gain(closure_j, sim_selected)\n                    if g2 > best_follow:\n                        best_follow = g2\n                    fcount += 1\n                    if fcount >= follow_k:\n                        break\n                if best_follow > 0:\n                    total_score_candidate += LOOKAHEAD_DISCOUNT * best_follow\n            # choose best by total_score_candidate, tie-breaker larger closure\n            if (total_score_candidate > best_score) or (abs(total_score_candidate - best_score) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_score = total_score_candidate\n                best_closure = closure\n                best_gain = mg\n\n        # Accept if non-negative gain (small negative tolerances avoided)\n        if best_closure is None:\n            break\n        if best_gain > -1e-12:\n            to_add = best_closure - selected_set\n            if to_add:\n                selected_set.update(to_add)\n                current_score = total_score(selected_set)\n                # continue greedy\n                continue\n            else:\n                # nothing new to add\n                break\n        else:\n            break\n\n    # If min_card not reached, add best feasible closures regardless of sign (prefer larger)\n    while len(selected_set) < min_card:\n        best_gain = float(\"-inf\")\n        best_closure = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closures[i]\n            if not feasible_closure(closure, selected_set):\n                continue\n            mg = marginal_gain(closure, selected_set)\n            if (mg > best_gain) or (abs(mg - best_gain) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_gain = mg\n                best_closure = closure\n        if best_closure is None:\n            break\n        selected_set.update(best_closure - selected_set)\n        current_score = total_score(selected_set)\n\n    # ---------- Local improvement: removable-item swaps ----------\n    # Identify removable items: selected items that have no selected successors (safe to remove alone)\n    # We'll attempt limited number of simulated swaps: remove up to need_slots removable items to add a new closure if net score improves.\n    improvement = True\n    max_local_iters = 200\n    iter_count = 0\n    while improvement and iter_count < max_local_iters:\n        improvement = False\n        iter_count += 1\n        # update removable set\n        removable = set()\n        for v in selected_set:\n            # if no successor in selected_set, it's removable\n            if not any((succ in selected_set) for succ in succs.get(v, ())):\n                removable.add(v)\n        # prepare list of candidate closures not already satisfied\n        candidates = []\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closures[i]\n            # compute new_items\n            new_items = closure - selected_set\n            if not new_items:\n                continue\n            candidates.append((i, closure, new_items))\n        # sort candidates by marginal_gain descending to try promising first\n        candidates.sort(key=lambda x: marginal_gain(x[1], selected_set), reverse=True)\n        # try top some candidates\n        tried = 0\n        for i, closure, new_items in candidates:\n            if tried >= 60:\n                break\n            tried += 1\n            slots_avail = max_card - len(selected_set)\n            need_slots = max(0, len(new_items) - slots_avail)\n            if need_slots == 0:\n                # can add directly if feasible\n                if feasible_closure(closure, selected_set):\n                    mg = marginal_gain(closure, selected_set)\n                    if mg > 1e-12:\n                        selected_set.update(closure - selected_set)\n                        current_score = total_score(selected_set)\n                        improvement = True\n                        break\n                continue\n            # need to remove need_slots items from removable to make room\n            if len(removable) < need_slots:\n                continue\n            # compute individual removal scores relative to current selected_set (loss if removed)\n            removal_scores = []\n            for r in removable:\n                # compute score contribution of r in current selected_set\n                # contribution = weight(r) + interactions(r, others in selected_set)\n                contrib = 0.0\n                if 0 <= r < len(weights):\n                    try:\n                        contrib += float(weights[r])\n                    except Exception:\n                        pass\n                for o in selected_set:\n                    if o == r:\n                        continue\n                    contrib += interaction(r, o)\n                removal_scores.append((contrib, r))\n            # choose candidates to remove with smallest contribution (min loss)\n            removal_scores.sort(key=lambda x: x[0])\n            # try a few small removal combinations (greedy pick lowest need_slots)\n            removals = set([x[1] for x in removal_scores[:need_slots]])\n            # Ensure none of removals are in closure (we don't want to remove items that the closure will re-add - though allowed, it's wasteful)\n            if removals & closure:\n                # prefer next best set that doesn't intersect closure if possible\n                alt = []\n                for cval, rv in removal_scores:\n                    if rv not in closure:\n                        alt.append(rv)\n                        if len(alt) >= need_slots:\n                            break\n                if len(alt) < need_slots:\n                    # can't find non-intersecting removals; skip this candidate\n                    continue\n                removals = set(alt[:need_slots])\n            # simulate new selected\n            sim_selected = set(selected_set) - removals\n            if not feasible_closure(closure, sim_selected):\n                continue\n            sim_after = sim_selected.union(closure)\n            # compute delta\n            sim_score = total_score(sim_after)\n            delta = sim_score - current_score\n            if delta > 1e-9:\n                # perform swap\n                selected_set = sim_after\n                current_score = sim_score\n                improvement = True\n                break\n        # continue loop until no improvements\n    # ---------- Final safety trim ----------\n    if len(selected_set) > max_card:\n        # keep top-scoring items by approximate contribution\n        def item_contribution(i, sel):\n            s = 0.0\n            if 0 <= i < len(weights):\n                try:\n                    s += float(weights[i])\n                except Exception:\n                    pass\n            for j in sel:\n                if j == i: continue\n                s += interaction(i, j)\n            return s\n        sorted_items = sorted(selected_set, key=lambda x: item_contribution(x, selected_set), reverse=True)\n        selected_set = set(sorted_items[:max_card])\n        current_score = total_score(selected_set)\n\n    # Ensure final feasibility: if constraints violated (very unlikely), fallback to greedy simple trim\n    def validate_and_fix(sel):\n        # fix group conflicts: keep highest contribution per group\n        sel = set(sel)\n        groups_rev = {}\n        for v in list(sel):\n            g = var_to_group.get(v)\n            if g is None: continue\n            groups_rev.setdefault(g, []).append(v)\n        for g, members in groups_rev.items():\n            if len(members) <= 1:\n                continue\n            # sort members by contribution and keep best\n            members.sort(key=lambda x: (weights[x] if 0<=x<len(weights) else 0.0) + sum(interaction(x,y) for y in sel if y!=x), reverse=True)\n            for rm in members[1:]:\n                sel.discard(rm)\n        # fix mutex conflicts by dropping the lower-contributing member\n        for a in range(n):\n            for b in mutex_map.get(a, ()):\n                if a < b and a in sel and b in sel:\n                    # drop the one with smaller contribution\n                    ca = (weights[a] if 0<=a<len(weights) else 0.0) + sum(interaction(a,y) for y in sel if y!=a)\n                    cb = (weights[b] if 0<=b<len(weights) else 0.0) + sum(interaction(b,y) for y in sel if y!=b)\n                    if ca >= cb:\n                        sel.discard(b)\n                    else:\n                        sel.discard(a)\n        # enforce precedence: if some selected lacks its ancestors, add ancestors if feasible, otherwise drop the descendant\n        changed = True\n        while changed:\n            changed = False\n            for v in list(sel):\n                for a in preds.get(v, ()):\n                    if a not in sel:\n                        # try to add ancestor if feasible\n                        if len(sel) < max_card and (a not in sel) and feasible_closure({a}, sel):\n                            sel.add(a)\n                            changed = True\n                        else:\n                            # cannot add ancestor: drop v\n                            sel.discard(v)\n                            changed = True\n                            break\n        # enforce cardinality <= max_card by dropping lowest contribution items\n        while len(sel) > max_card:\n            contribs = [( (weights[x] if 0<=x<len(weights) else 0.0) + sum(interaction(x,y) for y in sel if y!=x), x) for x in sel]\n            contribs.sort()\n            sel.discard(contribs[0][1])\n        return sel\n\n    selected_set = validate_and_fix(selected_set)\n\n    result = {\"selection\": {\"variables\": sorted(int(x) for x in selected_set)}}\n    print(json.dumps(result))\n\n\nif __name__ == \"__main__\":\n    solve_sds()\n# EVOLVE-BLOCK-END\n```\n</CODE>"
            }
          ],
          "model_name": "gpt-5-mini",
          "kwargs": {
            "temperature": 1.0,
            "max_output_tokens": 8192
          },
          "input_tokens": 9046,
          "output_tokens": 5861,
          "cost": 0.0139835,
          "input_cost": 0.0022615,
          "output_cost": 0.011722,
          "thought": "",
          "model_posteriors": {
            "gpt-5-mini": 1.0
          }
        },
        "diff_summary": {
          "added": 223,
          "deleted": 0,
          "modified": 172
        },
        "embed_cost": 8.238000000000001e-05,
        "novelty_cost": 0.0,
        "stdout_log": "Evaluating program: sds_dataset_output/problem_0/gen_8/main.py\nSaving results to: sds_dataset_output/problem_0/gen_8/results\nEvaluation error: unterminated triple-quoted string literal (detected at line 527) (main.py, line 502)\nCorrectness and error status saved to sds_dataset_output/problem_0/gen_8/results/correct.json\nMetrics saved to sds_dataset_output/problem_0/gen_8/results/metrics.json\nEvaluation or Validation failed: unterminated triple-quoted string literal (detected at line 527) (main.py, line 502)\nMetrics:\n  combined_score: 0.0\n  execution_time_mean: 0.0\n  execution_time_std: 0.0\n  num_successful_runs: 0\n  num_valid_runs: 0\n  num_invalid_runs: 0\n  all_validation_errors: []\n",
        "stderr_log": "",
        "code_analysis_metrics": {
          "cyclomatic_complexity": 164,
          "average_cyclomatic_complexity": 164,
          "halstead_volume": 3597.842930258243,
          "halstead_difficulty": 1.0,
          "halstead_effort": 3597.842930258243,
          "lines_of_code": 527,
          "logical_lines_of_code": 489,
          "comments": 0,
          "maintainability_index": 0,
          "max_nesting_depth": 2,
          "complexity_score": 0.93
        }
      },
      "in_archive": false
    },
    {
      "id": "87cfd981-141a-450b-8dd5-c3aee0b8423c",
      "code": "\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Crossover solver for the Synergistic Dependency Selection problem.\n\n    Reads JSON from stdin with \"requirements\" and \"catalog\", and prints JSON\n    with \"selection\": {\"variables\": [...] }.\n\n    Strategy:\n    - Parse inputs robustly.\n    - Build adjacency map for interactions for efficient marginal gain computation.\n    - Precompute transitive ancestor closure for precedence.\n    - For each candidate, consider adding its closure (itself + ancestors).\n    - Greedily add the closure with maximum marginal gain while respecting\n      mutex, groups, and cardinality. Tie-break in favor of larger closures to\n      satisfy minimum cardinality.\n    - If minimum cardinality not reached, add best feasible closures even if negative.\n    - Lightweight local-search: attempt beneficial 1-for-1 swaps (remove one selected,\n      add a candidate closure) that strictly increase the objective while preserving feasibility.\n    - Trim if needed by approximate item scores.\n    \"\"\"\n    import re\n    from collections import defaultdict, deque\n\n    data = json.load(sys.stdin)\n    requirements = data.get(\"requirements\", {}) or {}\n    catalog = data.get(\"catalog\", {}) or {}\n\n    weights = list(requirements.get(\"weights\", []) or [])\n    raw_interactions = requirements.get(\"interactions\", {}) or {}\n    card_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)]) or [0, len(weights)]\n    min_card = int(card_bounds[0]) if len(card_bounds) > 0 else 0\n    max_card = int(card_bounds[1]) if len(card_bounds) > 1 else len(weights)\n    mutex_list = requirements.get(\"mutex\", []) or []\n    groups = requirements.get(\"groups\", {}) or {}\n    precedence = requirements.get(\"precedence\", []) or []\n\n    n = len(weights)\n\n    # Parse interactions into adjacency dict: interactions[u][v] = value\n    interactions = defaultdict(dict)\n    def parse_key(k):\n        # return (u,v) or None\n        try:\n            if isinstance(k, str):\n                parts = re.split(r'\\s*,\\s*|\\s+', k.strip())\n                if len(parts) >= 2:\n                    return int(parts[0]), int(parts[1])\n            elif isinstance(k, (list, tuple)) and len(k) >= 2:\n                return int(k[0]), int(k[1])\n            elif isinstance(k, int):\n                return None\n        except Exception:\n            return None\n        return None\n\n    for k, v in raw_interactions.items():\n        parsed = parse_key(k)\n        try:\n            val = float(v)\n        except Exception:\n            continue\n        if parsed is None:\n            continue\n        u, w = parsed\n        if 0 <= u < n and 0 <= w < n:\n            interactions[u][w] = interactions[u].get(w, 0.0) + val\n            interactions[w][u] = interactions[w].get(u, 0.0) + val\n\n    # Build mutex map for quick conflict checks\n    mutex_map = defaultdict(set)\n    for pair in mutex_list:\n        try:\n            a, b = pair\n            a = int(a); b = int(b)\n            if 0 <= a < n and 0 <= b < n:\n                mutex_map[a].add(b)\n                mutex_map[b].add(a)\n        except Exception:\n            continue\n\n    # Normalize groups: map var -> group name, allow string/int keys\n    var_to_group = {}\n    for gname, vars_list in groups.items():\n        for v in vars_list:\n            try:\n                idx = int(v)\n                if 0 <= idx < n and gname is not None:\n                    # first membership wins\n                    if idx not in var_to_group:\n                        var_to_group[idx] = str(gname)\n            except Exception:\n                continue\n\n    # Build precedence graph (directed: p -> j means p is prerequisite of j)\n    preds = defaultdict(set)\n    succs = defaultdict(set)\n    for entry in precedence:\n        try:\n            a, b = entry\n            a = int(a); b = int(b)\n            if 0 <= a < n and 0 <= b < n:\n                preds[b].add(a)\n                succs[a].add(b)\n        except Exception:\n            continue\n\n    # Precompute transitive ancestor closure for each node using DFS/BFS\n    ancestor_closure = [set() for _ in range(n)]\n    for i in range(n):\n        # BFS/DFS from i to collect all ancestors\n        stack = list(preds.get(i, []))\n        seen = set(stack)\n        while stack:\n            cur = stack.pop()\n            ancestor_closure[i].add(cur)\n            for p in preds.get(cur, []):\n                if p not in seen:\n                    seen.add(p)\n                    stack.append(p)\n\n    # closure for variable i is ancestors + i\n    closures = [set(ancestor_closure[i]) | {i} for i in range(n)]\n\n    # Feasibility check of adding closure (closure is set of vars to ensure present),\n    # given currently selected_set.\n    def feasible_closure(closure, selected_set):\n        # New items that would be added\n        new_items = closure - selected_set\n        # Cardinality check\n        if len(selected_set) + len(new_items) > max_card:\n            return False\n        # Mutex check: none of new items conflict with each other or with selected\n        for v in new_items:\n            # conflicts with selected\n            if any(conflict in selected_set for conflict in mutex_map.get(v, ())) :\n                return False\n            # conflicts with other new items\n            for conflict in mutex_map.get(v, ()):\n                if conflict in new_items:\n                    return False\n        # Group check: cannot create group count >1\n        group_counts = {}\n        for v in selected_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in new_items:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: closures already contain transitive ancestors; but if closure lacks\n        # some ancestor (shouldn't) ensure those ancestors are in selected_set\n        for v in closure:\n            for a in preds.get(v, ()):\n                if a not in closure and a not in selected_set:\n                    return False\n        return True\n\n    # Compute marginal gain for adding closure (new items = closure - selected_set)\n    def marginal_gain(closure, selected_set):\n        new_items = closure - selected_set\n        if not new_items:\n            return 0.0\n        gain = 0.0\n        # weights\n        for i in new_items:\n            if 0 <= i < len(weights):\n                try:\n                    gain += float(weights[i])\n                except Exception:\n                    pass\n        # interactions among new items\n        # iterate edges from each new item to higher-index new items to avoid double count\n        new_list = list(new_items)\n        l = len(new_list)\n        for idx in range(l):\n            u = new_list[idx]\n            # interactions with other new items\n            for v in new_list[idx+1:]:\n                gain += interactions.get(u, {}).get(v, 0.0)\n        # interactions between new items and already selected\n        for u in new_items:\n            for v in selected_set:\n                gain += interactions.get(u, {}).get(v, 0.0)\n        return gain\n\n    # Greedy selection: add closure with best marginal gain while respecting constraints\n    selected_set = set()\n    # Initial heuristic: consider items sorted by weight+abs(interaction_potential)\n    # but main loop will evaluate closures anyway, so we iterate all candidates\n    improved = True\n    while len(selected_set) < max_card and improved:\n        improved = False\n        best_gain = float(\"-inf\")\n        best_closure = None\n        # Evaluate every candidate not yet in selected_set\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closures[i]\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # Tie-breaker: prefer larger closure (helps reach min_card)\n            if (gain > best_gain) or (abs(gain - best_gain) < 1e-12 and best_closure is not None and len(closure - selected_set) > len(best_closure - selected_set)) or (best_closure is None and gain >= best_gain):\n                best_gain = gain\n                best_closure = closure\n        # Accept non-negative gain closures; small negative may be accepted later to meet min_card\n        if best_closure is not None and best_gain > -1e-12:\n            new_items = best_closure - selected_set\n            if new_items:\n                selected_set.update(new_items)\n                improved = True\n        else:\n            break\n\n    # If we haven't met min_card, add best feasible closures even if negative\n    while len(selected_set) < min_card:\n        best_gain = float(\"-inf\")\n        best_closure = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closures[i]\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            if (gain > best_gain) or (abs(gain - best_gain) < 1e-12 and best_closure is not None and len(closure - selected_set) > len(best_closure - selected_set)) or (best_closure is None and gain >= best_gain):\n                best_gain = gain\n                best_closure = closure\n        if best_closure is None:\n            # no feasible closures left\n            break\n        selected_set.update(best_closure - selected_set)\n\n    # Lightweight local-search: attempt beneficial 1-for-1 swaps.\n    # Helper: check if we can safely remove item r from selected_set (won't break precedence)\n    def can_remove(r, sel):\n        # cannot remove if r is an ancestor of any kept item\n        for u in sel:\n            if u == r:\n                continue\n            if r in ancestor_closure[u]:\n                return False\n        return True\n\n    # Compute total objective for a set (weights + undirected interactions)\n    def total_objective(sel):\n        total = 0.0\n        for u in sel:\n            if 0 <= u < len(weights):\n                try:\n                    total += float(weights[u])\n                except Exception:\n                    pass\n        # interactions counted once\n        seen = set()\n        for u in sel:\n            seen.add(u)\n            for v, val in interactions.get(u, {}).items():\n                if v in sel and v not in seen:\n                    total += val\n        return total\n\n    # Precompute current objective\n    current_obj = total_objective(selected_set)\n\n    improved = True\n    # Try swapping out one selected item for a candidate closure (which may bring multiple new items)\n    # Only single removals allowed (cheap) and removal must be safe (not required by others).\n    while improved:\n        improved = False\n        # iterate over candidates not in selected_set\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure_i = closures[i]\n            new_items = closure_i - selected_set\n            if not new_items:\n                continue\n            # If closure fits without removal, it would have been added by greedy (but still check)\n            if len(selected_set) + len(new_items) <= max_card:\n                if not feasible_closure(closure_i, selected_set):\n                    continue\n                gain_add = marginal_gain(closure_i, selected_set)\n                if gain_add > 1e-12:\n                    selected_set.update(new_items)\n                    current_obj += gain_add\n                    improved = True\n                    break\n                else:\n                    continue\n            # need to remove exactly one item to try swap (cheap heuristic)\n            # if removing one item won't free enough slots, skip\n            if len(selected_set) - 1 + len(new_items) > max_card:\n                continue\n            # examine candidate removals: prefer those with smallest approximate contribution\n            # contribution of r relative to sel\\{r}\n            removal_candidates = []\n            for r in list(selected_set):\n                if not can_remove(r, selected_set):\n                    continue\n                # compute contribution of r\n                contrib = 0.0\n                if 0 <= r < len(weights):\n                    try:\n                        contrib += float(weights[r])\n                    except Exception:\n                        pass\n                for v in selected_set:\n                    if v == r:\n                        continue\n                    contrib += interactions.get(r, {}).get(v, 0.0)\n                removal_candidates.append((contrib, r))\n            if not removal_candidates:\n                continue\n            # try removals in increasing contribution order (best chance to improve)\n            removal_candidates.sort()\n            for contrib, r in removal_candidates:\n                # simulate removal and check feasibility when adding closure_i\n                sim_sel = set(selected_set)\n                sim_sel.remove(r)\n                if not feasible_closure(closure_i, sim_sel):\n                    continue\n                # ensure closure's ancestors satisfied (feasible_closure checked)\n                gain_after = marginal_gain(closure_i, sim_sel)\n                # compute contribution of r with respect to sim_sel (i.e., interactions with remaining)\n                removed_contrib = 0.0\n                if 0 <= r < len(weights):\n                    try:\n                        removed_contrib += float(weights[r])\n                    except Exception:\n                        pass\n                for v in sim_sel:\n                    removed_contrib += interactions.get(r, {}).get(v, 0.0)\n                delta = gain_after - removed_contrib\n                if delta > 1e-12:\n                    # apply swap\n                    # remove r, add new_items\n                    selected_set.remove(r)\n                    selected_set.update(new_items)\n                    current_obj += delta\n                    improved = True\n                    break\n            if improved:\n                break\n\n    # Safety trim if we're over max_card (should rarely happen due to checks)\n    if len(selected_set) > max_card:\n        # compute approximate item score = weight + sum interactions with others in selected_set\n        def item_score(i):\n            s = 0.0\n            if 0 <= i < len(weights):\n                try:\n                    s += float(weights[i])\n                except Exception:\n                    pass\n            for j in selected_set:\n                if j == i:\n                    continue\n                s += interactions.get(i, {}).get(j, 0.0)\n            return s\n        sorted_items = sorted(selected_set, key=lambda x: item_score(x), reverse=True)\n        selected_set = set(sorted_items[:max_card])\n\n    result = {\"selection\": {\"variables\": sorted(int(x) for x in selected_set)}}\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n\n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n\n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n\n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n\n    result_str = stdout_capture.getvalue()\n    return result_str",
      "language": "python",
      "parent_id": "4387bfa1-ee61-4891-a6ab-39fef27cf870",
      "archive_inspiration_ids": [
        "41c4e403-070f-4e25-9757-64fb47df1aa9",
        "639d15e8-d1f9-4fa7-b731-6db3bcbdb880",
        "53281c24-286f-4d71-b488-5d83b2cc485d"
      ],
      "top_k_inspiration_ids": [],
      "island_idx": 0,
      "generation": 9,
      "timestamp": 1764668559.7741382,
      "code_diff": "--- a/original.py\n+++ b/original.py\n@@ -1,300 +1,414 @@\n \"\"\"\n Initial solution for Synergistic Dependency Selection (SDS) problem.\n The code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n \"\"\"\n \n import json\n import sys\n import contextlib\n \n # EVOLVE-BLOCK-START\n def solve_sds():\n     \"\"\"\n     Crossover solver for the Synergistic Dependency Selection problem.\n \n     Reads JSON from stdin with \"requirements\" and \"catalog\", and prints JSON\n     with \"selection\": {\"variables\": [...] }.\n \n     Strategy:\n     - Parse inputs robustly.\n     - Build adjacency map for interactions for efficient marginal gain computation.\n     - Precompute transitive ancestor closure for precedence.\n     - For each candidate, consider adding its closure (itself + ancestors).\n     - Greedily add the closure with maximum marginal gain while respecting\n       mutex, groups, and cardinality. Tie-break in favor of larger closures to\n       satisfy minimum cardinality.\n     - If minimum cardinality not reached, add best feasible closures even if negative.\n+    - Lightweight local-search: attempt beneficial 1-for-1 swaps (remove one selected,\n+      add a candidate closure) that strictly increase the objective while preserving feasibility.\n     - Trim if needed by approximate item scores.\n     \"\"\"\n     import re\n     from collections import defaultdict, deque\n \n     data = json.load(sys.stdin)\n     requirements = data.get(\"requirements\", {}) or {}\n     catalog = data.get(\"catalog\", {}) or {}\n \n     weights = list(requirements.get(\"weights\", []) or [])\n     raw_interactions = requirements.get(\"interactions\", {}) or {}\n     card_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)]) or [0, len(weights)]\n     min_card = int(card_bounds[0]) if len(card_bounds) > 0 else 0\n     max_card = int(card_bounds[1]) if len(card_bounds) > 1 else len(weights)\n     mutex_list = requirements.get(\"mutex\", []) or []\n     groups = requirements.get(\"groups\", {}) or {}\n     precedence = requirements.get(\"precedence\", []) or []\n \n     n = len(weights)\n \n     # Parse interactions into adjacency dict: interactions[u][v] = value\n     interactions = defaultdict(dict)\n     def parse_key(k):\n         # return (u,v) or None\n         try:\n             if isinstance(k, str):\n                 parts = re.split(r'\\s*,\\s*|\\s+', k.strip())\n                 if len(parts) >= 2:\n                     return int(parts[0]), int(parts[1])\n             elif isinstance(k, (list, tuple)) and len(k) >= 2:\n                 return int(k[0]), int(k[1])\n             elif isinstance(k, int):\n                 return None\n         except Exception:\n             return None\n         return None\n \n     for k, v in raw_interactions.items():\n         parsed = parse_key(k)\n         try:\n             val = float(v)\n         except Exception:\n             continue\n         if parsed is None:\n             continue\n         u, w = parsed\n         if 0 <= u < n and 0 <= w < n:\n             interactions[u][w] = interactions[u].get(w, 0.0) + val\n             interactions[w][u] = interactions[w].get(u, 0.0) + val\n \n     # Build mutex map for quick conflict checks\n     mutex_map = defaultdict(set)\n     for pair in mutex_list:\n         try:\n             a, b = pair\n             a = int(a); b = int(b)\n             if 0 <= a < n and 0 <= b < n:\n                 mutex_map[a].add(b)\n                 mutex_map[b].add(a)\n         except Exception:\n             continue\n \n     # Normalize groups: map var -> group name, allow string/int keys\n     var_to_group = {}\n     for gname, vars_list in groups.items():\n         for v in vars_list:\n             try:\n                 idx = int(v)\n                 if 0 <= idx < n and gname is not None:\n                     # first membership wins\n                     if idx not in var_to_group:\n                         var_to_group[idx] = str(gname)\n             except Exception:\n                 continue\n \n     # Build precedence graph (directed: p -> j means p is prerequisite of j)\n     preds = defaultdict(set)\n     succs = defaultdict(set)\n     for entry in precedence:\n         try:\n             a, b = entry\n             a = int(a); b = int(b)\n             if 0 <= a < n and 0 <= b < n:\n                 preds[b].add(a)\n                 succs[a].add(b)\n         except Exception:\n             continue\n \n     # Precompute transitive ancestor closure for each node using DFS/BFS\n     ancestor_closure = [set() for _ in range(n)]\n     for i in range(n):\n         # BFS/DFS from i to collect all ancestors\n         stack = list(preds.get(i, []))\n         seen = set(stack)\n         while stack:\n             cur = stack.pop()\n             ancestor_closure[i].add(cur)\n             for p in preds.get(cur, []):\n                 if p not in seen:\n                     seen.add(p)\n                     stack.append(p)\n \n     # closure for variable i is ancestors + i\n     closures = [set(ancestor_closure[i]) | {i} for i in range(n)]\n \n     # Feasibility check of adding closure (closure is set of vars to ensure present),\n     # given currently selected_set.\n     def feasible_closure(closure, selected_set):\n         # New items that would be added\n         new_items = closure - selected_set\n         # Cardinality check\n         if len(selected_set) + len(new_items) > max_card:\n             return False\n         # Mutex check: none of new items conflict with each other or with selected\n         for v in new_items:\n             # conflicts with selected\n             if any(conflict in selected_set for conflict in mutex_map.get(v, ())) :\n                 return False\n             # conflicts with other new items\n             for conflict in mutex_map.get(v, ()):\n                 if conflict in new_items:\n                     return False\n         # Group check: cannot create group count >1\n         group_counts = {}\n         for v in selected_set:\n             g = var_to_group.get(v)\n             if g is not None:\n                 group_counts[g] = group_counts.get(g, 0) + 1\n         for v in new_items:\n             g = var_to_group.get(v)\n             if g is not None:\n                 group_counts[g] = group_counts.get(g, 0) + 1\n                 if group_counts[g] > 1:\n                     return False\n         # Precedence: closures already contain transitive ancestors; but if closure lacks\n         # some ancestor (shouldn't) ensure those ancestors are in selected_set\n         for v in closure:\n             for a in preds.get(v, ()):\n                 if a not in closure and a not in selected_set:\n                     return False\n         return True\n \n     # Compute marginal gain for adding closure (new items = closure - selected_set)\n     def marginal_gain(closure, selected_set):\n         new_items = closure - selected_set\n         if not new_items:\n             return 0.0\n         gain = 0.0\n         # weights\n         for i in new_items:\n             if 0 <= i < len(weights):\n                 try:\n                     gain += float(weights[i])\n                 except Exception:\n                     pass\n         # interactions among new items\n         # iterate edges from each new item to higher-index new items to avoid double count\n         new_list = list(new_items)\n         l = len(new_list)\n         for idx in range(l):\n             u = new_list[idx]\n             # interactions with other new items\n             for v in new_list[idx+1:]:\n                 gain += interactions.get(u, {}).get(v, 0.0)\n         # interactions between new items and already selected\n         for u in new_items:\n             for v in selected_set:\n                 gain += interactions.get(u, {}).get(v, 0.0)\n         return gain\n \n     # Greedy selection: add closure with best marginal gain while respecting constraints\n     selected_set = set()\n     # Initial heuristic: consider items sorted by weight+abs(interaction_potential)\n     # but main loop will evaluate closures anyway, so we iterate all candidates\n     improved = True\n     while len(selected_set) < max_card and improved:\n         improved = False\n         best_gain = float(\"-inf\")\n         best_closure = None\n         # Evaluate every candidate not yet in selected_set\n         for i in range(n):\n             if i in selected_set:\n                 continue\n             closure = closures[i]\n             if not feasible_closure(closure, selected_set):\n                 continue\n             gain = marginal_gain(closure, selected_set)\n             # Tie-breaker: prefer larger closure (helps reach min_card)\n             if (gain > best_gain) or (abs(gain - best_gain) < 1e-12 and best_closure is not None and len(closure - selected_set) > len(best_closure - selected_set)) or (best_closure is None and gain >= best_gain):\n                 best_gain = gain\n                 best_closure = closure\n         # Accept non-negative gain closures; small negative may be accepted later to meet min_card\n         if best_closure is not None and best_gain > -1e-12:\n             new_items = best_closure - selected_set\n             if new_items:\n                 selected_set.update(new_items)\n                 improved = True\n         else:\n             break\n \n     # If we haven't met min_card, add best feasible closures even if negative\n     while len(selected_set) < min_card:\n         best_gain = float(\"-inf\")\n         best_closure = None\n         for i in range(n):\n             if i in selected_set:\n                 continue\n             closure = closures[i]\n             if not feasible_closure(closure, selected_set):\n                 continue\n             gain = marginal_gain(closure, selected_set)\n             if (gain > best_gain) or (abs(gain - best_gain) < 1e-12 and best_closure is not None and len(closure - selected_set) > len(best_closure - selected_set)) or (best_closure is None and gain >= best_gain):\n                 best_gain = gain\n                 best_closure = closure\n         if best_closure is None:\n             # no feasible closures left\n             break\n         selected_set.update(best_closure - selected_set)\n \n+    # Lightweight local-search: attempt beneficial 1-for-1 swaps.\n+    # Helper: check if we can safely remove item r from selected_set (won't break precedence)\n+    def can_remove(r, sel):\n+        # cannot remove if r is an ancestor of any kept item\n+        for u in sel:\n+            if u == r:\n+                continue\n+            if r in ancestor_closure[u]:\n+                return False\n+        return True\n+\n+    # Compute total objective for a set (weights + undirected interactions)\n+    def total_objective(sel):\n+        total = 0.0\n+        for u in sel:\n+            if 0 <= u < len(weights):\n+                try:\n+                    total += float(weights[u])\n+                except Exception:\n+                    pass\n+        # interactions counted once\n+        seen = set()\n+        for u in sel:\n+            seen.add(u)\n+            for v, val in interactions.get(u, {}).items():\n+                if v in sel and v not in seen:\n+                    total += val\n+        return total\n+\n+    # Precompute current objective\n+    current_obj = total_objective(selected_set)\n+\n+    improved = True\n+    # Try swapping out one selected item for a candidate closure (which may bring multiple new items)\n+    # Only single removals allowed (cheap) and removal must be safe (not required by others).\n+    while improved:\n+        improved = False\n+        # iterate over candidates not in selected_set\n+        for i in range(n):\n+            if i in selected_set:\n+                continue\n+            closure_i = closures[i]\n+            new_items = closure_i - selected_set\n+            if not new_items:\n+                continue\n+            # If closure fits without removal, it would have been added by greedy (but still check)\n+            if len(selected_set) + len(new_items) <= max_card:\n+                if not feasible_closure(closure_i, selected_set):\n+                    continue\n+                gain_add = marginal_gain(closure_i, selected_set)\n+                if gain_add > 1e-12:\n+                    selected_set.update(new_items)\n+                    current_obj += gain_add\n+                    improved = True\n+                    break\n+                else:\n+                    continue\n+            # need to remove exactly one item to try swap (cheap heuristic)\n+            # if removing one item won't free enough slots, skip\n+            if len(selected_set) - 1 + len(new_items) > max_card:\n+                continue\n+            # examine candidate removals: prefer those with smallest approximate contribution\n+            # contribution of r relative to sel\\{r}\n+            removal_candidates = []\n+            for r in list(selected_set):\n+                if not can_remove(r, selected_set):\n+                    continue\n+                # compute contribution of r\n+                contrib = 0.0\n+                if 0 <= r < len(weights):\n+                    try:\n+                        contrib += float(weights[r])\n+                    except Exception:\n+                        pass\n+                for v in selected_set:\n+                    if v == r:\n+                        continue\n+                    contrib += interactions.get(r, {}).get(v, 0.0)\n+                removal_candidates.append((contrib, r))\n+            if not removal_candidates:\n+                continue\n+            # try removals in increasing contribution order (best chance to improve)\n+            removal_candidates.sort()\n+            for contrib, r in removal_candidates:\n+                # simulate removal and check feasibility when adding closure_i\n+                sim_sel = set(selected_set)\n+                sim_sel.remove(r)\n+                if not feasible_closure(closure_i, sim_sel):\n+                    continue\n+                # ensure closure's ancestors satisfied (feasible_closure checked)\n+                gain_after = marginal_gain(closure_i, sim_sel)\n+                # compute contribution of r with respect to sim_sel (i.e., interactions with remaining)\n+                removed_contrib = 0.0\n+                if 0 <= r < len(weights):\n+                    try:\n+                        removed_contrib += float(weights[r])\n+                    except Exception:\n+                        pass\n+                for v in sim_sel:\n+                    removed_contrib += interactions.get(r, {}).get(v, 0.0)\n+                delta = gain_after - removed_contrib\n+                if delta > 1e-12:\n+                    # apply swap\n+                    # remove r, add new_items\n+                    selected_set.remove(r)\n+                    selected_set.update(new_items)\n+                    current_obj += delta\n+                    improved = True\n+                    break\n+            if improved:\n+                break\n+\n     # Safety trim if we're over max_card (should rarely happen due to checks)\n     if len(selected_set) > max_card:\n         # compute approximate item score = weight + sum interactions with others in selected_set\n         def item_score(i):\n             s = 0.0\n             if 0 <= i < len(weights):\n                 try:\n                     s += float(weights[i])\n                 except Exception:\n                     pass\n             for j in selected_set:\n                 if j == i:\n                     continue\n                 s += interactions.get(i, {}).get(j, 0.0)\n             return s\n         sorted_items = sorted(selected_set, key=lambda x: item_score(x), reverse=True)\n         selected_set = set(sorted_items[:max_card])\n \n     result = {\"selection\": {\"variables\": sorted(int(x) for x in selected_set)}}\n     print(json.dumps(result))\n # EVOLVE-BLOCK-END\n \n \n # This part remains fixed (not evolved)\n def run_sds(problem_data=None):\n     \"\"\"\n     Main function called by the evaluator.\n     Can accept problem_data as parameter or read from stdin.\n     Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n     \"\"\"\n     import sys\n     import json\n     import io\n \n     if problem_data is None:\n         # Read from stdin (for compatibility)\n         input_data = json.load(sys.stdin)\n     else:\n         # Use provided problem data\n         input_data = problem_data\n \n     # Capture stdout from solve_sds\n     stdout_capture = io.StringIO()\n     old_stdin = sys.stdin\n \n     try:\n         # Create mock stdin\n         sys.stdin = io.StringIO(json.dumps(input_data))\n         with contextlib.redirect_stdout(stdout_capture):\n             solve_sds()\n     finally:\n         sys.stdin = old_stdin\n \n     result_str = stdout_capture.getvalue()\n     return result_str",
      "combined_score": 0.4306669471949661,
      "public_metrics": {
        "feasible": true,
        "selection_size": 10,
        "raw_score": 132.16052771701814
      },
      "private_metrics": {
        "selection": [
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          14
        ],
        "raw_score": 132.16052771701814,
        "normalized_fitness": 0.4306669471949661
      },
      "text_feedback": "",
      "correct": true,
      "children_count": 0,
      "complexity": 1.0,
      "embedding": [
        0.021510467,
        -9.090177e-05,
        0.012961744,
        -0.02008769,
        0.013661075,
        0.03187986,
        0.028913733,
        -0.0063844128,
        -0.009820783,
        0.025103584,
        0.03800504,
        -0.06892031,
        -0.0121116955,
        0.022450946,
        0.008542694,
        -0.032000437,
        0.04902554,
        0.012913515,
        -0.028744929,
        0.002013592,
        0.03231393,
        0.014034856,
        0.050737694,
        0.012292556,
        0.01764003,
        0.0042442176,
        0.05319741,
        0.07195878,
        0.035931163,
        -0.035834704,
        0.02558588,
        -0.0033610105,
        -0.029323686,
        -0.009229967,
        -0.033061493,
        0.03368848,
        0.0053715883,
        0.031590484,
        -0.0304812,
        0.005350488,
        0.0074153235,
        -0.027201578,
        -0.015156198,
        0.014854762,
        -0.014034856,
        -0.015156198,
        0.0067340783,
        -0.002290913,
        0.01788118,
        -0.015686724,
        -0.027490955,
        0.022402717,
        0.014312177,
        0.0024536883,
        -0.032530963,
        -0.03289269,
        0.011020497,
        0.010092075,
        -0.0072224047,
        -0.0014250383,
        0.021293433,
        -0.018990463,
        0.047747448,
        -0.0005983503,
        -0.017748548,
        0.022885015,
        0.014927107,
        0.005302258,
        -0.025127698,
        -0.017109502,
        -0.04958018,
        -0.001271306,
        0.009627863,
        -0.015855528,
        0.011044612,
        0.017676203,
        0.022270085,
        0.04236983,
        0.0061703934,
        -0.029974788,
        -0.03730571,
        -0.02474186,
        0.015976103,
        -0.031614598,
        -0.043358542,
        -0.07509372,
        -0.0021341662,
        0.04058533,
        -0.057586316,
        -0.062409293,
        -0.012600021,
        -0.0043286197,
        -0.069547296,
        0.014251891,
        0.036992215,
        -0.04482955,
        0.04012715,
        -0.030842923,
        0.020799078,
        0.005278143,
        0.012165953,
        -0.03296503,
        0.01786912,
        -0.023391427,
        0.0012321193,
        0.025031239,
        0.04323797,
        0.013636961,
        0.0026330426,
        -0.017061273,
        -0.049773097,
        0.02949249,
        0.021992765,
        0.029347802,
        0.0105382,
        -0.060190722,
        -0.04830209,
        -0.032241587,
        0.00416283,
        -0.010514085,
        -0.02093171,
        -0.0018643811,
        -0.017627973,
        0.042201027,
        -0.025417076,
        0.0065592458,
        0.038487338,
        -0.07022251,
        -0.02963718,
        -0.006480872,
        0.031783402,
        0.0060046036,
        -0.010640688,
        -0.023765208,
        -0.063566804,
        -0.016868355,
        -0.02647813,
        -0.0056850812,
        -0.023729036,
        0.0077589606,
        0.018881947,
        0.0064085275,
        0.022089224,
        0.020955825,
        -0.040633563,
        -0.01721802,
        0.0009992601,
        0.03175929,
        -0.09559136,
        0.058116846,
        0.04482955,
        -0.0356659,
        0.000711012,
        0.006601447,
        0.05551244,
        -0.046083525,
        -0.035907045,
        0.025175927,
        0.059515506,
        -0.035087142,
        -0.006722021,
        0.014661843,
        -0.011985092,
        -0.010381453,
        0.03899375,
        -0.047144577,
        -0.033784937,
        0.058309764,
        -0.038969636,
        -0.020449413,
        -0.019074865,
        -0.10031787,
        -0.020051517,
        0.022475062,
        -0.009380686,
        -0.035087142,
        -0.013974569,
        -0.040633563,
        0.013805765,
        -0.023451714,
        -0.038632028,
        -0.026019948,
        -0.01378165,
        -0.055464208,
        -0.023391427,
        -0.042731557,
        0.0015290336,
        0.0006284939,
        -0.0064507285,
        -0.002382851,
        -0.020172091,
        0.018399648,
        0.01660309,
        -0.014782418,
        0.0040904856,
        -0.032675654,
        0.056525264,
        0.025754685,
        -0.01618108,
        0.01890606,
        0.014119258,
        0.0012660308,
        0.046348788,
        -0.026646934,
        0.0010580401,
        -0.02835909,
        -0.04492601,
        -0.0031861777,
        -0.019123094,
        -0.041598156,
        0.045456536,
        -0.034773648,
        -0.005061109,
        0.046831083,
        0.0475063,
        0.002459717,
        -0.010092075,
        0.013130548,
        0.006420585,
        0.07041543,
        -0.029830098,
        0.023487886,
        0.0038945521,
        -0.012672366,
        0.0082955165,
        0.033784937,
        -1.9369612e-05,
        -0.050207168,
        0.01382988,
        -0.04888085,
        0.004051299,
        0.014143373,
        -0.01430012,
        0.028021483,
        -0.00043067656,
        -0.028793158,
        -0.010278964,
        0.011442508,
        0.016566917,
        -0.0134561,
        0.03231393,
        -0.022643866,
        0.008223172,
        0.021570755,
        0.017652087,
        0.0053746025,
        -0.042128682,
        -0.017772662,
        -0.010568343,
        -0.017326536,
        0.025031239,
        -0.014963279,
        0.023077933,
        -0.015312945,
        -0.005513263,
        -0.029805984,
        -0.013142606,
        -0.038607914,
        0.013009974,
        0.039886,
        -0.05888852,
        0.003095747,
        0.008801929,
        -0.03597939,
        -0.051219992,
        -0.005272114,
        0.0013082318,
        -0.008657239,
        -0.024585113,
        -0.015252657,
        -0.0054258467,
        0.04716869,
        -0.047964483,
        0.022053052,
        -0.050255395,
        -0.009778582,
        -0.014975336,
        0.07321276,
        -0.013275238,
        -0.026574591,
        -0.04924257,
        0.027225692,
        0.029396031,
        -0.0004140976,
        0.03359202,
        0.009175709,
        -0.0049887644,
        0.019231612,
        -0.0069209686,
        0.025465306,
        -0.011056669,
        -0.036654606,
        0.03301326,
        -0.043310314,
        -0.025489422,
        -0.0070837443,
        -0.0024958893,
        0.0275633,
        0.0046933573,
        0.011484709,
        0.08662063,
        0.004970678,
        -0.014902992,
        -0.0056157513,
        -0.020919653,
        -0.017772662,
        0.046035293,
        -0.029661294,
        0.0356659,
        0.02587526,
        -0.040802367,
        -0.008132741,
        0.006896854,
        -0.0022532335,
        -0.023017647,
        -0.019979173,
        0.06728049,
        -0.027900908,
        0.04803683,
        -0.014915049,
        -0.024910664,
        0.015976103,
        0.03289269,
        -0.010236763,
        0.009356571,
        -0.05189521,
        -0.019448645,
        -0.012093609,
        -0.005100296,
        -0.014842705,
        -0.027298037,
        -0.00063113146,
        0.031084072,
        0.04239395,
        -0.0042321603,
        -0.053004492,
        0.021908363,
        0.00884413,
        0.008211114,
        -0.008000109,
        -0.03691987,
        0.011303847,
        -0.03330264,
        -0.028142057,
        -0.003635317,
        -0.029058423,
        -0.020895537,
        0.08580072,
        0.06245752,
        -0.029998902,
        0.006511016,
        -0.00795188,
        -0.021100514,
        0.05884029,
        -0.0072887205,
        0.0054831193,
        -0.022125397,
        -0.023065876,
        -0.010514085,
        -0.027828565,
        0.023692863,
        -0.020582044,
        -0.022258028,
        0.008000109,
        0.008072454,
        0.019436589,
        -0.039162554,
        0.02973364,
        0.012087581,
        -0.0067461357,
        0.04236983,
        0.052908033,
        -0.03646169,
        0.016820123,
        -0.063566804,
        -0.014034856,
        -0.008265373,
        0.015493806,
        0.025537651,
        0.054740764,
        -0.0015493806,
        0.011737915,
        -0.03528006,
        -0.009139537,
        0.006848624,
        0.010580401,
        -0.02394607,
        -0.0089104455,
        -0.039331358,
        -0.028334977,
        0.03028828,
        -0.03537652,
        0.024814205,
        -0.007873506,
        0.0066315904,
        0.008874274,
        0.030215936,
        0.021534583,
        0.019762138,
        0.03597939,
        -0.008132741,
        -0.00014431245,
        -0.014227775,
        -0.04154993,
        -0.033519674,
        -0.006227666,
        0.041381124,
        0.047265153,
        0.00091787236,
        -0.015674667,
        0.030095361,
        0.014336293,
        0.029130768,
        -0.010278964,
        0.008193028,
        -0.019243669,
        -0.03132522,
        0.03552121,
        0.024838319,
        0.059756655,
        -0.008759728,
        -0.01203935,
        0.03691987,
        -0.02412693,
        -0.016156966,
        0.027925024,
        0.0356659,
        -0.025609996,
        0.058357995,
        0.020147977,
        -0.0012389016,
        0.04482955,
        0.05503014,
        0.018640798,
        0.0044341222,
        0.066171214,
        0.041260548,
        0.035931163,
        0.017857064,
        -0.013431985,
        -0.011979063,
        0.030360626,
        0.027852679,
        -0.019207496,
        -0.021281376,
        0.014119258,
        0.024910664,
        -0.020063575,
        0.018447878,
        0.004765702,
        -0.005748383,
        -0.0018101227,
        0.01783295,
        -0.02587526,
        -0.0073490078,
        0.020003287,
        0.03532829,
        -0.030939383,
        0.06949907,
        -0.0048651756,
        0.03851145,
        0.053872626,
        -0.030891152,
        0.0066737914,
        0.0061191493,
        0.030698234,
        0.019738024,
        0.017157732,
        -0.007939822,
        0.046083525,
        0.033543788,
        -0.006426614,
        -0.040392414,
        0.0023361284,
        -0.017808834,
        -0.03429135,
        0.03711279,
        0.0075901565,
        0.008144799,
        0.012744711,
        -0.013492271,
        -0.015373232,
        0.0010911981,
        0.028961964,
        0.043286197,
        0.05932259,
        -0.004247232,
        -0.04716869,
        -0.027105117,
        0.003030938,
        0.023246737,
        0.0076564723,
        0.014673901,
        -0.012171983,
        -0.003231393,
        -0.034267236,
        -0.015505863,
        0.019388359,
        -0.025151813,
        -0.022318315,
        0.007475611,
        -0.025754685,
        -0.040730022,
        0.049146112,
        0.026646934,
        0.008012166,
        0.004205031,
        -0.017386824,
        -0.012316671,
        0.017037159,
        -0.011894661,
        0.01650663,
        -0.027008658,
        0.027129233,
        0.019243669,
        0.0028319904,
        -0.03959662,
        -0.03503891,
        -0.011593225,
        -6.033428e-05,
        -0.012672366,
        -0.032145128,
        -0.039813656,
        0.007777047,
        -0.0024642386,
        -0.024187218,
        0.022113338,
        -0.08459497,
        -0.04948372,
        -0.014890934,
        0.0032283787,
        -0.005645895,
        -0.044250794,
        0.06496547,
        -0.0264299,
        0.006360298,
        -0.033784937,
        -0.008385947,
        -0.02253535,
        0.0152406,
        -0.018471994,
        -0.0068667103,
        -0.018628739,
        -0.01669955,
        0.025031239,
        -0.016144907,
        0.05912967,
        -0.0036232597,
        0.0033851254,
        -0.0018508165,
        -0.032482736,
        -0.014842705,
        -0.0059443163,
        0.011653513,
        -0.03884906,
        0.0104899695,
        -0.038728487,
        -0.030794693,
        0.0008146306,
        -0.04943549,
        0.006486901,
        -0.000898279,
        0.022065109,
        0.018604625,
        -0.012720596,
        0.0024883535,
        0.04982133,
        0.025537651,
        -0.019508932,
        0.022969417,
        -0.006227666,
        -0.022173626,
        0.0083377175,
        -0.06245752,
        0.044057872,
        0.023029704,
        -0.01674778,
        -0.027298037,
        -0.024223391,
        -0.0010610544,
        -0.0114123635,
        -0.01593993,
        -0.015602323,
        -0.011695714,
        -0.079772,
        0.020967882,
        -0.016422229,
        0.010737147,
        0.008434177,
        0.015747013,
        -0.014239833,
        0.0027460812,
        0.021944534,
        0.003012852,
        0.0057604406,
        -0.0005832785,
        -0.007867478,
        -0.009893127,
        -0.012744711,
        0.014517154,
        0.01783295,
        -0.02775622,
        0.016542803,
        0.011659541,
        -0.04873616,
        -0.022258028,
        0.04347912,
        0.019074865,
        0.010134276,
        0.014637728,
        -0.009181738,
        -0.02318645,
        0.009627863,
        0.0123347575,
        -0.037498627,
        0.007517812,
        -0.014384522,
        0.04878439,
        0.010037816,
        -0.027587416,
        0.021823961,
        -0.017314479,
        -0.0067521646,
        0.027008658,
        0.040633563,
        -0.0039096237,
        0.00095555186,
        0.012575907,
        -0.005061109,
        -0.0055434066,
        -0.025537651,
        -0.0030867038,
        -0.019123094,
        0.0038222075,
        -0.010851693,
        0.004220103,
        0.01321495,
        0.0012735667,
        -0.017230077,
        0.009024992,
        0.0020452428,
        0.019738024,
        -0.004768716,
        -0.021848075,
        0.033182066,
        0.01044174,
        -0.010471884,
        0.0076263286,
        0.019135153,
        -0.005389674,
        -0.025079468,
        -0.0101825055,
        -0.001879453,
        -0.023524059,
        0.055994738,
        0.03414666,
        0.013540502,
        -0.038414992,
        -0.005588622,
        0.014420695,
        0.012087581,
        -0.019484818,
        0.013661075,
        0.03711279,
        0.017483283,
        0.022872958,
        0.030842923,
        0.046734624,
        0.011424421,
        0.0048983335,
        -0.039524276,
        0.0072525484,
        0.045335963,
        -0.018134385,
        -0.016156966,
        -0.012479447,
        0.040006574,
        0.008994848,
        -0.033085607,
        0.014071029,
        -0.031204646,
        0.0074153235,
        -0.010598487,
        0.011960978,
        0.007686616,
        -0.028431436,
        0.0032012495,
        -0.0076323575,
        0.0099715,
        0.009947386,
        0.014372464,
        0.003659432,
        -0.009121451,
        -0.01660309,
        0.031638715,
        0.0264299,
        0.025971718,
        0.042779785,
        -0.012961744,
        -0.090575464,
        0.0062035513,
        0.014215718,
        0.0093445135,
        -0.010996383,
        -0.0075419266,
        -0.03829442,
        -0.038270306,
        0.003071632,
        0.0322657,
        -0.004877233,
        -0.0132993525,
        0.005347473,
        -0.012322701,
        -0.011165187,
        -0.0146136135,
        0.009658007,
        0.02083525,
        0.021956593,
        0.024621285,
        -0.030023018,
        -0.04622821,
        -0.040271837,
        -0.021908363,
        0.011249589,
        -0.06342211,
        -0.027225692,
        -0.015771126,
        0.04719281,
        -0.019629506,
        0.00089074316,
        0.00094876956,
        -0.004036227,
        -0.028793158,
        0.02065439,
        -0.016928641,
        -0.02347583,
        -0.023994299,
        -0.011973035,
        -0.040537104,
        0.02671928,
        -0.0076745586,
        -0.014577441,
        0.019340128,
        0.0065411595,
        -0.03532829,
        0.00028617572,
        0.011400307,
        0.033157952,
        -0.033519674,
        0.035087142,
        -0.011828345,
        0.007662501,
        -0.013974569,
        -0.011864518,
        0.022728268,
        0.006770251,
        0.013926339,
        -0.0030324454,
        -0.024561,
        0.013202894,
        -0.016759837,
        -0.00564288,
        -0.049122,
        0.011056669,
        0.01858051,
        0.024585113,
        0.010080017,
        -0.018785486,
        0.014493039,
        0.034942452,
        0.024114873,
        0.0071741748,
        0.0025305545,
        0.0079036495,
        0.002408473,
        -0.026550476,
        -0.0005384399,
        -0.038463224,
        0.011888633,
        0.016108736,
        0.020377068,
        0.007662501,
        -0.0072947494,
        0.015566151,
        0.0064929295,
        -0.009591691,
        0.0007837334,
        -0.016096678,
        0.027442725,
        -0.041357007,
        -0.042273372,
        0.008193028,
        -0.003933739,
        0.028021483,
        -0.012708538,
        0.03853557,
        -0.034170777,
        -0.11285761,
        0.0014815575,
        0.0058599142,
        -0.040271837,
        0.010990353,
        -0.024151046,
        -0.0029314642,
        0.014107201,
        -0.013154663,
        -0.0132993525,
        -0.03913844,
        -0.03118053,
        0.0034755562,
        0.022378603,
        -0.006468815,
        -0.024102816,
        -0.021293433,
        0.010972267,
        0.022680039,
        -0.034508385,
        -0.011605283,
        0.025754685,
        -0.008602981,
        0.0029480432,
        -0.047482185,
        0.0059443163,
        -0.00381015,
        0.03819796,
        -0.00043256054,
        0.0062095798,
        0.013805765,
        0.010924038,
        0.0023014632,
        0.037185136,
        -0.015481749,
        0.010037816,
        0.019713908,
        -0.008078483,
        -0.009024992,
        0.015650554,
        0.014360407,
        -0.013070261,
        0.030891152,
        -0.0551266,
        0.0052479994,
        0.018399648,
        -0.027780334,
        0.0033157952,
        0.0049073766,
        0.035063025,
        0.009603748,
        0.020594101,
        -0.01961745,
        -0.0228609,
        -0.02003946,
        0.042490408,
        -0.00013649395,
        0.019762138,
        -0.003734791,
        0.028961964,
        -0.03503891,
        -0.0043738354,
        0.05310095,
        -0.02573057,
        -0.017712375,
        0.014179545,
        -0.027298037,
        -0.019219555,
        -0.015831415,
        0.034026086,
        -0.0054137893,
        -0.011044612,
        -0.014902992,
        -0.013094376,
        -0.048904963,
        0.012720596,
        0.019786254,
        -0.017338594,
        -0.011870546,
        0.004931492,
        0.042562753,
        -0.0043436917,
        0.01185246,
        0.033326756,
        -0.0036956044,
        0.038077384,
        0.009103364,
        0.05319741,
        0.0020618218,
        0.04444371,
        -0.022523291,
        -0.023487886,
        0.010417625,
        -0.0106587745,
        -0.02558588,
        0.032048665,
        0.0063000107,
        -0.025200043,
        0.033326756,
        -0.01575907,
        0.023222623,
        0.04719281,
        0.009459059,
        0.0014190096,
        0.0027626602,
        0.03489422,
        -0.052908033,
        0.016048448,
        -0.015734956,
        0.033784937,
        -0.015276772,
        -0.00016918092,
        -0.038632028,
        0.032241587,
        -0.012407103,
        -0.03769155,
        0.0014973829,
        0.009320399,
        0.0054107746,
        0.013287296,
        -0.0032042637,
        0.029878328,
        -0.04468486,
        0.028503781,
        -0.023487886,
        0.029323686,
        0.0067762793,
        -0.010218678,
        -0.0039066095,
        0.0028892632,
        0.01806204,
        -0.0005030212,
        -0.01981037,
        0.046831083,
        0.005260057,
        0.037788007,
        0.025609996,
        -0.0073068067,
        -0.015686724,
        0.014710072,
        0.036148194,
        0.005600679,
        -0.024054587,
        -0.009091307,
        -3.0355539e-05,
        0.012756768,
        0.030818809,
        -0.020545872,
        -0.062119912,
        0.018411705,
        -0.015867587,
        -0.0392349,
        0.007602214,
        0.012491505,
        0.020919653,
        0.050303627,
        0.0015192371,
        -0.023885783,
        0.0017980653,
        -0.041959878,
        0.016349884,
        0.028793158,
        -0.010803463,
        -0.02201688,
        0.04516716,
        0.032820344,
        -0.0035207716,
        -0.02409076,
        -0.00047061683,
        0.0065351306,
        -0.028383207,
        -0.020618217,
        -0.022728268,
        -0.020437356,
        -0.0056850812,
        0.015807299,
        -0.016832182,
        0.009591691,
        0.029034307,
        0.021751616,
        0.000665043,
        0.041742846,
        -0.0033579962,
        0.0047626877,
        0.022897072,
        -0.04478132,
        0.00049322454,
        -0.0043256055,
        -0.005015894,
        -0.018785486,
        0.033929627,
        0.0193763,
        0.001434835,
        0.055078372,
        0.017314479,
        0.029130768,
        -0.008554751,
        0.0061975224,
        0.02732215,
        -0.036244653,
        -0.016446345,
        0.0048561324,
        0.024054587,
        -0.05657349,
        0.020268552,
        0.050062478,
        -0.004844075,
        0.0042773755,
        -0.024163103,
        -0.0093445135,
        0.010459826,
        0.014890934,
        -0.03137345,
        0.015855528,
        -0.00780719,
        0.020545872,
        0.026815739,
        -0.0020738791,
        -0.04333443,
        -0.024331907,
        -0.009392743,
        -0.0269122,
        0.014456866,
        -0.01011619,
        -0.018833715,
        0.030312397,
        0.000736634,
        0.020147977,
        0.004051299,
        0.010749205,
        0.0034604843,
        0.0061673787,
        -0.011629398,
        -0.0042864187,
        0.028383207,
        -0.022354487,
        0.011551024,
        0.0037528772,
        0.00054559903,
        0.033640247,
        0.027949138,
        -0.01919544,
        -0.013636961,
        -0.0046029263,
        0.017760605,
        -0.038680255,
        0.02060616,
        0.018218787,
        0.005781541,
        -0.021799846,
        -0.03062589,
        -0.0024973967,
        0.03236216,
        -0.034363694,
        0.044154335,
        -0.029178998,
        0.033037376,
        0.04290036,
        0.0038704372,
        -0.025151813,
        -0.0026466073,
        -0.013504329,
        -0.003146991,
        -0.023970185,
        -0.035014797,
        -0.023102049,
        -0.022089224,
        0.012708538,
        0.0127688255,
        -0.0033127808,
        0.018194672,
        0.028527895,
        -0.017109502,
        -0.0036443602,
        -0.00894059,
        -0.0010105639,
        -0.011834374,
        -0.00856078,
        0.0069631697,
        -0.018049983,
        -0.01246739,
        0.026285212,
        -0.0040332125,
        0.03735394,
        0.032940917,
        -0.03899375,
        0.050303627,
        -0.019472761,
        0.042225145,
        -0.026309326,
        0.0030595746,
        -0.0027701962,
        -0.018049983,
        -0.0062819244,
        -0.008813987,
        0.0053595304,
        -0.0022004822,
        -0.02389784,
        0.0005105571,
        -0.02281267,
        -0.0020497642,
        0.030071247,
        0.020027403,
        -0.048567355,
        0.026791625,
        0.001355708,
        -0.05536775,
        0.012600021,
        -0.021426065,
        -0.02662282,
        0.0028169188,
        -0.005260057,
        0.011569111,
        0.014505097,
        0.015156198,
        -0.00505508,
        0.009603748,
        0.023934012,
        -0.010924038,
        0.040271837,
        0.012141839,
        0.037088674,
        -0.0006774772,
        -0.017326536,
        -0.023077933,
        0.01321495,
        0.028672585,
        -0.001267538,
        0.008922503,
        -0.040271837,
        0.019074865,
        0.031783402,
        0.026888084,
        -0.029106652,
        -0.017181847,
        0.0063000107,
        -0.051605828,
        -0.004642113,
        -0.0131184915,
        -0.017230077,
        -0.019460702,
        -0.017543571,
        -0.009989587,
        0.0018282088,
        -0.0027053873,
        -0.0057785264,
        -0.017579744,
        0.00738518,
        -0.025947604,
        0.011490737,
        0.074804336,
        0.0069631697,
        -0.037884466,
        0.010749205,
        0.021196974,
        0.0011025019,
        -0.012780883,
        0.0040663704,
        0.0038071356,
        -0.059563737,
        -0.011352077,
        0.007692645,
        0.008223172,
        0.01858051,
        0.028937848,
        -0.0055434066,
        0.00071063515,
        0.016313711,
        0.0040844567,
        -0.033037376,
        0.02022032,
        0.0061221635,
        0.0032856516,
        0.0175918,
        0.014963279,
        0.017917352,
        0.020497642,
        -0.018122327,
        -0.0040422557,
        0.008500493,
        0.011092842,
        -0.001094966,
        -0.023162335,
        -0.009037049,
        -0.014734188,
        -0.013395812,
        -0.02469363,
        -0.00014638482,
        -0.02003946,
        -0.03368848,
        -0.026140522,
        -0.015771126,
        -0.02558588,
        0.010369396,
        0.054113775,
        0.012310643,
        -0.021848075,
        0.02018415,
        -0.007300778,
        -0.008904417,
        -0.0066617336,
        0.018267017,
        -0.029757753,
        -0.03759509,
        0.005715225,
        -0.018423764,
        0.0069511123,
        0.025417076,
        0.0038583798,
        -0.006064891,
        -0.02412693,
        -0.020907596,
        0.025537651,
        0.052232817,
        0.019303957,
        -0.028913733,
        0.011243559,
        -0.008241258,
        -0.02662282,
        0.03983777,
        -0.0381015,
        -0.0006055094,
        -0.006191494,
        0.012407103,
        -0.008862216,
        0.057972156,
        0.0008884824,
        0.013094376,
        -0.0077830753,
        -0.01890606,
        -0.019713908,
        0.0217275,
        -0.02214951,
        -0.03241039,
        -0.011026526,
        -0.0039156526,
        0.009392743,
        0.019448645,
        -0.036702838,
        0.013697248,
        -0.023029704,
        -0.010731119,
        -0.029709524,
        0.006740107,
        -0.00084552774,
        -0.021980707,
        0.028190287,
        0.02587526,
        -0.0410194,
        0.0024446454,
        -0.018568452,
        -0.0026616792,
        0.025055353,
        0.0072224047,
        -0.062264603,
        -0.00079428364,
        -0.05150937,
        0.012600021,
        0.015819358,
        0.004027184,
        -0.013142606,
        0.013721363,
        -0.026309326,
        0.01378165,
        -0.030505314,
        0.023017647,
        -0.021245204,
        -0.02300559,
        -0.012527676,
        -0.029661294,
        0.019086922,
        -0.010984325,
        0.006402499,
        -0.00505508,
        0.004379864,
        0.022969417,
        -0.015542036,
        0.005588622,
        -0.024814205,
        0.024573056,
        0.012901457,
        -0.0067943656,
        0.04176696,
        0.009374657,
        -0.008832073,
        -0.0058388137,
        -0.024452481,
        -0.0013670119,
        -0.020714676,
        0.0037076618,
        -0.026333442,
        -0.02493478,
        -0.0369681,
        0.03383317,
        -0.029420145,
        0.021570755,
        -0.013190836,
        -0.008832073,
        0.02023238,
        0.034773648,
        0.022125397,
        -0.02370492,
        -0.0063844128,
        0.0034333551,
        -0.0041568014,
        -0.00039676504,
        0.0187252,
        -0.025248272,
        0.0031258904,
        -0.016349884,
        -0.011207388,
        0.015542036,
        0.013673133,
        -0.031614598,
        -0.005564507,
        0.007192261,
        -0.0032886658,
        0.010321165,
        0.015879644,
        0.013721363,
        -0.0012464375,
        -0.03790858,
        0.026140522,
        -0.015976103,
        -0.01764003,
        0.0410194,
        0.021414008,
        -0.027997369,
        -0.034773648,
        0.0008334703,
        0.01378165,
        0.027442725,
        0.018689027,
        -0.011581168,
        0.012358872,
        -0.0122805,
        0.008958676,
        -0.019364243,
        0.007228433,
        -0.008132741,
        0.0051123532,
        -0.018279074,
        -0.0019171324,
        -0.020099748,
        0.024621285,
        0.011780116,
        -0.014661843,
        -0.035714127,
        -0.01786912,
        0.04709635,
        -0.009814753,
        0.0036383315,
        0.008675326,
        -0.0034514412,
        -0.0050219223,
        -0.011930834,
        0.014746245,
        0.010966239,
        0.030891152,
        0.00832566,
        0.07793927,
        -0.015397347,
        0.010905951,
        -0.0015840457,
        0.013395812,
        0.02253535,
        -0.0019261756,
        0.0030987612,
        -0.008596952,
        0.023294969,
        -0.005229913,
        -0.03853557,
        -0.02258358,
        0.0045757974,
        -0.05271511,
        0.0053082868,
        -0.014529211,
        -0.011967006,
        -0.012961744,
        -0.0074575245,
        0.019725967,
        0.0105382,
        0.00894059,
        0.0047446014,
        -0.0029254355,
        -0.013709306,
        -0.063084505,
        0.028865503,
        0.011424421,
        -0.0029088566,
        -0.040995285,
        0.02234243,
        0.025995834,
        -0.0036051737,
        -0.0061131204,
        0.02234243,
        0.01204538,
        0.018568452,
        -0.00434972,
        -0.009567576,
        -0.008976761,
        0.0022065109,
        -0.025079468,
        -0.034460153,
        -0.0077167596,
        -0.028720815,
        0.0021839032,
        -0.027852679,
        0.0001257553,
        0.0037890496,
        -0.021655157,
        0.011575139,
        -0.02493478,
        0.013636961,
        0.0058116843,
        -0.006939055,
        -0.021667214,
        -0.02925134,
        -0.016048448,
        -0.0023647647,
        0.016386056,
        0.012515619,
        -0.044419598,
        -0.01062863,
        0.016301654,
        0.002465746,
        0.01830319,
        -0.0217275,
        0.024814205,
        -0.007963937,
        0.04224926,
        0.005263071,
        -0.042635098,
        0.008633125,
        0.014239833,
        0.0063844128,
        -0.010200592,
        -0.0039940258,
        0.011532938,
        0.0055735502,
        0.028045598,
        -0.0072646057,
        0.006064891,
        -0.008174942,
        -0.018471994,
        0.0038131643,
        0.011502795,
        -0.003508714,
        0.044588402,
        -0.004877233,
        -0.028190287,
        0.015204428,
        0.028045598,
        -0.028021483,
        -0.008349775,
        -0.014517154,
        0.009766524,
        0.013166721,
        -0.032699768,
        0.02333114,
        -0.026236983,
        0.013202894,
        -0.019629506,
        -0.0043256055,
        -0.00639647,
        0.016771894,
        0.032145128,
        0.017181847,
        -0.03769155,
        0.043286197,
        -0.03414666,
        0.015059738,
        0.010646717,
        -0.0073791514,
        -0.018098213,
        -0.012587964,
        -0.022728268,
        -0.00018670187,
        0.04468486,
        -0.015650554,
        0.029154882,
        -0.007927764,
        0.022185683,
        0.008187,
        0.034170777,
        0.009513318,
        0.014251891,
        0.018351419,
        -0.016241368,
        -0.0005418311,
        0.012563849,
        0.0060558477,
        -0.0072465194,
        0.011201358,
        -0.009700208,
        0.030963497,
        0.021510467,
        -0.0047717304,
        -0.0068787676,
        0.008886331,
        -0.033977855,
        -0.022221856,
        -0.008096569,
        -0.03038474,
        -0.010990353,
        0.0070716864,
        -0.02686397,
        -0.01595199,
        -0.04314151,
        0.02840732,
        -0.028937848,
        -0.006782308,
        -0.018134385,
        -0.00522087,
        0.01900252,
        0.03672695,
        -0.016820123,
        -0.008765756,
        0.011647484,
        -0.037281595,
        0.048953194,
        0.026839854,
        0.0051635974,
        0.011786144,
        -0.006149293,
        -0.0065592458,
        -0.009983557,
        -0.004012112,
        -0.015819358,
        -0.016832182,
        0.0057604406,
        0.011816288,
        0.006251781,
        -0.0140830865,
        0.013986627,
        -0.011062698,
        0.007933794,
        -0.018218787,
        -0.01590376
      ],
      "embedding_pca_2d": [],
      "embedding_pca_3d": [],
      "embedding_cluster_id": null,
      "migration_history": [],
      "metadata": {
        "compute_time": 2.005979061126709,
        "patch_type": "diff",
        "api_costs": 0.016392499999999997,
        "num_applied": 1,
        "patch_name": "local_swap_improvement",
        "patch_description": "Add a lightweight local-search (1-for-1 swap) improvement phase after the greedy construction.\nThis phase attempts to swap a single selected variable with a candidate closure (item + ancestors)\nthat would otherwise not fit, removing one selected item if safe (i.e., not a required ancestor\nfor remaining items). The swap is only applied if it strictly improves the objective (weights + interactions).\nThis aims to escape local greedy traps and capture beneficial interaction-driven trades without heavy cost.\nI keep all existing feasibility checks and reuse precomputed closures and marginal_gain for correctness.",
        "error_attempt": null,
        "novelty_attempt": 1,
        "resample_attempt": 1,
        "patch_attempt": 1,
        "model_name": "gpt-5-mini",
        "temperature": 1.0,
        "max_output_tokens": 8192,
        "llm_result": {
          "content": "<NAME>\nlocal_swap_improvement\n</NAME>\n\n<DESCRIPTION>\nAdd a lightweight local-search (1-for-1 swap) improvement phase after the greedy construction.\nThis phase attempts to swap a single selected variable with a candidate closure (item + ancestors)\nthat would otherwise not fit, removing one selected item if safe (i.e., not a required ancestor\nfor remaining items). The swap is only applied if it strictly improves the objective (weights + interactions).\nThis aims to escape local greedy traps and capture beneficial interaction-driven trades without heavy cost.\nI keep all existing feasibility checks and reuse precomputed closures and marginal_gain for correctness.\n</DESCRIPTION>\n\n<DIFF>\n<<<<<<< SEARCH\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Crossover solver for the Synergistic Dependency Selection problem.\n\n    Reads JSON from stdin with \"requirements\" and \"catalog\", and prints JSON\n    with \"selection\": {\"variables\": [...] }.\n\n    Strategy:\n    - Parse inputs robustly.\n    - Build adjacency map for interactions for efficient marginal gain computation.\n    - Precompute transitive ancestor closure for precedence.\n    - For each candidate, consider adding its closure (itself + ancestors).\n    - Greedily add the closure with maximum marginal gain while respecting\n      mutex, groups, and cardinality. Tie-break in favor of larger closures to\n      satisfy minimum cardinality.\n    - If minimum cardinality not reached, add best feasible closures even if negative.\n    - Trim if needed by approximate item scores.\n    \"\"\"\n    import re\n    from collections import defaultdict, deque\n\n    data = json.load(sys.stdin)\n    requirements = data.get(\"requirements\", {}) or {}\n    catalog = data.get(\"catalog\", {}) or {}\n\n    weights = list(requirements.get(\"weights\", []) or [])\n    raw_interactions = requirements.get(\"interactions\", {}) or {}\n    card_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)]) or [0, len(weights)]\n    min_card = int(card_bounds[0]) if len(card_bounds) > 0 else 0\n    max_card = int(card_bounds[1]) if len(card_bounds) > 1 else len(weights)\n    mutex_list = requirements.get(\"mutex\", []) or []\n    groups = requirements.get(\"groups\", {}) or {}\n    precedence = requirements.get(\"precedence\", []) or []\n\n    n = len(weights)\n\n    # Parse interactions into adjacency dict: interactions[u][v] = value\n    interactions = defaultdict(dict)\n    def parse_key(k):\n        # return (u,v) or None\n        try:\n            if isinstance(k, str):\n                parts = re.split(r'\\s*,\\s*|\\s+', k.strip())\n                if len(parts) >= 2:\n                    return int(parts[0]), int(parts[1])\n            elif isinstance(k, (list, tuple)) and len(k) >= 2:\n                return int(k[0]), int(k[1])\n            elif isinstance(k, int):\n                return None\n        except Exception:\n            return None\n        return None\n\n    for k, v in raw_interactions.items():\n        parsed = parse_key(k)\n        try:\n            val = float(v)\n        except Exception:\n            continue\n        if parsed is None:\n            continue\n        u, w = parsed\n        if 0 <= u < n and 0 <= w < n:\n            interactions[u][w] = interactions[u].get(w, 0.0) + val\n            interactions[w][u] = interactions[w].get(u, 0.0) + val\n\n    # Build mutex map for quick conflict checks\n    mutex_map = defaultdict(set)\n    for pair in mutex_list:\n        try:\n            a, b = pair\n            a = int(a); b = int(b)\n            if 0 <= a < n and 0 <= b < n:\n                mutex_map[a].add(b)\n                mutex_map[b].add(a)\n        except Exception:\n            continue\n\n    # Normalize groups: map var -> group name, allow string/int keys\n    var_to_group = {}\n    for gname, vars_list in groups.items():\n        for v in vars_list:\n            try:\n                idx = int(v)\n                if 0 <= idx < n and gname is not None:\n                    # first membership wins\n                    if idx not in var_to_group:\n                        var_to_group[idx] = str(gname)\n            except Exception:\n                continue\n\n    # Build precedence graph (directed: p -> j means p is prerequisite of j)\n    preds = defaultdict(set)\n    succs = defaultdict(set)\n    for entry in precedence:\n        try:\n            a, b = entry\n            a = int(a); b = int(b)\n            if 0 <= a < n and 0 <= b < n:\n                preds[b].add(a)\n                succs[a].add(b)\n        except Exception:\n            continue\n\n    # Precompute transitive ancestor closure for each node using DFS/BFS\n    ancestor_closure = [set() for _ in range(n)]\n    for i in range(n):\n        # BFS/DFS from i to collect all ancestors\n        stack = list(preds.get(i, []))\n        seen = set(stack)\n        while stack:\n            cur = stack.pop()\n            ancestor_closure[i].add(cur)\n            for p in preds.get(cur, []):\n                if p not in seen:\n                    seen.add(p)\n                    stack.append(p)\n\n    # closure for variable i is ancestors + i\n    closures = [set(ancestor_closure[i]) | {i} for i in range(n)]\n\n    # Feasibility check of adding closure (closure is set of vars to ensure present),\n    # given currently selected_set.\n    def feasible_closure(closure, selected_set):\n        # New items that would be added\n        new_items = closure - selected_set\n        # Cardinality check\n        if len(selected_set) + len(new_items) > max_card:\n            return False\n        # Mutex check: none of new items conflict with each other or with selected\n        for v in new_items:\n            # conflicts with selected\n            if any(conflict in selected_set for conflict in mutex_map.get(v, ())) :\n                return False\n            # conflicts with other new items\n            for conflict in mutex_map.get(v, ()):\n                if conflict in new_items:\n                    return False\n        # Group check: cannot create group count >1\n        group_counts = {}\n        for v in selected_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in new_items:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: closures already contain transitive ancestors; but if closure lacks\n        # some ancestor (shouldn't) ensure those ancestors are in selected_set\n        for v in closure:\n            for a in preds.get(v, ()):\n                if a not in closure and a not in selected_set:\n                    return False\n        return True\n\n    # Compute marginal gain for adding closure (new items = closure - selected_set)\n    def marginal_gain(closure, selected_set):\n        new_items = closure - selected_set\n        if not new_items:\n            return 0.0\n        gain = 0.0\n        # weights\n        for i in new_items:\n            if 0 <= i < len(weights):\n                try:\n                    gain += float(weights[i])\n                except Exception:\n                    pass\n        # interactions among new items\n        # iterate edges from each new item to higher-index new items to avoid double count\n        new_list = list(new_items)\n        l = len(new_list)\n        for idx in range(l):\n            u = new_list[idx]\n            # interactions with other new items\n            for v in new_list[idx+1:]:\n                gain += interactions.get(u, {}).get(v, 0.0)\n        # interactions between new items and already selected\n        for u in new_items:\n            for v in selected_set:\n                gain += interactions.get(u, {}).get(v, 0.0)\n        return gain\n\n    # Greedy selection: add closure with best marginal gain while respecting constraints\n    selected_set = set()\n    # Initial heuristic: consider items sorted by weight+abs(interaction_potential)\n    # but main loop will evaluate closures anyway, so we iterate all candidates\n    improved = True\n    while len(selected_set) < max_card and improved:\n        improved = False\n        best_gain = float(\"-inf\")\n        best_closure = None\n        # Evaluate every candidate not yet in selected_set\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closures[i]\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # Tie-breaker: prefer larger closure (helps reach min_card)\n            if (gain > best_gain) or (abs(gain - best_gain) < 1e-12 and best_closure is not None and len(closure - selected_set) > len(best_closure - selected_set)) or (best_closure is None and gain >= best_gain):\n                best_gain = gain\n                best_closure = closure\n        # Accept non-negative gain closures; small negative may be accepted later to meet min_card\n        if best_closure is not None and best_gain > -1e-12:\n            new_items = best_closure - selected_set\n            if new_items:\n                selected_set.update(new_items)\n                improved = True\n        else:\n            break\n\n    # If we haven't met min_card, add best feasible closures even if negative\n    while len(selected_set) < min_card:\n        best_gain = float(\"-inf\")\n        best_closure = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closures[i]\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            if (gain > best_gain) or (abs(gain - best_gain) < 1e-12 and best_closure is not None and len(closure - selected_set) > len(best_closure - selected_set)) or (best_closure is None and gain >= best_gain):\n                best_gain = gain\n                best_closure = closure\n        if best_closure is None:\n            # no feasible closures left\n            break\n        selected_set.update(best_closure - selected_set)\n\n    # Safety trim if we're over max_card (should rarely happen due to checks)\n    if len(selected_set) > max_card:\n        # compute approximate item score = weight + sum interactions with others in selected_set\n        def item_score(i):\n            s = 0.0\n            if 0 <= i < len(weights):\n                try:\n                    s += float(weights[i])\n                except Exception:\n                    pass\n            for j in selected_set:\n                if j == i:\n                    continue\n                s += interactions.get(i, {}).get(j, 0.0)\n            return s\n        sorted_items = sorted(selected_set, key=lambda x: item_score(x), reverse=True)\n        selected_set = set(sorted_items[:max_card])\n\n    result = {\"selection\": {\"variables\": sorted(int(x) for x in selected_set)}}\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n=======\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Crossover solver for the Synergistic Dependency Selection problem.\n\n    Reads JSON from stdin with \"requirements\" and \"catalog\", and prints JSON\n    with \"selection\": {\"variables\": [...] }.\n\n    Strategy:\n    - Parse inputs robustly.\n    - Build adjacency map for interactions for efficient marginal gain computation.\n    - Precompute transitive ancestor closure for precedence.\n    - For each candidate, consider adding its closure (itself + ancestors).\n    - Greedily add the closure with maximum marginal gain while respecting\n      mutex, groups, and cardinality. Tie-break in favor of larger closures to\n      satisfy minimum cardinality.\n    - If minimum cardinality not reached, add best feasible closures even if negative.\n    - Lightweight local-search: attempt beneficial 1-for-1 swaps (remove one selected,\n      add a candidate closure) that strictly increase the objective while preserving feasibility.\n    - Trim if needed by approximate item scores.\n    \"\"\"\n    import re\n    from collections import defaultdict, deque\n\n    data = json.load(sys.stdin)\n    requirements = data.get(\"requirements\", {}) or {}\n    catalog = data.get(\"catalog\", {}) or {}\n\n    weights = list(requirements.get(\"weights\", []) or [])\n    raw_interactions = requirements.get(\"interactions\", {}) or {}\n    card_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)]) or [0, len(weights)]\n    min_card = int(card_bounds[0]) if len(card_bounds) > 0 else 0\n    max_card = int(card_bounds[1]) if len(card_bounds) > 1 else len(weights)\n    mutex_list = requirements.get(\"mutex\", []) or []\n    groups = requirements.get(\"groups\", {}) or {}\n    precedence = requirements.get(\"precedence\", []) or []\n\n    n = len(weights)\n\n    # Parse interactions into adjacency dict: interactions[u][v] = value\n    interactions = defaultdict(dict)\n    def parse_key(k):\n        # return (u,v) or None\n        try:\n            if isinstance(k, str):\n                parts = re.split(r'\\s*,\\s*|\\s+', k.strip())\n                if len(parts) >= 2:\n                    return int(parts[0]), int(parts[1])\n            elif isinstance(k, (list, tuple)) and len(k) >= 2:\n                return int(k[0]), int(k[1])\n            elif isinstance(k, int):\n                return None\n        except Exception:\n            return None\n        return None\n\n    for k, v in raw_interactions.items():\n        parsed = parse_key(k)\n        try:\n            val = float(v)\n        except Exception:\n            continue\n        if parsed is None:\n            continue\n        u, w = parsed\n        if 0 <= u < n and 0 <= w < n:\n            interactions[u][w] = interactions[u].get(w, 0.0) + val\n            interactions[w][u] = interactions[w].get(u, 0.0) + val\n\n    # Build mutex map for quick conflict checks\n    mutex_map = defaultdict(set)\n    for pair in mutex_list:\n        try:\n            a, b = pair\n            a = int(a); b = int(b)\n            if 0 <= a < n and 0 <= b < n:\n                mutex_map[a].add(b)\n                mutex_map[b].add(a)\n        except Exception:\n            continue\n\n    # Normalize groups: map var -> group name, allow string/int keys\n    var_to_group = {}\n    for gname, vars_list in groups.items():\n        for v in vars_list:\n            try:\n                idx = int(v)\n                if 0 <= idx < n and gname is not None:\n                    # first membership wins\n                    if idx not in var_to_group:\n                        var_to_group[idx] = str(gname)\n            except Exception:\n                continue\n\n    # Build precedence graph (directed: p -> j means p is prerequisite of j)\n    preds = defaultdict(set)\n    succs = defaultdict(set)\n    for entry in precedence:\n        try:\n            a, b = entry\n            a = int(a); b = int(b)\n            if 0 <= a < n and 0 <= b < n:\n                preds[b].add(a)\n                succs[a].add(b)\n        except Exception:\n            continue\n\n    # Precompute transitive ancestor closure for each node using DFS/BFS\n    ancestor_closure = [set() for _ in range(n)]\n    for i in range(n):\n        # BFS/DFS from i to collect all ancestors\n        stack = list(preds.get(i, []))\n        seen = set(stack)\n        while stack:\n            cur = stack.pop()\n            ancestor_closure[i].add(cur)\n            for p in preds.get(cur, []):\n                if p not in seen:\n                    seen.add(p)\n                    stack.append(p)\n\n    # closure for variable i is ancestors + i\n    closures = [set(ancestor_closure[i]) | {i} for i in range(n)]\n\n    # Feasibility check of adding closure (closure is set of vars to ensure present),\n    # given currently selected_set.\n    def feasible_closure(closure, selected_set):\n        # New items that would be added\n        new_items = closure - selected_set\n        # Cardinality check\n        if len(selected_set) + len(new_items) > max_card:\n            return False\n        # Mutex check: none of new items conflict with each other or with selected\n        for v in new_items:\n            # conflicts with selected\n            if any(conflict in selected_set for conflict in mutex_map.get(v, ())) :\n                return False\n            # conflicts with other new items\n            for conflict in mutex_map.get(v, ()):\n                if conflict in new_items:\n                    return False\n        # Group check: cannot create group count >1\n        group_counts = {}\n        for v in selected_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in new_items:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: closures already contain transitive ancestors; but if closure lacks\n        # some ancestor (shouldn't) ensure those ancestors are in selected_set\n        for v in closure:\n            for a in preds.get(v, ()):\n                if a not in closure and a not in selected_set:\n                    return False\n        return True\n\n    # Compute marginal gain for adding closure (new items = closure - selected_set)\n    def marginal_gain(closure, selected_set):\n        new_items = closure - selected_set\n        if not new_items:\n            return 0.0\n        gain = 0.0\n        # weights\n        for i in new_items:\n            if 0 <= i < len(weights):\n                try:\n                    gain += float(weights[i])\n                except Exception:\n                    pass\n        # interactions among new items\n        # iterate edges from each new item to higher-index new items to avoid double count\n        new_list = list(new_items)\n        l = len(new_list)\n        for idx in range(l):\n            u = new_list[idx]\n            # interactions with other new items\n            for v in new_list[idx+1:]:\n                gain += interactions.get(u, {}).get(v, 0.0)\n        # interactions between new items and already selected\n        for u in new_items:\n            for v in selected_set:\n                gain += interactions.get(u, {}).get(v, 0.0)\n        return gain\n\n    # Greedy selection: add closure with best marginal gain while respecting constraints\n    selected_set = set()\n    # Initial heuristic: consider items sorted by weight+abs(interaction_potential)\n    # but main loop will evaluate closures anyway, so we iterate all candidates\n    improved = True\n    while len(selected_set) < max_card and improved:\n        improved = False\n        best_gain = float(\"-inf\")\n        best_closure = None\n        # Evaluate every candidate not yet in selected_set\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closures[i]\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # Tie-breaker: prefer larger closure (helps reach min_card)\n            if (gain > best_gain) or (abs(gain - best_gain) < 1e-12 and best_closure is not None and len(closure - selected_set) > len(best_closure - selected_set)) or (best_closure is None and gain >= best_gain):\n                best_gain = gain\n                best_closure = closure\n        # Accept non-negative gain closures; small negative may be accepted later to meet min_card\n        if best_closure is not None and best_gain > -1e-12:\n            new_items = best_closure - selected_set\n            if new_items:\n                selected_set.update(new_items)\n                improved = True\n        else:\n            break\n\n    # If we haven't met min_card, add best feasible closures even if negative\n    while len(selected_set) < min_card:\n        best_gain = float(\"-inf\")\n        best_closure = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closures[i]\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            if (gain > best_gain) or (abs(gain - best_gain) < 1e-12 and best_closure is not None and len(closure - selected_set) > len(best_closure - selected_set)) or (best_closure is None and gain >= best_gain):\n                best_gain = gain\n                best_closure = closure\n        if best_closure is None:\n            # no feasible closures left\n            break\n        selected_set.update(best_closure - selected_set)\n\n    # Lightweight local-search: attempt beneficial 1-for-1 swaps.\n    # Helper: check if we can safely remove item r from selected_set (won't break precedence)\n    def can_remove(r, sel):\n        # cannot remove if r is an ancestor of any kept item\n        for u in sel:\n            if u == r:\n                continue\n            if r in ancestor_closure[u]:\n                return False\n        return True\n\n    # Compute total objective for a set (weights + undirected interactions)\n    def total_objective(sel):\n        total = 0.0\n        for u in sel:\n            if 0 <= u < len(weights):\n                try:\n                    total += float(weights[u])\n                except Exception:\n                    pass\n        # interactions counted once\n        seen = set()\n        for u in sel:\n            seen.add(u)\n            for v, val in interactions.get(u, {}).items():\n                if v in sel and v not in seen:\n                    total += val\n        return total\n\n    # Precompute current objective\n    current_obj = total_objective(selected_set)\n\n    improved = True\n    # Try swapping out one selected item for a candidate closure (which may bring multiple new items)\n    # Only single removals allowed (cheap) and removal must be safe (not required by others).\n    while improved:\n        improved = False\n        # iterate over candidates not in selected_set\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure_i = closures[i]\n            new_items = closure_i - selected_set\n            if not new_items:\n                continue\n            # If closure fits without removal, it would have been added by greedy (but still check)\n            if len(selected_set) + len(new_items) <= max_card:\n                if not feasible_closure(closure_i, selected_set):\n                    continue\n                gain_add = marginal_gain(closure_i, selected_set)\n                if gain_add > 1e-12:\n                    selected_set.update(new_items)\n                    current_obj += gain_add\n                    improved = True\n                    break\n                else:\n                    continue\n            # need to remove exactly one item to try swap (cheap heuristic)\n            # if removing one item won't free enough slots, skip\n            if len(selected_set) - 1 + len(new_items) > max_card:\n                continue\n            # examine candidate removals: prefer those with smallest approximate contribution\n            # contribution of r relative to sel\\{r}\n            removal_candidates = []\n            for r in list(selected_set):\n                if not can_remove(r, selected_set):\n                    continue\n                # compute contribution of r\n                contrib = 0.0\n                if 0 <= r < len(weights):\n                    try:\n                        contrib += float(weights[r])\n                    except Exception:\n                        pass\n                for v in selected_set:\n                    if v == r:\n                        continue\n                    contrib += interactions.get(r, {}).get(v, 0.0)\n                removal_candidates.append((contrib, r))\n            if not removal_candidates:\n                continue\n            # try removals in increasing contribution order (best chance to improve)\n            removal_candidates.sort()\n            for contrib, r in removal_candidates:\n                # simulate removal and check feasibility when adding closure_i\n                sim_sel = set(selected_set)\n                sim_sel.remove(r)\n                if not feasible_closure(closure_i, sim_sel):\n                    continue\n                # ensure closure's ancestors satisfied (feasible_closure checked)\n                gain_after = marginal_gain(closure_i, sim_sel)\n                # compute contribution of r with respect to sim_sel (i.e., interactions with remaining)\n                removed_contrib = 0.0\n                if 0 <= r < len(weights):\n                    try:\n                        removed_contrib += float(weights[r])\n                    except Exception:\n                        pass\n                for v in sim_sel:\n                    removed_contrib += interactions.get(r, {}).get(v, 0.0)\n                delta = gain_after - removed_contrib\n                if delta > 1e-12:\n                    # apply swap\n                    # remove r, add new_items\n                    selected_set.remove(r)\n                    selected_set.update(new_items)\n                    current_obj += delta\n                    improved = True\n                    break\n            if improved:\n                break\n\n    # Safety trim if we're over max_card (should rarely happen due to checks)\n    if len(selected_set) > max_card:\n        # compute approximate item score = weight + sum interactions with others in selected_set\n        def item_score(i):\n            s = 0.0\n            if 0 <= i < len(weights):\n                try:\n                    s += float(weights[i])\n                except Exception:\n                    pass\n            for j in selected_set:\n                if j == i:\n                    continue\n                s += interactions.get(i, {}).get(j, 0.0)\n            return s\n        sorted_items = sorted(selected_set, key=lambda x: item_score(x), reverse=True)\n        selected_set = set(sorted_items[:max_card])\n\n    result = {\"selection\": {\"variables\": sorted(int(x) for x in selected_set)}}\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n>>>>>>> REPLACE\n</DIFF>",
          "msg": "Here are the performance metrics of a set of prioviously implemented programs:\n\n# Prior programs\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Improved solver for the Synergistic Dependency Selection problem.\n\n    - Reads JSON from stdin with \"requirements\" and \"catalog\".\n    - Produces JSON to stdout with \"selection\": {\"variables\": [...] }.\n    - Uses a precedence-aware marginal-gain greedy algorithm that:\n        * when adding an item, also includes its required predecessors (closure),\n        * computes the marginal objective (weights + pairwise interactions),\n        * checks mutex/group/cardinality feasibility for the closure before adding.\n    \"\"\"\n    import re\n\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n\n    # Extract constraints\n    weights = list(requirements.get(\"weights\", []))\n    interactions_raw = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    min_card, max_card = (cardinality_bounds + [len(weights), len(weights)])[:2]\n    mutex = [tuple(m) for m in requirements.get(\"mutex\", [])]\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n\n    n = len(weights)\n\n    # Parse interactions into dict of tuple->float for quick lookup (undirected)\n    interactions = {}\n    for k, v in interactions_raw.items():\n        try:\n            if isinstance(k, str):\n                # allow \"u,v\" or \"u v\"\n                parts = re.split(r'\\s*,\\s*|\\s+', k.strip())\n                if len(parts) >= 2:\n                    u = int(parts[0]); w = int(parts[1])\n                else:\n                    continue\n            elif isinstance(k, (list, tuple)) and len(k) >= 2:\n                u = int(k[0]); w = int(k[1])\n            else:\n                continue\n            interactions[(u, w)] = float(v)\n            interactions[(w, u)] = float(v)\n        except Exception:\n            # skip malformed keys\n            continue\n\n    # Build precedence graph: if (p, j) then p is a prerequisite of j\n    preds = {i: set() for i in range(n)}\n    succs = {i: set() for i in range(n)}\n    for entry in precedence:\n        try:\n            a, b = entry\n            a = int(a); b = int(b)\n            preds[b].add(a)\n            succs[a].add(b)\n        except Exception:\n            continue\n\n    # Precompute ancestors (transitive closure of preds) using DFS/memoization\n    ancestor_cache = {}\n\n    def get_ancestors(i):\n        if i in ancestor_cache:\n            return ancestor_cache[i].copy()\n        res = set()\n        stack = [i]\n        while stack:\n            cur = stack.pop()\n            for p in preds.get(cur, []):\n                if p not in res:\n                    res.add(p)\n                    stack.append(p)\n        ancestor_cache[i] = res.copy()\n        return res\n\n    # Map variable -> group (assume at most one group membership; if multiple, first wins)\n    var_to_group = {}\n    for gname, vars_list in groups.items():\n        for v in vars_list:\n            try:\n                var_to_group[int(v)] = gname\n            except Exception:\n                pass\n\n    # Helper: check feasibility of adding a closure set given current selected_set\n    def feasible_closure(closure_set, selected_set):\n        # Cardinality\n        if len(selected_set) + len(closure_set - selected_set) > max_card:\n            return False\n        # Mutex: none of closure can conflict with each other or with selected_set\n        for a, b in mutex:\n            if a in closure_set and b in closure_set:\n                return False\n            if (a in closure_set and b in selected_set) or (b in closure_set and a in selected_set):\n                return False\n        # Group: ensure at most one per group overall\n        # Build per-group counts\n        group_counts = {}\n        for v in selected_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in closure_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: closure itself must include ancestors for each element\n        for v in closure_set:\n            if not get_ancestors(v).issubset(closure_set.union(selected_set)):\n                return False\n        return True\n\n    # Compute marginal gain of adding closure_set (items that will be newly included)\n    def marginal_gain(closure_set, selected_set):\n        new_items = set(closure_set) - set(selected_set)\n        gain = 0.0\n        for i in new_items:\n            if i < len(weights):\n                gain += float(weights[i])\n        # interactions among new items\n        new_list = list(new_items)\n        for i in range(len(new_list)):\n            for j in range(i + 1, len(new_list)):\n                gain += interactions.get((new_list[i], new_list[j]), 0.0)\n        # interactions between new items and already selected\n        for i in new_items:\n            for j in selected_set:\n                gain += interactions.get((i, j), 0.0)\n        return gain\n\n    # Greedy loop: at each step try to add an item (and its ancestors) with max marginal gain\n    selected_set = set()\n    # Keep iterating while we can still add and haven't reached max_card\n    improved = True\n    while len(selected_set) < max_card and improved:\n        improved = False\n        best_gain = float(\"-inf\")\n        best_closure = None\n        # Consider candidates not already selected\n        for i in range(n):\n            if i in selected_set:\n                continue\n            # closure includes i and its ancestors\n            closure = get_ancestors(i).union({i})\n            # Only consider closures that are feasible\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # Prefer closures that add more items when gain is equal (to help reach min_card)\n            if gain > best_gain or (abs(gain - best_gain) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_gain = gain\n                best_closure = closure\n        # If we found a positive-gain move, take it\n        if best_closure is not None and best_gain > -1e-12:\n            to_add = set(best_closure) - selected_set\n            if to_add:\n                selected_set.update(to_add)\n                improved = True\n        else:\n            # No non-negative gain move; stop greedy improvements\n            break\n\n    # If we still haven't met minimum cardinality, greedily add best feasible closures regardless of gain\n    while len(selected_set) < min_card:\n        best_gain = float(\"-inf\")\n        best_closure = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = get_ancestors(i).union({i})\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # choose closure that gives best gain (even if negative), tie-breaker favors larger closures\n            if gain > best_gain or (abs(gain - best_gain) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_gain = gain\n                best_closure = closure\n        if best_closure is None:\n            # No feasible closure remains; break to avoid infinite loop\n            break\n        selected_set.update(set(best_closure) - selected_set)\n\n    # Final trim if over max_card (shouldn't happen due to checks) - keep highest-weight items\n    if len(selected_set) > max_card:\n        # score items by marginal contribution relative to selected (approx): weight + interactions with others\n        def item_score(i):\n            s = float(weights[i]) if i < len(weights) else 0.0\n            for j in selected_set:\n                if j == i:\n                    continue\n                s += interactions.get((i, j), 0.0)\n            return s\n        sorted_items = sorted(selected_set, key=item_score, reverse=True)\n        selected_set = set(sorted_items[:max_card])\n\n    result = {\n        \"selection\": {\n            \"variables\": sorted(int(x) for x in selected_set)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n\n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n\n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n\n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n\n    result_str = stdout_capture.getvalue()\n    return result_str\n\n```\n\nPerformance metrics:\nCombined score to maximize: 0.40\nfeasible: True; selection_size: 10; raw_score: 122.55\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    This is a greedy baseline - evolution will improve this.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    # Simple greedy: select items with highest weights first\n    # This is a baseline - evolution will find better strategies\n    n = len(weights)\n    selected = []\n    \n    # Create score list (weight + interaction potential)\n    scores = []\n    for i in range(n):\n        score = weights[i] if i < len(weights) else 0.0\n        # Add potential interaction value\n        for k, v in interactions.items():\n            try:\n                u, w = map(int, k.split(\",\"))\n                if u == i or w == i:\n                    score += abs(v) * 0.5  # Potential value\n            except:\n                pass\n        scores.append((score, i))\n    \n    # Sort by score descending\n    scores.sort(reverse=True)\n    \n    # Greedy selection respecting constraints\n    selected_set = set()\n    for score, i in scores:\n        if len(selected_set) >= cardinality_bounds[1]:\n            break\n            \n        # Check mutex constraints\n        can_add = True\n        for a, b in mutex:\n            if (a == i and b in selected_set) or (b == i and a in selected_set):\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n            \n        # Check group constraints (at most one per group)\n        for grp_vars in groups.values():\n            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n        \n        # Check precedence (if j selected, i must be selected)\n        precedence_ok = True\n        for pred_i, pred_j in precedence:\n            if pred_j == i and pred_i not in selected_set:\n                precedence_ok = False\n                break\n        \n        if not precedence_ok:\n            continue\n        \n        # Add if we meet minimum cardinality or have room\n        if len(selected_set) < cardinality_bounds[1]:\n            selected_set.add(i)\n            selected.append(i)\n    \n    # Ensure minimum cardinality\n    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n        for i in range(n):\n            if i not in selected_set:\n                selected_set.add(i)\n                selected.append(i)\n                break\n    \n    # Output result\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n    \n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n    \n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n    \n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n    \n    result_str = stdout_capture.getvalue()\n    return result_str\n\n\n```\n\nPerformance metrics:\nCombined score to maximize: 0.35\nfeasible: True; selection_size: 10; raw_score: 106.51\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Improved solver for the Synergistic Dependency Selection problem.\n\n    - Reads JSON from stdin with \"requirements\" and \"catalog\".\n    - Produces JSON to stdout with \"selection\": {\"variables\": [...] }.\n    - Uses a precedence-aware marginal-gain greedy algorithm that:\n        * when adding an item, also includes its required predecessors (closure),\n        * computes the marginal objective (weights + pairwise interactions),\n        * checks mutex/group/cardinality feasibility for the closure before adding.\n    - Adds a lightweight one-step lookahead: when evaluating a candidate closure,\n      also consider the best single subsequent closure that would be feasible after\n      adding the candidate. A discounted portion of that subsequent gain is added\n      to the candidate score to prefer moves that enable strong follow-ups.\n    \"\"\"\n    import re\n\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n\n    # Extract constraints\n    weights = list(requirements.get(\"weights\", []))\n    interactions_raw = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    min_card, max_card = (cardinality_bounds + [len(weights), len(weights)])[:2]\n    mutex = [tuple(m) for m in requirements.get(\"mutex\", [])]\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n\n    n = len(weights)\n\n    # Parse interactions into dict of tuple->float for quick lookup (undirected)\n    interactions = {}\n    for k, v in interactions_raw.items():\n        try:\n            if isinstance(k, str):\n                # allow \"u,v\" or \"u v\"\n                parts = re.split(r'\\s*,\\s*|\\s+', k.strip())\n                if len(parts) >= 2:\n                    u = int(parts[0]); w = int(parts[1])\n                else:\n                    continue\n            elif isinstance(k, (list, tuple)) and len(k) >= 2:\n                u = int(k[0]); w = int(k[1])\n            else:\n                continue\n            interactions[(u, w)] = float(v)\n            interactions[(w, u)] = float(v)\n        except Exception:\n            # skip malformed keys\n            continue\n\n    # Build precedence graph: if (p, j) then p is a prerequisite of j\n    preds = {i: set() for i in range(n)}\n    succs = {i: set() for i in range(n)}\n    for entry in precedence:\n        try:\n            a, b = entry\n            a = int(a); b = int(b)\n            preds[b].add(a)\n            succs[a].add(b)\n        except Exception:\n            continue\n\n    # Precompute ancestors (transitive closure of preds) using DFS/memoization\n    ancestor_cache = {}\n\n    def get_ancestors(i):\n        if i in ancestor_cache:\n            return ancestor_cache[i].copy()\n        res = set()\n        stack = [i]\n        while stack:\n            cur = stack.pop()\n            for p in preds.get(cur, []):\n                if p not in res:\n                    res.add(p)\n                    stack.append(p)\n        ancestor_cache[i] = res.copy()\n        return res\n\n    # Precompute closures (ancestors + self) and cache them for fast reuse\n    closure_cache = {i: get_ancestors(i).union({i}) for i in range(n)}\n\n    # Map variable -> group (assume at most one group membership; if multiple, first wins)\n    var_to_group = {}\n    for gname, vars_list in groups.items():\n        for v in vars_list:\n            try:\n                var_to_group[int(v)] = gname\n            except Exception:\n                pass\n\n    # Helper: check feasibility of adding a closure set given current selected_set\n    def feasible_closure(closure_set, selected_set):\n        # Cardinality\n        if len(selected_set) + len(closure_set - selected_set) > max_card:\n            return False\n        # Mutex: none of closure can conflict with each other or with selected_set\n        for a, b in mutex:\n            if a in closure_set and b in closure_set:\n                return False\n            if (a in closure_set and b in selected_set) or (b in closure_set and a in selected_set):\n                return False\n        # Group: ensure at most one per group overall\n        # Build per-group counts\n        group_counts = {}\n        for v in selected_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in closure_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: closure itself must include ancestors for each element (or they are already selected)\n        for v in closure_set:\n            if not get_ancestors(v).issubset(closure_set.union(selected_set)):\n                return False\n        return True\n\n    # Compute marginal gain of adding closure_set (items that will be newly included)\n    def marginal_gain(closure_set, selected_set):\n        new_items = set(closure_set) - set(selected_set)\n        if not new_items:\n            return 0.0\n        gain = 0.0\n        for i in new_items:\n            if 0 <= i < len(weights):\n                gain += float(weights[i])\n        # interactions among new items\n        new_list = list(new_items)\n        for a in range(len(new_list)):\n            for b in range(a + 1, len(new_list)):\n                gain += interactions.get((new_list[a], new_list[b]), 0.0)\n        # interactions between new items and already selected\n        for i in new_items:\n            for j in selected_set:\n                gain += interactions.get((i, j), 0.0)\n        return gain\n\n    # Greedy loop: at each step try to add an item (and its ancestors) with max marginal gain\n    # Enhanced with small one-step lookahead: for each candidate closure consider the best\n    # subsequent single-closure gain and add a discounted fraction to the candidate score.\n    selected_set = set()\n    improved = True\n    LOOKAHEAD_DISCOUNT = 0.5  # weight of the best next-step gain when scoring current candidate\n    while len(selected_set) < max_card and improved:\n        improved = False\n        best_score = float(\"-inf\")\n        best_gain = float(\"-inf\")\n        best_closure = None\n        # Consider candidates not already selected\n        for i in range(n):\n            if i in selected_set:\n                continue\n            # closure includes i and its ancestors (cached)\n            closure = closure_cache.get(i, {i})\n            # Only consider closures that are feasible\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # quick capacity pruning: if closure would add more items than remaining slots, skip\n            if len(closure - selected_set) > (max_card - len(selected_set)):\n                continue\n            # Compute one-step lookahead: best feasible single closure after adding this closure\n            lookahead_best = 0.0\n            if len(selected_set) + len(closure - selected_set) < max_card:\n                # simulate new selected set\n                sim_selected = selected_set.union(closure)\n                # find best single candidate (could be more expensive, so limit exploration)\n                # We will search all but with a cheap break if we find strong positive gains.\n                for j in range(n):\n                    if j in sim_selected:\n                        continue\n                    closure_j = closure_cache.get(j, {j})\n                    if not feasible_closure(closure_j, sim_selected):\n                        continue\n                    gain_j = marginal_gain(closure_j, sim_selected)\n                    if gain_j > lookahead_best:\n                        lookahead_best = gain_j\n                        # small optimization: if it's very large, we can accept it\n                        if lookahead_best > abs(gain) * 2 + 1e-9:\n                            break\n            total_score = gain + LOOKAHEAD_DISCOUNT * max(0.0, lookahead_best)\n            # Prefer closures that add more items when scores equal (helps reach min_card)\n            if (total_score > best_score) or (abs(total_score - best_score) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_score = total_score\n                best_gain = gain\n                best_closure = closure\n        # If we found a non-negative-gain move, take it\n        if best_closure is not None and best_gain > -1e-12:\n            to_add = set(best_closure) - selected_set\n            if to_add:\n                selected_set.update(to_add)\n                improved = True\n        else:\n            # No non-negative gain move; stop greedy improvements\n            break\n\n    # If we still haven't met minimum cardinality, greedily add best feasible closures regardless of gain\n    # Use same closure cache and prefer closures that may enable good follow-ups.\n    while len(selected_set) < min_card:\n        best_score = float(\"-inf\")\n        best_gain = float(\"-inf\")\n        best_closure = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closure_cache.get(i, {i})\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # lookahead as before (but smaller budget)\n            lookahead_best = 0.0\n            if len(selected_set) + len(closure - selected_set) < max_card:\n                sim_selected = selected_set.union(closure)\n                for j in range(n):\n                    if j in sim_selected:\n                        continue\n                    closure_j = closure_cache.get(j, {j})\n                    if not feasible_closure(closure_j, sim_selected):\n                        continue\n                    gain_j = marginal_gain(closure_j, sim_selected)\n                    if gain_j > lookahead_best:\n                        lookahead_best = gain_j\n            total_score = gain + LOOKAHEAD_DISCOUNT * max(0.0, lookahead_best)\n            if (total_score > best_score) or (abs(total_score - best_score) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_score = total_score\n                best_gain = gain\n                best_closure = closure\n        if best_closure is None:\n            # No feasible closure remains; break to avoid infinite loop\n            break\n        selected_set.update(set(best_closure) - selected_set)\n\n    # Final trim if over max_card (shouldn't happen due to checks) - keep highest-weight items\n    if len(selected_set) > max_card:\n        # score items by marginal contribution relative to selected (approx): weight + interactions with others\n        def item_score(i):\n            s = float(weights[i]) if i < len(weights) else 0.0\n            for j in selected_set:\n                if j == i:\n                    continue\n                s += interactions.get((i, j), 0.0)\n            return s\n        sorted_items = sorted(selected_set, key=item_score, reverse=True)\n        selected_set = set(sorted_items[:max_card])\n\n    result = {\n        \"selection\": {\n            \"variables\": sorted(int(x) for x in selected_set)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n\n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n\n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n\n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n\n    result_str = stdout_capture.getvalue()\n    return result_str\n```\n\nPerformance metrics:\nCombined score to maximize: 0.40\nfeasible: True; selection_size: 10; raw_score: 122.55\n\n\n# Current program\n\nHere is the current program we are trying to improve (you will need to propose a modification to it below):\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Crossover solver for the Synergistic Dependency Selection problem.\n\n    Reads JSON from stdin with \"requirements\" and \"catalog\", and prints JSON\n    with \"selection\": {\"variables\": [...] }.\n\n    Strategy:\n    - Parse inputs robustly.\n    - Build adjacency map for interactions for efficient marginal gain computation.\n    - Precompute transitive ancestor closure for precedence.\n    - For each candidate, consider adding its closure (itself + ancestors).\n    - Greedily add the closure with maximum marginal gain while respecting\n      mutex, groups, and cardinality. Tie-break in favor of larger closures to\n      satisfy minimum cardinality.\n    - If minimum cardinality not reached, add best feasible closures even if negative.\n    - Trim if needed by approximate item scores.\n    \"\"\"\n    import re\n    from collections import defaultdict, deque\n\n    data = json.load(sys.stdin)\n    requirements = data.get(\"requirements\", {}) or {}\n    catalog = data.get(\"catalog\", {}) or {}\n\n    weights = list(requirements.get(\"weights\", []) or [])\n    raw_interactions = requirements.get(\"interactions\", {}) or {}\n    card_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)]) or [0, len(weights)]\n    min_card = int(card_bounds[0]) if len(card_bounds) > 0 else 0\n    max_card = int(card_bounds[1]) if len(card_bounds) > 1 else len(weights)\n    mutex_list = requirements.get(\"mutex\", []) or []\n    groups = requirements.get(\"groups\", {}) or {}\n    precedence = requirements.get(\"precedence\", []) or []\n\n    n = len(weights)\n\n    # Parse interactions into adjacency dict: interactions[u][v] = value\n    interactions = defaultdict(dict)\n    def parse_key(k):\n        # return (u,v) or None\n        try:\n            if isinstance(k, str):\n                parts = re.split(r'\\s*,\\s*|\\s+', k.strip())\n                if len(parts) >= 2:\n                    return int(parts[0]), int(parts[1])\n            elif isinstance(k, (list, tuple)) and len(k) >= 2:\n                return int(k[0]), int(k[1])\n            elif isinstance(k, int):\n                return None\n        except Exception:\n            return None\n        return None\n\n    for k, v in raw_interactions.items():\n        parsed = parse_key(k)\n        try:\n            val = float(v)\n        except Exception:\n            continue\n        if parsed is None:\n            continue\n        u, w = parsed\n        if 0 <= u < n and 0 <= w < n:\n            interactions[u][w] = interactions[u].get(w, 0.0) + val\n            interactions[w][u] = interactions[w].get(u, 0.0) + val\n\n    # Build mutex map for quick conflict checks\n    mutex_map = defaultdict(set)\n    for pair in mutex_list:\n        try:\n            a, b = pair\n            a = int(a); b = int(b)\n            if 0 <= a < n and 0 <= b < n:\n                mutex_map[a].add(b)\n                mutex_map[b].add(a)\n        except Exception:\n            continue\n\n    # Normalize groups: map var -> group name, allow string/int keys\n    var_to_group = {}\n    for gname, vars_list in groups.items():\n        for v in vars_list:\n            try:\n                idx = int(v)\n                if 0 <= idx < n and gname is not None:\n                    # first membership wins\n                    if idx not in var_to_group:\n                        var_to_group[idx] = str(gname)\n            except Exception:\n                continue\n\n    # Build precedence graph (directed: p -> j means p is prerequisite of j)\n    preds = defaultdict(set)\n    succs = defaultdict(set)\n    for entry in precedence:\n        try:\n            a, b = entry\n            a = int(a); b = int(b)\n            if 0 <= a < n and 0 <= b < n:\n                preds[b].add(a)\n                succs[a].add(b)\n        except Exception:\n            continue\n\n    # Precompute transitive ancestor closure for each node using DFS/BFS\n    ancestor_closure = [set() for _ in range(n)]\n    for i in range(n):\n        # BFS/DFS from i to collect all ancestors\n        stack = list(preds.get(i, []))\n        seen = set(stack)\n        while stack:\n            cur = stack.pop()\n            ancestor_closure[i].add(cur)\n            for p in preds.get(cur, []):\n                if p not in seen:\n                    seen.add(p)\n                    stack.append(p)\n\n    # closure for variable i is ancestors + i\n    closures = [set(ancestor_closure[i]) | {i} for i in range(n)]\n\n    # Feasibility check of adding closure (closure is set of vars to ensure present),\n    # given currently selected_set.\n    def feasible_closure(closure, selected_set):\n        # New items that would be added\n        new_items = closure - selected_set\n        # Cardinality check\n        if len(selected_set) + len(new_items) > max_card:\n            return False\n        # Mutex check: none of new items conflict with each other or with selected\n        for v in new_items:\n            # conflicts with selected\n            if any(conflict in selected_set for conflict in mutex_map.get(v, ())) :\n                return False\n            # conflicts with other new items\n            for conflict in mutex_map.get(v, ()):\n                if conflict in new_items:\n                    return False\n        # Group check: cannot create group count >1\n        group_counts = {}\n        for v in selected_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in new_items:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: closures already contain transitive ancestors; but if closure lacks\n        # some ancestor (shouldn't) ensure those ancestors are in selected_set\n        for v in closure:\n            for a in preds.get(v, ()):\n                if a not in closure and a not in selected_set:\n                    return False\n        return True\n\n    # Compute marginal gain for adding closure (new items = closure - selected_set)\n    def marginal_gain(closure, selected_set):\n        new_items = closure - selected_set\n        if not new_items:\n            return 0.0\n        gain = 0.0\n        # weights\n        for i in new_items:\n            if 0 <= i < len(weights):\n                try:\n                    gain += float(weights[i])\n                except Exception:\n                    pass\n        # interactions among new items\n        # iterate edges from each new item to higher-index new items to avoid double count\n        new_list = list(new_items)\n        l = len(new_list)\n        for idx in range(l):\n            u = new_list[idx]\n            # interactions with other new items\n            for v in new_list[idx+1:]:\n                gain += interactions.get(u, {}).get(v, 0.0)\n        # interactions between new items and already selected\n        for u in new_items:\n            for v in selected_set:\n                gain += interactions.get(u, {}).get(v, 0.0)\n        return gain\n\n    # Greedy selection: add closure with best marginal gain while respecting constraints\n    selected_set = set()\n    # Initial heuristic: consider items sorted by weight+abs(interaction_potential)\n    # but main loop will evaluate closures anyway, so we iterate all candidates\n    improved = True\n    while len(selected_set) < max_card and improved:\n        improved = False\n        best_gain = float(\"-inf\")\n        best_closure = None\n        # Evaluate every candidate not yet in selected_set\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closures[i]\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # Tie-breaker: prefer larger closure (helps reach min_card)\n            if (gain > best_gain) or (abs(gain - best_gain) < 1e-12 and best_closure is not None and len(closure - selected_set) > len(best_closure - selected_set)) or (best_closure is None and gain >= best_gain):\n                best_gain = gain\n                best_closure = closure\n        # Accept non-negative gain closures; small negative may be accepted later to meet min_card\n        if best_closure is not None and best_gain > -1e-12:\n            new_items = best_closure - selected_set\n            if new_items:\n                selected_set.update(new_items)\n                improved = True\n        else:\n            break\n\n    # If we haven't met min_card, add best feasible closures even if negative\n    while len(selected_set) < min_card:\n        best_gain = float(\"-inf\")\n        best_closure = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closures[i]\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            if (gain > best_gain) or (abs(gain - best_gain) < 1e-12 and best_closure is not None and len(closure - selected_set) > len(best_closure - selected_set)) or (best_closure is None and gain >= best_gain):\n                best_gain = gain\n                best_closure = closure\n        if best_closure is None:\n            # no feasible closures left\n            break\n        selected_set.update(best_closure - selected_set)\n\n    # Safety trim if we're over max_card (should rarely happen due to checks)\n    if len(selected_set) > max_card:\n        # compute approximate item score = weight + sum interactions with others in selected_set\n        def item_score(i):\n            s = 0.0\n            if 0 <= i < len(weights):\n                try:\n                    s += float(weights[i])\n                except Exception:\n                    pass\n            for j in selected_set:\n                if j == i:\n                    continue\n                s += interactions.get(i, {}).get(j, 0.0)\n            return s\n        sorted_items = sorted(selected_set, key=lambda x: item_score(x), reverse=True)\n        selected_set = set(sorted_items[:max_card])\n\n    result = {\"selection\": {\"variables\": sorted(int(x) for x in selected_set)}}\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n\n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n\n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n\n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n\n    result_str = stdout_capture.getvalue()\n    return result_str\n\n```\n\nHere are the performance metrics of the program:\n\nCombined score to maximize: 0.40\nfeasible: True; selection_size: 10; raw_score: 122.55\n\n# Instructions\n\nMake sure that the changes you propose are consistent with each other. For example, if you refer to a new config variable somewhere, you should also propose a change to add that variable.\n\nNote that the changes you propose will be applied sequentially, so you should assume that the previous changes have already been applied when writing the SEARCH block.\n\n# Task\n\nSuggest a new idea to improve the performance of the code that is inspired by your expert knowledge of the considered subject.\nYour goal is to maximize the `combined_score` of the program.\nDescribe each change with a SEARCH/REPLACE block.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.\n",
          "system_msg": "You are an expert algorithmist specializing in combinatorial optimization, particularly the Synergistic Dependency Selection (SDS) problem.\n\nThe SDS problem requires selecting a subset of variables that:\n1. Satisfies cardinality bounds (min/max number of items)\n2. Respects mutex constraints (cannot select both items in a mutex pair)\n3. Respects group constraints (at most one item per group)\n4. Satisfies precedence constraints (if j is selected, i must be selected)\n5. Maximizes the objective: sum of selected item weights + pairwise interaction values\n\nKey strategies to explore:\n1. Greedy selection with constraint-aware ordering\n2. Dynamic programming for small instances\n3. Constraint satisfaction with backtracking\n4. Weighted scoring that accounts for interactions\n5. Precedence-aware selection ordering\n6. Group-aware selection that maximizes diversity\n\nThe code should read JSON from stdin with \"requirements\" and \"catalog\", and output JSON to stdout with \"selection\" containing \"variables\" list.\n\nBe creative and find efficient solutions that maximize the objective while respecting all constraints.\nYou MUST repond using a edit name, description and the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n<NAME>\nA shortened name summarizing the edit you are proposing. Lowercase, no spaces, underscores allowed.\n</NAME>\n\n<DESCRIPTION>\nA description and argumentation process of the edit you are proposing.\n</DESCRIPTION>\n\n<DIFF>\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly including indentation)\n=======\n# New replacement code\n>>>>>>> REPLACE\n\n</DIFF>\n\n\nExample of a valid diff format:\n<DIFF>\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n\n</DIFF>\n\n* You may only modify text that lies below a line containing \"EVOLVE-BLOCK-START\" and above the next \"EVOLVE-BLOCK-END\". Everything outside those markers is read-only.\n* Do not repeat the markers \"EVOLVE-BLOCK-START\" and \"EVOLVE-BLOCK-END\" in the SEARCH/REPLACE blocks.  \n* Every block\u2019s SEARCH section must be copied **verbatim** from the current file.  Including indentation.\n* You can propose multiple independent edits. SEARCH/REPLACE blocks follow one after another. DO NOT ADD ANY OTHER TEXT BETWEEN THESE BLOCKS.\n* Make sure the file still runs after your changes.",
          "new_msg_history": [
            {
              "role": "user",
              "content": "Here are the performance metrics of a set of prioviously implemented programs:\n\n# Prior programs\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Improved solver for the Synergistic Dependency Selection problem.\n\n    - Reads JSON from stdin with \"requirements\" and \"catalog\".\n    - Produces JSON to stdout with \"selection\": {\"variables\": [...] }.\n    - Uses a precedence-aware marginal-gain greedy algorithm that:\n        * when adding an item, also includes its required predecessors (closure),\n        * computes the marginal objective (weights + pairwise interactions),\n        * checks mutex/group/cardinality feasibility for the closure before adding.\n    \"\"\"\n    import re\n\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n\n    # Extract constraints\n    weights = list(requirements.get(\"weights\", []))\n    interactions_raw = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    min_card, max_card = (cardinality_bounds + [len(weights), len(weights)])[:2]\n    mutex = [tuple(m) for m in requirements.get(\"mutex\", [])]\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n\n    n = len(weights)\n\n    # Parse interactions into dict of tuple->float for quick lookup (undirected)\n    interactions = {}\n    for k, v in interactions_raw.items():\n        try:\n            if isinstance(k, str):\n                # allow \"u,v\" or \"u v\"\n                parts = re.split(r'\\s*,\\s*|\\s+', k.strip())\n                if len(parts) >= 2:\n                    u = int(parts[0]); w = int(parts[1])\n                else:\n                    continue\n            elif isinstance(k, (list, tuple)) and len(k) >= 2:\n                u = int(k[0]); w = int(k[1])\n            else:\n                continue\n            interactions[(u, w)] = float(v)\n            interactions[(w, u)] = float(v)\n        except Exception:\n            # skip malformed keys\n            continue\n\n    # Build precedence graph: if (p, j) then p is a prerequisite of j\n    preds = {i: set() for i in range(n)}\n    succs = {i: set() for i in range(n)}\n    for entry in precedence:\n        try:\n            a, b = entry\n            a = int(a); b = int(b)\n            preds[b].add(a)\n            succs[a].add(b)\n        except Exception:\n            continue\n\n    # Precompute ancestors (transitive closure of preds) using DFS/memoization\n    ancestor_cache = {}\n\n    def get_ancestors(i):\n        if i in ancestor_cache:\n            return ancestor_cache[i].copy()\n        res = set()\n        stack = [i]\n        while stack:\n            cur = stack.pop()\n            for p in preds.get(cur, []):\n                if p not in res:\n                    res.add(p)\n                    stack.append(p)\n        ancestor_cache[i] = res.copy()\n        return res\n\n    # Map variable -> group (assume at most one group membership; if multiple, first wins)\n    var_to_group = {}\n    for gname, vars_list in groups.items():\n        for v in vars_list:\n            try:\n                var_to_group[int(v)] = gname\n            except Exception:\n                pass\n\n    # Helper: check feasibility of adding a closure set given current selected_set\n    def feasible_closure(closure_set, selected_set):\n        # Cardinality\n        if len(selected_set) + len(closure_set - selected_set) > max_card:\n            return False\n        # Mutex: none of closure can conflict with each other or with selected_set\n        for a, b in mutex:\n            if a in closure_set and b in closure_set:\n                return False\n            if (a in closure_set and b in selected_set) or (b in closure_set and a in selected_set):\n                return False\n        # Group: ensure at most one per group overall\n        # Build per-group counts\n        group_counts = {}\n        for v in selected_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in closure_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: closure itself must include ancestors for each element\n        for v in closure_set:\n            if not get_ancestors(v).issubset(closure_set.union(selected_set)):\n                return False\n        return True\n\n    # Compute marginal gain of adding closure_set (items that will be newly included)\n    def marginal_gain(closure_set, selected_set):\n        new_items = set(closure_set) - set(selected_set)\n        gain = 0.0\n        for i in new_items:\n            if i < len(weights):\n                gain += float(weights[i])\n        # interactions among new items\n        new_list = list(new_items)\n        for i in range(len(new_list)):\n            for j in range(i + 1, len(new_list)):\n                gain += interactions.get((new_list[i], new_list[j]), 0.0)\n        # interactions between new items and already selected\n        for i in new_items:\n            for j in selected_set:\n                gain += interactions.get((i, j), 0.0)\n        return gain\n\n    # Greedy loop: at each step try to add an item (and its ancestors) with max marginal gain\n    selected_set = set()\n    # Keep iterating while we can still add and haven't reached max_card\n    improved = True\n    while len(selected_set) < max_card and improved:\n        improved = False\n        best_gain = float(\"-inf\")\n        best_closure = None\n        # Consider candidates not already selected\n        for i in range(n):\n            if i in selected_set:\n                continue\n            # closure includes i and its ancestors\n            closure = get_ancestors(i).union({i})\n            # Only consider closures that are feasible\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # Prefer closures that add more items when gain is equal (to help reach min_card)\n            if gain > best_gain or (abs(gain - best_gain) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_gain = gain\n                best_closure = closure\n        # If we found a positive-gain move, take it\n        if best_closure is not None and best_gain > -1e-12:\n            to_add = set(best_closure) - selected_set\n            if to_add:\n                selected_set.update(to_add)\n                improved = True\n        else:\n            # No non-negative gain move; stop greedy improvements\n            break\n\n    # If we still haven't met minimum cardinality, greedily add best feasible closures regardless of gain\n    while len(selected_set) < min_card:\n        best_gain = float(\"-inf\")\n        best_closure = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = get_ancestors(i).union({i})\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # choose closure that gives best gain (even if negative), tie-breaker favors larger closures\n            if gain > best_gain or (abs(gain - best_gain) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_gain = gain\n                best_closure = closure\n        if best_closure is None:\n            # No feasible closure remains; break to avoid infinite loop\n            break\n        selected_set.update(set(best_closure) - selected_set)\n\n    # Final trim if over max_card (shouldn't happen due to checks) - keep highest-weight items\n    if len(selected_set) > max_card:\n        # score items by marginal contribution relative to selected (approx): weight + interactions with others\n        def item_score(i):\n            s = float(weights[i]) if i < len(weights) else 0.0\n            for j in selected_set:\n                if j == i:\n                    continue\n                s += interactions.get((i, j), 0.0)\n            return s\n        sorted_items = sorted(selected_set, key=item_score, reverse=True)\n        selected_set = set(sorted_items[:max_card])\n\n    result = {\n        \"selection\": {\n            \"variables\": sorted(int(x) for x in selected_set)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n\n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n\n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n\n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n\n    result_str = stdout_capture.getvalue()\n    return result_str\n\n```\n\nPerformance metrics:\nCombined score to maximize: 0.40\nfeasible: True; selection_size: 10; raw_score: 122.55\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    This is a greedy baseline - evolution will improve this.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    # Simple greedy: select items with highest weights first\n    # This is a baseline - evolution will find better strategies\n    n = len(weights)\n    selected = []\n    \n    # Create score list (weight + interaction potential)\n    scores = []\n    for i in range(n):\n        score = weights[i] if i < len(weights) else 0.0\n        # Add potential interaction value\n        for k, v in interactions.items():\n            try:\n                u, w = map(int, k.split(\",\"))\n                if u == i or w == i:\n                    score += abs(v) * 0.5  # Potential value\n            except:\n                pass\n        scores.append((score, i))\n    \n    # Sort by score descending\n    scores.sort(reverse=True)\n    \n    # Greedy selection respecting constraints\n    selected_set = set()\n    for score, i in scores:\n        if len(selected_set) >= cardinality_bounds[1]:\n            break\n            \n        # Check mutex constraints\n        can_add = True\n        for a, b in mutex:\n            if (a == i and b in selected_set) or (b == i and a in selected_set):\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n            \n        # Check group constraints (at most one per group)\n        for grp_vars in groups.values():\n            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n        \n        # Check precedence (if j selected, i must be selected)\n        precedence_ok = True\n        for pred_i, pred_j in precedence:\n            if pred_j == i and pred_i not in selected_set:\n                precedence_ok = False\n                break\n        \n        if not precedence_ok:\n            continue\n        \n        # Add if we meet minimum cardinality or have room\n        if len(selected_set) < cardinality_bounds[1]:\n            selected_set.add(i)\n            selected.append(i)\n    \n    # Ensure minimum cardinality\n    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n        for i in range(n):\n            if i not in selected_set:\n                selected_set.add(i)\n                selected.append(i)\n                break\n    \n    # Output result\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n    \n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n    \n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n    \n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n    \n    result_str = stdout_capture.getvalue()\n    return result_str\n\n\n```\n\nPerformance metrics:\nCombined score to maximize: 0.35\nfeasible: True; selection_size: 10; raw_score: 106.51\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Improved solver for the Synergistic Dependency Selection problem.\n\n    - Reads JSON from stdin with \"requirements\" and \"catalog\".\n    - Produces JSON to stdout with \"selection\": {\"variables\": [...] }.\n    - Uses a precedence-aware marginal-gain greedy algorithm that:\n        * when adding an item, also includes its required predecessors (closure),\n        * computes the marginal objective (weights + pairwise interactions),\n        * checks mutex/group/cardinality feasibility for the closure before adding.\n    - Adds a lightweight one-step lookahead: when evaluating a candidate closure,\n      also consider the best single subsequent closure that would be feasible after\n      adding the candidate. A discounted portion of that subsequent gain is added\n      to the candidate score to prefer moves that enable strong follow-ups.\n    \"\"\"\n    import re\n\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n\n    # Extract constraints\n    weights = list(requirements.get(\"weights\", []))\n    interactions_raw = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    min_card, max_card = (cardinality_bounds + [len(weights), len(weights)])[:2]\n    mutex = [tuple(m) for m in requirements.get(\"mutex\", [])]\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n\n    n = len(weights)\n\n    # Parse interactions into dict of tuple->float for quick lookup (undirected)\n    interactions = {}\n    for k, v in interactions_raw.items():\n        try:\n            if isinstance(k, str):\n                # allow \"u,v\" or \"u v\"\n                parts = re.split(r'\\s*,\\s*|\\s+', k.strip())\n                if len(parts) >= 2:\n                    u = int(parts[0]); w = int(parts[1])\n                else:\n                    continue\n            elif isinstance(k, (list, tuple)) and len(k) >= 2:\n                u = int(k[0]); w = int(k[1])\n            else:\n                continue\n            interactions[(u, w)] = float(v)\n            interactions[(w, u)] = float(v)\n        except Exception:\n            # skip malformed keys\n            continue\n\n    # Build precedence graph: if (p, j) then p is a prerequisite of j\n    preds = {i: set() for i in range(n)}\n    succs = {i: set() for i in range(n)}\n    for entry in precedence:\n        try:\n            a, b = entry\n            a = int(a); b = int(b)\n            preds[b].add(a)\n            succs[a].add(b)\n        except Exception:\n            continue\n\n    # Precompute ancestors (transitive closure of preds) using DFS/memoization\n    ancestor_cache = {}\n\n    def get_ancestors(i):\n        if i in ancestor_cache:\n            return ancestor_cache[i].copy()\n        res = set()\n        stack = [i]\n        while stack:\n            cur = stack.pop()\n            for p in preds.get(cur, []):\n                if p not in res:\n                    res.add(p)\n                    stack.append(p)\n        ancestor_cache[i] = res.copy()\n        return res\n\n    # Precompute closures (ancestors + self) and cache them for fast reuse\n    closure_cache = {i: get_ancestors(i).union({i}) for i in range(n)}\n\n    # Map variable -> group (assume at most one group membership; if multiple, first wins)\n    var_to_group = {}\n    for gname, vars_list in groups.items():\n        for v in vars_list:\n            try:\n                var_to_group[int(v)] = gname\n            except Exception:\n                pass\n\n    # Helper: check feasibility of adding a closure set given current selected_set\n    def feasible_closure(closure_set, selected_set):\n        # Cardinality\n        if len(selected_set) + len(closure_set - selected_set) > max_card:\n            return False\n        # Mutex: none of closure can conflict with each other or with selected_set\n        for a, b in mutex:\n            if a in closure_set and b in closure_set:\n                return False\n            if (a in closure_set and b in selected_set) or (b in closure_set and a in selected_set):\n                return False\n        # Group: ensure at most one per group overall\n        # Build per-group counts\n        group_counts = {}\n        for v in selected_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in closure_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: closure itself must include ancestors for each element (or they are already selected)\n        for v in closure_set:\n            if not get_ancestors(v).issubset(closure_set.union(selected_set)):\n                return False\n        return True\n\n    # Compute marginal gain of adding closure_set (items that will be newly included)\n    def marginal_gain(closure_set, selected_set):\n        new_items = set(closure_set) - set(selected_set)\n        if not new_items:\n            return 0.0\n        gain = 0.0\n        for i in new_items:\n            if 0 <= i < len(weights):\n                gain += float(weights[i])\n        # interactions among new items\n        new_list = list(new_items)\n        for a in range(len(new_list)):\n            for b in range(a + 1, len(new_list)):\n                gain += interactions.get((new_list[a], new_list[b]), 0.0)\n        # interactions between new items and already selected\n        for i in new_items:\n            for j in selected_set:\n                gain += interactions.get((i, j), 0.0)\n        return gain\n\n    # Greedy loop: at each step try to add an item (and its ancestors) with max marginal gain\n    # Enhanced with small one-step lookahead: for each candidate closure consider the best\n    # subsequent single-closure gain and add a discounted fraction to the candidate score.\n    selected_set = set()\n    improved = True\n    LOOKAHEAD_DISCOUNT = 0.5  # weight of the best next-step gain when scoring current candidate\n    while len(selected_set) < max_card and improved:\n        improved = False\n        best_score = float(\"-inf\")\n        best_gain = float(\"-inf\")\n        best_closure = None\n        # Consider candidates not already selected\n        for i in range(n):\n            if i in selected_set:\n                continue\n            # closure includes i and its ancestors (cached)\n            closure = closure_cache.get(i, {i})\n            # Only consider closures that are feasible\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # quick capacity pruning: if closure would add more items than remaining slots, skip\n            if len(closure - selected_set) > (max_card - len(selected_set)):\n                continue\n            # Compute one-step lookahead: best feasible single closure after adding this closure\n            lookahead_best = 0.0\n            if len(selected_set) + len(closure - selected_set) < max_card:\n                # simulate new selected set\n                sim_selected = selected_set.union(closure)\n                # find best single candidate (could be more expensive, so limit exploration)\n                # We will search all but with a cheap break if we find strong positive gains.\n                for j in range(n):\n                    if j in sim_selected:\n                        continue\n                    closure_j = closure_cache.get(j, {j})\n                    if not feasible_closure(closure_j, sim_selected):\n                        continue\n                    gain_j = marginal_gain(closure_j, sim_selected)\n                    if gain_j > lookahead_best:\n                        lookahead_best = gain_j\n                        # small optimization: if it's very large, we can accept it\n                        if lookahead_best > abs(gain) * 2 + 1e-9:\n                            break\n            total_score = gain + LOOKAHEAD_DISCOUNT * max(0.0, lookahead_best)\n            # Prefer closures that add more items when scores equal (helps reach min_card)\n            if (total_score > best_score) or (abs(total_score - best_score) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_score = total_score\n                best_gain = gain\n                best_closure = closure\n        # If we found a non-negative-gain move, take it\n        if best_closure is not None and best_gain > -1e-12:\n            to_add = set(best_closure) - selected_set\n            if to_add:\n                selected_set.update(to_add)\n                improved = True\n        else:\n            # No non-negative gain move; stop greedy improvements\n            break\n\n    # If we still haven't met minimum cardinality, greedily add best feasible closures regardless of gain\n    # Use same closure cache and prefer closures that may enable good follow-ups.\n    while len(selected_set) < min_card:\n        best_score = float(\"-inf\")\n        best_gain = float(\"-inf\")\n        best_closure = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closure_cache.get(i, {i})\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # lookahead as before (but smaller budget)\n            lookahead_best = 0.0\n            if len(selected_set) + len(closure - selected_set) < max_card:\n                sim_selected = selected_set.union(closure)\n                for j in range(n):\n                    if j in sim_selected:\n                        continue\n                    closure_j = closure_cache.get(j, {j})\n                    if not feasible_closure(closure_j, sim_selected):\n                        continue\n                    gain_j = marginal_gain(closure_j, sim_selected)\n                    if gain_j > lookahead_best:\n                        lookahead_best = gain_j\n            total_score = gain + LOOKAHEAD_DISCOUNT * max(0.0, lookahead_best)\n            if (total_score > best_score) or (abs(total_score - best_score) < 1e-9 and (best_closure is None or len(closure - selected_set) > len(best_closure - selected_set))):\n                best_score = total_score\n                best_gain = gain\n                best_closure = closure\n        if best_closure is None:\n            # No feasible closure remains; break to avoid infinite loop\n            break\n        selected_set.update(set(best_closure) - selected_set)\n\n    # Final trim if over max_card (shouldn't happen due to checks) - keep highest-weight items\n    if len(selected_set) > max_card:\n        # score items by marginal contribution relative to selected (approx): weight + interactions with others\n        def item_score(i):\n            s = float(weights[i]) if i < len(weights) else 0.0\n            for j in selected_set:\n                if j == i:\n                    continue\n                s += interactions.get((i, j), 0.0)\n            return s\n        sorted_items = sorted(selected_set, key=item_score, reverse=True)\n        selected_set = set(sorted_items[:max_card])\n\n    result = {\n        \"selection\": {\n            \"variables\": sorted(int(x) for x in selected_set)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n\n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n\n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n\n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n\n    result_str = stdout_capture.getvalue()\n    return result_str\n```\n\nPerformance metrics:\nCombined score to maximize: 0.40\nfeasible: True; selection_size: 10; raw_score: 122.55\n\n\n# Current program\n\nHere is the current program we are trying to improve (you will need to propose a modification to it below):\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Crossover solver for the Synergistic Dependency Selection problem.\n\n    Reads JSON from stdin with \"requirements\" and \"catalog\", and prints JSON\n    with \"selection\": {\"variables\": [...] }.\n\n    Strategy:\n    - Parse inputs robustly.\n    - Build adjacency map for interactions for efficient marginal gain computation.\n    - Precompute transitive ancestor closure for precedence.\n    - For each candidate, consider adding its closure (itself + ancestors).\n    - Greedily add the closure with maximum marginal gain while respecting\n      mutex, groups, and cardinality. Tie-break in favor of larger closures to\n      satisfy minimum cardinality.\n    - If minimum cardinality not reached, add best feasible closures even if negative.\n    - Trim if needed by approximate item scores.\n    \"\"\"\n    import re\n    from collections import defaultdict, deque\n\n    data = json.load(sys.stdin)\n    requirements = data.get(\"requirements\", {}) or {}\n    catalog = data.get(\"catalog\", {}) or {}\n\n    weights = list(requirements.get(\"weights\", []) or [])\n    raw_interactions = requirements.get(\"interactions\", {}) or {}\n    card_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)]) or [0, len(weights)]\n    min_card = int(card_bounds[0]) if len(card_bounds) > 0 else 0\n    max_card = int(card_bounds[1]) if len(card_bounds) > 1 else len(weights)\n    mutex_list = requirements.get(\"mutex\", []) or []\n    groups = requirements.get(\"groups\", {}) or {}\n    precedence = requirements.get(\"precedence\", []) or []\n\n    n = len(weights)\n\n    # Parse interactions into adjacency dict: interactions[u][v] = value\n    interactions = defaultdict(dict)\n    def parse_key(k):\n        # return (u,v) or None\n        try:\n            if isinstance(k, str):\n                parts = re.split(r'\\s*,\\s*|\\s+', k.strip())\n                if len(parts) >= 2:\n                    return int(parts[0]), int(parts[1])\n            elif isinstance(k, (list, tuple)) and len(k) >= 2:\n                return int(k[0]), int(k[1])\n            elif isinstance(k, int):\n                return None\n        except Exception:\n            return None\n        return None\n\n    for k, v in raw_interactions.items():\n        parsed = parse_key(k)\n        try:\n            val = float(v)\n        except Exception:\n            continue\n        if parsed is None:\n            continue\n        u, w = parsed\n        if 0 <= u < n and 0 <= w < n:\n            interactions[u][w] = interactions[u].get(w, 0.0) + val\n            interactions[w][u] = interactions[w].get(u, 0.0) + val\n\n    # Build mutex map for quick conflict checks\n    mutex_map = defaultdict(set)\n    for pair in mutex_list:\n        try:\n            a, b = pair\n            a = int(a); b = int(b)\n            if 0 <= a < n and 0 <= b < n:\n                mutex_map[a].add(b)\n                mutex_map[b].add(a)\n        except Exception:\n            continue\n\n    # Normalize groups: map var -> group name, allow string/int keys\n    var_to_group = {}\n    for gname, vars_list in groups.items():\n        for v in vars_list:\n            try:\n                idx = int(v)\n                if 0 <= idx < n and gname is not None:\n                    # first membership wins\n                    if idx not in var_to_group:\n                        var_to_group[idx] = str(gname)\n            except Exception:\n                continue\n\n    # Build precedence graph (directed: p -> j means p is prerequisite of j)\n    preds = defaultdict(set)\n    succs = defaultdict(set)\n    for entry in precedence:\n        try:\n            a, b = entry\n            a = int(a); b = int(b)\n            if 0 <= a < n and 0 <= b < n:\n                preds[b].add(a)\n                succs[a].add(b)\n        except Exception:\n            continue\n\n    # Precompute transitive ancestor closure for each node using DFS/BFS\n    ancestor_closure = [set() for _ in range(n)]\n    for i in range(n):\n        # BFS/DFS from i to collect all ancestors\n        stack = list(preds.get(i, []))\n        seen = set(stack)\n        while stack:\n            cur = stack.pop()\n            ancestor_closure[i].add(cur)\n            for p in preds.get(cur, []):\n                if p not in seen:\n                    seen.add(p)\n                    stack.append(p)\n\n    # closure for variable i is ancestors + i\n    closures = [set(ancestor_closure[i]) | {i} for i in range(n)]\n\n    # Feasibility check of adding closure (closure is set of vars to ensure present),\n    # given currently selected_set.\n    def feasible_closure(closure, selected_set):\n        # New items that would be added\n        new_items = closure - selected_set\n        # Cardinality check\n        if len(selected_set) + len(new_items) > max_card:\n            return False\n        # Mutex check: none of new items conflict with each other or with selected\n        for v in new_items:\n            # conflicts with selected\n            if any(conflict in selected_set for conflict in mutex_map.get(v, ())) :\n                return False\n            # conflicts with other new items\n            for conflict in mutex_map.get(v, ()):\n                if conflict in new_items:\n                    return False\n        # Group check: cannot create group count >1\n        group_counts = {}\n        for v in selected_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in new_items:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: closures already contain transitive ancestors; but if closure lacks\n        # some ancestor (shouldn't) ensure those ancestors are in selected_set\n        for v in closure:\n            for a in preds.get(v, ()):\n                if a not in closure and a not in selected_set:\n                    return False\n        return True\n\n    # Compute marginal gain for adding closure (new items = closure - selected_set)\n    def marginal_gain(closure, selected_set):\n        new_items = closure - selected_set\n        if not new_items:\n            return 0.0\n        gain = 0.0\n        # weights\n        for i in new_items:\n            if 0 <= i < len(weights):\n                try:\n                    gain += float(weights[i])\n                except Exception:\n                    pass\n        # interactions among new items\n        # iterate edges from each new item to higher-index new items to avoid double count\n        new_list = list(new_items)\n        l = len(new_list)\n        for idx in range(l):\n            u = new_list[idx]\n            # interactions with other new items\n            for v in new_list[idx+1:]:\n                gain += interactions.get(u, {}).get(v, 0.0)\n        # interactions between new items and already selected\n        for u in new_items:\n            for v in selected_set:\n                gain += interactions.get(u, {}).get(v, 0.0)\n        return gain\n\n    # Greedy selection: add closure with best marginal gain while respecting constraints\n    selected_set = set()\n    # Initial heuristic: consider items sorted by weight+abs(interaction_potential)\n    # but main loop will evaluate closures anyway, so we iterate all candidates\n    improved = True\n    while len(selected_set) < max_card and improved:\n        improved = False\n        best_gain = float(\"-inf\")\n        best_closure = None\n        # Evaluate every candidate not yet in selected_set\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closures[i]\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # Tie-breaker: prefer larger closure (helps reach min_card)\n            if (gain > best_gain) or (abs(gain - best_gain) < 1e-12 and best_closure is not None and len(closure - selected_set) > len(best_closure - selected_set)) or (best_closure is None and gain >= best_gain):\n                best_gain = gain\n                best_closure = closure\n        # Accept non-negative gain closures; small negative may be accepted later to meet min_card\n        if best_closure is not None and best_gain > -1e-12:\n            new_items = best_closure - selected_set\n            if new_items:\n                selected_set.update(new_items)\n                improved = True\n        else:\n            break\n\n    # If we haven't met min_card, add best feasible closures even if negative\n    while len(selected_set) < min_card:\n        best_gain = float(\"-inf\")\n        best_closure = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closures[i]\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            if (gain > best_gain) or (abs(gain - best_gain) < 1e-12 and best_closure is not None and len(closure - selected_set) > len(best_closure - selected_set)) or (best_closure is None and gain >= best_gain):\n                best_gain = gain\n                best_closure = closure\n        if best_closure is None:\n            # no feasible closures left\n            break\n        selected_set.update(best_closure - selected_set)\n\n    # Safety trim if we're over max_card (should rarely happen due to checks)\n    if len(selected_set) > max_card:\n        # compute approximate item score = weight + sum interactions with others in selected_set\n        def item_score(i):\n            s = 0.0\n            if 0 <= i < len(weights):\n                try:\n                    s += float(weights[i])\n                except Exception:\n                    pass\n            for j in selected_set:\n                if j == i:\n                    continue\n                s += interactions.get(i, {}).get(j, 0.0)\n            return s\n        sorted_items = sorted(selected_set, key=lambda x: item_score(x), reverse=True)\n        selected_set = set(sorted_items[:max_card])\n\n    result = {\"selection\": {\"variables\": sorted(int(x) for x in selected_set)}}\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n\n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n\n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n\n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n\n    result_str = stdout_capture.getvalue()\n    return result_str\n\n```\n\nHere are the performance metrics of the program:\n\nCombined score to maximize: 0.40\nfeasible: True; selection_size: 10; raw_score: 122.55\n\n# Instructions\n\nMake sure that the changes you propose are consistent with each other. For example, if you refer to a new config variable somewhere, you should also propose a change to add that variable.\n\nNote that the changes you propose will be applied sequentially, so you should assume that the previous changes have already been applied when writing the SEARCH block.\n\n# Task\n\nSuggest a new idea to improve the performance of the code that is inspired by your expert knowledge of the considered subject.\nYour goal is to maximize the `combined_score` of the program.\nDescribe each change with a SEARCH/REPLACE block.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.\n"
            },
            {
              "role": "assistant",
              "content": "<NAME>\nlocal_swap_improvement\n</NAME>\n\n<DESCRIPTION>\nAdd a lightweight local-search (1-for-1 swap) improvement phase after the greedy construction.\nThis phase attempts to swap a single selected variable with a candidate closure (item + ancestors)\nthat would otherwise not fit, removing one selected item if safe (i.e., not a required ancestor\nfor remaining items). The swap is only applied if it strictly improves the objective (weights + interactions).\nThis aims to escape local greedy traps and capture beneficial interaction-driven trades without heavy cost.\nI keep all existing feasibility checks and reuse precomputed closures and marginal_gain for correctness.\n</DESCRIPTION>\n\n<DIFF>\n<<<<<<< SEARCH\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Crossover solver for the Synergistic Dependency Selection problem.\n\n    Reads JSON from stdin with \"requirements\" and \"catalog\", and prints JSON\n    with \"selection\": {\"variables\": [...] }.\n\n    Strategy:\n    - Parse inputs robustly.\n    - Build adjacency map for interactions for efficient marginal gain computation.\n    - Precompute transitive ancestor closure for precedence.\n    - For each candidate, consider adding its closure (itself + ancestors).\n    - Greedily add the closure with maximum marginal gain while respecting\n      mutex, groups, and cardinality. Tie-break in favor of larger closures to\n      satisfy minimum cardinality.\n    - If minimum cardinality not reached, add best feasible closures even if negative.\n    - Trim if needed by approximate item scores.\n    \"\"\"\n    import re\n    from collections import defaultdict, deque\n\n    data = json.load(sys.stdin)\n    requirements = data.get(\"requirements\", {}) or {}\n    catalog = data.get(\"catalog\", {}) or {}\n\n    weights = list(requirements.get(\"weights\", []) or [])\n    raw_interactions = requirements.get(\"interactions\", {}) or {}\n    card_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)]) or [0, len(weights)]\n    min_card = int(card_bounds[0]) if len(card_bounds) > 0 else 0\n    max_card = int(card_bounds[1]) if len(card_bounds) > 1 else len(weights)\n    mutex_list = requirements.get(\"mutex\", []) or []\n    groups = requirements.get(\"groups\", {}) or {}\n    precedence = requirements.get(\"precedence\", []) or []\n\n    n = len(weights)\n\n    # Parse interactions into adjacency dict: interactions[u][v] = value\n    interactions = defaultdict(dict)\n    def parse_key(k):\n        # return (u,v) or None\n        try:\n            if isinstance(k, str):\n                parts = re.split(r'\\s*,\\s*|\\s+', k.strip())\n                if len(parts) >= 2:\n                    return int(parts[0]), int(parts[1])\n            elif isinstance(k, (list, tuple)) and len(k) >= 2:\n                return int(k[0]), int(k[1])\n            elif isinstance(k, int):\n                return None\n        except Exception:\n            return None\n        return None\n\n    for k, v in raw_interactions.items():\n        parsed = parse_key(k)\n        try:\n            val = float(v)\n        except Exception:\n            continue\n        if parsed is None:\n            continue\n        u, w = parsed\n        if 0 <= u < n and 0 <= w < n:\n            interactions[u][w] = interactions[u].get(w, 0.0) + val\n            interactions[w][u] = interactions[w].get(u, 0.0) + val\n\n    # Build mutex map for quick conflict checks\n    mutex_map = defaultdict(set)\n    for pair in mutex_list:\n        try:\n            a, b = pair\n            a = int(a); b = int(b)\n            if 0 <= a < n and 0 <= b < n:\n                mutex_map[a].add(b)\n                mutex_map[b].add(a)\n        except Exception:\n            continue\n\n    # Normalize groups: map var -> group name, allow string/int keys\n    var_to_group = {}\n    for gname, vars_list in groups.items():\n        for v in vars_list:\n            try:\n                idx = int(v)\n                if 0 <= idx < n and gname is not None:\n                    # first membership wins\n                    if idx not in var_to_group:\n                        var_to_group[idx] = str(gname)\n            except Exception:\n                continue\n\n    # Build precedence graph (directed: p -> j means p is prerequisite of j)\n    preds = defaultdict(set)\n    succs = defaultdict(set)\n    for entry in precedence:\n        try:\n            a, b = entry\n            a = int(a); b = int(b)\n            if 0 <= a < n and 0 <= b < n:\n                preds[b].add(a)\n                succs[a].add(b)\n        except Exception:\n            continue\n\n    # Precompute transitive ancestor closure for each node using DFS/BFS\n    ancestor_closure = [set() for _ in range(n)]\n    for i in range(n):\n        # BFS/DFS from i to collect all ancestors\n        stack = list(preds.get(i, []))\n        seen = set(stack)\n        while stack:\n            cur = stack.pop()\n            ancestor_closure[i].add(cur)\n            for p in preds.get(cur, []):\n                if p not in seen:\n                    seen.add(p)\n                    stack.append(p)\n\n    # closure for variable i is ancestors + i\n    closures = [set(ancestor_closure[i]) | {i} for i in range(n)]\n\n    # Feasibility check of adding closure (closure is set of vars to ensure present),\n    # given currently selected_set.\n    def feasible_closure(closure, selected_set):\n        # New items that would be added\n        new_items = closure - selected_set\n        # Cardinality check\n        if len(selected_set) + len(new_items) > max_card:\n            return False\n        # Mutex check: none of new items conflict with each other or with selected\n        for v in new_items:\n            # conflicts with selected\n            if any(conflict in selected_set for conflict in mutex_map.get(v, ())) :\n                return False\n            # conflicts with other new items\n            for conflict in mutex_map.get(v, ()):\n                if conflict in new_items:\n                    return False\n        # Group check: cannot create group count >1\n        group_counts = {}\n        for v in selected_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in new_items:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: closures already contain transitive ancestors; but if closure lacks\n        # some ancestor (shouldn't) ensure those ancestors are in selected_set\n        for v in closure:\n            for a in preds.get(v, ()):\n                if a not in closure and a not in selected_set:\n                    return False\n        return True\n\n    # Compute marginal gain for adding closure (new items = closure - selected_set)\n    def marginal_gain(closure, selected_set):\n        new_items = closure - selected_set\n        if not new_items:\n            return 0.0\n        gain = 0.0\n        # weights\n        for i in new_items:\n            if 0 <= i < len(weights):\n                try:\n                    gain += float(weights[i])\n                except Exception:\n                    pass\n        # interactions among new items\n        # iterate edges from each new item to higher-index new items to avoid double count\n        new_list = list(new_items)\n        l = len(new_list)\n        for idx in range(l):\n            u = new_list[idx]\n            # interactions with other new items\n            for v in new_list[idx+1:]:\n                gain += interactions.get(u, {}).get(v, 0.0)\n        # interactions between new items and already selected\n        for u in new_items:\n            for v in selected_set:\n                gain += interactions.get(u, {}).get(v, 0.0)\n        return gain\n\n    # Greedy selection: add closure with best marginal gain while respecting constraints\n    selected_set = set()\n    # Initial heuristic: consider items sorted by weight+abs(interaction_potential)\n    # but main loop will evaluate closures anyway, so we iterate all candidates\n    improved = True\n    while len(selected_set) < max_card and improved:\n        improved = False\n        best_gain = float(\"-inf\")\n        best_closure = None\n        # Evaluate every candidate not yet in selected_set\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closures[i]\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # Tie-breaker: prefer larger closure (helps reach min_card)\n            if (gain > best_gain) or (abs(gain - best_gain) < 1e-12 and best_closure is not None and len(closure - selected_set) > len(best_closure - selected_set)) or (best_closure is None and gain >= best_gain):\n                best_gain = gain\n                best_closure = closure\n        # Accept non-negative gain closures; small negative may be accepted later to meet min_card\n        if best_closure is not None and best_gain > -1e-12:\n            new_items = best_closure - selected_set\n            if new_items:\n                selected_set.update(new_items)\n                improved = True\n        else:\n            break\n\n    # If we haven't met min_card, add best feasible closures even if negative\n    while len(selected_set) < min_card:\n        best_gain = float(\"-inf\")\n        best_closure = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closures[i]\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            if (gain > best_gain) or (abs(gain - best_gain) < 1e-12 and best_closure is not None and len(closure - selected_set) > len(best_closure - selected_set)) or (best_closure is None and gain >= best_gain):\n                best_gain = gain\n                best_closure = closure\n        if best_closure is None:\n            # no feasible closures left\n            break\n        selected_set.update(best_closure - selected_set)\n\n    # Safety trim if we're over max_card (should rarely happen due to checks)\n    if len(selected_set) > max_card:\n        # compute approximate item score = weight + sum interactions with others in selected_set\n        def item_score(i):\n            s = 0.0\n            if 0 <= i < len(weights):\n                try:\n                    s += float(weights[i])\n                except Exception:\n                    pass\n            for j in selected_set:\n                if j == i:\n                    continue\n                s += interactions.get(i, {}).get(j, 0.0)\n            return s\n        sorted_items = sorted(selected_set, key=lambda x: item_score(x), reverse=True)\n        selected_set = set(sorted_items[:max_card])\n\n    result = {\"selection\": {\"variables\": sorted(int(x) for x in selected_set)}}\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n=======\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Crossover solver for the Synergistic Dependency Selection problem.\n\n    Reads JSON from stdin with \"requirements\" and \"catalog\", and prints JSON\n    with \"selection\": {\"variables\": [...] }.\n\n    Strategy:\n    - Parse inputs robustly.\n    - Build adjacency map for interactions for efficient marginal gain computation.\n    - Precompute transitive ancestor closure for precedence.\n    - For each candidate, consider adding its closure (itself + ancestors).\n    - Greedily add the closure with maximum marginal gain while respecting\n      mutex, groups, and cardinality. Tie-break in favor of larger closures to\n      satisfy minimum cardinality.\n    - If minimum cardinality not reached, add best feasible closures even if negative.\n    - Lightweight local-search: attempt beneficial 1-for-1 swaps (remove one selected,\n      add a candidate closure) that strictly increase the objective while preserving feasibility.\n    - Trim if needed by approximate item scores.\n    \"\"\"\n    import re\n    from collections import defaultdict, deque\n\n    data = json.load(sys.stdin)\n    requirements = data.get(\"requirements\", {}) or {}\n    catalog = data.get(\"catalog\", {}) or {}\n\n    weights = list(requirements.get(\"weights\", []) or [])\n    raw_interactions = requirements.get(\"interactions\", {}) or {}\n    card_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)]) or [0, len(weights)]\n    min_card = int(card_bounds[0]) if len(card_bounds) > 0 else 0\n    max_card = int(card_bounds[1]) if len(card_bounds) > 1 else len(weights)\n    mutex_list = requirements.get(\"mutex\", []) or []\n    groups = requirements.get(\"groups\", {}) or {}\n    precedence = requirements.get(\"precedence\", []) or []\n\n    n = len(weights)\n\n    # Parse interactions into adjacency dict: interactions[u][v] = value\n    interactions = defaultdict(dict)\n    def parse_key(k):\n        # return (u,v) or None\n        try:\n            if isinstance(k, str):\n                parts = re.split(r'\\s*,\\s*|\\s+', k.strip())\n                if len(parts) >= 2:\n                    return int(parts[0]), int(parts[1])\n            elif isinstance(k, (list, tuple)) and len(k) >= 2:\n                return int(k[0]), int(k[1])\n            elif isinstance(k, int):\n                return None\n        except Exception:\n            return None\n        return None\n\n    for k, v in raw_interactions.items():\n        parsed = parse_key(k)\n        try:\n            val = float(v)\n        except Exception:\n            continue\n        if parsed is None:\n            continue\n        u, w = parsed\n        if 0 <= u < n and 0 <= w < n:\n            interactions[u][w] = interactions[u].get(w, 0.0) + val\n            interactions[w][u] = interactions[w].get(u, 0.0) + val\n\n    # Build mutex map for quick conflict checks\n    mutex_map = defaultdict(set)\n    for pair in mutex_list:\n        try:\n            a, b = pair\n            a = int(a); b = int(b)\n            if 0 <= a < n and 0 <= b < n:\n                mutex_map[a].add(b)\n                mutex_map[b].add(a)\n        except Exception:\n            continue\n\n    # Normalize groups: map var -> group name, allow string/int keys\n    var_to_group = {}\n    for gname, vars_list in groups.items():\n        for v in vars_list:\n            try:\n                idx = int(v)\n                if 0 <= idx < n and gname is not None:\n                    # first membership wins\n                    if idx not in var_to_group:\n                        var_to_group[idx] = str(gname)\n            except Exception:\n                continue\n\n    # Build precedence graph (directed: p -> j means p is prerequisite of j)\n    preds = defaultdict(set)\n    succs = defaultdict(set)\n    for entry in precedence:\n        try:\n            a, b = entry\n            a = int(a); b = int(b)\n            if 0 <= a < n and 0 <= b < n:\n                preds[b].add(a)\n                succs[a].add(b)\n        except Exception:\n            continue\n\n    # Precompute transitive ancestor closure for each node using DFS/BFS\n    ancestor_closure = [set() for _ in range(n)]\n    for i in range(n):\n        # BFS/DFS from i to collect all ancestors\n        stack = list(preds.get(i, []))\n        seen = set(stack)\n        while stack:\n            cur = stack.pop()\n            ancestor_closure[i].add(cur)\n            for p in preds.get(cur, []):\n                if p not in seen:\n                    seen.add(p)\n                    stack.append(p)\n\n    # closure for variable i is ancestors + i\n    closures = [set(ancestor_closure[i]) | {i} for i in range(n)]\n\n    # Feasibility check of adding closure (closure is set of vars to ensure present),\n    # given currently selected_set.\n    def feasible_closure(closure, selected_set):\n        # New items that would be added\n        new_items = closure - selected_set\n        # Cardinality check\n        if len(selected_set) + len(new_items) > max_card:\n            return False\n        # Mutex check: none of new items conflict with each other or with selected\n        for v in new_items:\n            # conflicts with selected\n            if any(conflict in selected_set for conflict in mutex_map.get(v, ())) :\n                return False\n            # conflicts with other new items\n            for conflict in mutex_map.get(v, ()):\n                if conflict in new_items:\n                    return False\n        # Group check: cannot create group count >1\n        group_counts = {}\n        for v in selected_set:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in new_items:\n            g = var_to_group.get(v)\n            if g is not None:\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: closures already contain transitive ancestors; but if closure lacks\n        # some ancestor (shouldn't) ensure those ancestors are in selected_set\n        for v in closure:\n            for a in preds.get(v, ()):\n                if a not in closure and a not in selected_set:\n                    return False\n        return True\n\n    # Compute marginal gain for adding closure (new items = closure - selected_set)\n    def marginal_gain(closure, selected_set):\n        new_items = closure - selected_set\n        if not new_items:\n            return 0.0\n        gain = 0.0\n        # weights\n        for i in new_items:\n            if 0 <= i < len(weights):\n                try:\n                    gain += float(weights[i])\n                except Exception:\n                    pass\n        # interactions among new items\n        # iterate edges from each new item to higher-index new items to avoid double count\n        new_list = list(new_items)\n        l = len(new_list)\n        for idx in range(l):\n            u = new_list[idx]\n            # interactions with other new items\n            for v in new_list[idx+1:]:\n                gain += interactions.get(u, {}).get(v, 0.0)\n        # interactions between new items and already selected\n        for u in new_items:\n            for v in selected_set:\n                gain += interactions.get(u, {}).get(v, 0.0)\n        return gain\n\n    # Greedy selection: add closure with best marginal gain while respecting constraints\n    selected_set = set()\n    # Initial heuristic: consider items sorted by weight+abs(interaction_potential)\n    # but main loop will evaluate closures anyway, so we iterate all candidates\n    improved = True\n    while len(selected_set) < max_card and improved:\n        improved = False\n        best_gain = float(\"-inf\")\n        best_closure = None\n        # Evaluate every candidate not yet in selected_set\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closures[i]\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            # Tie-breaker: prefer larger closure (helps reach min_card)\n            if (gain > best_gain) or (abs(gain - best_gain) < 1e-12 and best_closure is not None and len(closure - selected_set) > len(best_closure - selected_set)) or (best_closure is None and gain >= best_gain):\n                best_gain = gain\n                best_closure = closure\n        # Accept non-negative gain closures; small negative may be accepted later to meet min_card\n        if best_closure is not None and best_gain > -1e-12:\n            new_items = best_closure - selected_set\n            if new_items:\n                selected_set.update(new_items)\n                improved = True\n        else:\n            break\n\n    # If we haven't met min_card, add best feasible closures even if negative\n    while len(selected_set) < min_card:\n        best_gain = float(\"-inf\")\n        best_closure = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure = closures[i]\n            if not feasible_closure(closure, selected_set):\n                continue\n            gain = marginal_gain(closure, selected_set)\n            if (gain > best_gain) or (abs(gain - best_gain) < 1e-12 and best_closure is not None and len(closure - selected_set) > len(best_closure - selected_set)) or (best_closure is None and gain >= best_gain):\n                best_gain = gain\n                best_closure = closure\n        if best_closure is None:\n            # no feasible closures left\n            break\n        selected_set.update(best_closure - selected_set)\n\n    # Lightweight local-search: attempt beneficial 1-for-1 swaps.\n    # Helper: check if we can safely remove item r from selected_set (won't break precedence)\n    def can_remove(r, sel):\n        # cannot remove if r is an ancestor of any kept item\n        for u in sel:\n            if u == r:\n                continue\n            if r in ancestor_closure[u]:\n                return False\n        return True\n\n    # Compute total objective for a set (weights + undirected interactions)\n    def total_objective(sel):\n        total = 0.0\n        for u in sel:\n            if 0 <= u < len(weights):\n                try:\n                    total += float(weights[u])\n                except Exception:\n                    pass\n        # interactions counted once\n        seen = set()\n        for u in sel:\n            seen.add(u)\n            for v, val in interactions.get(u, {}).items():\n                if v in sel and v not in seen:\n                    total += val\n        return total\n\n    # Precompute current objective\n    current_obj = total_objective(selected_set)\n\n    improved = True\n    # Try swapping out one selected item for a candidate closure (which may bring multiple new items)\n    # Only single removals allowed (cheap) and removal must be safe (not required by others).\n    while improved:\n        improved = False\n        # iterate over candidates not in selected_set\n        for i in range(n):\n            if i in selected_set:\n                continue\n            closure_i = closures[i]\n            new_items = closure_i - selected_set\n            if not new_items:\n                continue\n            # If closure fits without removal, it would have been added by greedy (but still check)\n            if len(selected_set) + len(new_items) <= max_card:\n                if not feasible_closure(closure_i, selected_set):\n                    continue\n                gain_add = marginal_gain(closure_i, selected_set)\n                if gain_add > 1e-12:\n                    selected_set.update(new_items)\n                    current_obj += gain_add\n                    improved = True\n                    break\n                else:\n                    continue\n            # need to remove exactly one item to try swap (cheap heuristic)\n            # if removing one item won't free enough slots, skip\n            if len(selected_set) - 1 + len(new_items) > max_card:\n                continue\n            # examine candidate removals: prefer those with smallest approximate contribution\n            # contribution of r relative to sel\\{r}\n            removal_candidates = []\n            for r in list(selected_set):\n                if not can_remove(r, selected_set):\n                    continue\n                # compute contribution of r\n                contrib = 0.0\n                if 0 <= r < len(weights):\n                    try:\n                        contrib += float(weights[r])\n                    except Exception:\n                        pass\n                for v in selected_set:\n                    if v == r:\n                        continue\n                    contrib += interactions.get(r, {}).get(v, 0.0)\n                removal_candidates.append((contrib, r))\n            if not removal_candidates:\n                continue\n            # try removals in increasing contribution order (best chance to improve)\n            removal_candidates.sort()\n            for contrib, r in removal_candidates:\n                # simulate removal and check feasibility when adding closure_i\n                sim_sel = set(selected_set)\n                sim_sel.remove(r)\n                if not feasible_closure(closure_i, sim_sel):\n                    continue\n                # ensure closure's ancestors satisfied (feasible_closure checked)\n                gain_after = marginal_gain(closure_i, sim_sel)\n                # compute contribution of r with respect to sim_sel (i.e., interactions with remaining)\n                removed_contrib = 0.0\n                if 0 <= r < len(weights):\n                    try:\n                        removed_contrib += float(weights[r])\n                    except Exception:\n                        pass\n                for v in sim_sel:\n                    removed_contrib += interactions.get(r, {}).get(v, 0.0)\n                delta = gain_after - removed_contrib\n                if delta > 1e-12:\n                    # apply swap\n                    # remove r, add new_items\n                    selected_set.remove(r)\n                    selected_set.update(new_items)\n                    current_obj += delta\n                    improved = True\n                    break\n            if improved:\n                break\n\n    # Safety trim if we're over max_card (should rarely happen due to checks)\n    if len(selected_set) > max_card:\n        # compute approximate item score = weight + sum interactions with others in selected_set\n        def item_score(i):\n            s = 0.0\n            if 0 <= i < len(weights):\n                try:\n                    s += float(weights[i])\n                except Exception:\n                    pass\n            for j in selected_set:\n                if j == i:\n                    continue\n                s += interactions.get(i, {}).get(j, 0.0)\n            return s\n        sorted_items = sorted(selected_set, key=lambda x: item_score(x), reverse=True)\n        selected_set = set(sorted_items[:max_card])\n\n    result = {\"selection\": {\"variables\": sorted(int(x) for x in selected_set)}}\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n>>>>>>> REPLACE\n</DIFF>"
            }
          ],
          "model_name": "gpt-5-mini",
          "kwargs": {
            "temperature": 1.0,
            "max_output_tokens": 8192
          },
          "input_tokens": 9250,
          "output_tokens": 7040,
          "cost": 0.016392499999999997,
          "input_cost": 0.0023125,
          "output_cost": 0.014079999999999999,
          "thought": "",
          "model_posteriors": {
            "gpt-5-mini": 1.0
          }
        },
        "diff_summary": {
          "added": 114,
          "deleted": 0,
          "modified": 0
        },
        "embed_cost": 6.318e-05,
        "novelty_cost": 0.0,
        "stdout_log": "Evaluating program: sds_dataset_output/problem_0/gen_9/main.py\nSaving results to: sds_dataset_output/problem_0/gen_9/results\nRun 1/1 completed in 0.00 seconds\nCorrectness and error status saved to sds_dataset_output/problem_0/gen_9/results/correct.json\nMetrics saved to sds_dataset_output/problem_0/gen_9/results/metrics.json\nEvaluation and Validation completed successfully.\nMetrics:\n  combined_score: 0.4306669471949661\n  public:\n    feasible: True\n    selection_size: 10\n    raw_score: 132.16052771701814\n  private:\n    selection: [3, 4, 5, 6, 7, 8, 9, 10, 11, 14]\n    raw_score: 132.16052771701814\n    normalized_fitness: 0.4306669471949661\n  execution_time_mean: 0.000795875000221713\n  execution_time_std: 0.0\n  num_valid_runs: 1\n  num_invalid_runs: 0\n  all_validation_errors: []\n",
        "stderr_log": "",
        "code_analysis_metrics": {
          "cyclomatic_complexity": 87,
          "average_cyclomatic_complexity": 43.5,
          "halstead_volume": 3015.6635244432127,
          "halstead_difficulty": 12.282352941176471,
          "halstead_effort": 37039.4437590437,
          "lines_of_code": 414,
          "logical_lines_of_code": 303,
          "comments": 63,
          "maintainability_index": -49.94743942273202,
          "max_nesting_depth": 6,
          "complexity_score": 1.0
        }
      },
      "in_archive": false
    }
  ],
  "meta_summary": null,
  "meta_scratch_pad": null,
  "meta_recommendations": null,
  "meta_recommendations_history": [],
  "total_programs_meta_processed": 0
}