{
  "unprocessed_programs": [
    {
      "id": "aac66d0e-7541-4a5b-b733-00b0ef41adec",
      "code": "\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    This is a greedy baseline - evolution will improve this.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    # Simple greedy: select items with highest weights first\n    # This is a baseline - evolution will find better strategies\n    n = len(weights)\n    selected = []\n    \n    # Create score list (weight + interaction potential)\n    scores = []\n    for i in range(n):\n        score = weights[i] if i < len(weights) else 0.0\n        # Add potential interaction value\n        for k, v in interactions.items():\n            try:\n                u, w = map(int, k.split(\",\"))\n                if u == i or w == i:\n                    score += abs(v) * 0.5  # Potential value\n            except:\n                pass\n        scores.append((score, i))\n    \n    # Sort by score descending\n    scores.sort(reverse=True)\n    \n    # Greedy selection respecting constraints\n    selected_set = set()\n    for score, i in scores:\n        if len(selected_set) >= cardinality_bounds[1]:\n            break\n            \n        # Check mutex constraints\n        can_add = True\n        for a, b in mutex:\n            if (a == i and b in selected_set) or (b == i and a in selected_set):\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n            \n        # Check group constraints (at most one per group)\n        for grp_vars in groups.values():\n            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n        \n        # Check precedence (if j selected, i must be selected)\n        precedence_ok = True\n        for pred_i, pred_j in precedence:\n            if pred_j == i and pred_i not in selected_set:\n                precedence_ok = False\n                break\n        \n        if not precedence_ok:\n            continue\n        \n        # Add if we meet minimum cardinality or have room\n        if len(selected_set) < cardinality_bounds[1]:\n            selected_set.add(i)\n            selected.append(i)\n    \n    # Ensure minimum cardinality\n    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n        for i in range(n):\n            if i not in selected_set:\n                selected_set.add(i)\n                selected.append(i)\n                break\n    \n    # Output result\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n    \n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n    \n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n    \n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n    \n    result_str = stdout_capture.getvalue()\n    return result_str\n\n",
      "language": "python",
      "parent_id": null,
      "archive_inspiration_ids": [],
      "top_k_inspiration_ids": [],
      "island_idx": 0,
      "generation": 0,
      "timestamp": 1764626662.325779,
      "code_diff": null,
      "combined_score": 0.21460534544453808,
      "public_metrics": {
        "feasible": true,
        "selection_size": 10,
        "raw_score": 101.95173081379961
      },
      "private_metrics": {
        "selection": [
          0,
          1,
          2,
          6,
          9,
          10,
          14,
          16,
          17,
          18
        ],
        "raw_score": 101.95173081379961,
        "normalized_fitness": 0.21460534544453808
      },
      "text_feedback": "",
      "correct": true,
      "children_count": 0,
      "complexity": 1.0,
      "embedding": [
        0.025548656,
        -0.00076658087,
        0.021985417,
        -0.030396597,
        0.001218803,
        0.018749416,
        0.03432343,
        0.014192351,
        -0.03514758,
        0.016349684,
        0.027802948,
        -0.06122951,
        -0.023354962,
        0.010774552,
        6.902636e-05,
        -0.03265089,
        0.03832298,
        0.013925714,
        -0.006005388,
        -0.0033147805,
        0.038880497,
        0.037304915,
        0.04435867,
        0.041352946,
        0.0134166805,
        -0.0038268443,
        0.041207507,
        0.08842646,
        0.020894632,
        -0.03749883,
        0.011410844,
        -0.016337566,
        -0.04096511,
        -0.0017331394,
        -0.003532938,
        0.028021106,
        0.0034965784,
        0.029863324,
        -0.050127722,
        -0.016252726,
        -0.010562454,
        -0.029014934,
        -0.02503962,
        0.015646733,
        -0.0043116384,
        -0.014834703,
        0.0045540356,
        -0.016192127,
        0.029063413,
        -0.026348567,
        -0.043219406,
        0.017210195,
        0.029645167,
        -0.022567172,
        -0.013319721,
        -0.03684436,
        0.013877234,
        0.024651786,
        -0.007932445,
        -0.0058751,
        0.03665044,
        -0.057738993,
        0.027221195,
        0.04455259,
        0.00839906,
        0.014374149,
        0.018773656,
        0.010023121,
        -0.03694132,
        -0.025645614,
        -0.02695456,
        -0.0043904176,
        0.0026633383,
        -0.019609926,
        0.0030057242,
        0.02443363,
        0.0076961084,
        0.03526878,
        0.0025845591,
        -0.04111055,
        -0.05361824,
        -0.019585686,
        -0.013901474,
        -0.031487383,
        -0.06908318,
        -0.059096415,
        0.0052842572,
        0.01592549,
        -0.029669406,
        -0.055605896,
        -0.018628217,
        -0.0067507597,
        -0.07979713,
        0.020761313,
        0.008665697,
        -0.04685536,
        0.03694132,
        -0.033887114,
        0.013513639,
        -0.016167887,
        -0.013610598,
        -0.023670077,
        0.008865674,
        -0.009350468,
        -0.012883406,
        0.010168559,
        0.02695456,
        0.031196509,
        0.013671197,
        -0.011392664,
        -0.040771194,
        0.020276519,
        0.015380097,
        0.05958121,
        0.03102683,
        -0.04355876,
        -0.07596725,
        -0.026590964,
        -0.0035086982,
        -0.009726184,
        -0.020421956,
        -0.0268576,
        0.0069204373,
        0.03202066,
        -0.03514758,
        0.032990247,
        0.015489175,
        -0.08672968,
        -0.031220747,
        0.0073446324,
        0.035729334,
        0.0056842123,
        0.0038965335,
        -0.050612517,
        -0.061084073,
        -0.019888682,
        -0.030687474,
        -0.023560999,
        -0.019270571,
        0.058854017,
        0.016143648,
        0.01094423,
        -0.0064295833,
        0.024821464,
        -0.047364395,
        -0.032432735,
        -0.012259234,
        0.0100716,
        -0.09002629,
        0.037547313,
        0.049036935,
        -0.025063861,
        3.6028163e-05,
        -0.008677817,
        0.046685684,
        -0.051436666,
        -0.038953215,
        -0.0042237695,
        0.05933881,
        -0.033062965,
        -0.03512334,
        0.0046661445,
        -0.013186403,
        0.003202672,
        0.03349928,
        -0.0185555,
        -0.03538998,
        0.03374168,
        -0.027293915,
        -0.013707557,
        -0.018155543,
        -0.07058604,
        -0.009174731,
        0.014761984,
        0.0017210195,
        -0.019985642,
        0.0043328484,
        -0.03272361,
        0.008708117,
        -0.041425668,
        -0.04869758,
        -0.03762003,
        -0.016931439,
        -0.059823606,
        -0.0068355985,
        -0.062393017,
        -0.023064084,
        -0.023306482,
        0.0006438673,
        0.0026284936,
        -0.019209972,
        0.0122955935,
        0.015634613,
        -0.011259345,
        0.015658854,
        -0.019840203,
        0.05473327,
        0.038274504,
        0.008496019,
        0.01592549,
        0.010156439,
        0.0149074225,
        0.026712162,
        -0.024227591,
        -0.018119184,
        -0.029960282,
        -0.08125151,
        -0.029960282,
        -0.008877794,
        -0.06132647,
        0.030905632,
        -0.015913371,
        0.0013703011,
        0.054781746,
        0.047121998,
        -0.010168559,
        -0.021488504,
        0.003945013,
        -0.012847047,
        0.011925938,
        -0.028796777,
        0.0051721483,
        0.014216591,
        0.017428352,
        -4.454994e-05,
        0.03691708,
        -0.029063413,
        -0.030057242,
        0.028699817,
        -0.035705093,
        -0.0012907647,
        5.240891e-05,
        0.016228486,
        0.03776547,
        -0.008302101,
        -0.01832522,
        -0.038056348,
        0.028142305,
        0.013574238,
        -0.0054812045,
        0.027948387,
        -0.0061477968,
        0.019585686,
        0.023051966,
        0.026372805,
        -0.012241054,
        -0.029039174,
        -0.00417529,
        0.005514534,
        -0.004272249,
        0.02010684,
        0.0034541588,
        0.03172978,
        -0.029572448,
        -0.01937965,
        -0.03177826,
        -0.028966455,
        -0.02442151,
        -0.004960051,
        0.04629785,
        -0.06636833,
        -0.000965801,
        0.014568066,
        -0.011816859,
        -0.05109731,
        0.0105685145,
        0.021088548,
        -0.008144543,
        -0.008744475,
        0.0050358,
        -0.003013299,
        0.032263055,
        -0.05274561,
        0.0117380805,
        -0.035002142,
        -0.0005078977,
        -0.005605433,
        0.044867706,
        -0.026494004,
        -0.01504074,
        -0.06981037,
        -0.0073143328,
        0.031632822,
        0.0019528117,
        0.04612817,
        0.018737298,
        -0.0045146463,
        0.013622718,
        0.00019164522,
        0.038104825,
        0.012422852,
        -0.010750311,
        0.039559208,
        -0.022700489,
        -0.030057242,
        -0.028166544,
        0.009780724,
        0.037014037,
        0.00085066236,
        0.002852711,
        0.069034696,
        0.012980365,
        -0.007720348,
        0.0014362029,
        -0.029111894,
        -0.02101583,
        0.04355876,
        -0.03524454,
        0.03958345,
        0.035826292,
        -0.018749416,
        0.01679812,
        0.027802948,
        0.010738192,
        -0.03456583,
        -0.027802948,
        0.053666722,
        -0.026178887,
        0.03008148,
        0.011616882,
        -0.031705543,
        0.0038813837,
        0.034032553,
        -0.0028299862,
        0.008168783,
        -0.05274561,
        -0.020737072,
        -0.0047176536,
        0.0031511625,
        -0.020737072,
        -0.038298745,
        0.017125355,
        0.025403216,
        0.041910462,
        0.001257435,
        -0.06287781,
        0.029160373,
        0.016604202,
        0.023633718,
        0.0077809473,
        -0.03265089,
        0.008871734,
        -0.015489175,
        -0.046273608,
        0.010604873,
        -0.014592306,
        -0.042492215,
        0.07645205,
        0.047412876,
        -0.02274897,
        0.023136804,
        -0.017295035,
        -0.0088899145,
        0.019076653,
        -0.016786,
        -0.004129841,
        -0.013840875,
        -0.01420447,
        -0.03189946,
        -0.032311536,
        0.046443287,
        0.0121077355,
        -0.009380768,
        0.013889355,
        -0.005463025,
        0.0054872646,
        -0.03538998,
        0.032844808,
        0.01431355,
        -0.035196062,
        0.05798139,
        0.018943334,
        -0.035462696,
        0.017161716,
        -0.055751335,
        -0.016979918,
        0.020676473,
        0.031341948,
        0.0042237695,
        0.06210214,
        -0.011289645,
        0.009938282,
        -0.024445748,
        -0.0074173515,
        0.017137475,
        -0.0016952648,
        -0.032287296,
        -0.030566275,
        -0.011247226,
        -0.020264398,
        0.037304915,
        -0.023791276,
        0.035026383,
        0.009641345,
        -0.0077445875,
        0.020058362,
        -0.0025406247,
        -0.0064538233,
        0.024942663,
        0.02442151,
        0.0068901377,
        0.00048252175,
        -0.003429919,
        -0.03580205,
        -0.031560104,
        -0.0009604985,
        0.028893735,
        0.028142305,
        0.0134166805,
        -0.013210642,
        0.042371016,
        0.0025800143,
        0.036868602,
        -0.021379424,
        0.008829315,
        -0.0017119296,
        -0.028893735,
        0.058950976,
        0.016676921,
        0.06724096,
        -0.0067810593,
        -0.00293755,
        0.02845742,
        -0.03626261,
        -0.004347998,
        0.02770599,
        0.03849266,
        -0.029863324,
        0.052988008,
        0.01603457,
        -0.0003516652,
        0.023379201,
        0.04952173,
        -0.002837561,
        -0.0029905743,
        0.0504186,
        0.039050173,
        0.014774104,
        0.029936044,
        -0.020870391,
        0.0053024366,
        0.024845704,
        0.02175514,
        0.008053644,
        0.0070901155,
        0.011332065,
        0.03524454,
        -0.008453599,
        0.026760641,
        0.017452592,
        0.018167663,
        -0.022312654,
        0.012222874,
        -0.014846823,
        0.0021527894,
        0.020300757,
        0.03279633,
        -0.027584791,
        0.05541198,
        -0.0105685145,
        0.04801887,
        0.06888926,
        -0.024748744,
        0.023985194,
        -0.0021770291,
        0.024797224,
        0.03177826,
        -0.004102571,
        -0.029063413,
        0.049158134,
        0.0115502225,
        -0.005202448,
        -0.062683895,
        -0.009598926,
        -0.014349909,
        -0.02251869,
        0.035899013,
        0.010774552,
        -0.024712386,
        0.0121077355,
        -0.0121077355,
        -0.017052637,
        -0.00038821413,
        0.021585463,
        0.027996866,
        0.048043106,
        -0.008229382,
        -0.032287296,
        -0.018749416,
        0.020652235,
        0.035705093,
        0.0039541028,
        0.012616769,
        -0.012077436,
        -0.018894855,
        -0.025282018,
        0.014895302,
        0.018797897,
        -0.02011896,
        -0.0148589425,
        0.037038278,
        -0.014798343,
        -0.039244093,
        0.05037012,
        0.05027316,
        -0.023015605,
        -0.003696556,
        -0.029936044,
        -0.009907982,
        -0.00032344865,
        -0.020724952,
        0.03257817,
        -0.030105721,
        0.032675132,
        0.037014037,
        -0.012150155,
        -0.035608135,
        -0.0619567,
        -0.017367752,
        0.0065932013,
        -0.018919095,
        -0.02426395,
        -0.021306707,
        0.029669406,
        -0.009089892,
        -0.029984523,
        0.0064174635,
        -0.0718465,
        -0.024894184,
        -0.017525312,
        0.005638763,
        -0.012204695,
        -0.045449458,
        0.07465831,
        -0.043122444,
        -0.0013392441,
        -0.0063326247,
        -0.019949282,
        -0.038007867,
        0.003266301,
        -0.0018588828,
        -0.022882286,
        -0.023924595,
        -0.009907982,
        0.029523969,
        -0.028675579,
        0.050806433,
        0.011774439,
        -0.0015248293,
        0.009550446,
        -0.021391544,
        -0.029039174,
        -0.012247114,
        0.009877683,
        -0.013198523,
        0.011544162,
        -0.023318602,
        -0.013962073,
        0.007938505,
        -0.042322535,
        0.0065932013,
        -0.002866346,
        0.021524863,
        0.018070705,
        -0.013089444,
        -0.0117199,
        0.048479423,
        0.034517348,
        -0.023124684,
        -0.004054092,
        0.014107511,
        -0.01937965,
        0.01510134,
        -0.022421733,
        0.040916633,
        0.016543603,
        -0.02610617,
        -0.027196955,
        -0.015016501,
        -0.009386828,
        -0.009156551,
        -0.024991142,
        0.0023860966,
        -0.011931998,
        -0.047437113,
        0.0033238705,
        -0.010095839,
        -0.012992485,
        0.025330499,
        -0.003684436,
        -0.013719676,
        -0.0014695325,
        0.043922357,
        0.0088414345,
        -0.022227814,
        0.00056811824,
        0.01593761,
        -0.012786448,
        -0.003187522,
        0.02265201,
        0.03022692,
        -0.04588577,
        0.025233539,
        0.021137029,
        -0.038832016,
        -0.022046017,
        0.058999456,
        0.029136132,
        0.018107064,
        0.027099997,
        -0.029184612,
        -0.03439615,
        0.00336023,
        -0.0017316244,
        -0.04043184,
        0.008193023,
        -0.037232198,
        0.02695456,
        0.013065204,
        -0.022252055,
        0.016555723,
        -0.017101116,
        0.00754461,
        0.010744252,
        0.047606792,
        0.009053532,
        0.0065023024,
        0.0146286655,
        -0.014386268,
        -0.0053084968,
        -0.032287296,
        -0.0006434886,
        -0.01510134,
        -7.722857e-06,
        -0.019573567,
        0.007799127,
        0.007805187,
        0.008526319,
        -0.017379873,
        0.03185098,
        0.028724058,
        0.014749864,
        0.003863204,
        -0.023379201,
        0.033329602,
        0.01095635,
        -0.026542483,
        -0.008465719,
        0.03614141,
        -0.010768492,
        -0.025718333,
        -0.002427001,
        0.0016058809,
        -0.019100891,
        0.045594897,
        0.050564036,
        -0.0111745065,
        -0.034177992,
        -0.012392553,
        0.005705422,
        0.0039692526,
        -0.037571553,
        0.042371016,
        0.03861386,
        0.023560999,
        0.015404336,
        0.02855438,
        0.03442039,
        0.0026769731,
        0.009483787,
        -0.042613413,
        -0.007471891,
        0.023767037,
        -0.0088899145,
        -0.01431355,
        -0.020203799,
        0.027075756,
        -0.0044782865,
        -0.037207957,
        0.020421956,
        -0.009683765,
        0.008998993,
        -0.0008612672,
        0.0083263405,
        0.024748744,
        -0.04755831,
        0.006211426,
        0.0097746635,
        0.016628442,
        0.010435196,
        0.0017391993,
        0.0040480318,
        -0.008132423,
        -0.019925043,
        0.035729334,
        0.025330499,
        0.01596185,
        0.041498385,
        -0.018664578,
        -0.088184066,
        -0.01007766,
        0.014931662,
        0.0065871417,
        -0.00015699,
        -0.014798343,
        -0.03677164,
        -0.016519364,
        0.0133682005,
        0.020797672,
        0.0011559313,
        -0.01088363,
        0.022567172,
        -0.022870168,
        -0.011653241,
        -0.0029769395,
        0.0059266095,
        0.022809569,
        0.017598031,
        0.03189946,
        -0.014555947,
        -0.061568867,
        -0.023161044,
        -0.019173611,
        -0.002173999,
        -0.060744718,
        -0.039147135,
        -0.0016998097,
        0.023197403,
        0.004744923,
        -0.0032390314,
        0.014422628,
        -0.0134166805,
        -0.036626205,
        0.021415785,
        0.0068477183,
        -0.020809792,
        -0.024385149,
        0.003693526,
        -0.02840894,
        0.017937386,
        -0.0038116944,
        -0.0077324677,
        0.022930767,
        0.022058137,
        -0.03017844,
        -0.0061690067,
        0.0065265424,
        0.018846376,
        -0.02434879,
        0.024251832,
        -0.03260241,
        0.008314221,
        -0.0018558529,
        -0.009059592,
        0.028118065,
        0.006405344,
        0.022033898,
        -0.0031329826,
        -0.019088773,
        0.02091887,
        -0.011047249,
        -0.027415114,
        -0.048358224,
        0.012053196,
        0.017973745,
        0.024009435,
        -0.0020694654,
        -0.022870168,
        0.028748298,
        0.026324326,
        0.017743468,
        0.018700937,
        -0.012992485,
        0.017925266,
        0.01087151,
        -0.013174283,
        -0.0035814173,
        -0.026566723,
        0.008289982,
        0.03189946,
        0.018094944,
        0.010598814,
        -0.0106594125,
        0.026518244,
        0.026227368,
        0.0042358893,
        0.0014581701,
        0.002755752,
        0.034880944,
        -0.04777647,
        -0.041765023,
        0.013186403,
        0.0024512408,
        0.031341948,
        -0.010180678,
        0.047970388,
        -0.032505453,
        -0.113344885,
        -0.021100668,
        -0.004611605,
        -0.024845704,
        0.021573342,
        0.00062568753,
        0.037111,
        0.022021778,
        -0.010671533,
        -0.002692123,
        -0.024894184,
        -0.021573342,
        0.0035450577,
        0.023536758,
        0.0100413,
        -0.017198075,
        -0.016446644,
        -0.008744475,
        0.008883854,
        -0.039850086,
        -0.017416233,
        0.008568738,
        -0.0015483116,
        -0.0058114706,
        -0.056575485,
        -0.0014975596,
        -0.00029769394,
        0.032238815,
        0.009289869,
        0.021524863,
        -0.016276967,
        0.0050691296,
        -0.023221644,
        0.055169582,
        -0.023003485,
        -0.00021493806,
        0.0061417366,
        -0.009156551,
        -0.02511234,
        0.010392776,
        0.017258674,
        -0.024021553,
        0.013756036,
        -0.06404132,
        0.016119407,
        0.008550558,
        -0.02352464,
        -0.0095868055,
        -0.0013286391,
        0.04617665,
        -0.00044578343,
        0.03172978,
        -0.019088773,
        -0.03194794,
        -0.02183998,
        0.02105219,
        0.012035017,
        0.01431355,
        -0.0013634837,
        0.018700937,
        -0.028990695,
        -0.024482109,
        0.024894184,
        -0.0028845256,
        -0.028093826,
        0.0026284936,
        -0.016083049,
        -0.028699817,
        -0.019355409,
        0.021864219,
        -0.026372805,
        0.0058448003,
        -0.023900354,
        -0.01848278,
        -0.04685536,
        0.018737298,
        0.0057751113,
        -0.013901474,
        -0.012380432,
        -0.0036571664,
        0.04363148,
        -0.0064901826,
        -0.02105219,
        0.0143014295,
        -0.0064841225,
        0.023936715,
        0.013816635,
        0.03279633,
        -0.03623837,
        0.048382465,
        -0.014362029,
        0.0044146576,
        0.011622941,
        -0.0032875107,
        -0.045110103,
        0.045425218,
        0.020034121,
        -0.035850532,
        0.0012316803,
        -0.026978798,
        0.008768716,
        0.050660998,
        -0.008047584,
        -0.0009332289,
        0.007865787,
        0.027390873,
        -0.056672443,
        0.016531482,
        -0.00504186,
        0.034856703,
        0.007883966,
        0.01679812,
        -0.03512334,
        0.020421956,
        -0.009659525,
        -0.025500176,
        0.021027949,
        0.02097947,
        0.011186627,
        0.01761015,
        -0.0110351285,
        0.030396597,
        -0.0334508,
        0.05138819,
        -0.027802948,
        0.025015382,
        0.0032814508,
        -0.010210978,
        -0.022046017,
        0.018167663,
        0.008829315,
        -0.002948155,
        -0.012665249,
        0.054248475,
        0.007629449,
        0.031414665,
        0.026203128,
        -0.012507691,
        -0.013356081,
        0.0133682005,
        0.020240158,
        0.0027481772,
        -0.014774104,
        0.0012612224,
        -0.029184612,
        0.0053206165,
        0.027245436,
        -0.024894184,
        -0.055218063,
        0.028093826,
        -0.011847159,
        -0.032190338,
        0.024312431,
        0.028263504,
        0.024191232,
        0.04014096,
        0.011774439,
        -0.028602859,
        0.0056508826,
        -0.030614754,
        0.002261868,
        0.021549104,
        0.020821912,
        -0.015549774,
        0.045788813,
        0.034105275,
        0.007914266,
        -0.023076205,
        0.0087020565,
        0.01916149,
        -0.03526878,
        -0.011865338,
        -0.04515858,
        -0.01011402,
        -0.0023830666,
        0.008180902,
        -0.009483787,
        0.016786,
        0.014495348,
        0.043098208,
        0.0025345648,
        0.042080138,
        -0.012319833,
        0.011332065,
        0.0056811823,
        -0.031487383,
        -0.027342394,
        0.00045032837,
        -0.0028860406,
        -0.018773656,
        0.009726184,
        0.018264621,
        -0.0057629915,
        0.045110103,
        0.019100891,
        0.019113012,
        -0.016555723,
        0.0115502225,
        0.04952173,
        -0.023161044,
        0.002261868,
        0.015537655,
        0.023694318,
        -0.04045608,
        0.016228486,
        0.047534075,
        0.011016949,
        0.010350357,
        -0.029087653,
        6.746404e-05,
        0.008090003,
        0.023318602,
        -0.012113796,
        -0.007986985,
        -0.017452592,
        0.02442151,
        0.033572,
        -0.005293347,
        -0.035608135,
        -0.012313773,
        -0.03541422,
        -0.030323878,
        0.02845742,
        -0.019646285,
        -0.0046631144,
        0.0112229865,
        0.020385597,
        0.0115502225,
        0.005566044,
        -0.01259253,
        0.011410844,
        0.017888907,
        -0.0035905072,
        -0.012737968,
        0.01587701,
        -0.0046570543,
        -0.0017376842,
        0.0049721706,
        0.0006824994,
        0.031511623,
        0.005514534,
        -0.017743468,
        0.011822919,
        -0.006787119,
        0.022833807,
        -0.02777871,
        0.011307825,
        -0.002273988,
        0.02345192,
        0.0034753685,
        -0.033887114,
        -0.010398836,
        0.0043389085,
        -0.036286846,
        0.05303649,
        -0.029208852,
        0.014919542,
        0.045085862,
        0.0058175307,
        -0.004760073,
        -0.010374596,
        -0.013574238,
        -0.01596185,
        -0.00754461,
        -0.029620927,
        -0.019525087,
        -0.01262889,
        0.0071628345,
        0.02168242,
        -0.0044237473,
        0.008544498,
        0.015355857,
        -0.026590964,
        -0.00843542,
        -0.007980925,
        -0.012338013,
        -0.0053206165,
        -0.018216142,
        -0.003111773,
        -0.023827637,
        -0.012919766,
        0.023039846,
        0.0068416586,
        0.042880047,
        0.016228486,
        -0.043461803,
        0.034008313,
        -0.004308609,
        0.03878354,
        -0.022942886,
        -0.013865115,
        0.014131752,
        -0.0049721706,
        -0.016846599,
        -0.020022001,
        -0.0064114034,
        0.004929751,
        -0.027584791,
        -8.13711e-06,
        -0.02695456,
        -0.019634167,
        0.031366184,
        0.006793179,
        -0.03943801,
        0.037256435,
        -0.0042237695,
        -0.056866363,
        0.0056508826,
        -0.0137439165,
        -0.028917976,
        0.020458316,
        0.0052388078,
        0.008586918,
        0.02101583,
        -0.00018009348,
        -0.0027527222,
        0.009405008,
        0.021924818,
        0.0046812943,
        0.04367996,
        0.0149074225,
        0.011319945,
        -0.0021861189,
        -0.018603979,
        -0.032190338,
        0.011132088,
        0.017731348,
        0.0048994515,
        0.009956461,
        -0.03160858,
        0.004054092,
        0.028602859,
        0.017246554,
        -0.026203128,
        -0.0285059,
        -0.014774104,
        -0.050660998,
        0.00049085415,
        0.00061584014,
        -0.013307601,
        -0.022567172,
        -0.024070034,
        -0.0042480095,
        0.0043510282,
        0.0025224448,
        0.0049964106,
        -0.018785777,
        0.009314109,
        0.00014458608,
        0.04280733,
        0.06927709,
        0.016167887,
        -0.025524415,
        0.0033390203,
        0.005111549,
        -0.0108957505,
        -0.02598497,
        0.006884078,
        0.0016770851,
        -0.04518282,
        0.02107643,
        0.011156327,
        0.010792731,
        0.028966455,
        0.021706661,
        -0.022894407,
        -0.006532602,
        0.025233539,
        0.007835487,
        -0.019488728,
        0.00057152694,
        0.010283697,
        -0.013562119,
        0.013356081,
        0.006387164,
        0.023306482,
        0.019028174,
        -0.020591635,
        0.0052115377,
        0.012968245,
        0.013234883,
        -0.009483787,
        -0.019197851,
        -0.017864667,
        -0.019949282,
        -0.004369208,
        -0.014895302,
        0.008447539,
        -0.012204695,
        -0.052454736,
        -0.017295035,
        -0.0049085417,
        -0.0334508,
        0.025330499,
        0.06452611,
        0.022155097,
        -0.022361133,
        0.016822359,
        0.013962073,
        0.008411179,
        0.009835263,
        0.011101788,
        -0.019416008,
        -0.03374168,
        -0.010332176,
        -0.027972627,
        0.0044085975,
        0.00078324566,
        0.021112788,
        0.010332176,
        -0.022094497,
        -0.025645614,
        0.02588801,
        0.05638157,
        0.0136954365,
        -0.022482332,
        0.019476607,
        0.01004736,
        -0.0152346585,
        0.04755831,
        -0.019706884,
        -0.013646957,
        -0.0017558641,
        0.0010612449,
        -0.014483227,
        0.05104883,
        0.02101583,
        0.012338013,
        0.00088474946,
        0.003923803,
        -0.022070257,
        0.007738528,
        -0.036601964,
        -0.034953665,
        -0.00672046,
        0.014034793,
        0.0009218665,
        0.02525778,
        -0.022555051,
        0.018749416,
        -0.028602859,
        -0.034880944,
        -0.023245882,
        0.014022673,
        -0.0005499385,
        -0.0136954365,
        0.0235004,
        0.017040517,
        -0.051727545,
        -0.008902034,
        -0.009641345,
        -0.007223434,
        0.023270123,
        -0.0009741334,
        -0.06462307,
        0.006005388,
        -0.044092033,
        3.3436124e-06,
        -0.006641681,
        -0.0037026159,
        0.019185731,
        0.018906975,
        -0.026663681,
        0.01670116,
        -0.011204806,
        0.028118065,
        -0.03684436,
        -0.022409612,
        -0.013295482,
        -0.025403216,
        0.011647182,
        -0.012847047,
        0.0037450353,
        -0.00420256,
        -0.012992485,
        0.01095635,
        -0.0053993957,
        -0.013319721,
        0.0064114034,
        0.015719453,
        0.010235218,
        -0.0030329938,
        0.015283138,
        0.025572896,
        0.006956797,
        -0.0234398,
        -0.0074537112,
        0.0016240607,
        -0.012968245,
        0.025233539,
        -0.02090675,
        -0.011992597,
        -0.029766366,
        0.020288639,
        -0.029839084,
        0.014713504,
        -0.01511346,
        -0.017210195,
        0.03008148,
        0.042055897,
        -0.0039541028,
        -0.024045793,
        -0.026687922,
        -0.0011635062,
        0.0045934254,
        -0.005278197,
        0.032481212,
        -0.009786784,
        -0.01005948,
        -0.012968245,
        0.0023664017,
        0.023015605,
        0.015271018,
        -0.011350244,
        0.0077506476,
        -0.0015816411,
        0.0039328933,
        0.01092605,
        0.015186179,
        0.002343677,
        -0.009532266,
        -0.019028174,
        0.03766851,
        -0.0005067615,
        -0.016470883,
        0.03665044,
        0.022482332,
        -0.030857151,
        0.011853219,
        0.017864667,
        0.0060538677,
        0.017234435,
        0.013259122,
        -0.0053387964,
        0.004360118,
        -0.01340456,
        -0.001843733,
        -0.026275847,
        0.003011784,
        -0.0042298296,
        0.009017172,
        0.0007840032,
        -0.018603979,
        -0.0005772081,
        0.023839755,
        0.02259141,
        -0.00584177,
        -0.049739886,
        -0.01847066,
        0.04787343,
        -0.014083272,
        -0.0018997873,
        0.0016922348,
        -0.002199754,
        0.016386045,
        -0.02693032,
        0.0044934363,
        0.0012680399,
        0.019634167,
        0.002261868,
        0.06476851,
        -0.018700937,
        -0.010326117,
        0.00040450017,
        -0.0028602858,
        0.020506795,
        -0.010198859,
        -0.016567843,
        0.0028996754,
        0.011301765,
        0.011392664,
        -0.049012695,
        -0.021137029,
        -0.0077567077,
        -0.050030764,
        0.023379201,
        0.02010684,
        -0.017804068,
        0.002680003,
        -0.01763439,
        0.03187522,
        0.004114691,
        -0.00011428645,
        0.009386828,
        -0.021185508,
        -0.004702504,
        -0.053278886,
        0.05473327,
        0.034032553,
        -0.030614754,
        -0.030396597,
        0.009708004,
        0.016895078,
        0.011271466,
        0.017088996,
        0.036529243,
        0.00077567075,
        0.031487383,
        0.00756279,
        -0.02267625,
        -0.014616546,
        -0.009653465,
        -0.0073446324,
        -0.03861386,
        -0.02010684,
        -0.047218956,
        -0.0036511065,
        -0.008465719,
        0.0025254749,
        0.014362029,
        -0.00589328,
        -0.0055084745,
        -0.022700489,
        0.008023344,
        0.014931662,
        -0.02511234,
        -0.030396597,
        -0.024760865,
        0.003102683,
        0.0022042987,
        0.0020528005,
        0.011204806,
        -0.043728437,
        -0.023354962,
        0.013174283,
        0.00056508824,
        0.0037995747,
        -0.021500623,
        0.007859726,
        0.009811023,
        0.050612517,
        -0.02016744,
        -0.036698923,
        0.008059704,
        0.0021240048,
        0.011422964,
        -0.021949058,
        0.017985865,
        0.02945125,
        0.0026072839,
        0.036747403,
        -0.020482555,
        0.0082839215,
        -0.01427719,
        0.007847606,
        0.010410956,
        0.04021368,
        0.0039692526,
        0.034687027,
        0.0011975932,
        -0.037886668,
        0.0009976156,
        -0.002608799,
        -0.030566275,
        -0.02106431,
        0.000563952,
        0.02188846,
        0.011659301,
        -0.023476161,
        0.0002160743,
        -0.0017679839,
        0.03858962,
        -0.02265201,
        0.0019679614,
        -0.010635173,
        0.031535864,
        0.03177826,
        0.016628442,
        -0.024469988,
        0.039268333,
        -0.027366634,
        0.016083049,
        0.020821912,
        -0.012507691,
        0.0022800479,
        -0.0070234565,
        -0.01000494,
        -0.015574015,
        0.055848293,
        0.0010673048,
        0.049036935,
        -0.013889355,
        0.013053085,
        0.025403216,
        0.039219853,
        0.0053387964,
        0.00922927,
        0.024094272,
        -0.0076052095,
        0.0059932685,
        0.014519587,
        0.016058808,
        -0.005372126,
        0.007229494,
        -0.0074961307,
        0.0148589425,
        0.006962857,
        0.00041359008,
        0.00026474308,
        0.0018300982,
        -0.016786,
        -0.017525312,
        -0.011695661,
        -0.04780071,
        -0.007865787,
        0.0028693757,
        -0.031972177,
        -0.02853014,
        -0.039947044,
        0.031220747,
        -0.025354737,
        -0.013731796,
        -0.009132311,
        0.0017952536,
        0.048067346,
        0.007974865,
        -0.0301542,
        -0.00083551253,
        0.02174302,
        -0.024106393,
        0.046612963,
        0.03185098,
        0.01674964,
        0.014216591,
        -0.006387164,
        -0.026154649,
        -0.025403216,
        -0.00840512,
        -0.009011112,
        -0.008641457,
        0.015852772,
        0.014349909,
        -0.008908094,
        -0.016676921,
        0.021403665,
        0.0036480764,
        0.005544834,
        -0.01594973,
        -0.016470883
      ],
      "embedding_pca_2d": [],
      "embedding_pca_3d": [],
      "embedding_cluster_id": null,
      "migration_history": [],
      "metadata": {
        "compute_time": 10.006747007369995,
        "api_costs": 0.0,
        "embed_cost": 1.354e-05,
        "novelty_cost": 0.0,
        "patch_type": "init",
        "patch_name": "initial_program",
        "patch_description": "Initial program from file.",
        "stdout_log": "Evaluating program: test_output/problem_0/gen_0/main.py\nSaving results to: test_output/problem_0/gen_0/results\nRun 1/1 completed in 0.00 seconds\nCorrectness and error status saved to test_output/problem_0/gen_0/results/correct.json\nMetrics saved to test_output/problem_0/gen_0/results/metrics.json\nEvaluation and Validation completed successfully.\nMetrics:\n  combined_score: 0.21460534544453808\n  public:\n    feasible: True\n    selection_size: 10\n    raw_score: 101.95173081379961\n  private:\n    selection: [0, 1, 2, 6, 9, 10, 14, 16, 17, 18]\n    raw_score: 101.95173081379961\n    normalized_fitness: 0.21460534544453808\n  execution_time_mean: 0.0009637499897507951\n  execution_time_std: 0.0\n  num_valid_runs: 1\n  num_invalid_runs: 0\n  all_validation_errors: []\n",
        "stderr_log": "",
        "code_analysis_metrics": {
          "cyclomatic_complexity": 30,
          "average_cyclomatic_complexity": 15.0,
          "halstead_volume": 483.4105501817314,
          "halstead_difficulty": 7.857142857142857,
          "halstead_effort": 3798.2257514278895,
          "lines_of_code": 145,
          "logical_lines_of_code": 84,
          "comments": 22,
          "maintainability_index": 1.4165259654789253,
          "max_nesting_depth": 5,
          "complexity_score": 1.0
        }
      },
      "in_archive": false
    },
    {
      "id": "77bb6502-9595-4a01-a1b3-796caceef6b3",
      "code": "\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Improved SDS solver:\n    - Reads JSON from stdin with \"requirements\" and \"catalog\"\n    - Writes JSON to stdout with \"selection\": {\"variables\": [...]}\n    \"\"\"\n    data = json.load(sys.stdin)\n    requirements = data.get(\"requirements\", {})\n    catalog = data.get(\"catalog\", {})\n\n    weights = requirements.get(\"weights\", [])\n    n = len(weights)\n    interactions_raw = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, n])\n    if cardinality_bounds is None:\n        cardinality_bounds = [0, n]\n    min_card, max_card = max(0, int(cardinality_bounds[0])), int(cardinality_bounds[1])\n\n    mutex_pairs = requirements.get(\"mutex\", []) or []\n    groups = requirements.get(\"groups\", {}) or {}\n    precedence_pairs = requirements.get(\"precedence\", []) or []\n\n    # Normalize and preprocess interactions: map (i,j) -> value, symmetric\n    interactions = {}\n    for k, v in interactions_raw.items():\n        try:\n            if isinstance(k, str):\n                parts = [p.strip() for p in k.split(\",\")]\n                if len(parts) >= 2:\n                    i = int(parts[0])\n                    j = int(parts[1])\n                else:\n                    continue\n            elif isinstance(k, (list, tuple)) and len(k) >= 2:\n                i, j = int(k[0]), int(k[1])\n            else:\n                continue\n            if 0 <= i < n and 0 <= j < n:\n                interactions[(i, j)] = float(v)\n                interactions[(j, i)] = float(v)\n        except Exception:\n            # Skip malformed keys\n            continue\n\n    # Normalize mutex pairs as tuples of ints\n    mutex = set()\n    for p in mutex_pairs:\n        try:\n            a, b = int(p[0]), int(p[1]) if isinstance(p, (list, tuple)) else int(p.split(\",\")[1])\n            if 0 <= a < n and 0 <= b < n:\n                mutex.add((a, b))\n                mutex.add((b, a))\n        except Exception:\n            # try alternative parsing\n            try:\n                if isinstance(p, str):\n                    a_s, b_s = [x.strip() for x in p.split(\",\")]\n                    a, b = int(a_s), int(b_s)\n                    if 0 <= a < n and 0 <= b < n:\n                        mutex.add((a, b)); mutex.add((b, a))\n            except Exception:\n                continue\n\n    # Group mapping: group_id -> set(vars); also var -> group_id (assume at most one group membership for variable)\n    group_of = {}\n    group_sets = {}\n    for gid, lst in groups.items():\n        try:\n            vars_list = [int(x) for x in lst]\n        except Exception:\n            # try parsing if they are strings with commas\n            vars_list = []\n            for item in lst:\n                try:\n                    vars_list.append(int(item))\n                except Exception:\n                    pass\n        gset = set(v for v in vars_list if 0 <= v < n)\n        group_sets[gid] = gset\n        for v in gset:\n            # if a variable appears in multiple groups, we keep the first encountered group only\n            if v not in group_of:\n                group_of[v] = gid\n\n    # Precedence: Build adjacency where if (i,j) then i is required if j selected.\n    # We'll compute transitive prerequisites for each node.\n    prereq_adj = defaultdict(set)  # j -> set of direct prerequisites i\n    depend_adj = defaultdict(set)  # i -> set of direct dependents j\n    for p in precedence_pairs:\n        try:\n            i, j = int(p[0]), int(p[1]) if isinstance(p, (list, tuple)) else (int(p.split(\",\")[0]), int(p.split(\",\")[1]))\n        except Exception:\n            try:\n                # p may be a list-like [i,j]\n                i, j = int(p[0]), int(p[1])\n            except Exception:\n                continue\n        if 0 <= i < n and 0 <= j < n:\n            prereq_adj[j].add(i)\n            depend_adj[i].add(j)\n\n    # Compute transitive closure of prerequisites for each node using DFS/BFS\n    trans_prereq = [set() for _ in range(n)]\n    for v in range(n):\n        seen = set()\n        stack = list(prereq_adj.get(v, []))\n        while stack:\n            u = stack.pop()\n            if u in seen:\n                continue\n            seen.add(u)\n            for w in prereq_adj.get(u, []):\n                if w not in seen:\n                    stack.append(w)\n        trans_prereq[v] = seen\n\n    # Helper: compute closure of a set of variables: include all prerequisites transitively\n    def closure_of(vars_iterable):\n        closure = set()\n        stack = list(vars_iterable)\n        while stack:\n            x = stack.pop()\n            if x in closure:\n                continue\n            closure.add(x)\n            for p in trans_prereq[x]:\n                if p not in closure:\n                    stack.append(p)\n        return closure\n\n    # Helper: compute objective for a set of variables (sum weights + pairwise interactions)\n    def compute_score(var_set):\n        s = 0.0\n        for v in var_set:\n            s += weights[v]\n        # sum interactions for unordered pairs; to avoid double counting use i<j\n        # interactions dict is symmetric, but we can iterate pairs\n        vs = sorted(var_set)\n        L = len(vs)\n        for i_idx in range(L):\n            i = vs[i_idx]\n            for j_idx in range(i_idx + 1, L):\n                j = vs[j_idx]\n                val = interactions.get((i, j), 0.0)\n                s += val\n        return s\n\n    # Feasibility checks for adding candidate closure to current selection\n    def feasible_union(sel_set, add_set):\n        # union size check\n        union_set = sel_set.union(add_set)\n        if len(union_set) > max_card:\n            return False\n        # group constraints: at most one per group\n        # For each group, ensure that number of variables from union_set <=1\n        # Use group_of mapping for speed\n        occupied = {}\n        for v in union_set:\n            gid = group_of.get(v)\n            if gid is None:\n                continue\n            if gid in occupied:\n                # another var already present in this group\n                return False\n            occupied[gid] = v\n        # mutex constraints\n        # For each var in add_set, ensure it doesn't conflict with any already in sel_set\n        for a in add_set:\n            for b in sel_set:\n                if (a, b) in mutex:\n                    return False\n        # Also ensure no mutex within add_set\n        add_list = list(add_set)\n        for i_idx in range(len(add_list)):\n            a = add_list[i_idx]\n            for j_idx in range(i_idx + 1, len(add_list)):\n                b = add_list[j_idx]\n                if (a, b) in mutex:\n                    return False\n        # Precedence: add_set should already be closed (we will ensure), and sel_set may have nodes that require items not in union:\n        # But since sel_set is assumed previously feasible, only need to ensure that union doesn't violate precedence (it won't).\n        return True\n\n    # Start greedy selection\n    selected = set()\n\n    # We'll iteratively pick a candidate that maximizes marginal_gain / added_count\n    # Precompute base interaction sums for speed when evaluating candidate closure\n    # But given small n typical and simplicity, compute marginal gain on the fly.\n\n    # Candidate set is {0..n-1} \\ selected\n    # Greedy loop\n    while True:\n        best_candidate = None\n        best_score_ratio = -float(\"inf\")\n        best_gain = -float(\"inf\")\n        best_addset = None\n\n        for v in range(n):\n            if v in selected:\n                continue\n            # candidate requires closure\n            cand_closure = closure_of([v])\n            add_set = cand_closure - selected\n            if not add_set:\n                # nothing new would be added (all prerequisites already present and v already selected? if v already selected we skip)\n                # If v itself already present then continue; otherwise must include v but maybe transitive closure included v? handle:\n                if v in selected:\n                    continue\n            # feasibility check\n            if not feasible_union(selected, add_set):\n                continue\n            # compute marginal gain\n            # sum weights of add_set\n            gain = sum(weights[x] for x in add_set)\n            # interactions between add_set and selected\n            for a in add_set:\n                for b in selected:\n                    gain += interactions.get((a, b), 0.0)\n            # interactions internal to add_set (unordered)\n            add_list = sorted(add_set)\n            for i_idx in range(len(add_list)):\n                for j_idx in range(i_idx + 1, len(add_list)):\n                    a = add_list[i_idx]; b = add_list[j_idx]\n                    gain += interactions.get((a, b), 0.0)\n            added = len(add_set)\n            if added == 0:\n                continue\n            # Use gain per added item as primary ranking, tie-break by absolute gain\n            ratio = gain / added\n            if ratio > best_score_ratio or (abs(ratio - best_score_ratio) <= 1e-9 and gain > best_gain):\n                best_score_ratio = ratio\n                best_candidate = v\n                best_gain = gain\n                best_addset = add_set\n\n        if best_candidate is None:\n            break\n        # If best_gain is negative and we already satisfy min_card, stop\n        if best_gain <= 0 and len(selected) >= min_card:\n            break\n        # Otherwise add best_addset (even if negative but needed to reach min_card)\n        if feasible_union(selected, best_addset):\n            selected |= best_addset\n        else:\n            # can't add, break to avoid infinite loop\n            break\n        # Stop if reach max\n        if len(selected) >= max_card:\n            break\n\n    # If below minimum cardinality, force-add best feasible nodes (smallest penalty)\n    if len(selected) < min_card:\n        # compute for each candidate not selected the marginal gain (may be negative) and cost added\n        candidates = []\n        for v in range(n):\n            if v in selected:\n                continue\n            add_set = closure_of([v]) - selected\n            if not add_set:\n                continue\n            if not feasible_union(selected, add_set):\n                continue\n            # compute gain as above\n            gain = sum(weights[x] for x in add_set)\n            for a in add_set:\n                for b in selected:\n                    gain += interactions.get((a, b), 0.0)\n            add_list = sorted(add_set)\n            for i_idx in range(len(add_list)):\n                for j_idx in range(i_idx + 1, len(add_list)):\n                    a = add_list[i_idx]; b = add_list[j_idx]\n                    gain += interactions.get((a, b), 0.0)\n            candidates.append((gain / len(add_set), gain, add_set))\n        # Sort by best ratio then gain\n        candidates.sort(key=lambda x: ( -x[0], -x[1] ))\n        idx = 0\n        # Add until reach min_card or no candidate\n        while len(selected) < min_card and idx < len(candidates):\n            add_set = candidates[idx][2]\n            if feasible_union(selected, add_set):\n                selected |= add_set\n            idx += 1\n        # If still below min_card, add any remaining feasible singletons ignoring gain\n        if len(selected) < min_card:\n            for v in range(n):\n                if len(selected) >= min_card:\n                    break\n                if v in selected:\n                    continue\n                add_set = closure_of([v]) - selected\n                if not add_set:\n                    continue\n                if feasible_union(selected, add_set):\n                    selected |= add_set\n\n    # Local improvement: try single additions, single removals (only removable if not required by other selected), and single swaps\n    current_score = compute_score(selected)\n    improved = True\n    iter_limit = 200\n    it = 0\n    while improved and it < iter_limit:\n        improved = False\n        it += 1\n        # Try adding a single candidate closure that improves score\n        best_delta = 0.0\n        best_action = None  # (\"add\", add_set) or (\"remove\", rem) or (\"swap\", (rem_set, add_set))\n        for v in range(n):\n            if v in selected:\n                continue\n            add_set = closure_of([v]) - selected\n            if not add_set:\n                continue\n            if not feasible_union(selected, add_set):\n                continue\n            new_score = compute_score(selected.union(add_set))\n            delta = new_score - current_score\n            if delta > best_delta + 1e-9:\n                best_delta = delta\n                best_action = (\"add\", add_set)\n        # Try removals: only remove variables that are not prerequisites for any remaining selected variable\n        # So a variable r is removable if none of its dependents are in selected (transitively)\n        # We can check direct dependents and their transitive closure: since we have trans_prereq, we can check if any selected node requires r\n        removable = []\n        for r in list(selected):\n            # if any selected node (other than r) has r in its trans_prereq, r is required\n            required = False\n            for s in selected:\n                if s == r:\n                    continue\n                if r in trans_prereq[s]:\n                    required = True\n                    break\n            if not required:\n                removable.append(r)\n        for r in removable:\n            new_selected = set(selected)\n            new_selected.remove(r)\n            # removing r might allow other nodes to become infeasible wrt precedence? We ensure only removable ones\n            if len(new_selected) < min_card:\n                continue  # do not remove below minimum\n            new_score = compute_score(new_selected)\n            delta = new_score - current_score\n            if delta > best_delta + 1e-9:\n                best_delta = delta\n                best_action = (\"remove\", r)\n        # Try single swaps: remove one removable r and add candidate add_set such that net gain positive\n        if not best_action:\n            # consider swaps\n            for r in removable:\n                temp_selected = set(selected)\n                temp_selected.remove(r)\n                # examine adds that are feasible with temp_selected\n                for v in range(n):\n                    if v in temp_selected:\n                        continue\n                    add_set = closure_of([v]) - temp_selected\n                    if not add_set:\n                        continue\n                    if not feasible_union(temp_selected, add_set):\n                        continue\n                    if len(temp_selected.union(add_set)) > max_card:\n                        continue\n                    new_score = compute_score(temp_selected.union(add_set))\n                    delta = new_score - current_score\n                    if delta > best_delta + 1e-9:\n                        best_delta = delta\n                        best_action = (\"swap\", (r, add_set))\n        # Apply best action if it yields improvement\n        if best_action and best_delta > 1e-9:\n            improved = True\n            typ = best_action[0]\n            if typ == \"add\":\n                selected |= best_action[1]\n            elif typ == \"remove\":\n                selected.remove(best_action[1])\n            elif typ == \"swap\":\n                r, add_set = best_action[1]\n                if r in selected:\n                    selected.remove(r)\n                selected |= add_set\n            current_score = compute_score(selected)\n        else:\n            # no improving action found\n            break\n\n    # Final safety trims: if selection exceeds max_card (shouldn't), remove lowest marginal contributors\n    if len(selected) > max_card:\n        # compute marginal contribution of each removable var (cannot remove required ones)\n        removable = []\n        for r in list(selected):\n            # check if removable (no selected depends on r)\n            required = False\n            for s in selected:\n                if s == r:\n                    continue\n                if r in trans_prereq[s]:\n                    required = True; break\n            if not required:\n                removable.append(r)\n        # sort removable by (weight + interactions with others) ascending (smallest contribution removed first)\n        contribs = []\n        for r in removable:\n            contrib = weights[r]\n            for o in selected:\n                if o == r:\n                    continue\n                contrib += interactions.get((r, o), 0.0)\n            contribs.append((contrib, r))\n        contribs.sort()  # ascending\n        idx = 0\n        while len(selected) > max_card and idx < len(contribs):\n            selected.remove(contribs[idx][1])\n            idx += 1\n\n    final_selection = sorted(int(x) for x in selected)\n    # Guarantee feasibility one last time: if still below min_card, pad with feasible singletons (ignore objective)\n    idx = 0\n    while len(final_selection) < min_card and idx < n:\n        if idx not in final_selection:\n            trial_add = closure_of([idx])\n            # only add those within bounds and feasible\n            if len(set(final_selection).union(trial_add)) <= max_card:\n                # check groups and mutex quickly\n                ok = True\n                # groups\n                for v in trial_add:\n                    gid = group_of.get(v)\n                    if gid is not None:\n                        for u in final_selection:\n                            if group_of.get(u) == gid:\n                                ok = False; break\n                    if not ok:\n                        break\n                # mutex\n                if ok:\n                    for a in trial_add:\n                        for b in final_selection:\n                            if (a, b) in mutex:\n                                ok = False; break\n                        if not ok:\n                            break\n                if ok:\n                    final_selection = sorted(set(final_selection).union(trial_add))\n        idx += 1\n\n    result = {\"selection\": {\"variables\": final_selection}}\n    print(json.dumps(result))\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n    \n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n    \n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n    \n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n    \n    result_str = stdout_capture.getvalue()\n    return result_str\n\n",
      "language": "python",
      "parent_id": "aac66d0e-7541-4a5b-b733-00b0ef41adec",
      "archive_inspiration_ids": [],
      "top_k_inspiration_ids": [],
      "island_idx": 0,
      "generation": 1,
      "timestamp": 1764626745.999846,
      "code_diff": "--- a/original.py\n+++ b/original.py\n@@ -1,145 +1,495 @@\n \"\"\"\n Initial solution for Synergistic Dependency Selection (SDS) problem.\n The code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n \"\"\"\n \n import json\n import sys\n import contextlib\n \n # EVOLVE-BLOCK-START\n def solve_sds():\n     \"\"\"\n-    Solve the Synergistic Dependency Selection problem.\n-    \n-    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n-    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n-    \n-    This is a greedy baseline - evolution will improve this.\n+    Improved SDS solver:\n+    - Reads JSON from stdin with \"requirements\" and \"catalog\"\n+    - Writes JSON to stdout with \"selection\": {\"variables\": [...]}\n     \"\"\"\n-    # Read input\n-    input_data = json.load(sys.stdin)\n-    requirements = input_data.get(\"requirements\", {})\n-    catalog = input_data.get(\"catalog\", {})\n-    \n-    # Extract constraints\n+    data = json.load(sys.stdin)\n+    requirements = data.get(\"requirements\", {})\n+    catalog = data.get(\"catalog\", {})\n+\n     weights = requirements.get(\"weights\", [])\n-    interactions = requirements.get(\"interactions\", {})\n-    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n-    mutex = requirements.get(\"mutex\", [])\n-    groups = requirements.get(\"groups\", {})\n-    precedence = requirements.get(\"precedence\", [])\n-    \n-    # Simple greedy: select items with highest weights first\n-    # This is a baseline - evolution will find better strategies\n     n = len(weights)\n-    selected = []\n-    \n-    # Create score list (weight + interaction potential)\n-    scores = []\n-    for i in range(n):\n-        score = weights[i] if i < len(weights) else 0.0\n-        # Add potential interaction value\n-        for k, v in interactions.items():\n+    interactions_raw = requirements.get(\"interactions\", {})\n+    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, n])\n+    if cardinality_bounds is None:\n+        cardinality_bounds = [0, n]\n+    min_card, max_card = max(0, int(cardinality_bounds[0])), int(cardinality_bounds[1])\n+\n+    mutex_pairs = requirements.get(\"mutex\", []) or []\n+    groups = requirements.get(\"groups\", {}) or {}\n+    precedence_pairs = requirements.get(\"precedence\", []) or []\n+\n+    # Normalize and preprocess interactions: map (i,j) -> value, symmetric\n+    interactions = {}\n+    for k, v in interactions_raw.items():\n+        try:\n+            if isinstance(k, str):\n+                parts = [p.strip() for p in k.split(\",\")]\n+                if len(parts) >= 2:\n+                    i = int(parts[0])\n+                    j = int(parts[1])\n+                else:\n+                    continue\n+            elif isinstance(k, (list, tuple)) and len(k) >= 2:\n+                i, j = int(k[0]), int(k[1])\n+            else:\n+                continue\n+            if 0 <= i < n and 0 <= j < n:\n+                interactions[(i, j)] = float(v)\n+                interactions[(j, i)] = float(v)\n+        except Exception:\n+            # Skip malformed keys\n+            continue\n+\n+    # Normalize mutex pairs as tuples of ints\n+    mutex = set()\n+    for p in mutex_pairs:\n+        try:\n+            a, b = int(p[0]), int(p[1]) if isinstance(p, (list, tuple)) else int(p.split(\",\")[1])\n+            if 0 <= a < n and 0 <= b < n:\n+                mutex.add((a, b))\n+                mutex.add((b, a))\n+        except Exception:\n+            # try alternative parsing\n             try:\n-                u, w = map(int, k.split(\",\"))\n-                if u == i or w == i:\n-                    score += abs(v) * 0.5  # Potential value\n-            except:\n-                pass\n-        scores.append((score, i))\n-    \n-    # Sort by score descending\n-    scores.sort(reverse=True)\n-    \n-    # Greedy selection respecting constraints\n-    selected_set = set()\n-    for score, i in scores:\n-        if len(selected_set) >= cardinality_bounds[1]:\n+                if isinstance(p, str):\n+                    a_s, b_s = [x.strip() for x in p.split(\",\")]\n+                    a, b = int(a_s), int(b_s)\n+                    if 0 <= a < n and 0 <= b < n:\n+                        mutex.add((a, b)); mutex.add((b, a))\n+            except Exception:\n+                continue\n+\n+    # Group mapping: group_id -> set(vars); also var -> group_id (assume at most one group membership for variable)\n+    group_of = {}\n+    group_sets = {}\n+    for gid, lst in groups.items():\n+        try:\n+            vars_list = [int(x) for x in lst]\n+        except Exception:\n+            # try parsing if they are strings with commas\n+            vars_list = []\n+            for item in lst:\n+                try:\n+                    vars_list.append(int(item))\n+                except Exception:\n+                    pass\n+        gset = set(v for v in vars_list if 0 <= v < n)\n+        group_sets[gid] = gset\n+        for v in gset:\n+            # if a variable appears in multiple groups, we keep the first encountered group only\n+            if v not in group_of:\n+                group_of[v] = gid\n+\n+    # Precedence: Build adjacency where if (i,j) then i is required if j selected.\n+    # We'll compute transitive prerequisites for each node.\n+    prereq_adj = defaultdict(set)  # j -> set of direct prerequisites i\n+    depend_adj = defaultdict(set)  # i -> set of direct dependents j\n+    for p in precedence_pairs:\n+        try:\n+            i, j = int(p[0]), int(p[1]) if isinstance(p, (list, tuple)) else (int(p.split(\",\")[0]), int(p.split(\",\")[1]))\n+        except Exception:\n+            try:\n+                # p may be a list-like [i,j]\n+                i, j = int(p[0]), int(p[1])\n+            except Exception:\n+                continue\n+        if 0 <= i < n and 0 <= j < n:\n+            prereq_adj[j].add(i)\n+            depend_adj[i].add(j)\n+\n+    # Compute transitive closure of prerequisites for each node using DFS/BFS\n+    trans_prereq = [set() for _ in range(n)]\n+    for v in range(n):\n+        seen = set()\n+        stack = list(prereq_adj.get(v, []))\n+        while stack:\n+            u = stack.pop()\n+            if u in seen:\n+                continue\n+            seen.add(u)\n+            for w in prereq_adj.get(u, []):\n+                if w not in seen:\n+                    stack.append(w)\n+        trans_prereq[v] = seen\n+\n+    # Helper: compute closure of a set of variables: include all prerequisites transitively\n+    def closure_of(vars_iterable):\n+        closure = set()\n+        stack = list(vars_iterable)\n+        while stack:\n+            x = stack.pop()\n+            if x in closure:\n+                continue\n+            closure.add(x)\n+            for p in trans_prereq[x]:\n+                if p not in closure:\n+                    stack.append(p)\n+        return closure\n+\n+    # Helper: compute objective for a set of variables (sum weights + pairwise interactions)\n+    def compute_score(var_set):\n+        s = 0.0\n+        for v in var_set:\n+            s += weights[v]\n+        # sum interactions for unordered pairs; to avoid double counting use i<j\n+        # interactions dict is symmetric, but we can iterate pairs\n+        vs = sorted(var_set)\n+        L = len(vs)\n+        for i_idx in range(L):\n+            i = vs[i_idx]\n+            for j_idx in range(i_idx + 1, L):\n+                j = vs[j_idx]\n+                val = interactions.get((i, j), 0.0)\n+                s += val\n+        return s\n+\n+    # Feasibility checks for adding candidate closure to current selection\n+    def feasible_union(sel_set, add_set):\n+        # union size check\n+        union_set = sel_set.union(add_set)\n+        if len(union_set) > max_card:\n+            return False\n+        # group constraints: at most one per group\n+        # For each group, ensure that number of variables from union_set <=1\n+        # Use group_of mapping for speed\n+        occupied = {}\n+        for v in union_set:\n+            gid = group_of.get(v)\n+            if gid is None:\n+                continue\n+            if gid in occupied:\n+                # another var already present in this group\n+                return False\n+            occupied[gid] = v\n+        # mutex constraints\n+        # For each var in add_set, ensure it doesn't conflict with any already in sel_set\n+        for a in add_set:\n+            for b in sel_set:\n+                if (a, b) in mutex:\n+                    return False\n+        # Also ensure no mutex within add_set\n+        add_list = list(add_set)\n+        for i_idx in range(len(add_list)):\n+            a = add_list[i_idx]\n+            for j_idx in range(i_idx + 1, len(add_list)):\n+                b = add_list[j_idx]\n+                if (a, b) in mutex:\n+                    return False\n+        # Precedence: add_set should already be closed (we will ensure), and sel_set may have nodes that require items not in union:\n+        # But since sel_set is assumed previously feasible, only need to ensure that union doesn't violate precedence (it won't).\n+        return True\n+\n+    # Start greedy selection\n+    selected = set()\n+\n+    # We'll iteratively pick a candidate that maximizes marginal_gain / added_count\n+    # Precompute base interaction sums for speed when evaluating candidate closure\n+    # But given small n typical and simplicity, compute marginal gain on the fly.\n+\n+    # Candidate set is {0..n-1} \\ selected\n+    # Greedy loop\n+    while True:\n+        best_candidate = None\n+        best_score_ratio = -float(\"inf\")\n+        best_gain = -float(\"inf\")\n+        best_addset = None\n+\n+        for v in range(n):\n+            if v in selected:\n+                continue\n+            # candidate requires closure\n+            cand_closure = closure_of([v])\n+            add_set = cand_closure - selected\n+            if not add_set:\n+                # nothing new would be added (all prerequisites already present and v already selected? if v already selected we skip)\n+                # If v itself already present then continue; otherwise must include v but maybe transitive closure included v? handle:\n+                if v in selected:\n+                    continue\n+            # feasibility check\n+            if not feasible_union(selected, add_set):\n+                continue\n+            # compute marginal gain\n+            # sum weights of add_set\n+            gain = sum(weights[x] for x in add_set)\n+            # interactions between add_set and selected\n+            for a in add_set:\n+                for b in selected:\n+                    gain += interactions.get((a, b), 0.0)\n+            # interactions internal to add_set (unordered)\n+            add_list = sorted(add_set)\n+            for i_idx in range(len(add_list)):\n+                for j_idx in range(i_idx + 1, len(add_list)):\n+                    a = add_list[i_idx]; b = add_list[j_idx]\n+                    gain += interactions.get((a, b), 0.0)\n+            added = len(add_set)\n+            if added == 0:\n+                continue\n+            # Use gain per added item as primary ranking, tie-break by absolute gain\n+            ratio = gain / added\n+            if ratio > best_score_ratio or (abs(ratio - best_score_ratio) <= 1e-9 and gain > best_gain):\n+                best_score_ratio = ratio\n+                best_candidate = v\n+                best_gain = gain\n+                best_addset = add_set\n+\n+        if best_candidate is None:\n             break\n-            \n-        # Check mutex constraints\n-        can_add = True\n-        for a, b in mutex:\n-            if (a == i and b in selected_set) or (b == i and a in selected_set):\n-                can_add = False\n-                break\n-        \n-        if not can_add:\n-            continue\n-            \n-        # Check group constraints (at most one per group)\n-        for grp_vars in groups.values():\n-            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n-                can_add = False\n-                break\n-        \n-        if not can_add:\n-            continue\n-        \n-        # Check precedence (if j selected, i must be selected)\n-        precedence_ok = True\n-        for pred_i, pred_j in precedence:\n-            if pred_j == i and pred_i not in selected_set:\n-                precedence_ok = False\n-                break\n-        \n-        if not precedence_ok:\n-            continue\n-        \n-        # Add if we meet minimum cardinality or have room\n-        if len(selected_set) < cardinality_bounds[1]:\n-            selected_set.add(i)\n-            selected.append(i)\n-    \n-    # Ensure minimum cardinality\n-    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n-        for i in range(n):\n-            if i not in selected_set:\n-                selected_set.add(i)\n-                selected.append(i)\n-                break\n-    \n-    # Output result\n-    result = {\n-        \"selection\": {\n-            \"variables\": sorted(selected)\n-        }\n-    }\n+        # If best_gain is negative and we already satisfy min_card, stop\n+        if best_gain <= 0 and len(selected) >= min_card:\n+            break\n+        # Otherwise add best_addset (even if negative but needed to reach min_card)\n+        if feasible_union(selected, best_addset):\n+            selected |= best_addset\n+        else:\n+            # can't add, break to avoid infinite loop\n+            break\n+        # Stop if reach max\n+        if len(selected) >= max_card:\n+            break\n+\n+    # If below minimum cardinality, force-add best feasible nodes (smallest penalty)\n+    if len(selected) < min_card:\n+        # compute for each candidate not selected the marginal gain (may be negative) and cost added\n+        candidates = []\n+        for v in range(n):\n+            if v in selected:\n+                continue\n+            add_set = closure_of([v]) - selected\n+            if not add_set:\n+                continue\n+            if not feasible_union(selected, add_set):\n+                continue\n+            # compute gain as above\n+            gain = sum(weights[x] for x in add_set)\n+            for a in add_set:\n+                for b in selected:\n+                    gain += interactions.get((a, b), 0.0)\n+            add_list = sorted(add_set)\n+            for i_idx in range(len(add_list)):\n+                for j_idx in range(i_idx + 1, len(add_list)):\n+                    a = add_list[i_idx]; b = add_list[j_idx]\n+                    gain += interactions.get((a, b), 0.0)\n+            candidates.append((gain / len(add_set), gain, add_set))\n+        # Sort by best ratio then gain\n+        candidates.sort(key=lambda x: ( -x[0], -x[1] ))\n+        idx = 0\n+        # Add until reach min_card or no candidate\n+        while len(selected) < min_card and idx < len(candidates):\n+            add_set = candidates[idx][2]\n+            if feasible_union(selected, add_set):\n+                selected |= add_set\n+            idx += 1\n+        # If still below min_card, add any remaining feasible singletons ignoring gain\n+        if len(selected) < min_card:\n+            for v in range(n):\n+                if len(selected) >= min_card:\n+                    break\n+                if v in selected:\n+                    continue\n+                add_set = closure_of([v]) - selected\n+                if not add_set:\n+                    continue\n+                if feasible_union(selected, add_set):\n+                    selected |= add_set\n+\n+    # Local improvement: try single additions, single removals (only removable if not required by other selected), and single swaps\n+    current_score = compute_score(selected)\n+    improved = True\n+    iter_limit = 200\n+    it = 0\n+    while improved and it < iter_limit:\n+        improved = False\n+        it += 1\n+        # Try adding a single candidate closure that improves score\n+        best_delta = 0.0\n+        best_action = None  # (\"add\", add_set) or (\"remove\", rem) or (\"swap\", (rem_set, add_set))\n+        for v in range(n):\n+            if v in selected:\n+                continue\n+            add_set = closure_of([v]) - selected\n+            if not add_set:\n+                continue\n+            if not feasible_union(selected, add_set):\n+                continue\n+            new_score = compute_score(selected.union(add_set))\n+            delta = new_score - current_score\n+            if delta > best_delta + 1e-9:\n+                best_delta = delta\n+                best_action = (\"add\", add_set)\n+        # Try removals: only remove variables that are not prerequisites for any remaining selected variable\n+        # So a variable r is removable if none of its dependents are in selected (transitively)\n+        # We can check direct dependents and their transitive closure: since we have trans_prereq, we can check if any selected node requires r\n+        removable = []\n+        for r in list(selected):\n+            # if any selected node (other than r) has r in its trans_prereq, r is required\n+            required = False\n+            for s in selected:\n+                if s == r:\n+                    continue\n+                if r in trans_prereq[s]:\n+                    required = True\n+                    break\n+            if not required:\n+                removable.append(r)\n+        for r in removable:\n+            new_selected = set(selected)\n+            new_selected.remove(r)\n+            # removing r might allow other nodes to become infeasible wrt precedence? We ensure only removable ones\n+            if len(new_selected) < min_card:\n+                continue  # do not remove below minimum\n+            new_score = compute_score(new_selected)\n+            delta = new_score - current_score\n+            if delta > best_delta + 1e-9:\n+                best_delta = delta\n+                best_action = (\"remove\", r)\n+        # Try single swaps: remove one removable r and add candidate add_set such that net gain positive\n+        if not best_action:\n+            # consider swaps\n+            for r in removable:\n+                temp_selected = set(selected)\n+                temp_selected.remove(r)\n+                # examine adds that are feasible with temp_selected\n+                for v in range(n):\n+                    if v in temp_selected:\n+                        continue\n+                    add_set = closure_of([v]) - temp_selected\n+                    if not add_set:\n+                        continue\n+                    if not feasible_union(temp_selected, add_set):\n+                        continue\n+                    if len(temp_selected.union(add_set)) > max_card:\n+                        continue\n+                    new_score = compute_score(temp_selected.union(add_set))\n+                    delta = new_score - current_score\n+                    if delta > best_delta + 1e-9:\n+                        best_delta = delta\n+                        best_action = (\"swap\", (r, add_set))\n+        # Apply best action if it yields improvement\n+        if best_action and best_delta > 1e-9:\n+            improved = True\n+            typ = best_action[0]\n+            if typ == \"add\":\n+                selected |= best_action[1]\n+            elif typ == \"remove\":\n+                selected.remove(best_action[1])\n+            elif typ == \"swap\":\n+                r, add_set = best_action[1]\n+                if r in selected:\n+                    selected.remove(r)\n+                selected |= add_set\n+            current_score = compute_score(selected)\n+        else:\n+            # no improving action found\n+            break\n+\n+    # Final safety trims: if selection exceeds max_card (shouldn't), remove lowest marginal contributors\n+    if len(selected) > max_card:\n+        # compute marginal contribution of each removable var (cannot remove required ones)\n+        removable = []\n+        for r in list(selected):\n+            # check if removable (no selected depends on r)\n+            required = False\n+            for s in selected:\n+                if s == r:\n+                    continue\n+                if r in trans_prereq[s]:\n+                    required = True; break\n+            if not required:\n+                removable.append(r)\n+        # sort removable by (weight + interactions with others) ascending (smallest contribution removed first)\n+        contribs = []\n+        for r in removable:\n+            contrib = weights[r]\n+            for o in selected:\n+                if o == r:\n+                    continue\n+                contrib += interactions.get((r, o), 0.0)\n+            contribs.append((contrib, r))\n+        contribs.sort()  # ascending\n+        idx = 0\n+        while len(selected) > max_card and idx < len(contribs):\n+            selected.remove(contribs[idx][1])\n+            idx += 1\n+\n+    final_selection = sorted(int(x) for x in selected)\n+    # Guarantee feasibility one last time: if still below min_card, pad with feasible singletons (ignore objective)\n+    idx = 0\n+    while len(final_selection) < min_card and idx < n:\n+        if idx not in final_selection:\n+            trial_add = closure_of([idx])\n+            # only add those within bounds and feasible\n+            if len(set(final_selection).union(trial_add)) <= max_card:\n+                # check groups and mutex quickly\n+                ok = True\n+                # groups\n+                for v in trial_add:\n+                    gid = group_of.get(v)\n+                    if gid is not None:\n+                        for u in final_selection:\n+                            if group_of.get(u) == gid:\n+                                ok = False; break\n+                    if not ok:\n+                        break\n+                # mutex\n+                if ok:\n+                    for a in trial_add:\n+                        for b in final_selection:\n+                            if (a, b) in mutex:\n+                                ok = False; break\n+                        if not ok:\n+                            break\n+                if ok:\n+                    final_selection = sorted(set(final_selection).union(trial_add))\n+        idx += 1\n+\n+    result = {\"selection\": {\"variables\": final_selection}}\n     print(json.dumps(result))\n+\n # EVOLVE-BLOCK-END\n \n \n # This part remains fixed (not evolved)\n def run_sds(problem_data=None):\n     \"\"\"\n     Main function called by the evaluator.\n     Can accept problem_data as parameter or read from stdin.\n     Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n     \"\"\"\n     import sys\n     import json\n     import io\n     \n     if problem_data is None:\n         # Read from stdin (for compatibility)\n         input_data = json.load(sys.stdin)\n     else:\n         # Use provided problem data\n         input_data = problem_data\n     \n     # Capture stdout from solve_sds\n     stdout_capture = io.StringIO()\n     old_stdin = sys.stdin\n     \n     try:\n         # Create mock stdin\n         sys.stdin = io.StringIO(json.dumps(input_data))\n         with contextlib.redirect_stdout(stdout_capture):\n             solve_sds()\n     finally:\n         sys.stdin = old_stdin\n     \n     result_str = stdout_capture.getvalue()\n     return result_str\n \n",
      "combined_score": 0.0,
      "public_metrics": {},
      "private_metrics": {},
      "text_feedback": "",
      "correct": false,
      "children_count": 0,
      "complexity": 1.0,
      "embedding": [
        0.014268842,
        -0.014111898,
        0.026968243,
        -0.02738676,
        0.010874924,
        0.02371165,
        0.030133283,
        -0.014151134,
        -0.023528548,
        0.042427246,
        0.046377007,
        -0.05137306,
        -0.021213623,
        0.016884578,
        0.035966374,
        -0.012516298,
        0.030028654,
        0.0015751638,
        -0.015236665,
        0.036881883,
        0.026340466,
        -0.010371394,
        0.06487026,
        0.015184349,
        0.032356657,
        -0.011855825,
        0.0228223,
        0.039759193,
        0.045252237,
        -0.03350758,
        0.05545361,
        -0.007598714,
        -0.024470214,
        -0.0005909929,
        -0.033978414,
        0.054093428,
        0.010639507,
        0.029113146,
        -0.043787427,
        0.0014419247,
        0.0010201372,
        -0.019618023,
        -0.043813583,
        0.0042309538,
        0.006398745,
        0.0042309538,
        0.008664627,
        -0.0075921747,
        0.028249953,
        -0.0048652696,
        -0.019748809,
        0.02688977,
        0.020494295,
        0.015132035,
        -0.012660164,
        -0.038608268,
        -0.0353386,
        0.0047867973,
        0.02571269,
        0.008239569,
        0.030891847,
        -0.015393608,
        0.06450406,
        0.013052524,
        -0.0015596328,
        0.003740503,
        0.00053459115,
        0.034161516,
        0.0064020148,
        -0.008265727,
        -0.05477352,
        -0.008553458,
        0.05168695,
        -0.03750966,
        -0.022443019,
        -0.0010029714,
        0.044336732,
        0.03531244,
        0.025019519,
        -0.037666604,
        -0.015459002,
        -0.01855865,
        0.036751095,
        -0.024954125,
        -0.03492008,
        -0.074286915,
        -0.0056696087,
        0.0042309538,
        -0.07072951,
        -0.06241147,
        -0.009939798,
        -0.009449348,
        -0.034553878,
        0.04656011,
        0.039654564,
        -0.02053353,
        0.036620308,
        -0.014033426,
        -0.0028348044,
        -0.02481026,
        0.0006134719,
        -0.035757117,
        0.014700439,
        -0.028642314,
        0.044676777,
        0.030918004,
        0.041642524,
        0.014465022,
        -0.012287421,
        -0.005784047,
        -0.027569862,
        0.029714765,
        -0.00238032,
        0.0128040295,
        0.017106917,
        -0.05665685,
        -0.01964418,
        -0.024090933,
        -0.021265937,
        -0.02182832,
        -0.0038418628,
        0.0020615272,
        -0.018532492,
        0.050719127,
        0.0019601674,
        0.017800085,
        0.02440482,
        -0.035887904,
        -0.0007385368,
        0.011090722,
        0.03560017,
        0.007886445,
        0.041328635,
        -0.022953087,
        -0.04943742,
        0.0069709374,
        -0.02966245,
        -0.013124458,
        0.004832573,
        0.025490351,
        -0.0027448884,
        0.022351468,
        0.024836417,
        0.028746942,
        -0.044964507,
        0.028903887,
        -0.00059753226,
        0.041720994,
        -0.08532532,
        0.024130167,
        0.031781197,
        0.014085741,
        0.015602867,
        0.012352815,
        0.06492258,
        -0.067433685,
        -0.03353374,
        0.04088396,
        0.04315965,
        -0.03115342,
        -0.0013928796,
        -0.008435749,
        -0.019657258,
        -0.017577749,
        0.06366702,
        -0.023685493,
        -0.022652278,
        0.024234798,
        -0.06361471,
        -0.026654353,
        0.025477272,
        -0.07915218,
        0.01458273,
        -0.0029835743,
        0.008357278,
        -0.020376585,
        0.012875962,
        -0.018035503,
        0.0025863093,
        -0.021305174,
        -0.056604534,
        -0.019160269,
        -0.04880964,
        -0.032513604,
        -0.025738847,
        -0.014177291,
        0.009423191,
        -0.034056887,
        -0.02321466,
        -0.0060488903,
        -0.007899524,
        0.01895101,
        0.01735541,
        -0.0014852479,
        0.0074875453,
        -0.0068205325,
        0.04763256,
        0.043787427,
        -0.015302057,
        0.04315965,
        0.0016086779,
        -0.021004364,
        0.019330291,
        -0.033376794,
        -0.004008616,
        -0.015550553,
        -0.03076106,
        -0.004852191,
        -0.021605982,
        -0.047109414,
        0.03818975,
        -0.026549725,
        0.0017509086,
        0.040910117,
        0.00803031,
        0.042217985,
        -0.00051579054,
        0.019971147,
        0.0035475926,
        0.07821052,
        -0.01706768,
        0.031101106,
        0.026275072,
        0.0005112947,
        -0.007193275,
        0.057023052,
        0.018780988,
        -0.029897867,
        0.014177291,
        -0.01477891,
        0.004754101,
        -0.009547438,
        -0.026235836,
        -0.0126994,
        -0.01797011,
        -0.022272995,
        -0.012777872,
        -0.0026664163,
        0.0066407006,
        -0.0073698373,
        0.023175424,
        0.007422152,
        0.027203659,
        0.018728672,
        0.01893793,
        0.002362337,
        -0.04028234,
        -0.0287731,
        -0.016544532,
        0.019421842,
        0.033559896,
        -0.02788375,
        0.025529588,
        -0.025921948,
        -0.0387129,
        -0.023332369,
        0.012424747,
        -0.03821591,
        -0.011685803,
        0.04287192,
        -0.070310995,
        -0.012346276,
        0.007834131,
        -0.031807356,
        -0.036881883,
        0.008468446,
        0.020651238,
        0.018153211,
        0.014648124,
        -0.022887694,
        -0.015864441,
        0.02350239,
        -0.0490189,
        -0.011143037,
        -0.0373004,
        -4.396174e-05,
        0.021592904,
        0.0763795,
        -0.01608678,
        -0.03928836,
        -0.05718,
        0.0026925737,
        0.06141749,
        0.0029721304,
        0.027151344,
        -0.011332678,
        -0.0042832685,
        0.00912892,
        0.01676687,
        0.013732616,
        -0.008246109,
        -0.013627986,
        0.033167537,
        -0.045304555,
        -0.02559498,
        -0.051033016,
        -0.0047475616,
        0.018833302,
        -0.0029688608,
        -0.0015179445,
        0.07794894,
        -0.002422826,
        0.017381568,
        0.021893714,
        -0.038843684,
        -0.00933164,
        0.06330082,
        -0.015995229,
        0.015498238,
        0.02568653,
        -0.021789083,
        -0.005666339,
        -0.0058298223,
        0.002530725,
        -0.05388417,
        -0.022024501,
        0.0474233,
        -0.026118128,
        0.03473698,
        0.00024808626,
        -0.036463365,
        -0.043525852,
        0.017237702,
        -0.0068597686,
        0.019134112,
        -0.02955782,
        0.004116515,
        0.021213623,
        0.0014353853,
        -0.02678514,
        0.010364856,
        -0.0077818157,
        0.05796472,
        0.015511316,
        -0.030970318,
        -0.031048791,
        -0.020572767,
        -0.010508721,
        -0.019408764,
        0.024771024,
        -0.030185597,
        0.00090569875,
        -0.018388627,
        -0.023476234,
        -0.01319639,
        -0.0076444894,
        0.0031862939,
        0.06968322,
        0.0490189,
        -0.00753986,
        -0.0072259717,
        -0.006529532,
        -0.022037579,
        0.049803622,
        -0.010763755,
        0.007454849,
        -0.028197639,
        0.013444885,
        -0.0029917485,
        -0.019317213,
        0.016727634,
        0.0054930463,
        0.008304963,
        0.0186502,
        -0.0051922365,
        0.038582113,
        -0.03594022,
        0.025634216,
        -0.0046462016,
        0.006532802,
        0.04574923,
        0.06722443,
        -0.0020664318,
        0.035155497,
        -0.08998133,
        -0.01667532,
        0.010757216,
        0.026039656,
        0.03185967,
        0.035678644,
        -0.011574633,
        0.015445923,
        -0.051137645,
        -0.0023705112,
        0.001974881,
        0.019971147,
        0.0053916867,
        -0.0011525588,
        -0.035966374,
        -0.037143458,
        0.025451114,
        -0.047658715,
        -0.0012130478,
        0.006192756,
        0.00054072175,
        -0.0018342851,
        0.03065643,
        0.048391122,
        0.026942085,
        0.055872127,
        -0.009115841,
        0.036149476,
        -0.03115342,
        -0.045801543,
        -0.009547438,
        -0.0006674215,
        0.057389256,
        0.03293212,
        -0.02927009,
        -0.00011106662,
        0.016230645,
        0.008481525,
        0.035861745,
        -0.014412708,
        0.044179786,
        -0.011064565,
        -0.023999382,
        0.035835586,
        0.0016757061,
        0.06711979,
        -0.01905564,
        -0.021514433,
        0.021592904,
        -0.046324693,
        -0.039052945,
        0.021645218,
        0.04187794,
        -0.018990247,
        0.043290436,
        0.004136133,
        0.005643451,
        0.07229895,
        0.048260335,
        0.013811088,
        0.010770295,
        0.008219952,
        0.01608678,
        0.021893714,
        -0.018323233,
        0.0056565297,
        -0.012790951,
        -0.011692341,
        0.02063816,
        -0.024875652,
        -0.027936064,
        -0.011875443,
        0.02291385,
        -0.022272995,
        0.015746733,
        0.026314307,
        0.024692552,
        0.0037960873,
        0.0244179,
        0.006997095,
        -0.028119165,
        -0.025451114,
        0.07925681,
        0.00882811,
        0.027255973,
        0.021501353,
        0.030211756,
        0.03183351,
        -0.04603696,
        0.023777043,
        0.027099028,
        0.015328215,
        0.041119374,
        0.0142426845,
        -0.030080969,
        0.06439943,
        0.013706459,
        -0.017237702,
        -0.023188503,
        -0.016021386,
        -0.029060831,
        -0.030368699,
        0.02600042,
        -0.0040968973,
        0.027020557,
        -0.0062646884,
        -0.00023521192,
        -0.0068793865,
        0.011398071,
        0.018035503,
        0.05456426,
        0.045121454,
        0.02211605,
        -0.038765214,
        -0.02044198,
        0.008690784,
        0.032016613,
        -0.00082927017,
        -0.008089164,
        -0.01477891,
        0.0056565297,
        -0.011626949,
        -0.022586884,
        0.029950181,
        -0.01270594,
        -0.021605982,
        0.016845342,
        -0.008239569,
        -0.015720576,
        0.030682588,
        0.013601829,
        -0.017682377,
        0.011398071,
        -0.018153211,
        0.008749638,
        0.027831435,
        -0.024744866,
        0.020742789,
        -0.013222547,
        0.009933259,
        0.02420864,
        0.0062123737,
        -0.02062508,
        -0.02212913,
        -0.02798838,
        0.016858421,
        -0.0014885175,
        -0.035077024,
        -0.004476179,
        0.006496835,
        0.0021285554,
        -0.009468965,
        0.014046504,
        -0.09186466,
        -0.05187005,
        -0.01329448,
        -0.0021187465,
        -0.006925162,
        -0.03481545,
        0.07575172,
        -0.01557671,
        0.003165041,
        -0.036620308,
        -0.027203659,
        -1.1494935e-05,
        -0.0035018171,
        0.001080626,
        0.018741751,
        -0.011012251,
        0.00015479846,
        0.027439075,
        -0.030682588,
        0.051346906,
        0.006925162,
        -0.012215489,
        -0.011450386,
        -0.024444057,
        -0.034266148,
        -0.0022789603,
        -0.0098417085,
        -0.034187675,
        -0.0061469804,
        -0.033899944,
        0.009776315,
        -0.016936893,
        -0.0036947276,
        0.0066733975,
        0.0022626119,
        0.021671375,
        -0.025908869,
        -0.014517337,
        -0.025935026,
        0.03680341,
        0.031101106,
        -0.0014942394,
        0.05139922,
        -0.0058690584,
        -0.023136187,
        -0.004714865,
        -0.066910535,
        0.056342963,
        -0.0035574015,
        -0.0006637431,
        -0.02113515,
        -0.0084030535,
        -0.009874404,
        -0.027177501,
        -0.02598734,
        -0.020978205,
        -0.008213412,
        -0.086894765,
        0.032905962,
        -0.014033426,
        0.010659126,
        -0.017407725,
        -0.013654144,
        -0.014661202,
        -0.022351468,
        0.01438655,
        0.025647296,
        -0.029610137,
        -0.015890598,
        -0.032278188,
        -0.008599233,
        -0.021292094,
        0.020873576,
        -0.00124084,
        -0.034370776,
        0.036489524,
        0.016819185,
        -0.027936064,
        -0.00724559,
        0.04365664,
        0.026628196,
        0.008553458,
        0.0062156436,
        -0.029688608,
        -0.00912892,
        -0.0077752764,
        -0.010502182,
        -0.024836417,
        0.0128040295,
        -0.018100895,
        0.03580943,
        0.03669878,
        -0.05357028,
        -0.0015645373,
        -0.007193275,
        -0.0051758885,
        0.021200543,
        0.033978414,
        0.013915718,
        -0.024470214,
        0.01477891,
        -0.000863193,
        -0.0049241236,
        -0.038660582,
        -0.005604215,
        -0.010881463,
        0.011921219,
        -0.027046714,
        0.012915199,
        0.02927009,
        -0.012123938,
        -0.0042996164,
        0.015027406,
        0.017865479,
        0.00036068552,
        -0.0007499807,
        -0.042714976,
        0.024300192,
        0.025765004,
        -0.03471082,
        0.0059017553,
        -0.0059181037,
        0.009730539,
        -0.022168366,
        -0.031310365,
        0.009789393,
        -0.024169404,
        0.03850364,
        0.0078014336,
        0.012123938,
        -0.034266148,
        -0.012889041,
        -0.016505297,
        -0.010031349,
        -0.021658298,
        -0.016557612,
        0.028040694,
        -0.013013288,
        0.021305174,
        0.01657069,
        0.034893923,
        0.012346276,
        -0.0026598768,
        -0.041197848,
        -0.0054047653,
        -0.003701267,
        -0.021854477,
        0.009553977,
        -0.018179368,
        0.024653316,
        -0.008357278,
        -0.023829358,
        0.05228857,
        -0.01587752,
        0.0053426414,
        -0.039366834,
        0.03512934,
        0.0075856354,
        -0.008965436,
        0.021318251,
        0.0012923372,
        0.0128628835,
        0.0020664318,
        0.00903083,
        0.009717461,
        -0.01568134,
        -0.0109272385,
        0.02154059,
        0.017878558,
        0.027648333,
        0.039471462,
        -0.007324062,
        -0.11415073,
        -0.0072782864,
        0.013183312,
        -0.009383954,
        -0.023593942,
        -0.016217565,
        -0.03682957,
        0.003740503,
        0.009482045,
        0.031807356,
        -0.013320638,
        0.009370876,
        0.012195871,
        -0.02530725,
        -0.00208278,
        -0.030630274,
        0.0011574633,
        0.04219183,
        0.03413536,
        0.017224625,
        -0.029191619,
        -0.046010803,
        -0.010587193,
        -0.043892056,
        -0.0062646884,
        -0.032958277,
        -0.014726596,
        -0.0033203503,
        0.01985344,
        0.009900562,
        0.012084702,
        0.007696804,
        -0.010377934,
        0.008880425,
        -0.0022446287,
        -0.0024342698,
        -0.0022904042,
        -0.029139303,
        -0.0033710303,
        -0.041014746,
        0.026654353,
        -0.023554707,
        -0.02571269,
        0.021815242,
        0.001548189,
        -0.028406898,
        -0.011430768,
        -0.00019669111,
        0.039942294,
        -0.052680932,
        0.04096243,
        -0.027962223,
        0.010090203,
        0.002708922,
        -0.0016430094,
        0.01666224,
        0.028746942,
        0.027203659,
        0.015485159,
        -0.014334235,
        0.019814203,
        -0.018074738,
        -0.0070624882,
        -0.019801125,
        0.0009939799,
        0.013026367,
        0.041145533,
        0.032827493,
        0.000102892445,
        0.01706768,
        0.021959107,
        0.02660204,
        0.0003535331,
        -0.007834131,
        0.0064150933,
        0.015393608,
        -0.03970688,
        -0.0040609306,
        -0.041537892,
        -0.011339217,
        0.011770814,
        0.0041851783,
        -0.013837245,
        -0.000575462,
        0.016335273,
        0.010175214,
        0.006624352,
        -0.007951839,
        -0.016701477,
        0.03086569,
        -0.042845763,
        -0.03970688,
        0.02271767,
        -0.0035247048,
        0.0289562,
        -0.010704901,
        0.030447172,
        -0.018310154,
        -0.1158248,
        -0.018741751,
        0.012777872,
        -0.0111038005,
        0.015158192,
        -0.0141249765,
        -0.0055649793,
        0.013719537,
        0.001706768,
        -0.027203659,
        -0.035783272,
        -0.014752753,
        0.013405649,
        0.017486198,
        0.013274862,
        -0.015341294,
        0.0070428704,
        0.0076248716,
        0.017643142,
        -0.024444057,
        -0.01923874,
        0.02033735,
        0.006320273,
        0.009240089,
        -0.027229816,
        -0.0057709683,
        0.007709883,
        0.025424957,
        -0.016727634,
        0.021174386,
        0.027569862,
        -0.00047451092,
        0.005735002,
        0.029531663,
        -0.034972396,
        -0.025804238,
        0.018728672,
        0.0127451755,
        -0.0057186536,
        0.013222547,
        0.026811298,
        -0.006287576,
        0.029688608,
        -0.044676777,
        -0.0013634526,
        -0.022900771,
        -0.018113974,
        -0.00198469,
        -0.009416651,
        0.02798838,
        -0.0040740096,
        0.0064347116,
        -0.005071259,
        -0.02738676,
        -0.02538572,
        0.013641065,
        0.0038451324,
        0.006997095,
        -0.024692552,
        0.018153211,
        -0.0011975168,
        -0.009266246,
        0.0575462,
        -0.025647296,
        -0.025320329,
        0.016452981,
        -0.026157364,
        -0.010371394,
        -0.009612831,
        0.0070101735,
        -0.009965955,
        -0.008488065,
        -0.022874614,
        -0.018297076,
        -0.017773928,
        0.041145533,
        -0.010946857,
        -0.0010986093,
        -0.025176462,
        -0.0009817185,
        0.032408975,
        -0.024522528,
        0.020965127,
        0.017603906,
        0.017420804,
        0.027465232,
        0.024391742,
        0.040648542,
        0.012038927,
        0.048652697,
        -0.008396514,
        -0.009285864,
        0.0010953397,
        -0.0066930153,
        -0.042217985,
        0.027203659,
        -0.0013748964,
        -0.0019029483,
        0.026026577,
        -0.0015955992,
        0.039497618,
        0.056029074,
        0.02250841,
        -0.00931856,
        -0.028197639,
        0.046586264,
        -0.03157194,
        -0.004456561,
        -0.003701267,
        0.041119374,
        -0.007363298,
        0.0039432226,
        -0.059481844,
        0.017930873,
        0.005408035,
        -0.0002007782,
        -0.0020713361,
        0.0077752764,
        0.013706459,
        0.013902639,
        -0.0024947585,
        0.030630274,
        -0.027203659,
        0.017695457,
        -0.0023492582,
        0.033612214,
        -0.012052005,
        -0.0006351335,
        -0.0029361642,
        0.010992632,
        0.036071006,
        -0.0071867355,
        -0.007690265,
        0.079518385,
        -0.0068924655,
        0.026144285,
        0.046298534,
        -0.017512355,
        -0.0012441096,
        0.020808183,
        0.020049619,
        0.0011656375,
        -0.0104564065,
        -0.017303096,
        -0.022560727,
        0.023345446,
        0.016243722,
        -0.009606292,
        -0.046455476,
        0.020886654,
        -0.025568822,
        -0.01895101,
        0.0024947585,
        0.013163693,
        -0.0034658506,
        0.056133702,
        -0.026078891,
        -0.04684784,
        -0.03594022,
        -0.016126014,
        0.042531874,
        0.03531244,
        -0.003313811,
        -0.032408975,
        0.030630274,
        0.0088150315,
        -0.018440941,
        -0.02093897,
        0.020363508,
        0.032408975,
        -0.055087406,
        -0.036306422,
        -0.030421015,
        -0.01895101,
        0.0064575993,
        0.021279015,
        -0.009181235,
        -0.0006122458,
        0.018846381,
        -0.0008770891,
        0.019107955,
        0.024587922,
        0.0020321002,
        0.019094875,
        0.03591406,
        -0.033612214,
        0.009449348,
        -0.007055949,
        -0.006231992,
        -0.009638988,
        0.037143458,
        0.024326349,
        -0.0033301595,
        0.05744157,
        0.0029884789,
        0.02341084,
        -0.012091242,
        0.010711441,
        0.027805278,
        -0.018780988,
        -0.015367451,
        0.0014280286,
        0.019997304,
        -0.058906384,
        0.00922701,
        0.06052814,
        0.009213931,
        -0.010240608,
        -0.009370876,
        -0.0093251,
        0.008913122,
        0.006676667,
        -0.019461079,
        -0.0038582112,
        -0.023345446,
        0.021082835,
        0.019173348,
        0.0029116415,
        -0.04415363,
        -0.02976708,
        -0.022652278,
        -0.011293442,
        0.04169484,
        0.0039464924,
        -0.0075594783,
        0.028642314,
        -0.0012833456,
        0.019971147,
        0.010731058,
        -0.00664724,
        -0.013562593,
        0.018100895,
        -0.017525434,
        -0.00803685,
        0.014177291,
        -0.022246838,
        0.009233549,
        -0.005251091,
        -0.014425786,
        0.051739264,
        0.018427862,
        -0.011770814,
        0.0022773254,
        -0.012947895,
        0.0371173,
        -0.00073036266,
        0.033481427,
        0.023201581,
        -0.00044712744,
        -0.0029361642,
        -0.024326349,
        -0.026772061,
        0.029113146,
        -0.03026407,
        0.03580943,
        -0.010286383,
        0.022272995,
        0.044179786,
        0.010495642,
        0.0022805952,
        0.01667532,
        -0.016309116,
        0.005215124,
        -0.024914889,
        -0.021370566,
        -0.01399419,
        -0.01896409,
        0.023240818,
        0.030080969,
        0.013680302,
        0.004603696,
        0.030394856,
        -0.012320118,
        0.028014537,
        -0.021893714,
        -0.015053563,
        -0.0064510596,
        0.007422152,
        0.007788355,
        -0.029845553,
        -0.014608888,
        0.028119165,
        0.012535917,
        0.025738847,
        0.026837455,
        -0.051765423,
        0.01875483,
        -0.029688608,
        0.037640445,
        -0.02092589,
        -0.0071801962,
        0.01636143,
        0.007232511,
        0.011653106,
        0.003740503,
        -0.009586674,
        0.00012118216,
        -0.02481026,
        0.024666393,
        -0.027125185,
        0.0076444894,
        0.014072661,
        0.014059583,
        -0.039236046,
        0.037064984,
        0.009894023,
        -0.041433264,
        0.0050941464,
        -0.02023272,
        -0.0070690275,
        0.0047279433,
        -0.029243933,
        0.01318985,
        -0.0028135513,
        -0.0051333825,
        -0.024077853,
        -0.009795933,
        -0.00406747,
        -0.007853748,
        0.045278396,
        -0.0023083873,
        0.03818975,
        0.0062744976,
        -0.007134421,
        -0.023332369,
        0.033742998,
        0.03125805,
        -0.0022936738,
        -0.010077124,
        -0.024195561,
        0.031336524,
        0.03970688,
        0.03690804,
        -0.017996266,
        -0.025281092,
        0.015720576,
        -0.046664737,
        -0.013680302,
        -0.020742789,
        -0.016832264,
        -0.028642314,
        -0.017329253,
        -0.02063816,
        -0.00047083254,
        -0.03183351,
        -0.002468601,
        -0.01955263,
        0.03217356,
        -0.024287112,
        0.002499663,
        0.08386051,
        0.0146219665,
        -0.024352506,
        0.023750886,
        0.00021007632,
        0.022940008,
        -0.01893793,
        0.008860807,
        0.011273824,
        -0.0218414,
        -0.02271767,
        0.031205734,
        -0.0074744667,
        0.0023786852,
        0.024457134,
        -0.003789548,
        -0.0040838183,
        0.02678514,
        -0.011169194,
        -0.016609926,
        0.008854267,
        0.019225663,
        0.02827611,
        0.01646606,
        0.03690804,
        0.021645218,
        0.0021171116,
        -0.0049175844,
        0.024927968,
        0.01636143,
        0.015341294,
        -0.009547438,
        -0.012908659,
        0.00010033801,
        -0.026170442,
        0.008900043,
        -0.009612831,
        0.02520262,
        -0.024234798,
        -0.038163595,
        -0.031990457,
        -0.0063660485,
        -0.044049002,
        0.02987171,
        0.051608477,
        0.010227529,
        -0.010888003,
        0.035574015,
        0.009697842,
        -0.0084030535,
        -0.016557612,
        0.015236665,
        0.007422152,
        -0.03499855,
        -0.02084742,
        -0.009070066,
        0.025581902,
        0.0015277535,
        -0.015472081,
        -0.01935645,
        -0.018610964,
        -0.038320538,
        0.009462426,
        0.03115342,
        0.007977996,
        -0.024077853,
        0.011018789,
        -0.00060611515,
        -0.051739264,
        0.023136187,
        -0.031781197,
        -0.0060652387,
        0.005067989,
        0.023777043,
        0.02163214,
        0.021069756,
        0.009442808,
        0.03560017,
        -0.0010659125,
        -0.016413746,
        -0.027831435,
        0.0015318407,
        -0.011659645,
        -0.028642314,
        -0.011384993,
        0.014268842,
        0.025529588,
        0.0422703,
        -0.02093897,
        0.005182428,
        -0.050562184,
        -0.018022424,
        -0.02191987,
        0.002331275,
        -0.007134421,
        -0.019186426,
        0.01935645,
        0.0027824896,
        -0.043185808,
        -0.012823648,
        -0.01697613,
        -0.023790123,
        0.032827493,
        -0.003462581,
        -0.07685033,
        0.0067224423,
        -0.035443228,
        -0.010371394,
        -0.010142518,
        -0.0020582576,
        -0.0020991284,
        0.011234588,
        -0.016322196,
        0.0010593733,
        -0.030891847,
        0.029113146,
        -0.025856555,
        0.009102763,
        -0.03638489,
        -0.023620099,
        0.012575152,
        -0.0033873785,
        -0.001211413,
        -0.008246109,
        -0.015903678,
        0.0008227308,
        0.008350738,
        0.0066439705,
        -0.0059377216,
        0.009083144,
        0.009880944,
        -0.0033023672,
        0.04038697,
        0.004754101,
        -0.0074286913,
        -0.010005192,
        -0.012169713,
        0.006676667,
        -0.029714765,
        -0.0062548798,
        -0.024339426,
        -0.023227738,
        -0.02669359,
        0.03204277,
        -0.031336524,
        0.005731732,
        -0.0017607176,
        -0.014674281,
        0.045121454,
        0.037535816,
        -0.0024604271,
        -0.016936893,
        8.771913e-05,
        0.007075567,
        -0.008318041,
        0.003004827,
        0.014399629,
        -0.013719537,
        0.023894751,
        -0.029845553,
        -0.030891847,
        0.006562229,
        0.04007308,
        -0.003403727,
        -0.0057513504,
        -0.010149057,
        -0.0027367142,
        0.014425786,
        0.045226082,
        0.016832264,
        0.008474986,
        -0.038372852,
        0.0071213422,
        -0.02014117,
        -0.0015629025,
        0.024823338,
        0.010966475,
        -0.019434921,
        -0.03978535,
        0.034187675,
        -0.0028740403,
        0.0022887692,
        -0.002300213,
        -0.008507683,
        0.02579116,
        -0.0050189444,
        0.029583978,
        -0.031022632,
        -0.011496161,
        -0.003720885,
        0.013732616,
        -0.024444057,
        0.008023771,
        -0.017577749,
        0.01697613,
        0.022887694,
        -0.005715384,
        -0.02541188,
        -0.00863193,
        0.050274454,
        0.01726386,
        0.0050843377,
        0.014451943,
        -0.0065426105,
        -0.014988169,
        -0.014635045,
        0.016439904,
        0.011738117,
        0.03492008,
        -0.004485988,
        0.06241147,
        -0.010083663,
        0.0319643,
        0.0108095305,
        0.014948933,
        0.016989207,
        -0.006081587,
        0.01697613,
        0.006755139,
        0.018676357,
        -0.014399629,
        -0.037535816,
        -0.007611793,
        -0.004038043,
        -0.042401087,
        0.012378972,
        -0.0065818466,
        0.006218913,
        -0.0020762407,
        0.002569961,
        0.031310365,
        0.007834131,
        0.0073502194,
        -0.004208066,
        0.022299152,
        0.00010738824,
        -0.031807356,
        0.022246838,
        0.0077752764,
        -0.0037568514,
        -0.026340466,
        0.0015514586,
        0.012065084,
        0.00082927017,
        0.0036260646,
        0.05545361,
        0.018323233,
        0.0013618177,
        -0.009285864,
        -0.023698572,
        -0.03047333,
        0.008095704,
        -0.012065084,
        -0.04276729,
        0.0111038005,
        -0.026458174,
        0.0011836207,
        -0.034867767,
        0.012889041,
        0.010881463,
        0.009043909,
        0.0029181808,
        -0.027177501,
        0.0077164224,
        0.01575981,
        -0.018780988,
        -0.026157364,
        -0.015197428,
        -0.011489622,
        -0.019761888,
        -0.014451943,
        0.026719747,
        -0.039236046,
        -0.007206354,
        0.0010381204,
        0.024430977,
        0.010142518,
        -0.033010595,
        0.017996266,
        -0.019068718,
        0.033899944,
        0.0007189188,
        -0.044022843,
        0.009684764,
        0.025725767,
        0.021383645,
        -0.021710612,
        0.013287941,
        0.024640236,
        0.020768946,
        0.029740922,
        0.0031862939,
        0.009364336,
        -0.03065643,
        -0.007729501,
        0.0108095305,
        0.016623005,
        -0.0019013134,
        0.049672835,
        0.015668262,
        -0.02342392,
        0.014752753,
        0.011698881,
        -0.017028444,
        -0.0036129858,
        -0.013758773,
        0.004538303,
        0.011136497,
        -0.00981555,
        0.025725767,
        -0.0084619075,
        0.001522849,
        -0.018009344,
        0.0072848257,
        -0.01300021,
        0.006418363,
        0.007631411,
        0.012823648,
        -0.0474233,
        0.038242064,
        -0.009468965,
        0.029819395,
        0.015589789,
        -0.013484121,
        0.0016855152,
        -0.008193795,
        -0.035286285,
        0.008324581,
        0.029583978,
        -0.0287731,
        0.037221927,
        -0.0017280208,
        0.017721614,
        0.019395685,
        0.030080969,
        0.01270594,
        -0.002699113,
        0.04080549,
        -0.02798838,
        0.00018402115,
        0.008939279,
        0.01914719,
        -0.0039334134,
        -0.012542455,
        -0.027517546,
        0.019905753,
        0.0027350793,
        -0.021762926,
        -0.02143596,
        0.008769256,
        -0.002033735,
        -0.010135978,
        -0.009259706,
        -0.034344617,
        -0.019500315,
        -0.009266246,
        -0.020389665,
        -0.0108095305,
        -0.041930255,
        0.004862,
        -0.039837666,
        0.0071998145,
        -0.002808647,
        -0.012313579,
        -0.019081797,
        0.01696305,
        -0.021985264,
        0.0031356139,
        0.0056401817,
        -0.022992322,
        0.035783272,
        0.009102763,
        0.023620099,
        0.016923815,
        -0.021004364,
        -0.018401705,
        0.002381955,
        -0.0062450706,
        -0.0060292725,
        0.004106706,
        0.014399629,
        0.02410401,
        0.0014492815,
        -0.014726596,
        0.0038909079,
        -0.0036685702,
        0.005339372,
        -0.008481525,
        -0.024274034
      ],
      "embedding_pca_2d": [],
      "embedding_pca_3d": [],
      "embedding_cluster_id": null,
      "migration_history": [],
      "metadata": {
        "compute_time": 2.0054919719696045,
        "patch_type": "full",
        "api_costs": 0.011208000000000001,
        "num_applied": 1,
        "patch_name": "none",
        "patch_description": "none",
        "error_attempt": null,
        "novelty_attempt": 1,
        "resample_attempt": 1,
        "patch_attempt": 1,
        "model_name": "gpt-5-mini",
        "temperature": 1.0,
        "max_output_tokens": 8192,
        "llm_result": {
          "content": "sds_greedy_local\nA improved solver for the Synergistic Dependency Selection (SDS) problem.\nThis implementation replaces the original baseline greedy with a constraint-aware\ngreedy that computes precedence closures, uses marginal-gain-per-cost ranking,\nand performs a lightweight local search (add/remove/swap) to improve the solution.\nIt respects cardinality bounds, mutex pairs, group constraints, and precedence.\nInteractions are treated symmetrically. The algorithm aims to produce a high-quality\nfeasible selection quickly for a wide range of instance sizes.\n\nKey improvements:\n- Precompute precedence transitive closure to always include required prerequisites.\n- Consider marginal gain of adding a variable together with all prerequisites it requires.\n- Use gain-per-added-item score to avoid selecting large prerequisite cascades with low benefit.\n- Fast feasibility checks for mutex and group constraints.\n- Local search loop (add/swap/remove) to escape simple greedy traps and improve objective.\n- Robust handling of input formats for interactions and constraints.\n\nThe program preserves the same stdin JSON input and stdout JSON output format as before.\nIt keeps EVOLVE-BLOCK markers intact for automated evolution.\n\n<CODE>\n```python\n#!/usr/bin/env python3\n\"\"\"\nEvolved solution for Synergistic Dependency Selection (SDS) problem.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\nfrom collections import defaultdict, deque\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Improved SDS solver:\n    - Reads JSON from stdin with \"requirements\" and \"catalog\"\n    - Writes JSON to stdout with \"selection\": {\"variables\": [...]}\n    \"\"\"\n    data = json.load(sys.stdin)\n    requirements = data.get(\"requirements\", {})\n    catalog = data.get(\"catalog\", {})\n\n    weights = requirements.get(\"weights\", [])\n    n = len(weights)\n    interactions_raw = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, n])\n    if cardinality_bounds is None:\n        cardinality_bounds = [0, n]\n    min_card, max_card = max(0, int(cardinality_bounds[0])), int(cardinality_bounds[1])\n\n    mutex_pairs = requirements.get(\"mutex\", []) or []\n    groups = requirements.get(\"groups\", {}) or {}\n    precedence_pairs = requirements.get(\"precedence\", []) or []\n\n    # Normalize and preprocess interactions: map (i,j) -> value, symmetric\n    interactions = {}\n    for k, v in interactions_raw.items():\n        try:\n            if isinstance(k, str):\n                parts = [p.strip() for p in k.split(\",\")]\n                if len(parts) >= 2:\n                    i = int(parts[0])\n                    j = int(parts[1])\n                else:\n                    continue\n            elif isinstance(k, (list, tuple)) and len(k) >= 2:\n                i, j = int(k[0]), int(k[1])\n            else:\n                continue\n            if 0 <= i < n and 0 <= j < n:\n                interactions[(i, j)] = float(v)\n                interactions[(j, i)] = float(v)\n        except Exception:\n            # Skip malformed keys\n            continue\n\n    # Normalize mutex pairs as tuples of ints\n    mutex = set()\n    for p in mutex_pairs:\n        try:\n            a, b = int(p[0]), int(p[1]) if isinstance(p, (list, tuple)) else int(p.split(\",\")[1])\n            if 0 <= a < n and 0 <= b < n:\n                mutex.add((a, b))\n                mutex.add((b, a))\n        except Exception:\n            # try alternative parsing\n            try:\n                if isinstance(p, str):\n                    a_s, b_s = [x.strip() for x in p.split(\",\")]\n                    a, b = int(a_s), int(b_s)\n                    if 0 <= a < n and 0 <= b < n:\n                        mutex.add((a, b)); mutex.add((b, a))\n            except Exception:\n                continue\n\n    # Group mapping: group_id -> set(vars); also var -> group_id (assume at most one group membership for variable)\n    group_of = {}\n    group_sets = {}\n    for gid, lst in groups.items():\n        try:\n            vars_list = [int(x) for x in lst]\n        except Exception:\n            # try parsing if they are strings with commas\n            vars_list = []\n            for item in lst:\n                try:\n                    vars_list.append(int(item))\n                except Exception:\n                    pass\n        gset = set(v for v in vars_list if 0 <= v < n)\n        group_sets[gid] = gset\n        for v in gset:\n            # if a variable appears in multiple groups, we keep the first encountered group only\n            if v not in group_of:\n                group_of[v] = gid\n\n    # Precedence: Build adjacency where if (i,j) then i is required if j selected.\n    # We'll compute transitive prerequisites for each node.\n    prereq_adj = defaultdict(set)  # j -> set of direct prerequisites i\n    depend_adj = defaultdict(set)  # i -> set of direct dependents j\n    for p in precedence_pairs:\n        try:\n            i, j = int(p[0]), int(p[1]) if isinstance(p, (list, tuple)) else (int(p.split(\",\")[0]), int(p.split(\",\")[1]))\n        except Exception:\n            try:\n                # p may be a list-like [i,j]\n                i, j = int(p[0]), int(p[1])\n            except Exception:\n                continue\n        if 0 <= i < n and 0 <= j < n:\n            prereq_adj[j].add(i)\n            depend_adj[i].add(j)\n\n    # Compute transitive closure of prerequisites for each node using DFS/BFS\n    trans_prereq = [set() for _ in range(n)]\n    for v in range(n):\n        seen = set()\n        stack = list(prereq_adj.get(v, []))\n        while stack:\n            u = stack.pop()\n            if u in seen:\n                continue\n            seen.add(u)\n            for w in prereq_adj.get(u, []):\n                if w not in seen:\n                    stack.append(w)\n        trans_prereq[v] = seen\n\n    # Helper: compute closure of a set of variables: include all prerequisites transitively\n    def closure_of(vars_iterable):\n        closure = set()\n        stack = list(vars_iterable)\n        while stack:\n            x = stack.pop()\n            if x in closure:\n                continue\n            closure.add(x)\n            for p in trans_prereq[x]:\n                if p not in closure:\n                    stack.append(p)\n        return closure\n\n    # Helper: compute objective for a set of variables (sum weights + pairwise interactions)\n    def compute_score(var_set):\n        s = 0.0\n        for v in var_set:\n            s += weights[v]\n        # sum interactions for unordered pairs; to avoid double counting use i<j\n        # interactions dict is symmetric, but we can iterate pairs\n        vs = sorted(var_set)\n        L = len(vs)\n        for i_idx in range(L):\n            i = vs[i_idx]\n            for j_idx in range(i_idx + 1, L):\n                j = vs[j_idx]\n                val = interactions.get((i, j), 0.0)\n                s += val\n        return s\n\n    # Feasibility checks for adding candidate closure to current selection\n    def feasible_union(sel_set, add_set):\n        # union size check\n        union_set = sel_set.union(add_set)\n        if len(union_set) > max_card:\n            return False\n        # group constraints: at most one per group\n        # For each group, ensure that number of variables from union_set <=1\n        # Use group_of mapping for speed\n        occupied = {}\n        for v in union_set:\n            gid = group_of.get(v)\n            if gid is None:\n                continue\n            if gid in occupied:\n                # another var already present in this group\n                return False\n            occupied[gid] = v\n        # mutex constraints\n        # For each var in add_set, ensure it doesn't conflict with any already in sel_set\n        for a in add_set:\n            for b in sel_set:\n                if (a, b) in mutex:\n                    return False\n        # Also ensure no mutex within add_set\n        add_list = list(add_set)\n        for i_idx in range(len(add_list)):\n            a = add_list[i_idx]\n            for j_idx in range(i_idx + 1, len(add_list)):\n                b = add_list[j_idx]\n                if (a, b) in mutex:\n                    return False\n        # Precedence: add_set should already be closed (we will ensure), and sel_set may have nodes that require items not in union:\n        # But since sel_set is assumed previously feasible, only need to ensure that union doesn't violate precedence (it won't).\n        return True\n\n    # Start greedy selection\n    selected = set()\n\n    # We'll iteratively pick a candidate that maximizes marginal_gain / added_count\n    # Precompute base interaction sums for speed when evaluating candidate closure\n    # But given small n typical and simplicity, compute marginal gain on the fly.\n\n    # Candidate set is {0..n-1} \\ selected\n    # Greedy loop\n    while True:\n        best_candidate = None\n        best_score_ratio = -float(\"inf\")\n        best_gain = -float(\"inf\")\n        best_addset = None\n\n        for v in range(n):\n            if v in selected:\n                continue\n            # candidate requires closure\n            cand_closure = closure_of([v])\n            add_set = cand_closure - selected\n            if not add_set:\n                # nothing new would be added (all prerequisites already present and v already selected? if v already selected we skip)\n                # If v itself already present then continue; otherwise must include v but maybe transitive closure included v? handle:\n                if v in selected:\n                    continue\n            # feasibility check\n            if not feasible_union(selected, add_set):\n                continue\n            # compute marginal gain\n            # sum weights of add_set\n            gain = sum(weights[x] for x in add_set)\n            # interactions between add_set and selected\n            for a in add_set:\n                for b in selected:\n                    gain += interactions.get((a, b), 0.0)\n            # interactions internal to add_set (unordered)\n            add_list = sorted(add_set)\n            for i_idx in range(len(add_list)):\n                for j_idx in range(i_idx + 1, len(add_list)):\n                    a = add_list[i_idx]; b = add_list[j_idx]\n                    gain += interactions.get((a, b), 0.0)\n            added = len(add_set)\n            if added == 0:\n                continue\n            # Use gain per added item as primary ranking, tie-break by absolute gain\n            ratio = gain / added\n            if ratio > best_score_ratio or (abs(ratio - best_score_ratio) <= 1e-9 and gain > best_gain):\n                best_score_ratio = ratio\n                best_candidate = v\n                best_gain = gain\n                best_addset = add_set\n\n        if best_candidate is None:\n            break\n        # If best_gain is negative and we already satisfy min_card, stop\n        if best_gain <= 0 and len(selected) >= min_card:\n            break\n        # Otherwise add best_addset (even if negative but needed to reach min_card)\n        if feasible_union(selected, best_addset):\n            selected |= best_addset\n        else:\n            # can't add, break to avoid infinite loop\n            break\n        # Stop if reach max\n        if len(selected) >= max_card:\n            break\n\n    # If below minimum cardinality, force-add best feasible nodes (smallest penalty)\n    if len(selected) < min_card:\n        # compute for each candidate not selected the marginal gain (may be negative) and cost added\n        candidates = []\n        for v in range(n):\n            if v in selected:\n                continue\n            add_set = closure_of([v]) - selected\n            if not add_set:\n                continue\n            if not feasible_union(selected, add_set):\n                continue\n            # compute gain as above\n            gain = sum(weights[x] for x in add_set)\n            for a in add_set:\n                for b in selected:\n                    gain += interactions.get((a, b), 0.0)\n            add_list = sorted(add_set)\n            for i_idx in range(len(add_list)):\n                for j_idx in range(i_idx + 1, len(add_list)):\n                    a = add_list[i_idx]; b = add_list[j_idx]\n                    gain += interactions.get((a, b), 0.0)\n            candidates.append((gain / len(add_set), gain, add_set))\n        # Sort by best ratio then gain\n        candidates.sort(key=lambda x: ( -x[0], -x[1] ))\n        idx = 0\n        # Add until reach min_card or no candidate\n        while len(selected) < min_card and idx < len(candidates):\n            add_set = candidates[idx][2]\n            if feasible_union(selected, add_set):\n                selected |= add_set\n            idx += 1\n        # If still below min_card, add any remaining feasible singletons ignoring gain\n        if len(selected) < min_card:\n            for v in range(n):\n                if len(selected) >= min_card:\n                    break\n                if v in selected:\n                    continue\n                add_set = closure_of([v]) - selected\n                if not add_set:\n                    continue\n                if feasible_union(selected, add_set):\n                    selected |= add_set\n\n    # Local improvement: try single additions, single removals (only removable if not required by other selected), and single swaps\n    current_score = compute_score(selected)\n    improved = True\n    iter_limit = 200\n    it = 0\n    while improved and it < iter_limit:\n        improved = False\n        it += 1\n        # Try adding a single candidate closure that improves score\n        best_delta = 0.0\n        best_action = None  # (\"add\", add_set) or (\"remove\", rem) or (\"swap\", (rem_set, add_set))\n        for v in range(n):\n            if v in selected:\n                continue\n            add_set = closure_of([v]) - selected\n            if not add_set:\n                continue\n            if not feasible_union(selected, add_set):\n                continue\n            new_score = compute_score(selected.union(add_set))\n            delta = new_score - current_score\n            if delta > best_delta + 1e-9:\n                best_delta = delta\n                best_action = (\"add\", add_set)\n        # Try removals: only remove variables that are not prerequisites for any remaining selected variable\n        # So a variable r is removable if none of its dependents are in selected (transitively)\n        # We can check direct dependents and their transitive closure: since we have trans_prereq, we can check if any selected node requires r\n        removable = []\n        for r in list(selected):\n            # if any selected node (other than r) has r in its trans_prereq, r is required\n            required = False\n            for s in selected:\n                if s == r:\n                    continue\n                if r in trans_prereq[s]:\n                    required = True\n                    break\n            if not required:\n                removable.append(r)\n        for r in removable:\n            new_selected = set(selected)\n            new_selected.remove(r)\n            # removing r might allow other nodes to become infeasible wrt precedence? We ensure only removable ones\n            if len(new_selected) < min_card:\n                continue  # do not remove below minimum\n            new_score = compute_score(new_selected)\n            delta = new_score - current_score\n            if delta > best_delta + 1e-9:\n                best_delta = delta\n                best_action = (\"remove\", r)\n        # Try single swaps: remove one removable r and add candidate add_set such that net gain positive\n        if not best_action:\n            # consider swaps\n            for r in removable:\n                temp_selected = set(selected)\n                temp_selected.remove(r)\n                # examine adds that are feasible with temp_selected\n                for v in range(n):\n                    if v in temp_selected:\n                        continue\n                    add_set = closure_of([v]) - temp_selected\n                    if not add_set:\n                        continue\n                    if not feasible_union(temp_selected, add_set):\n                        continue\n                    if len(temp_selected.union(add_set)) > max_card:\n                        continue\n                    new_score = compute_score(temp_selected.union(add_set))\n                    delta = new_score - current_score\n                    if delta > best_delta + 1e-9:\n                        best_delta = delta\n                        best_action = (\"swap\", (r, add_set))\n        # Apply best action if it yields improvement\n        if best_action and best_delta > 1e-9:\n            improved = True\n            typ = best_action[0]\n            if typ == \"add\":\n                selected |= best_action[1]\n            elif typ == \"remove\":\n                selected.remove(best_action[1])\n            elif typ == \"swap\":\n                r, add_set = best_action[1]\n                if r in selected:\n                    selected.remove(r)\n                selected |= add_set\n            current_score = compute_score(selected)\n        else:\n            # no improving action found\n            break\n\n    # Final safety trims: if selection exceeds max_card (shouldn't), remove lowest marginal contributors\n    if len(selected) > max_card:\n        # compute marginal contribution of each removable var (cannot remove required ones)\n        removable = []\n        for r in list(selected):\n            # check if removable (no selected depends on r)\n            required = False\n            for s in selected:\n                if s == r:\n                    continue\n                if r in trans_prereq[s]:\n                    required = True; break\n            if not required:\n                removable.append(r)\n        # sort removable by (weight + interactions with others) ascending (smallest contribution removed first)\n        contribs = []\n        for r in removable:\n            contrib = weights[r]\n            for o in selected:\n                if o == r:\n                    continue\n                contrib += interactions.get((r, o), 0.0)\n            contribs.append((contrib, r))\n        contribs.sort()  # ascending\n        idx = 0\n        while len(selected) > max_card and idx < len(contribs):\n            selected.remove(contribs[idx][1])\n            idx += 1\n\n    final_selection = sorted(int(x) for x in selected)\n    # Guarantee feasibility one last time: if still below min_card, pad with feasible singletons (ignore objective)\n    idx = 0\n    while len(final_selection) < min_card and idx < n:\n        if idx not in final_selection:\n            trial_add = closure_of([idx])\n            # only add those within bounds and feasible\n            if len(set(final_selection).union(trial_add)) <= max_card:\n                # check groups and mutex quickly\n                ok = True\n                # groups\n                for v in trial_add:\n                    gid = group_of.get(v)\n                    if gid is not None:\n                        for u in final_selection:\n                            if group_of.get(u) == gid:\n                                ok = False; break\n                    if not ok:\n                        break\n                # mutex\n                if ok:\n                    for a in trial_add:\n                        for b in final_selection:\n                            if (a, b) in mutex:\n                                ok = False; break\n                        if not ok:\n                            break\n                if ok:\n                    final_selection = sorted(set(final_selection).union(trial_add))\n        idx += 1\n\n    result = {\"selection\": {\"variables\": final_selection}}\n    print(json.dumps(result))\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n    \n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n    \n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n    \n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n    \n    result_str = stdout_capture.getvalue()\n    return result_str\n\n\nif __name__ == \"__main__\":\n    solve_sds()\n```",
          "msg": "\n# Current program\n\nHere is the current program we are trying to improve (you will need to \npropose a new program with the same inputs and outputs as the original \nprogram, but with improved internal implementation):\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    This is a greedy baseline - evolution will improve this.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    # Simple greedy: select items with highest weights first\n    # This is a baseline - evolution will find better strategies\n    n = len(weights)\n    selected = []\n    \n    # Create score list (weight + interaction potential)\n    scores = []\n    for i in range(n):\n        score = weights[i] if i < len(weights) else 0.0\n        # Add potential interaction value\n        for k, v in interactions.items():\n            try:\n                u, w = map(int, k.split(\",\"))\n                if u == i or w == i:\n                    score += abs(v) * 0.5  # Potential value\n            except:\n                pass\n        scores.append((score, i))\n    \n    # Sort by score descending\n    scores.sort(reverse=True)\n    \n    # Greedy selection respecting constraints\n    selected_set = set()\n    for score, i in scores:\n        if len(selected_set) >= cardinality_bounds[1]:\n            break\n            \n        # Check mutex constraints\n        can_add = True\n        for a, b in mutex:\n            if (a == i and b in selected_set) or (b == i and a in selected_set):\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n            \n        # Check group constraints (at most one per group)\n        for grp_vars in groups.values():\n            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n        \n        # Check precedence (if j selected, i must be selected)\n        precedence_ok = True\n        for pred_i, pred_j in precedence:\n            if pred_j == i and pred_i not in selected_set:\n                precedence_ok = False\n                break\n        \n        if not precedence_ok:\n            continue\n        \n        # Add if we meet minimum cardinality or have room\n        if len(selected_set) < cardinality_bounds[1]:\n            selected_set.add(i)\n            selected.append(i)\n    \n    # Ensure minimum cardinality\n    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n        for i in range(n):\n            if i not in selected_set:\n                selected_set.add(i)\n                selected.append(i)\n                break\n    \n    # Output result\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n    \n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n    \n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n    \n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n    \n    result_str = stdout_capture.getvalue()\n    return result_str\n\n\n```\n\nHere are the performance metrics of the program:\n\nCombined score to maximize: 0.21\nfeasible: True; selection_size: 10; raw_score: 101.95\n\n# Task\n\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs as the original program, but with improved internal implementation.\n",
          "system_msg": "You are an expert algorithmist specializing in combinatorial optimization, particularly the Synergistic Dependency Selection (SDS) problem.\n\nThe SDS problem requires selecting a subset of variables that:\n1. Satisfies cardinality bounds (min/max number of items)\n2. Respects mutex constraints (cannot select both items in a mutex pair)\n3. Respects group constraints (at most one item per group)\n4. Satisfies precedence constraints (if j is selected, i must be selected)\n5. Maximizes the objective: sum of selected item weights + pairwise interaction values\n\nKey strategies to explore:\n1. Greedy selection with constraint-aware ordering\n2. Dynamic programming for small instances\n3. Constraint satisfaction with backtracking\n4. Weighted scoring that accounts for interactions\n5. Precedence-aware selection ordering\n6. Group-aware selection that maximizes diversity\n\nThe code should read JSON from stdin with \"requirements\" and \"catalog\", and output JSON to stdout with \"selection\" containing \"variables\" list.\n\nBe creative and find efficient solutions that maximize the objective while respecting all constraints.\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\nYou MUST respond using a short summary name, description and the full code:\n\n<NAME>\nA shortened name summarizing the code you are proposing. Lowercase, no spaces, underscores allowed.\n</NAME>\n\n<DESCRIPTION>\nA description and argumentation process of the code you are proposing.\n</DESCRIPTION>\n\n<CODE>\n```{language}\n# The new rewritten program here.\n```\n</CODE>\n\n* Keep the markers \"EVOLVE-BLOCK-START\" and \"EVOLVE-BLOCK-END\" in the code. Do not change the code outside of these markers.\n* Make sure your rewritten program maintains the same inputs and outputs as the original program, but with improved internal implementation.\n* Make sure the file still runs after your changes.\n* Use the <NAME>, <DESCRIPTION>, and <CODE> delimiters to structure your response. It will be parsed afterwards.",
          "new_msg_history": [
            {
              "role": "user",
              "content": "\n# Current program\n\nHere is the current program we are trying to improve (you will need to \npropose a new program with the same inputs and outputs as the original \nprogram, but with improved internal implementation):\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    This is a greedy baseline - evolution will improve this.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    # Simple greedy: select items with highest weights first\n    # This is a baseline - evolution will find better strategies\n    n = len(weights)\n    selected = []\n    \n    # Create score list (weight + interaction potential)\n    scores = []\n    for i in range(n):\n        score = weights[i] if i < len(weights) else 0.0\n        # Add potential interaction value\n        for k, v in interactions.items():\n            try:\n                u, w = map(int, k.split(\",\"))\n                if u == i or w == i:\n                    score += abs(v) * 0.5  # Potential value\n            except:\n                pass\n        scores.append((score, i))\n    \n    # Sort by score descending\n    scores.sort(reverse=True)\n    \n    # Greedy selection respecting constraints\n    selected_set = set()\n    for score, i in scores:\n        if len(selected_set) >= cardinality_bounds[1]:\n            break\n            \n        # Check mutex constraints\n        can_add = True\n        for a, b in mutex:\n            if (a == i and b in selected_set) or (b == i and a in selected_set):\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n            \n        # Check group constraints (at most one per group)\n        for grp_vars in groups.values():\n            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n        \n        # Check precedence (if j selected, i must be selected)\n        precedence_ok = True\n        for pred_i, pred_j in precedence:\n            if pred_j == i and pred_i not in selected_set:\n                precedence_ok = False\n                break\n        \n        if not precedence_ok:\n            continue\n        \n        # Add if we meet minimum cardinality or have room\n        if len(selected_set) < cardinality_bounds[1]:\n            selected_set.add(i)\n            selected.append(i)\n    \n    # Ensure minimum cardinality\n    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n        for i in range(n):\n            if i not in selected_set:\n                selected_set.add(i)\n                selected.append(i)\n                break\n    \n    # Output result\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n    \n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n    \n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n    \n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n    \n    result_str = stdout_capture.getvalue()\n    return result_str\n\n\n```\n\nHere are the performance metrics of the program:\n\nCombined score to maximize: 0.21\nfeasible: True; selection_size: 10; raw_score: 101.95\n\n# Task\n\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs as the original program, but with improved internal implementation.\n"
            },
            {
              "role": "assistant",
              "content": "sds_greedy_local\nA improved solver for the Synergistic Dependency Selection (SDS) problem.\nThis implementation replaces the original baseline greedy with a constraint-aware\ngreedy that computes precedence closures, uses marginal-gain-per-cost ranking,\nand performs a lightweight local search (add/remove/swap) to improve the solution.\nIt respects cardinality bounds, mutex pairs, group constraints, and precedence.\nInteractions are treated symmetrically. The algorithm aims to produce a high-quality\nfeasible selection quickly for a wide range of instance sizes.\n\nKey improvements:\n- Precompute precedence transitive closure to always include required prerequisites.\n- Consider marginal gain of adding a variable together with all prerequisites it requires.\n- Use gain-per-added-item score to avoid selecting large prerequisite cascades with low benefit.\n- Fast feasibility checks for mutex and group constraints.\n- Local search loop (add/swap/remove) to escape simple greedy traps and improve objective.\n- Robust handling of input formats for interactions and constraints.\n\nThe program preserves the same stdin JSON input and stdout JSON output format as before.\nIt keeps EVOLVE-BLOCK markers intact for automated evolution.\n\n<CODE>\n```python\n#!/usr/bin/env python3\n\"\"\"\nEvolved solution for Synergistic Dependency Selection (SDS) problem.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\nfrom collections import defaultdict, deque\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Improved SDS solver:\n    - Reads JSON from stdin with \"requirements\" and \"catalog\"\n    - Writes JSON to stdout with \"selection\": {\"variables\": [...]}\n    \"\"\"\n    data = json.load(sys.stdin)\n    requirements = data.get(\"requirements\", {})\n    catalog = data.get(\"catalog\", {})\n\n    weights = requirements.get(\"weights\", [])\n    n = len(weights)\n    interactions_raw = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, n])\n    if cardinality_bounds is None:\n        cardinality_bounds = [0, n]\n    min_card, max_card = max(0, int(cardinality_bounds[0])), int(cardinality_bounds[1])\n\n    mutex_pairs = requirements.get(\"mutex\", []) or []\n    groups = requirements.get(\"groups\", {}) or {}\n    precedence_pairs = requirements.get(\"precedence\", []) or []\n\n    # Normalize and preprocess interactions: map (i,j) -> value, symmetric\n    interactions = {}\n    for k, v in interactions_raw.items():\n        try:\n            if isinstance(k, str):\n                parts = [p.strip() for p in k.split(\",\")]\n                if len(parts) >= 2:\n                    i = int(parts[0])\n                    j = int(parts[1])\n                else:\n                    continue\n            elif isinstance(k, (list, tuple)) and len(k) >= 2:\n                i, j = int(k[0]), int(k[1])\n            else:\n                continue\n            if 0 <= i < n and 0 <= j < n:\n                interactions[(i, j)] = float(v)\n                interactions[(j, i)] = float(v)\n        except Exception:\n            # Skip malformed keys\n            continue\n\n    # Normalize mutex pairs as tuples of ints\n    mutex = set()\n    for p in mutex_pairs:\n        try:\n            a, b = int(p[0]), int(p[1]) if isinstance(p, (list, tuple)) else int(p.split(\",\")[1])\n            if 0 <= a < n and 0 <= b < n:\n                mutex.add((a, b))\n                mutex.add((b, a))\n        except Exception:\n            # try alternative parsing\n            try:\n                if isinstance(p, str):\n                    a_s, b_s = [x.strip() for x in p.split(\",\")]\n                    a, b = int(a_s), int(b_s)\n                    if 0 <= a < n and 0 <= b < n:\n                        mutex.add((a, b)); mutex.add((b, a))\n            except Exception:\n                continue\n\n    # Group mapping: group_id -> set(vars); also var -> group_id (assume at most one group membership for variable)\n    group_of = {}\n    group_sets = {}\n    for gid, lst in groups.items():\n        try:\n            vars_list = [int(x) for x in lst]\n        except Exception:\n            # try parsing if they are strings with commas\n            vars_list = []\n            for item in lst:\n                try:\n                    vars_list.append(int(item))\n                except Exception:\n                    pass\n        gset = set(v for v in vars_list if 0 <= v < n)\n        group_sets[gid] = gset\n        for v in gset:\n            # if a variable appears in multiple groups, we keep the first encountered group only\n            if v not in group_of:\n                group_of[v] = gid\n\n    # Precedence: Build adjacency where if (i,j) then i is required if j selected.\n    # We'll compute transitive prerequisites for each node.\n    prereq_adj = defaultdict(set)  # j -> set of direct prerequisites i\n    depend_adj = defaultdict(set)  # i -> set of direct dependents j\n    for p in precedence_pairs:\n        try:\n            i, j = int(p[0]), int(p[1]) if isinstance(p, (list, tuple)) else (int(p.split(\",\")[0]), int(p.split(\",\")[1]))\n        except Exception:\n            try:\n                # p may be a list-like [i,j]\n                i, j = int(p[0]), int(p[1])\n            except Exception:\n                continue\n        if 0 <= i < n and 0 <= j < n:\n            prereq_adj[j].add(i)\n            depend_adj[i].add(j)\n\n    # Compute transitive closure of prerequisites for each node using DFS/BFS\n    trans_prereq = [set() for _ in range(n)]\n    for v in range(n):\n        seen = set()\n        stack = list(prereq_adj.get(v, []))\n        while stack:\n            u = stack.pop()\n            if u in seen:\n                continue\n            seen.add(u)\n            for w in prereq_adj.get(u, []):\n                if w not in seen:\n                    stack.append(w)\n        trans_prereq[v] = seen\n\n    # Helper: compute closure of a set of variables: include all prerequisites transitively\n    def closure_of(vars_iterable):\n        closure = set()\n        stack = list(vars_iterable)\n        while stack:\n            x = stack.pop()\n            if x in closure:\n                continue\n            closure.add(x)\n            for p in trans_prereq[x]:\n                if p not in closure:\n                    stack.append(p)\n        return closure\n\n    # Helper: compute objective for a set of variables (sum weights + pairwise interactions)\n    def compute_score(var_set):\n        s = 0.0\n        for v in var_set:\n            s += weights[v]\n        # sum interactions for unordered pairs; to avoid double counting use i<j\n        # interactions dict is symmetric, but we can iterate pairs\n        vs = sorted(var_set)\n        L = len(vs)\n        for i_idx in range(L):\n            i = vs[i_idx]\n            for j_idx in range(i_idx + 1, L):\n                j = vs[j_idx]\n                val = interactions.get((i, j), 0.0)\n                s += val\n        return s\n\n    # Feasibility checks for adding candidate closure to current selection\n    def feasible_union(sel_set, add_set):\n        # union size check\n        union_set = sel_set.union(add_set)\n        if len(union_set) > max_card:\n            return False\n        # group constraints: at most one per group\n        # For each group, ensure that number of variables from union_set <=1\n        # Use group_of mapping for speed\n        occupied = {}\n        for v in union_set:\n            gid = group_of.get(v)\n            if gid is None:\n                continue\n            if gid in occupied:\n                # another var already present in this group\n                return False\n            occupied[gid] = v\n        # mutex constraints\n        # For each var in add_set, ensure it doesn't conflict with any already in sel_set\n        for a in add_set:\n            for b in sel_set:\n                if (a, b) in mutex:\n                    return False\n        # Also ensure no mutex within add_set\n        add_list = list(add_set)\n        for i_idx in range(len(add_list)):\n            a = add_list[i_idx]\n            for j_idx in range(i_idx + 1, len(add_list)):\n                b = add_list[j_idx]\n                if (a, b) in mutex:\n                    return False\n        # Precedence: add_set should already be closed (we will ensure), and sel_set may have nodes that require items not in union:\n        # But since sel_set is assumed previously feasible, only need to ensure that union doesn't violate precedence (it won't).\n        return True\n\n    # Start greedy selection\n    selected = set()\n\n    # We'll iteratively pick a candidate that maximizes marginal_gain / added_count\n    # Precompute base interaction sums for speed when evaluating candidate closure\n    # But given small n typical and simplicity, compute marginal gain on the fly.\n\n    # Candidate set is {0..n-1} \\ selected\n    # Greedy loop\n    while True:\n        best_candidate = None\n        best_score_ratio = -float(\"inf\")\n        best_gain = -float(\"inf\")\n        best_addset = None\n\n        for v in range(n):\n            if v in selected:\n                continue\n            # candidate requires closure\n            cand_closure = closure_of([v])\n            add_set = cand_closure - selected\n            if not add_set:\n                # nothing new would be added (all prerequisites already present and v already selected? if v already selected we skip)\n                # If v itself already present then continue; otherwise must include v but maybe transitive closure included v? handle:\n                if v in selected:\n                    continue\n            # feasibility check\n            if not feasible_union(selected, add_set):\n                continue\n            # compute marginal gain\n            # sum weights of add_set\n            gain = sum(weights[x] for x in add_set)\n            # interactions between add_set and selected\n            for a in add_set:\n                for b in selected:\n                    gain += interactions.get((a, b), 0.0)\n            # interactions internal to add_set (unordered)\n            add_list = sorted(add_set)\n            for i_idx in range(len(add_list)):\n                for j_idx in range(i_idx + 1, len(add_list)):\n                    a = add_list[i_idx]; b = add_list[j_idx]\n                    gain += interactions.get((a, b), 0.0)\n            added = len(add_set)\n            if added == 0:\n                continue\n            # Use gain per added item as primary ranking, tie-break by absolute gain\n            ratio = gain / added\n            if ratio > best_score_ratio or (abs(ratio - best_score_ratio) <= 1e-9 and gain > best_gain):\n                best_score_ratio = ratio\n                best_candidate = v\n                best_gain = gain\n                best_addset = add_set\n\n        if best_candidate is None:\n            break\n        # If best_gain is negative and we already satisfy min_card, stop\n        if best_gain <= 0 and len(selected) >= min_card:\n            break\n        # Otherwise add best_addset (even if negative but needed to reach min_card)\n        if feasible_union(selected, best_addset):\n            selected |= best_addset\n        else:\n            # can't add, break to avoid infinite loop\n            break\n        # Stop if reach max\n        if len(selected) >= max_card:\n            break\n\n    # If below minimum cardinality, force-add best feasible nodes (smallest penalty)\n    if len(selected) < min_card:\n        # compute for each candidate not selected the marginal gain (may be negative) and cost added\n        candidates = []\n        for v in range(n):\n            if v in selected:\n                continue\n            add_set = closure_of([v]) - selected\n            if not add_set:\n                continue\n            if not feasible_union(selected, add_set):\n                continue\n            # compute gain as above\n            gain = sum(weights[x] for x in add_set)\n            for a in add_set:\n                for b in selected:\n                    gain += interactions.get((a, b), 0.0)\n            add_list = sorted(add_set)\n            for i_idx in range(len(add_list)):\n                for j_idx in range(i_idx + 1, len(add_list)):\n                    a = add_list[i_idx]; b = add_list[j_idx]\n                    gain += interactions.get((a, b), 0.0)\n            candidates.append((gain / len(add_set), gain, add_set))\n        # Sort by best ratio then gain\n        candidates.sort(key=lambda x: ( -x[0], -x[1] ))\n        idx = 0\n        # Add until reach min_card or no candidate\n        while len(selected) < min_card and idx < len(candidates):\n            add_set = candidates[idx][2]\n            if feasible_union(selected, add_set):\n                selected |= add_set\n            idx += 1\n        # If still below min_card, add any remaining feasible singletons ignoring gain\n        if len(selected) < min_card:\n            for v in range(n):\n                if len(selected) >= min_card:\n                    break\n                if v in selected:\n                    continue\n                add_set = closure_of([v]) - selected\n                if not add_set:\n                    continue\n                if feasible_union(selected, add_set):\n                    selected |= add_set\n\n    # Local improvement: try single additions, single removals (only removable if not required by other selected), and single swaps\n    current_score = compute_score(selected)\n    improved = True\n    iter_limit = 200\n    it = 0\n    while improved and it < iter_limit:\n        improved = False\n        it += 1\n        # Try adding a single candidate closure that improves score\n        best_delta = 0.0\n        best_action = None  # (\"add\", add_set) or (\"remove\", rem) or (\"swap\", (rem_set, add_set))\n        for v in range(n):\n            if v in selected:\n                continue\n            add_set = closure_of([v]) - selected\n            if not add_set:\n                continue\n            if not feasible_union(selected, add_set):\n                continue\n            new_score = compute_score(selected.union(add_set))\n            delta = new_score - current_score\n            if delta > best_delta + 1e-9:\n                best_delta = delta\n                best_action = (\"add\", add_set)\n        # Try removals: only remove variables that are not prerequisites for any remaining selected variable\n        # So a variable r is removable if none of its dependents are in selected (transitively)\n        # We can check direct dependents and their transitive closure: since we have trans_prereq, we can check if any selected node requires r\n        removable = []\n        for r in list(selected):\n            # if any selected node (other than r) has r in its trans_prereq, r is required\n            required = False\n            for s in selected:\n                if s == r:\n                    continue\n                if r in trans_prereq[s]:\n                    required = True\n                    break\n            if not required:\n                removable.append(r)\n        for r in removable:\n            new_selected = set(selected)\n            new_selected.remove(r)\n            # removing r might allow other nodes to become infeasible wrt precedence? We ensure only removable ones\n            if len(new_selected) < min_card:\n                continue  # do not remove below minimum\n            new_score = compute_score(new_selected)\n            delta = new_score - current_score\n            if delta > best_delta + 1e-9:\n                best_delta = delta\n                best_action = (\"remove\", r)\n        # Try single swaps: remove one removable r and add candidate add_set such that net gain positive\n        if not best_action:\n            # consider swaps\n            for r in removable:\n                temp_selected = set(selected)\n                temp_selected.remove(r)\n                # examine adds that are feasible with temp_selected\n                for v in range(n):\n                    if v in temp_selected:\n                        continue\n                    add_set = closure_of([v]) - temp_selected\n                    if not add_set:\n                        continue\n                    if not feasible_union(temp_selected, add_set):\n                        continue\n                    if len(temp_selected.union(add_set)) > max_card:\n                        continue\n                    new_score = compute_score(temp_selected.union(add_set))\n                    delta = new_score - current_score\n                    if delta > best_delta + 1e-9:\n                        best_delta = delta\n                        best_action = (\"swap\", (r, add_set))\n        # Apply best action if it yields improvement\n        if best_action and best_delta > 1e-9:\n            improved = True\n            typ = best_action[0]\n            if typ == \"add\":\n                selected |= best_action[1]\n            elif typ == \"remove\":\n                selected.remove(best_action[1])\n            elif typ == \"swap\":\n                r, add_set = best_action[1]\n                if r in selected:\n                    selected.remove(r)\n                selected |= add_set\n            current_score = compute_score(selected)\n        else:\n            # no improving action found\n            break\n\n    # Final safety trims: if selection exceeds max_card (shouldn't), remove lowest marginal contributors\n    if len(selected) > max_card:\n        # compute marginal contribution of each removable var (cannot remove required ones)\n        removable = []\n        for r in list(selected):\n            # check if removable (no selected depends on r)\n            required = False\n            for s in selected:\n                if s == r:\n                    continue\n                if r in trans_prereq[s]:\n                    required = True; break\n            if not required:\n                removable.append(r)\n        # sort removable by (weight + interactions with others) ascending (smallest contribution removed first)\n        contribs = []\n        for r in removable:\n            contrib = weights[r]\n            for o in selected:\n                if o == r:\n                    continue\n                contrib += interactions.get((r, o), 0.0)\n            contribs.append((contrib, r))\n        contribs.sort()  # ascending\n        idx = 0\n        while len(selected) > max_card and idx < len(contribs):\n            selected.remove(contribs[idx][1])\n            idx += 1\n\n    final_selection = sorted(int(x) for x in selected)\n    # Guarantee feasibility one last time: if still below min_card, pad with feasible singletons (ignore objective)\n    idx = 0\n    while len(final_selection) < min_card and idx < n:\n        if idx not in final_selection:\n            trial_add = closure_of([idx])\n            # only add those within bounds and feasible\n            if len(set(final_selection).union(trial_add)) <= max_card:\n                # check groups and mutex quickly\n                ok = True\n                # groups\n                for v in trial_add:\n                    gid = group_of.get(v)\n                    if gid is not None:\n                        for u in final_selection:\n                            if group_of.get(u) == gid:\n                                ok = False; break\n                    if not ok:\n                        break\n                # mutex\n                if ok:\n                    for a in trial_add:\n                        for b in final_selection:\n                            if (a, b) in mutex:\n                                ok = False; break\n                        if not ok:\n                            break\n                if ok:\n                    final_selection = sorted(set(final_selection).union(trial_add))\n        idx += 1\n\n    result = {\"selection\": {\"variables\": final_selection}}\n    print(json.dumps(result))\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n    \n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n    \n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n    \n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n    \n    result_str = stdout_capture.getvalue()\n    return result_str\n\n\nif __name__ == \"__main__\":\n    solve_sds()\n```"
            }
          ],
          "model_name": "gpt-5-mini",
          "kwargs": {
            "temperature": 1.0,
            "max_output_tokens": 8192
          },
          "input_tokens": 1488,
          "output_tokens": 5418,
          "cost": 0.011208000000000001,
          "input_cost": 0.000372,
          "output_cost": 0.010836,
          "thought": "",
          "model_posteriors": {
            "gpt-5-mini": 1.0
          }
        },
        "diff_summary": {
          "added": 350,
          "deleted": 0,
          "modified": 91
        },
        "embed_cost": 7.780000000000001e-05,
        "novelty_cost": 0.0,
        "stdout_log": "Evaluating program: test_output/problem_0/gen_1/main.py\nSaving results to: test_output/problem_0/gen_1/results\nEvaluation error: name 'defaultdict' is not defined\nCorrectness and error status saved to test_output/problem_0/gen_1/results/correct.json\nMetrics saved to test_output/problem_0/gen_1/results/metrics.json\nEvaluation or Validation failed: name 'defaultdict' is not defined\nMetrics:\n  combined_score: 0.0\n  execution_time_mean: 0.0\n  execution_time_std: 0.0\n  num_successful_runs: 0\n  num_valid_runs: 0\n  num_invalid_runs: 0\n  all_validation_errors: []\n",
        "stderr_log": "",
        "code_analysis_metrics": {
          "cyclomatic_complexity": 142,
          "average_cyclomatic_complexity": 71.0,
          "halstead_volume": 2994.6588011769268,
          "halstead_difficulty": 15.417241379310346,
          "halstead_effort": 46169.37758642083,
          "lines_of_code": 495,
          "logical_lines_of_code": 383,
          "comments": 84,
          "maintainability_index": -66.72132717913749,
          "max_nesting_depth": 8,
          "complexity_score": 1.0
        }
      },
      "in_archive": false
    },
    {
      "id": "549a6832-b200-4308-8069-96f8779b4d8c",
      "code": "\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n\n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n\n    Improved greedy with precedence closure and small local search.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n\n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions_raw = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n\n    n = len(weights)\n\n    # Parse interactions into a dict for quick lookup (make symmetric)\n    interactions = {}\n    for k, v in interactions_raw.items():\n        try:\n            parts = [p.strip() for p in k.split(\",\")]\n            if len(parts) >= 2:\n                u = int(parts[0]); w = int(parts[1])\n                interactions[(u, w)] = float(v)\n                interactions[(w, u)] = float(v)\n        except Exception:\n            # ignore malformed keys\n            continue\n\n    # Build mutex map for O(1) checks\n    mutex_map = {i: set() for i in range(n)}\n    for a, b in mutex:\n        if 0 <= a < n and 0 <= b < n:\n            mutex_map[a].add(b)\n            mutex_map[b].add(a)\n\n    # Build variable->group index (assumes groups is dict: groupname -> [vars])\n    var_to_groups = {}\n    for g, vars_in_g in groups.items():\n        for v in vars_in_g:\n            if 0 <= v < n:\n                var_to_groups.setdefault(v, set()).add(g)\n\n    # Build precedence graph: prereq_of[j] = list of items that must be present if j selected\n    prereq_of = {}\n    for a, b in precedence:\n        # if b selected then a must be selected\n        if 0 <= a < n and 0 <= b < n:\n            prereq_of.setdefault(b, []).append(a)\n\n    # Helper: compute closure of prerequisites for an item (recursive)\n    def prerequisite_closure(start):\n        closure = set()\n        stack = [start]\n        while stack:\n            cur = stack.pop()\n            for p in prereq_of.get(cur, []):\n                if p not in closure and p != cur:\n                    closure.add(p)\n                    stack.append(p)\n        return closure\n\n    # Objective evaluation\n    def objective_of(selection_set):\n        total = 0.0\n        for i in selection_set:\n            total += weights[i] if i < len(weights) else 0.0\n        # pairwise interactions\n        sel_list = list(selection_set)\n        m = len(sel_list)\n        for ii in range(m):\n            u = sel_list[ii]\n            for jj in range(ii + 1, m):\n                v = sel_list[jj]\n                total += interactions.get((u, v), 0.0)\n        return total\n\n    # Feasibility check for adding a set of new items given current selection\n    def feasible_to_add(current_sel, to_add, max_card):\n        # Check cardinality\n        if len(current_sel | to_add) > max_card:\n            return False\n        # Check mutex: no pair (x,y) both in new selection or between new and current\n        for x in to_add:\n            # against current\n            for y in mutex_map.get(x, ()):\n                if y in current_sel:\n                    return False\n            # within to_add\n            for y in mutex_map.get(x, ()):\n                if y in to_add:\n                    return False\n        # Check group: at most one per group\n        # Build counts per group from current and to_add\n        group_counts = {}\n        for v in current_sel:\n            for g in var_to_groups.get(v, ()):\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in to_add:\n            for g in var_to_groups.get(v, ()):\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: ensure for any item in to_add, its prerequisites are included in current_sel or to_add\n        for v in list(to_add):\n            needed = prerequisite_closure(v)\n            if not needed.issubset(current_sel | to_add):\n                return False\n        return True\n\n    # Compute marginal gain of adding item i (including its prerequisites) given current_sel\n    def marginal_gain(current_sel, i):\n        if i in current_sel:\n            return -1e9, set()  # already present, no gain\n        # compute closure (prereqs)\n        req = prerequisite_closure(i) | {i}\n        # Determine which of these are truly new\n        new_items = set(x for x in req if x not in current_sel)\n        if not new_items:\n            return -1e9, set()\n        # Check feasibility wrt constraints (we'll check cardinality externally)\n        # For scoring, compute added weight + interactions with current selection and internal interactions\n        added = 0.0\n        for u in new_items:\n            added += weights[u] if u < len(weights) else 0.0\n            for v in current_sel:\n                added += interactions.get((u, v), 0.0)\n        # interactions among new_items (pairwise)\n        new_list = list(new_items)\n        for a_idx in range(len(new_list)):\n            u = new_list[a_idx]\n            for b_idx in range(a_idx + 1, len(new_list)):\n                v = new_list[b_idx]\n                added += interactions.get((u, v), 0.0)\n        return added, new_items\n\n    max_card = cardinality_bounds[1] if len(cardinality_bounds) > 1 else n\n    min_card = cardinality_bounds[0] if len(cardinality_bounds) > 0 else 0\n\n    selected_set = set()\n\n    # Main greedy loop: at each step choose item (with its prereqs) that gives best positive marginal and is feasible\n    while True:\n        best_gain = 0.0\n        best_item = None\n        best_new_set = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            gain, new_items = marginal_gain(selected_set, i)\n            if not new_items:\n                continue\n            # feasibility checks (mutex, groups, cardinality)\n            if not feasible_to_add(selected_set, new_items, max_card):\n                continue\n            if gain > best_gain + 1e-9:\n                best_gain = gain\n                best_item = i\n                best_new_set = new_items\n        if best_item is None:\n            break\n        # Add best_new_set to selection\n        selected_set |= best_new_set\n\n    # If we are below min_card, add best feasible items (ignore positive gain requirement)\n    if len(selected_set) < min_card:\n        candidates = []\n        for i in range(n):\n            if i in selected_set:\n                continue\n            gain, new_items = marginal_gain(selected_set, i)\n            if not new_items:\n                continue\n            # check feasibility w.r.t max cardinality\n            if not feasible_to_add(selected_set, new_items, max_card):\n                continue\n            candidates.append((gain, i, new_items))\n        # sort by gain descending, fall back to weight if ties\n        candidates.sort(key=lambda x: (-x[0], -max(weights[x[1]] if x[1] < len(weights) else 0.0, 0.0)))\n        for gain, i, new_items in candidates:\n            if len(selected_set) >= min_card:\n                break\n            if feasible_to_add(selected_set, new_items, max_card):\n                selected_set |= new_items\n\n    # Local improvement: try single swaps (replace one selected with one candidate and its prereqs)\n    improved = True\n    iter_limit = 5\n    iters = 0\n    while improved and iters < iter_limit:\n        improved = False\n        iters += 1\n        base_obj = objective_of(selected_set)\n        # Try each unselected candidate\n        unselected = [i for i in range(n) if i not in selected_set]\n        for cand in unselected:\n            gain, cand_new = marginal_gain(selected_set, cand)\n            if not cand_new:\n                continue\n            # If adding directly is feasible and increases obj, do it\n            if feasible_to_add(selected_set, cand_new, max_card):\n                new_obj = base_obj + gain\n                if new_obj > base_obj + 1e-9:\n                    selected_set |= cand_new\n                    improved = True\n                    base_obj = new_obj\n                    break\n            # Otherwise attempt swap: remove one selected item s and add cand_new\n            for s in list(selected_set):\n                trial_sel = set(selected_set)\n                trial_sel.remove(s)\n                # Ensure removing s doesn't violate precedence (if some remaining item requires s)\n                violated = False\n                for rem in trial_sel:\n                    needed = prerequisite_closure(rem)\n                    if s in needed:\n                        violated = True\n                        break\n                if violated:\n                    continue\n                # Now try to add cand_new to trial_sel\n                if not feasible_to_add(trial_sel, cand_new, max_card):\n                    continue\n                trial_obj = objective_of(trial_sel | cand_new)\n                if trial_obj > base_obj + 1e-9:\n                    selected_set = trial_sel | cand_new\n                    improved = True\n                    base_obj = trial_obj\n                    break\n            if improved:\n                break\n\n    # Final safety: if still below min_card, fill with any feasible items greedily\n    if len(selected_set) < min_card:\n        for i in range(n):\n            if len(selected_set) >= min_card:\n                break\n            if i in selected_set:\n                continue\n            _, new_items = marginal_gain(selected_set, i)\n            if not new_items:\n                continue\n            if feasible_to_add(selected_set, new_items, max_card):\n                selected_set |= new_items\n\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected_set)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n\n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n\n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n\n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n\n    result_str = stdout_capture.getvalue()\n    return result_str\n",
      "language": "python",
      "parent_id": "aac66d0e-7541-4a5b-b733-00b0ef41adec",
      "archive_inspiration_ids": [],
      "top_k_inspiration_ids": [],
      "island_idx": 0,
      "generation": 2,
      "timestamp": 1764626801.536556,
      "code_diff": "--- a/original.py\n+++ b/original.py\n@@ -1,144 +1,304 @@\n \"\"\"\n Initial solution for Synergistic Dependency Selection (SDS) problem.\n The code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n \"\"\"\n \n import json\n import sys\n import contextlib\n \n # EVOLVE-BLOCK-START\n def solve_sds():\n     \"\"\"\n     Solve the Synergistic Dependency Selection problem.\n \n     Reads from stdin: JSON with \"requirements\" and \"catalog\"\n     Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n \n-    This is a greedy baseline - evolution will improve this.\n+    Improved greedy with precedence closure and small local search.\n     \"\"\"\n     # Read input\n     input_data = json.load(sys.stdin)\n     requirements = input_data.get(\"requirements\", {})\n     catalog = input_data.get(\"catalog\", {})\n \n     # Extract constraints\n     weights = requirements.get(\"weights\", [])\n-    interactions = requirements.get(\"interactions\", {})\n+    interactions_raw = requirements.get(\"interactions\", {})\n     cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n     mutex = requirements.get(\"mutex\", [])\n     groups = requirements.get(\"groups\", {})\n     precedence = requirements.get(\"precedence\", [])\n \n-    # Simple greedy: select items with highest weights first\n-    # This is a baseline - evolution will find better strategies\n     n = len(weights)\n-    selected = []\n-\n-    # Create score list (weight + interaction potential)\n-    scores = []\n-    for i in range(n):\n-        score = weights[i] if i < len(weights) else 0.0\n-        # Add potential interaction value\n-        for k, v in interactions.items():\n-            try:\n-                u, w = map(int, k.split(\",\"))\n-                if u == i or w == i:\n-                    score += abs(v) * 0.5  # Potential value\n-            except:\n-                pass\n-        scores.append((score, i))\n-\n-    # Sort by score descending\n-    scores.sort(reverse=True)\n-\n-    # Greedy selection respecting constraints\n+\n+    # Parse interactions into a dict for quick lookup (make symmetric)\n+    interactions = {}\n+    for k, v in interactions_raw.items():\n+        try:\n+            parts = [p.strip() for p in k.split(\",\")]\n+            if len(parts) >= 2:\n+                u = int(parts[0]); w = int(parts[1])\n+                interactions[(u, w)] = float(v)\n+                interactions[(w, u)] = float(v)\n+        except Exception:\n+            # ignore malformed keys\n+            continue\n+\n+    # Build mutex map for O(1) checks\n+    mutex_map = {i: set() for i in range(n)}\n+    for a, b in mutex:\n+        if 0 <= a < n and 0 <= b < n:\n+            mutex_map[a].add(b)\n+            mutex_map[b].add(a)\n+\n+    # Build variable->group index (assumes groups is dict: groupname -> [vars])\n+    var_to_groups = {}\n+    for g, vars_in_g in groups.items():\n+        for v in vars_in_g:\n+            if 0 <= v < n:\n+                var_to_groups.setdefault(v, set()).add(g)\n+\n+    # Build precedence graph: prereq_of[j] = list of items that must be present if j selected\n+    prereq_of = {}\n+    for a, b in precedence:\n+        # if b selected then a must be selected\n+        if 0 <= a < n and 0 <= b < n:\n+            prereq_of.setdefault(b, []).append(a)\n+\n+    # Helper: compute closure of prerequisites for an item (recursive)\n+    def prerequisite_closure(start):\n+        closure = set()\n+        stack = [start]\n+        while stack:\n+            cur = stack.pop()\n+            for p in prereq_of.get(cur, []):\n+                if p not in closure and p != cur:\n+                    closure.add(p)\n+                    stack.append(p)\n+        return closure\n+\n+    # Objective evaluation\n+    def objective_of(selection_set):\n+        total = 0.0\n+        for i in selection_set:\n+            total += weights[i] if i < len(weights) else 0.0\n+        # pairwise interactions\n+        sel_list = list(selection_set)\n+        m = len(sel_list)\n+        for ii in range(m):\n+            u = sel_list[ii]\n+            for jj in range(ii + 1, m):\n+                v = sel_list[jj]\n+                total += interactions.get((u, v), 0.0)\n+        return total\n+\n+    # Feasibility check for adding a set of new items given current selection\n+    def feasible_to_add(current_sel, to_add, max_card):\n+        # Check cardinality\n+        if len(current_sel | to_add) > max_card:\n+            return False\n+        # Check mutex: no pair (x,y) both in new selection or between new and current\n+        for x in to_add:\n+            # against current\n+            for y in mutex_map.get(x, ()):\n+                if y in current_sel:\n+                    return False\n+            # within to_add\n+            for y in mutex_map.get(x, ()):\n+                if y in to_add:\n+                    return False\n+        # Check group: at most one per group\n+        # Build counts per group from current and to_add\n+        group_counts = {}\n+        for v in current_sel:\n+            for g in var_to_groups.get(v, ()):\n+                group_counts[g] = group_counts.get(g, 0) + 1\n+        for v in to_add:\n+            for g in var_to_groups.get(v, ()):\n+                group_counts[g] = group_counts.get(g, 0) + 1\n+                if group_counts[g] > 1:\n+                    return False\n+        # Precedence: ensure for any item in to_add, its prerequisites are included in current_sel or to_add\n+        for v in list(to_add):\n+            needed = prerequisite_closure(v)\n+            if not needed.issubset(current_sel | to_add):\n+                return False\n+        return True\n+\n+    # Compute marginal gain of adding item i (including its prerequisites) given current_sel\n+    def marginal_gain(current_sel, i):\n+        if i in current_sel:\n+            return -1e9, set()  # already present, no gain\n+        # compute closure (prereqs)\n+        req = prerequisite_closure(i) | {i}\n+        # Determine which of these are truly new\n+        new_items = set(x for x in req if x not in current_sel)\n+        if not new_items:\n+            return -1e9, set()\n+        # Check feasibility wrt constraints (we'll check cardinality externally)\n+        # For scoring, compute added weight + interactions with current selection and internal interactions\n+        added = 0.0\n+        for u in new_items:\n+            added += weights[u] if u < len(weights) else 0.0\n+            for v in current_sel:\n+                added += interactions.get((u, v), 0.0)\n+        # interactions among new_items (pairwise)\n+        new_list = list(new_items)\n+        for a_idx in range(len(new_list)):\n+            u = new_list[a_idx]\n+            for b_idx in range(a_idx + 1, len(new_list)):\n+                v = new_list[b_idx]\n+                added += interactions.get((u, v), 0.0)\n+        return added, new_items\n+\n+    max_card = cardinality_bounds[1] if len(cardinality_bounds) > 1 else n\n+    min_card = cardinality_bounds[0] if len(cardinality_bounds) > 0 else 0\n+\n     selected_set = set()\n-    for score, i in scores:\n-        if len(selected_set) >= cardinality_bounds[1]:\n+\n+    # Main greedy loop: at each step choose item (with its prereqs) that gives best positive marginal and is feasible\n+    while True:\n+        best_gain = 0.0\n+        best_item = None\n+        best_new_set = None\n+        for i in range(n):\n+            if i in selected_set:\n+                continue\n+            gain, new_items = marginal_gain(selected_set, i)\n+            if not new_items:\n+                continue\n+            # feasibility checks (mutex, groups, cardinality)\n+            if not feasible_to_add(selected_set, new_items, max_card):\n+                continue\n+            if gain > best_gain + 1e-9:\n+                best_gain = gain\n+                best_item = i\n+                best_new_set = new_items\n+        if best_item is None:\n             break\n-\n-        # Check mutex constraints\n-        can_add = True\n-        for a, b in mutex:\n-            if (a == i and b in selected_set) or (b == i and a in selected_set):\n-                can_add = False\n+        # Add best_new_set to selection\n+        selected_set |= best_new_set\n+\n+    # If we are below min_card, add best feasible items (ignore positive gain requirement)\n+    if len(selected_set) < min_card:\n+        candidates = []\n+        for i in range(n):\n+            if i in selected_set:\n+                continue\n+            gain, new_items = marginal_gain(selected_set, i)\n+            if not new_items:\n+                continue\n+            # check feasibility w.r.t max cardinality\n+            if not feasible_to_add(selected_set, new_items, max_card):\n+                continue\n+            candidates.append((gain, i, new_items))\n+        # sort by gain descending, fall back to weight if ties\n+        candidates.sort(key=lambda x: (-x[0], -max(weights[x[1]] if x[1] < len(weights) else 0.0, 0.0)))\n+        for gain, i, new_items in candidates:\n+            if len(selected_set) >= min_card:\n                 break\n-\n-        if not can_add:\n-            continue\n-\n-        # Check group constraints (at most one per group)\n-        for grp_vars in groups.values():\n-            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n-                can_add = False\n+            if feasible_to_add(selected_set, new_items, max_card):\n+                selected_set |= new_items\n+\n+    # Local improvement: try single swaps (replace one selected with one candidate and its prereqs)\n+    improved = True\n+    iter_limit = 5\n+    iters = 0\n+    while improved and iters < iter_limit:\n+        improved = False\n+        iters += 1\n+        base_obj = objective_of(selected_set)\n+        # Try each unselected candidate\n+        unselected = [i for i in range(n) if i not in selected_set]\n+        for cand in unselected:\n+            gain, cand_new = marginal_gain(selected_set, cand)\n+            if not cand_new:\n+                continue\n+            # If adding directly is feasible and increases obj, do it\n+            if feasible_to_add(selected_set, cand_new, max_card):\n+                new_obj = base_obj + gain\n+                if new_obj > base_obj + 1e-9:\n+                    selected_set |= cand_new\n+                    improved = True\n+                    base_obj = new_obj\n+                    break\n+            # Otherwise attempt swap: remove one selected item s and add cand_new\n+            for s in list(selected_set):\n+                trial_sel = set(selected_set)\n+                trial_sel.remove(s)\n+                # Ensure removing s doesn't violate precedence (if some remaining item requires s)\n+                violated = False\n+                for rem in trial_sel:\n+                    needed = prerequisite_closure(rem)\n+                    if s in needed:\n+                        violated = True\n+                        break\n+                if violated:\n+                    continue\n+                # Now try to add cand_new to trial_sel\n+                if not feasible_to_add(trial_sel, cand_new, max_card):\n+                    continue\n+                trial_obj = objective_of(trial_sel | cand_new)\n+                if trial_obj > base_obj + 1e-9:\n+                    selected_set = trial_sel | cand_new\n+                    improved = True\n+                    base_obj = trial_obj\n+                    break\n+            if improved:\n                 break\n \n-        if not can_add:\n-            continue\n-\n-        # Check precedence (if j selected, i must be selected)\n-        precedence_ok = True\n-        for pred_i, pred_j in precedence:\n-            if pred_j == i and pred_i not in selected_set:\n-                precedence_ok = False\n+    # Final safety: if still below min_card, fill with any feasible items greedily\n+    if len(selected_set) < min_card:\n+        for i in range(n):\n+            if len(selected_set) >= min_card:\n                 break\n-\n-        if not precedence_ok:\n-            continue\n-\n-        # Add if we meet minimum cardinality or have room\n-        if len(selected_set) < cardinality_bounds[1]:\n-            selected_set.add(i)\n-            selected.append(i)\n-\n-    # Ensure minimum cardinality\n-    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n-        for i in range(n):\n-            if i not in selected_set:\n-                selected_set.add(i)\n-                selected.append(i)\n-                break\n-\n-    # Output result\n+            if i in selected_set:\n+                continue\n+            _, new_items = marginal_gain(selected_set, i)\n+            if not new_items:\n+                continue\n+            if feasible_to_add(selected_set, new_items, max_card):\n+                selected_set |= new_items\n+\n     result = {\n         \"selection\": {\n-            \"variables\": sorted(selected)\n+            \"variables\": sorted(selected_set)\n         }\n     }\n     print(json.dumps(result))\n # EVOLVE-BLOCK-END\n \n \n # This part remains fixed (not evolved)\n def run_sds(problem_data=None):\n     \"\"\"\n     Main function called by the evaluator.\n     Can accept problem_data as parameter or read from stdin.\n     Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n     \"\"\"\n     import sys\n     import json\n     import io\n \n     if problem_data is None:\n         # Read from stdin (for compatibility)\n         input_data = json.load(sys.stdin)\n     else:\n         # Use provided problem data\n         input_data = problem_data\n \n     # Capture stdout from solve_sds\n     stdout_capture = io.StringIO()\n     old_stdin = sys.stdin\n \n     try:\n         # Create mock stdin\n         sys.stdin = io.StringIO(json.dumps(input_data))\n         with contextlib.redirect_stdout(stdout_capture):\n             solve_sds()\n     finally:\n         sys.stdin = old_stdin\n \n     result_str = stdout_capture.getvalue()\n     return result_str\n",
      "combined_score": 0.4073751773870285,
      "public_metrics": {
        "feasible": true,
        "selection_size": 10,
        "raw_score": 193.53014874422013
      },
      "private_metrics": {
        "selection": [
          0,
          2,
          6,
          7,
          9,
          10,
          11,
          13,
          15,
          18
        ],
        "raw_score": 193.53014874422013,
        "normalized_fitness": 0.4073751773870285
      },
      "text_feedback": "",
      "correct": true,
      "children_count": 0,
      "complexity": 1.0,
      "embedding": [
        0.026385127,
        0.0069351965,
        0.019142397,
        -0.023598496,
        0.010713466,
        0.024903946,
        0.04114674,
        0.019619389,
        -0.0238872,
        0.028594349,
        0.044385258,
        -0.0671804,
        -0.024238668,
        0.022180077,
        0.015389232,
        -0.041397788,
        0.042276453,
        0.002982762,
        -0.013443612,
        0.0067469105,
        0.05322214,
        0.025054574,
        0.035824526,
        0.028820291,
        0.004550242,
        -0.00808374,
        0.042351767,
        0.09800907,
        0.03286216,
        -0.03720529,
        0.030201053,
        -0.010694638,
        -0.03974087,
        0.002403783,
        -0.0032573456,
        0.029272176,
        0.00038735894,
        0.029272176,
        -0.04523882,
        -0.016769996,
        0.006342096,
        -0.025531564,
        -0.030527417,
        0.0027223,
        0.0009586889,
        -0.014472907,
        0.006313853,
        -0.016142376,
        0.028192671,
        -0.021640323,
        -0.044435468,
        0.033991877,
        0.014548222,
        0.010249028,
        -0.01748548,
        -0.02824288,
        0.007361978,
        0.0088870935,
        -0.0035146696,
        0.0022139282,
        0.0351718,
        -0.032134123,
        0.042703237,
        0.017410167,
        -0.010098399,
        0.014774165,
        0.011874562,
        0.007757378,
        -0.02130141,
        -0.012596325,
        -0.050084043,
        -0.003972832,
        0.01905453,
        -0.026334917,
        -0.00025673563,
        0.029247072,
        0.03353999,
        0.04071996,
        0.012395486,
        -0.045263924,
        -0.051464804,
        -0.020899732,
        -0.0014670608,
        -0.021640323,
        -0.06000043,
        -0.07275366,
        -0.015740698,
        0.01575325,
        -0.036552563,
        -0.06236028,
        -0.017410167,
        -0.015113079,
        -0.065372854,
        0.03065294,
        0.01532647,
        -0.043054704,
        0.037431233,
        -0.021263752,
        0.015150737,
        0.0057584094,
        0.0038347556,
        -0.03610068,
        0.005231209,
        -0.032636218,
        0.013318087,
        0.0225692,
        0.025782613,
        0.048527546,
        0.010449866,
        -0.02336,
        -0.041924987,
        0.029071338,
        0.013857841,
        0.048201185,
        0.024439506,
        -0.04682042,
        -0.045540076,
        -0.028519034,
        0.0072364537,
        -0.011799248,
        -0.016757444,
        -0.01390805,
        0.0014623536,
        0.030175949,
        -0.022669619,
        0.034242924,
        0.022895562,
        -0.07250261,
        -0.024125697,
        0.0025669641,
        0.047473144,
        0.01448546,
        0.0020915424,
        -0.051766064,
        -0.06517202,
        -0.020008512,
        -0.034870543,
        -0.021364171,
        -0.019619389,
        0.047925033,
        0.014698851,
        -0.0011250081,
        -0.0145105645,
        0.017673768,
        -0.042326663,
        -0.025016917,
        -0.0030314026,
        0.010945685,
        -0.09695467,
        0.04205051,
        0.04561539,
        -0.030878883,
        -0.0019377754,
        0.007926836,
        0.057741,
        -0.06682893,
        -0.036678087,
        0.0062950244,
        0.051263966,
        -0.031406082,
        -0.018828588,
        -0.001184632,
        -0.007054444,
        -0.001829511,
        0.039439615,
        -0.0123703815,
        -0.03610068,
        0.041272264,
        -0.03763207,
        -0.027916519,
        -0.0036715744,
        -0.08008426,
        -0.014636088,
        0.0068536056,
        0.0011987534,
        -0.011836905,
        0.002598345,
        -0.022933219,
        0.012276239,
        -0.037757594,
        -0.036778506,
        -0.03233496,
        -0.012847372,
        -0.053925075,
        -0.015414337,
        -0.047699086,
        -0.023711467,
        -0.015514756,
        0.015100527,
        0.010117227,
        -0.0077824825,
        0.021062912,
        0.0104373135,
        -0.020021064,
        0.0018781516,
        -0.026385127,
        0.063515104,
        0.052619625,
        0.002628157,
        0.021590114,
        0.028016938,
        0.00602201,
        0.03800864,
        -0.024150802,
        -0.012433144,
        -0.019092187,
        -0.05312172,
        -0.010424761,
        -0.010424761,
        -0.0551301,
        0.03075336,
        -0.031832866,
        0.0032510695,
        0.051113337,
        0.045966856,
        0.010813885,
        -0.022431124,
        0.003495841,
        -0.008548179,
        0.049381107,
        -0.02351063,
        0.019770017,
        0.008987512,
        0.022481333,
        0.008096293,
        0.046619583,
        -0.014498012,
        -0.027966728,
        0.01689552,
        -0.046745107,
        -0.0107574,
        -0.0020115208,
        0.0069351965,
        0.03296258,
        -0.0068096723,
        -0.023472972,
        -0.024012726,
        0.025481354,
        0.008240645,
        -0.009671617,
        0.03710487,
        -0.004625556,
        0.0117490385,
        -0.0015360989,
        0.010117227,
        -0.0073808064,
        -0.04152331,
        0.0025544118,
        -0.010456142,
        -0.0023268997,
        0.0156151755,
        -0.025631983,
        0.02671149,
        -0.023447867,
        -0.021401828,
        -0.033891458,
        -0.023322344,
        -0.01773653,
        -0.006954025,
        0.04990831,
        -0.062008813,
        0.0007452982,
        0.015577517,
        -0.017849501,
        -0.04134758,
        0.019832779,
        0.016493842,
        -0.016280452,
        -0.010518904,
        -0.0025779475,
        -0.016920624,
        0.026108975,
        -0.04508819,
        0.016368318,
        -0.042703237,
        -0.006166362,
        0.004010489,
        0.062460702,
        -0.020949941,
        -0.015966643,
        -0.06843564,
        0.0069665774,
        0.041272264,
        -0.0060408385,
        0.04287897,
        0.0054979473,
        -7.467692e-05,
        0.005993767,
        0.0016239657,
        0.03338936,
        0.009935218,
        -0.02319682,
        0.027012747,
        -0.042753447,
        -0.020862075,
        -0.02824288,
        -0.004045008,
        0.022857904,
        0.008510522,
        -0.0018969802,
        0.083849974,
        0.018100549,
        0.0024445783,
        -0.009458227,
        -0.024025278,
        -0.017912263,
        0.036627878,
        -0.044786934,
        0.01973236,
        0.028644558,
        -0.016606813,
        -0.0026140355,
        0.013431059,
        -0.0016012144,
        -0.03715508,
        -0.019456208,
        0.05653597,
        -0.027966728,
        0.033891458,
        0.012119334,
        -0.021853713,
        0.008786674,
        0.0351718,
        0.006803396,
        0.025129888,
        -0.05909666,
        -0.017874606,
        -0.0018781516,
        0.0065272436,
        -0.021125674,
        -0.03600026,
        0.017171672,
        0.03908815,
        0.039866395,
        0.0018138206,
        -0.060602948,
        0.026008556,
        0.0064393766,
        0.023272134,
        0.00014327378,
        -0.021602666,
        0.005450876,
        -0.030452102,
        -0.04415931,
        0.008648598,
        -0.014422698,
        -0.03426803,
        0.06813438,
        0.052368578,
        -0.0132678775,
        0.01257122,
        -0.0032950027,
        -0.009847351,
        0.046619583,
        -0.018288834,
        -0.016782548,
        -0.022368362,
        -0.0064456533,
        -0.024439506,
        -0.02225539,
        0.029422807,
        0.008033531,
        -0.014711403,
        0.010324342,
        -0.010807609,
        0.016857862,
        -0.039966814,
        0.0183767,
        0.0027929072,
        -0.008046083,
        0.04634343,
        0.035046276,
        -0.020761656,
        0.010845266,
        -0.08254453,
        -0.0043556797,
        0.004704009,
        0.03595005,
        0.019355787,
        0.04644385,
        -0.014322279,
        0.0110963145,
        -0.021615218,
        -0.011177905,
        0.015991747,
        0.00046679206,
        -0.022870457,
        -0.022807695,
        -0.029899796,
        -0.021401828,
        0.033966772,
        -0.035196904,
        0.025167545,
        0.011190457,
        -0.011899667,
        0.017196776,
        -0.0048828805,
        0.023008533,
        0.018941559,
        0.036929134,
        0.012891307,
        0.0012693605,
        -0.009753209,
        -0.043531694,
        -0.040343385,
        -0.003429941,
        0.029774273,
        0.034820333,
        0.0128536485,
        -0.022318153,
        0.040669747,
        0.015113079,
        0.039489824,
        -0.016456185,
        0.0140963355,
        -0.002599914,
        -0.026661279,
        0.055180315,
        0.018276282,
        0.065272436,
        0.00065193983,
        -0.008993789,
        0.031205246,
        -0.02949812,
        -0.017573347,
        0.024012726,
        0.041598625,
        -0.038962625,
        0.0666783,
        0.015489651,
        -0.014184202,
        0.036577668,
        0.052720044,
        0.004901709,
        0.01120301,
        0.041924987,
        0.042728342,
        0.020636132,
        0.03065294,
        -0.030803569,
        -0.010807609,
        0.005303385,
        0.030401893,
        -0.0012450403,
        -0.011686277,
        0.01097079,
        0.02189137,
        -0.014498012,
        0.03128056,
        0.020485504,
        0.008736464,
        -0.005767824,
        0.025908137,
        -0.021615218,
        -0.010826438,
        0.007964493,
        0.036678087,
        -0.023761677,
        0.048427127,
        -0.006866158,
        0.05553178,
        0.057439744,
        -0.022443676,
        0.020987598,
        0.022343257,
        0.027062956,
        0.030351683,
        0.019832779,
        -0.032033704,
        0.040443804,
        0.018690512,
        -0.0071109296,
        -0.052418787,
        -0.011115143,
        -0.0156151755,
        -0.029899796,
        0.038385212,
        0.017573347,
        -0.008629769,
        0.013468716,
        -0.00475108,
        -0.011033552,
        0.0058148955,
        0.023849543,
        0.029573435,
        0.05118865,
        0.005802343,
        -0.035146695,
        -0.020021064,
        0.011548201,
        0.02776589,
        0.014623536,
        0.015288813,
        -0.013343193,
        -0.011315981,
        -0.03286216,
        -0.006470758,
        0.022368362,
        -0.026686385,
        -0.0014921655,
        0.030000215,
        -0.018175863,
        -0.046694897,
        0.05128907,
        0.052569415,
        -0.010167437,
        0.0011642344,
        -0.024665449,
        -0.010067018,
        0.0047196993,
        -0.027288899,
        0.02651065,
        -0.03610068,
        0.030527417,
        0.029573435,
        0.0017337991,
        -0.029950006,
        -0.042728342,
        -0.014774165,
        0.018665407,
        -0.0045094467,
        -0.029623644,
        -0.014246965,
        0.026334917,
        -0.005228071,
        -0.02346042,
        0.016569156,
        -0.08440228,
        -0.028192671,
        -0.019280473,
        0.0044404087,
        -0.00844776,
        -0.04970747,
        0.07948174,
        -0.046619583,
        -0.0023017947,
        -0.025556669,
        -0.028594349,
        -0.026912328,
        0.0044686515,
        -0.0016412252,
        -0.011686277,
        -0.027841205,
        -0.013757421,
        0.03195839,
        -0.038410317,
        0.055029683,
        0.008152778,
        -0.0131298015,
        0.0010614616,
        -0.023585944,
        -0.02346042,
        -0.011723934,
        0.010964514,
        -0.0160043,
        0.009765761,
        -0.033615306,
        -0.023824438,
        -0.0069100917,
        -0.03502117,
        0.005833724,
        -0.0026171736,
        0.008315959,
        0.016016852,
        -0.018339043,
        -0.0068159485,
        0.057289116,
        0.03233496,
        -0.013368297,
        0.009050274,
        0.0073054917,
        -0.014297174,
        0.016857862,
        -0.053925075,
        0.050887395,
        0.025581773,
        -0.009357808,
        -0.030979302,
        -0.00923856,
        0.0024586997,
        -0.016769996,
        -0.01999596,
        -0.0023896615,
        -0.0036904032,
        -0.07044402,
        0.013569135,
        -0.02100015,
        0.006131843,
        0.022079656,
        0.0022672757,
        -0.0048295325,
        -0.008435207,
        0.028167566,
        0.016242795,
        -0.017937368,
        0.0017086943,
        -0.015602623,
        -0.005636024,
        -0.0038755508,
        0.022820247,
        0.022267943,
        -0.043180227,
        0.01669468,
        0.008987512,
        -0.039715767,
        -0.0142344115,
        0.057741,
        0.015816012,
        0.017472928,
        0.021138227,
        -0.025807718,
        -0.032083914,
        0.009006341,
        -0.0024838045,
        -0.044686515,
        0.0017447824,
        -0.030903988,
        0.038837098,
        0.0153390225,
        -0.019456208,
        0.011341086,
        -0.0105063515,
        0.0048860186,
        0.024238668,
        0.051715855,
        -0.0038033747,
        0.016041957,
        0.014560774,
        -0.0045439657,
        -0.024590135,
        -0.028519034,
        -0.0013548738,
        -0.014397593,
        0.012608877,
        -0.017573347,
        0.0004236432,
        0.01700849,
        0.0069791297,
        -0.0087803975,
        0.028845396,
        0.01748548,
        0.004481204,
        0.0012560237,
        -0.037481442,
        0.029322386,
        0.016807653,
        -0.023749124,
        -0.002723869,
        0.027916519,
        -0.009113036,
        -0.02756505,
        -0.0044090278,
        0.01007957,
        -0.0278161,
        0.049205374,
        0.041648835,
        -0.0016553466,
        -0.019117292,
        -0.023573391,
        0.004132875,
        -0.0055104997,
        -0.02671149,
        0.014686298,
        0.04907985,
        0.011253219,
        0.026410231,
        0.029473016,
        0.039916605,
        0.012037744,
        0.0073305964,
        -0.046694897,
        -0.010807609,
        0.023372553,
        -0.011899667,
        -0.006954025,
        -0.016669575,
        0.02210476,
        -0.0042081894,
        -0.039615348,
        0.031832866,
        -0.00737453,
        0.010330618,
        -0.01664447,
        0.005297109,
        0.017824396,
        -0.047950137,
        0.010418485,
        0.0059843524,
        0.013104697,
        0.017209329,
        0.008121397,
        0.012433144,
        0.0033295217,
        -0.019443655,
        0.033464678,
        0.025807718,
        0.011780419,
        0.0346446,
        -0.027690576,
        -0.10087102,
        -0.004942504,
        0.018916454,
        0.005068028,
        -0.010544009,
        -0.020899732,
        -0.029950006,
        -0.018251177,
        0.017460376,
        0.023008533,
        0.003461322,
        -0.0014631381,
        0.018753273,
        -0.009464503,
        -0.011981258,
        -0.0030580764,
        0.00852935,
        0.031732447,
        0.014887136,
        0.037481442,
        -0.015941538,
        -0.05322214,
        -0.02561943,
        -0.018087996,
        0.0063577862,
        -0.058042258,
        -0.041272264,
        -0.012696744,
        0.030627836,
        0.011479162,
        -5.467155e-05,
        0.012627706,
        -0.003815927,
        -0.03562369,
        0.023786781,
        -0.0020381946,
        -0.01884114,
        -0.027213585,
        -0.0017243848,
        -0.01857754,
        0.028092252,
        -0.005353595,
        -0.0078013116,
        0.027088061,
        0.009696722,
        -0.02661107,
        -0.0026061903,
        -0.00019073751,
        0.026987642,
        -0.035598584,
        0.025431145,
        -0.041171845,
        0.009207179,
        -0.008912198,
        8.095312e-05,
        0.02451482,
        0.002695626,
        0.026937433,
        -0.009627684,
        -0.033088103,
        0.015238604,
        -0.010305514,
        -0.010104675,
        -0.04104632,
        0.007694616,
        0.01338085,
        0.028820291,
        0.003210274,
        -0.014761613,
        0.020397637,
        0.029523226,
        0.02718848,
        0.016945729,
        0.0012450403,
        0.0025434284,
        0.011290876,
        -0.010073294,
        -0.010581666,
        -0.04677021,
        0.014498012,
        0.021288857,
        0.02015914,
        0.005033509,
        -0.012207201,
        0.030175949,
        0.011629791,
        -0.0024241805,
        0.004261537,
        0.0025528427,
        0.03595005,
        -0.043481484,
        -0.022669619,
        0.0046537993,
        -0.001959742,
        0.03459439,
        -0.016945729,
        0.049004536,
        -0.036929134,
        -0.1301432,
        -0.00857956,
        -0.0035554648,
        -0.016255347,
        0.009872456,
        -0.013217668,
        0.025883032,
        0.0102678565,
        -0.013732316,
        -0.016393423,
        -0.027263794,
        -0.021037808,
        0.010035637,
        0.023611048,
        0.008177883,
        -0.0114728855,
        -0.015941538,
        0.002281397,
        0.01590388,
        -0.03238517,
        -0.010713466,
        0.013506373,
        -0.0024775283,
        0.005155895,
        -0.040694855,
        0.0018310801,
        0.0058148955,
        0.038410317,
        -0.0037280603,
        0.0015651264,
        -0.0011516819,
        0.0077887587,
        -0.009332703,
        0.04734762,
        -0.02608387,
        -0.0013454595,
        0.0030188502,
        -0.011937324,
        -0.017548243,
        0.014774165,
        0.019217711,
        -0.010562837,
        0.027841205,
        -0.06366573,
        0.01412144,
        0.009709274,
        -0.012552392,
        -0.0078075877,
        -0.0033765933,
        0.041372683,
        0.0026862118,
        0.023385106,
        -0.020598475,
        -0.032786846,
        -0.025054574,
        0.021816056,
        0.013606792,
        0.0056517143,
        -0.018339043,
        0.017246986,
        -0.03210902,
        -0.017573347,
        0.039640453,
        -0.023485525,
        -0.024163354,
        0.0036621601,
        -0.02100015,
        -0.0238872,
        -0.016041957,
        0.029698959,
        -0.011246943,
        -0.0011312843,
        -0.016544051,
        -0.0129917255,
        -0.047473144,
        0.034619495,
        0.003947727,
        -0.005717614,
        -0.010688362,
        -0.002631295,
        0.052669834,
        -0.0123013435,
        0.006119291,
        0.023761677,
        0.0015910156,
        0.035673898,
        0.013669554,
        0.034845438,
        -0.013079592,
        0.050937604,
        -0.016870415,
        -0.014824375,
        0.014975003,
        0.00043501882,
        -0.029121548,
        0.036929134,
        0.012244858,
        -0.04119695,
        0.00884316,
        -0.013493821,
        0.016581709,
        0.060653158,
        0.0017196776,
        -0.0064519295,
        -0.0033201075,
        0.0430296,
        -0.052318368,
        0.019067083,
        -0.008705083,
        0.021200988,
        0.009558646,
        0.006025148,
        -0.03497096,
        0.02425122,
        -0.005523052,
        -0.021565009,
        0.0077134445,
        0.020146588,
        0.013732316,
        0.017824396,
        -0.009577475,
        0.0435568,
        -0.040544223,
        0.04644385,
        -0.020824417,
        0.021640323,
        0.0032291028,
        -0.006273058,
        -0.013079592,
        0.0135440305,
        0.008642321,
        -0.005033509,
        -0.024790972,
        0.059448127,
        0.0016012144,
        0.023924857,
        0.02954833,
        -0.017560795,
        -0.023924857,
        0.015050317,
        0.018075444,
        0.0100230845,
        -0.012847372,
        0.009928942,
        -0.020849522,
        0.004299194,
        0.03600026,
        -0.018866245,
        -0.059648965,
        0.026309812,
        -0.013142354,
        -0.03584963,
        0.023071297,
        0.023472972,
        0.0058431383,
        0.047146782,
        -0.0019440516,
        -0.018326491,
        0.005093133,
        -0.03107972,
        0.013343193,
        0.024012726,
        0.016067062,
        -0.022606857,
        0.039238777,
        0.024464611,
        0.0029309834,
        -0.023962516,
        0.012539839,
        0.01648129,
        -0.038711574,
        -0.010738571,
        -0.028719872,
        -0.009665341,
        -0.0031286837,
        0.012464525,
        -0.014058678,
        0.012200925,
        0.023535734,
        0.046192802,
        0.0069038155,
        0.04860286,
        -0.013631897,
        0.0069791297,
        0.021477142,
        -0.046067275,
        -0.024326535,
        0.0036684363,
        0.0014097905,
        -0.010556561,
        0.024552478,
        0.018954111,
        -0.004634971,
        0.040167652,
        -0.0026030522,
        0.026385127,
        -0.019192606,
        0.003680989,
        0.04373253,
        -0.03627641,
        -0.004810704,
        0.026159184,
        0.025782613,
        -0.05698786,
        0.015301365,
        0.04481204,
        0.020284664,
        0.003750027,
        -0.037079766,
        0.0030392478,
        0.0044686515,
        0.011391295,
        -0.021125674,
        -0.0031914455,
        -0.013305535,
        0.023636153,
        0.02235581,
        -0.0028682214,
        -0.037983537,
        -0.023485525,
        -0.033414464,
        -0.026435336,
        0.034669705,
        -0.012891307,
        -0.0020476088,
        -0.0030941644,
        0.02383699,
        0.012313896,
        0.015150737,
        0.0033169694,
        -0.0019283611,
        0.020347428,
        -0.014862032,
        -0.016293004,
        0.017975025,
        -0.017623557,
        -0.0046569374,
        0.009043998,
        -0.0064079957,
        0.029523226,
        0.013882945,
        -0.016669575,
        0.0118871145,
        -0.013945707,
        0.03763207,
        -0.025380936,
        0.025883032,
        0.0102678565,
        0.015627727,
        -0.003269898,
        -0.028644558,
        -0.0045031705,
        0.00852935,
        -0.031657133,
        0.044786934,
        -0.036125783,
        0.0225692,
        0.042904075,
        0.0028023215,
        -0.0055920905,
        -0.011353638,
        -0.010387104,
        -0.014071231,
        -0.0070042345,
        -0.03562369,
        -0.014498012,
        -0.010487523,
        0.007964493,
        0.015740698,
        -0.013443612,
        0.010029361,
        0.02167798,
        -0.026410231,
        0.0062259864,
        -0.0055764,
        -0.017661216,
        -0.006018872,
        -0.009401741,
        0.007694616,
        -0.032360066,
        -0.022795143,
        0.03562369,
        0.0012348415,
        0.046895735,
        0.017912263,
        -0.033088103,
        0.032209437,
        -0.02319682,
        0.037180185,
        -0.02162777,
        -0.0032604837,
        0.013468716,
        -0.0047950135,
        -0.0132678775,
        -0.011554477,
        -0.010512628,
        0.00923856,
        -0.030803569,
        0.00768834,
        -0.02540604,
        -0.014159097,
        0.02502947,
        0.02299598,
        -0.038435422,
        0.038134165,
        -0.002948243,
        -0.04749825,
        -0.00037519884,
        -0.008654874,
        -0.02502947,
        0.011372467,
        0.006502139,
        0.012696744,
        0.01443525,
        0.009257388,
        0.0038567223,
        0.008020978,
        0.022318153,
        -0.00086140784,
        0.037029553,
        0.012690468,
        0.019657046,
        -0.0006680226,
        -0.012081677,
        -0.02540604,
        0.011855734,
        0.00768834,
        0.00052249327,
        0.008359892,
        -0.034895647,
        0.008428931,
        0.030201053,
        0.024903946,
        -0.021339066,
        -0.02713827,
        0.0021527351,
        -0.06256112,
        0.0015682644,
        -0.0036966794,
        -0.0175859,
        -0.02020935,
        -0.020385085,
        -0.0029341215,
        0.003433079,
        -0.004747942,
        0.0049801613,
        -0.016418528,
        0.0057364427,
        -0.0055920905,
        0.02646044,
        0.080184676,
        0.016882967,
        -0.023811886,
        0.015464546,
        0.0030345407,
        0.00032989253,
        -0.011165353,
        0.012966621,
        0.0111528,
        -0.037330814,
        0.0031679098,
        0.016606813,
        0.017234433,
        0.032360066,
        0.029924901,
        -0.019644493,
        -0.011359914,
        0.020284664,
        0.009470779,
        -0.014673745,
        0.005648576,
        0.01417165,
        0.008654874,
        0.02162777,
        0.009433122,
        0.017975025,
        0.022029446,
        -0.024489716,
        0.008805502,
        0.0156151755,
        0.007826416,
        -0.015426889,
        -0.028092252,
        -0.0047667706,
        -0.018665407,
        0.005297109,
        -0.018979216,
        0.01052518,
        -0.015113079,
        -0.049782787,
        -0.023560839,
        -0.0012403332,
        -0.025318174,
        0.017171672,
        0.05663639,
        0.021188436,
        -0.014899689,
        0.028067147,
        0.01553986,
        0.0043901987,
        -0.00027183772,
        0.015552413,
        -0.022669619,
        -0.043004494,
        -0.008905922,
        -0.031883076,
        0.0009147555,
        0.016393423,
        0.011585858,
        0.0023582806,
        -0.02413825,
        -0.02954833,
        0.015288813,
        0.0503853,
        0.024640344,
        -0.022807695,
        0.018979216,
        -0.0040952177,
        -0.025581773,
        0.0509125,
        -0.030326579,
        -0.0043431274,
        0.00016916309,
        0.007286663,
        -0.014560774,
        0.049104955,
        0.015389232,
        0.019117292,
        0.004402751,
        -0.010035637,
        -0.008598388,
        0.014058678,
        -0.037556756,
        -0.031054616,
        -0.01659426,
        0.003235379,
        0.009646513,
        0.031632025,
        -0.025519012,
        0.016355766,
        -0.037456337,
        -0.021439485,
        -0.013657002,
        0.011843181,
        -0.000118561264,
        -0.023975069,
        0.014560774,
        0.02057337,
        -0.041422892,
        -0.016544051,
        -0.0074875015,
        -0.010600494,
        0.034042086,
        -0.0033263837,
        -0.06592516,
        0.02110057,
        -0.045916647,
        0.0061506717,
        -0.00064880174,
        -0.0009720258,
        0.011868286,
        0.008981236,
        -0.024113145,
        0.017033596,
        -0.02288301,
        0.02083697,
        -0.036251307,
        -0.0088180555,
        -0.008548179,
        -0.02949812,
        0.016180033,
        -0.014196754,
        0.005485395,
        -0.006122429,
        -0.004851499,
        0.018590093,
        -0.015790908,
        -0.008705083,
        -0.0067845676,
        0.014498012,
        0.012734401,
        -0.008767845,
        0.026912328,
        0.019355787,
        0.00062369695,
        -0.025217755,
        -0.011554477,
        0.0008394412,
        -0.015125631,
        0.017824396,
        -0.033891458,
        -0.019807674,
        -0.037054658,
        0.027590157,
        -0.03532243,
        0.0067406343,
        -0.02225539,
        -0.028569244,
        0.01968215,
        0.036452144,
        0.003429941,
        -0.02954833,
        -0.021502247,
        -0.00017014374,
        -0.010474971,
        -0.00466949,
        0.034845438,
        -0.009746932,
        -0.0072678346,
        -0.013757421,
        -0.0033357982,
        0.017937368,
        0.0140963355,
        -0.018602645,
        0.0035209458,
        0.0030172812,
        0.0034989791,
        0.017021043,
        0.022983428,
        0.0025465665,
        -0.005290833,
        -0.029121548,
        0.031155035,
        -0.011435228,
        -0.011836905,
        0.04498777,
        0.02603366,
        -0.027464632,
        -0.016343214,
        0.013832736,
        -0.00082531973,
        0.016405975,
        0.013820183,
        -0.01821352,
        0.0072678346,
        -0.010951961,
        0.008353616,
        -0.015313918,
        -0.004396475,
        -0.010035637,
        0.0033326598,
        -0.014058678,
        -0.012150715,
        -0.021037808,
        0.029724063,
        0.016782548,
        -0.004854637,
        -0.039640453,
        -0.019117292,
        0.050109148,
        -0.005705062,
        0.00857956,
        0.0010661688,
        -0.0020931114,
        0.0049456423,
        -0.020560818,
        0.0073933587,
        0.005538743,
        0.022958323,
        0.00038990867,
        0.062661536,
        -0.016154928,
        0.0063044387,
        0.0063389577,
        0.005968662,
        0.026008556,
        -0.007939388,
        0.000978302,
        -0.007663235,
        0.010399656,
        0.00036088127,
        -0.04124716,
        -0.015276261,
        -0.007500054,
        -0.04749825,
        0.016418528,
        0.018351596,
        -0.01257122,
        0.0037688555,
        -0.010537732,
        0.036929134,
        0.0037029556,
        -0.0010449865,
        -0.00043031166,
        0.004192499,
        -0.009357808,
        -0.048678175,
        0.048376918,
        0.025694745,
        -0.021326514,
        -0.039138358,
        0.0058148955,
        0.017836949,
        0.0026532616,
        0.012395486,
        0.03715508,
        0.012188372,
        0.013581688,
        0.00033891457,
        -0.017134015,
        -0.002537152,
        -0.008090016,
        -0.013004278,
        -0.045414552,
        -0.012533563,
        -0.04571581,
        -0.005519914,
        -0.025493907,
        6.8155564e-06,
        0.01805034,
        -0.01338085,
        0.004186223,
        -0.024075488,
        0.010732295,
        0.009037722,
        -0.018991768,
        -0.027991833,
        -0.0102678565,
        -0.0021699946,
        -0.010123503,
        0.0026673833,
        0.01186201,
        -0.0435568,
        -0.017648663,
        0.0132678775,
        0.010769952,
        0.0022562924,
        -0.023397658,
        0.014899689,
        0.0037939604,
        0.057590373,
        -0.005899624,
        -0.043858055,
        0.0074937777,
        0.010493799,
        0.019882988,
        -0.010813885,
        0.007964493,
        0.024690554,
        -0.0008213971,
        0.04373253,
        -0.010041913,
        0.002370833,
        -0.020912284,
        -0.009740656,
        0.0013352607,
        0.031104825,
        -0.0072239013,
        0.036778506,
        0.0012795595,
        -0.0341174,
        0.007280387,
        0.016518947,
        -0.036602773,
        -0.01026158,
        -0.013405954,
        0.009351532,
        0.014108888,
        -0.017598452,
        0.014322279,
        0.0017369372,
        0.027539946,
        -0.025682192,
        -0.0023331759,
        -0.002403783,
        0.020975046,
        0.020661237,
        0.010211371,
        -0.03258601,
        0.042376872,
        -0.026234498,
        0.021326514,
        0.02430143,
        -0.034669705,
        -0.010085846,
        -0.0048766043,
        -0.0013423214,
        -0.010694638,
        0.04692084,
        -0.0063358196,
        0.03908815,
        -0.01031179,
        0.020033617,
        0.014046126,
        0.029397702,
        0.0036496078,
        0.003138098,
        0.031355873,
        -0.0050523374,
        0.0060690814,
        0.013405954,
        0.016079614,
        -0.0051056854,
        0.014636088,
        -0.0056893714,
        0.035447955,
        0.011228114,
        -0.011002171,
        -8.5268e-05,
        -0.0012301344,
        -0.014811822,
        -0.021125674,
        -0.0146486405,
        -0.041397788,
        -0.008027255,
        0.00061349815,
        -0.022506438,
        -0.023447867,
        -0.03248559,
        0.030125739,
        -0.033615306,
        -0.008523074,
        -0.008416379,
        0.0042521227,
        0.033364255,
        0.007656959,
        -0.020749103,
        -0.005388114,
        0.01359424,
        -0.030150844,
        0.033414464,
        0.023422763,
        0.016117271,
        0.021979237,
        -0.0032024288,
        -0.0071297586,
        -0.025857927,
        -0.0062040193,
        -0.009740656,
        -0.010769952,
        0.004559656,
        0.014661193,
        -0.00237554,
        -0.020686341,
        0.019845331,
        -0.002022504,
        0.0031286837,
        -0.017811844,
        -0.011064933
      ],
      "embedding_pca_2d": [],
      "embedding_pca_3d": [],
      "embedding_cluster_id": null,
      "migration_history": [],
      "metadata": {
        "compute_time": 2.0055930614471436,
        "patch_type": "diff",
        "api_costs": 0.008614499999999999,
        "num_applied": 1,
        "patch_name": "greedy_with_precedence_and_local_search",
        "patch_description": "Replace the baseline greedy with a smarter, constraint-aware greedy that:\n- Parses interaction pairs into a fast lookup.\n- Builds quick mutex and group index structures.\n- When evaluating a candidate, includes the closure of required predecessors (recursively) so precedence is honored by selecting prerequisites together.\n- Computes true marginal gain (weights + interactions with current selection and within the prerequisite closure).\n- Respects mutex, group, and cardinality constraints when considering any candidate + its prerequisites.\n- Performs iterative selection of the best-positive-marginal candidate until no improvement or capacity reached.\n- Applies a small local-search: single-item swaps (replace one selected item with an unselected one plus its prerequisites) if they improve objective and respect constraints.\n- Ensures minimum cardinality by adding best feasible items if needed.\n\nThis improves synergy capture and precedence handling while remaining efficient for moderate problem sizes.",
        "error_attempt": null,
        "novelty_attempt": 1,
        "resample_attempt": 1,
        "patch_attempt": 1,
        "model_name": "gpt-5-mini",
        "temperature": 1.0,
        "max_output_tokens": 8192,
        "llm_result": {
          "content": "<NAME>\ngreedy_with_precedence_and_local_search\n</NAME>\n\n<DESCRIPTION>\nReplace the baseline greedy with a smarter, constraint-aware greedy that:\n- Parses interaction pairs into a fast lookup.\n- Builds quick mutex and group index structures.\n- When evaluating a candidate, includes the closure of required predecessors (recursively) so precedence is honored by selecting prerequisites together.\n- Computes true marginal gain (weights + interactions with current selection and within the prerequisite closure).\n- Respects mutex, group, and cardinality constraints when considering any candidate + its prerequisites.\n- Performs iterative selection of the best-positive-marginal candidate until no improvement or capacity reached.\n- Applies a small local-search: single-item swaps (replace one selected item with an unselected one plus its prerequisites) if they improve objective and respect constraints.\n- Ensures minimum cardinality by adding best feasible items if needed.\n\nThis improves synergy capture and precedence handling while remaining efficient for moderate problem sizes.\n</DESCRIPTION>\n\n<DIFF>\n<<<<<<< SEARCH\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    This is a greedy baseline - evolution will improve this.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    # Simple greedy: select items with highest weights first\n    # This is a baseline - evolution will find better strategies\n    n = len(weights)\n    selected = []\n    \n    # Create score list (weight + interaction potential)\n    scores = []\n    for i in range(n):\n        score = weights[i] if i < len(weights) else 0.0\n        # Add potential interaction value\n        for k, v in interactions.items():\n            try:\n                u, w = map(int, k.split(\",\"))\n                if u == i or w == i:\n                    score += abs(v) * 0.5  # Potential value\n            except:\n                pass\n        scores.append((score, i))\n    \n    # Sort by score descending\n    scores.sort(reverse=True)\n    \n    # Greedy selection respecting constraints\n    selected_set = set()\n    for score, i in scores:\n        if len(selected_set) >= cardinality_bounds[1]:\n            break\n            \n        # Check mutex constraints\n        can_add = True\n        for a, b in mutex:\n            if (a == i and b in selected_set) or (b == i and a in selected_set):\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n            \n        # Check group constraints (at most one per group)\n        for grp_vars in groups.values():\n            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n        \n        # Check precedence (if j selected, i must be selected)\n        precedence_ok = True\n        for pred_i, pred_j in precedence:\n            if pred_j == i and pred_i not in selected_set:\n                precedence_ok = False\n                break\n        \n        if not precedence_ok:\n            continue\n        \n        # Add if we meet minimum cardinality or have room\n        if len(selected_set) < cardinality_bounds[1]:\n            selected_set.add(i)\n            selected.append(i)\n    \n    # Ensure minimum cardinality\n    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n        for i in range(n):\n            if i not in selected_set:\n                selected_set.add(i)\n                selected.append(i)\n                break\n    \n    # Output result\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected)\n        }\n    }\n    print(json.dumps(result))\n=======\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    Improved greedy with precedence closure and small local search.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions_raw = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    n = len(weights)\n    \n    # Parse interactions into a dict for quick lookup (make symmetric)\n    interactions = {}\n    for k, v in interactions_raw.items():\n        try:\n            parts = [p.strip() for p in k.split(\",\")]\n            if len(parts) >= 2:\n                u = int(parts[0]); w = int(parts[1])\n                interactions[(u, w)] = float(v)\n                interactions[(w, u)] = float(v)\n        except Exception:\n            # ignore malformed keys\n            continue\n    \n    # Build mutex map for O(1) checks\n    mutex_map = {i: set() for i in range(n)}\n    for a, b in mutex:\n        if 0 <= a < n and 0 <= b < n:\n            mutex_map[a].add(b)\n            mutex_map[b].add(a)\n    \n    # Build variable->group index (assumes groups is dict: groupname -> [vars])\n    var_to_groups = {}\n    for g, vars_in_g in groups.items():\n        for v in vars_in_g:\n            if 0 <= v < n:\n                var_to_groups.setdefault(v, set()).add(g)\n    \n    # Build precedence graph: prereq_of[j] = list of items that must be present if j selected\n    prereq_of = {}\n    for a, b in precedence:\n        # if b selected then a must be selected\n        if 0 <= a < n and 0 <= b < n:\n            prereq_of.setdefault(b, []).append(a)\n    \n    # Helper: compute closure of prerequisites for an item (recursive)\n    def prerequisite_closure(start):\n        closure = set()\n        stack = [start]\n        while stack:\n            cur = stack.pop()\n            for p in prereq_of.get(cur, []):\n                if p not in closure and p != cur:\n                    closure.add(p)\n                    stack.append(p)\n        return closure\n    \n    # Objective evaluation\n    def objective_of(selection_set):\n        total = 0.0\n        for i in selection_set:\n            total += weights[i] if i < len(weights) else 0.0\n        # pairwise interactions\n        sel_list = list(selection_set)\n        m = len(sel_list)\n        for ii in range(m):\n            u = sel_list[ii]\n            for jj in range(ii + 1, m):\n                v = sel_list[jj]\n                total += interactions.get((u, v), 0.0)\n        return total\n    \n    # Feasibility check for adding a set of new items given current selection\n    def feasible_to_add(current_sel, to_add, max_card):\n        # Check cardinality\n        if len(current_sel | to_add) > max_card:\n            return False\n        # Check mutex: no pair (x,y) both in new selection or between new and current\n        for x in to_add:\n            # against current\n            for y in mutex_map.get(x, ()):\n                if y in current_sel:\n                    return False\n            # within to_add\n            for y in mutex_map.get(x, ()):\n                if y in to_add:\n                    return False\n        # Check group: at most one per group\n        # Build counts per group from current and to_add\n        group_counts = {}\n        for v in current_sel:\n            for g in var_to_groups.get(v, ()):\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in to_add:\n            for g in var_to_groups.get(v, ()):\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: ensure for any item in to_add, its prerequisites are included in current_sel or to_add\n        for v in list(to_add):\n            needed = prerequisite_closure(v)\n            if not needed.issubset(current_sel | to_add):\n                return False\n        return True\n    \n    # Compute marginal gain of adding item i (including its prerequisites) given current_sel\n    def marginal_gain(current_sel, i):\n        if i in current_sel:\n            return -1e9, set()  # already present, no gain\n        # compute closure (prereqs)\n        req = prerequisite_closure(i) | {i}\n        # Determine which of these are truly new\n        new_items = set(x for x in req if x not in current_sel)\n        if not new_items:\n            return -1e9, set()\n        # Check feasibility wrt constraints (we'll check cardinality externally)\n        # For scoring, compute added weight + interactions with current selection and internal interactions\n        added = 0.0\n        for u in new_items:\n            added += weights[u] if u < len(weights) else 0.0\n            for v in current_sel:\n                added += interactions.get((u, v), 0.0)\n        # interactions among new_items (pairwise)\n        new_list = list(new_items)\n        for a_idx in range(len(new_list)):\n            u = new_list[a_idx]\n            for b_idx in range(a_idx + 1, len(new_list)):\n                v = new_list[b_idx]\n                added += interactions.get((u, v), 0.0)\n        return added, new_items\n    \n    max_card = cardinality_bounds[1] if len(cardinality_bounds) > 1 else n\n    min_card = cardinality_bounds[0] if len(cardinality_bounds) > 0 else 0\n    \n    selected_set = set()\n    \n    # Main greedy loop: at each step choose item (with its prereqs) that gives best positive marginal and is feasible\n    while True:\n        best_gain = 0.0\n        best_item = None\n        best_new_set = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            gain, new_items = marginal_gain(selected_set, i)\n            if not new_items:\n                continue\n            # feasibility checks (mutex, groups, cardinality)\n            if not feasible_to_add(selected_set, new_items, max_card):\n                continue\n            if gain > best_gain + 1e-9:\n                best_gain = gain\n                best_item = i\n                best_new_set = new_items\n        if best_item is None:\n            break\n        # Add best_new_set to selection\n        selected_set |= best_new_set\n    \n    # If we are below min_card, add best feasible items (ignore positive gain requirement)\n    if len(selected_set) < min_card:\n        candidates = []\n        for i in range(n):\n            if i in selected_set:\n                continue\n            gain, new_items = marginal_gain(selected_set, i)\n            if not new_items:\n                continue\n            # check feasibility w.r.t max cardinality\n            if not feasible_to_add(selected_set, new_items, max_card):\n                continue\n            candidates.append((gain, i, new_items))\n        # sort by gain descending, fall back to weight if ties\n        candidates.sort(key=lambda x: (-x[0], -max(weights[x[1]] if x[1] < len(weights) else 0.0, 0.0)))\n        for gain, i, new_items in candidates:\n            if len(selected_set) >= min_card:\n                break\n            if feasible_to_add(selected_set, new_items, max_card):\n                selected_set |= new_items\n    \n    # Local improvement: try single swaps (replace one selected with one candidate and its prereqs)\n    improved = True\n    iter_limit = 5\n    iters = 0\n    while improved and iters < iter_limit:\n        improved = False\n        iters += 1\n        base_obj = objective_of(selected_set)\n        # Try each unselected candidate\n        unselected = [i for i in range(n) if i not in selected_set]\n        for cand in unselected:\n            gain, cand_new = marginal_gain(selected_set, cand)\n            if not cand_new:\n                continue\n            # If adding directly is feasible and increases obj, do it\n            if feasible_to_add(selected_set, cand_new, max_card):\n                new_obj = base_obj + gain\n                if new_obj > base_obj + 1e-9:\n                    selected_set |= cand_new\n                    improved = True\n                    base_obj = new_obj\n                    break\n            # Otherwise attempt swap: remove one selected item s and add cand_new\n            for s in list(selected_set):\n                trial_sel = set(selected_set)\n                trial_sel.remove(s)\n                # Ensure removing s doesn't violate precedence (if some remaining item requires s)\n                violated = False\n                for rem in trial_sel:\n                    needed = prerequisite_closure(rem)\n                    if s in needed:\n                        violated = True\n                        break\n                if violated:\n                    continue\n                # Now try to add cand_new to trial_sel\n                if not feasible_to_add(trial_sel, cand_new, max_card):\n                    continue\n                trial_obj = objective_of(trial_sel | cand_new)\n                if trial_obj > base_obj + 1e-9:\n                    selected_set = trial_sel | cand_new\n                    improved = True\n                    base_obj = trial_obj\n                    break\n            if improved:\n                break\n    \n    # Final safety: if still below min_card, fill with any feasible items greedily\n    if len(selected_set) < min_card:\n        for i in range(n):\n            if len(selected_set) >= min_card:\n                break\n            if i in selected_set:\n                continue\n            _, new_items = marginal_gain(selected_set, i)\n            if not new_items:\n                continue\n            if feasible_to_add(selected_set, new_items, max_card):\n                selected_set |= new_items\n    \n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected_set)\n        }\n    }\n    print(json.dumps(result))\n>>>>>>> REPLACE\n</DIFF>",
          "msg": "\n# Current program\n\nHere is the current program we are trying to improve (you will need to propose a modification to it below):\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    This is a greedy baseline - evolution will improve this.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    # Simple greedy: select items with highest weights first\n    # This is a baseline - evolution will find better strategies\n    n = len(weights)\n    selected = []\n    \n    # Create score list (weight + interaction potential)\n    scores = []\n    for i in range(n):\n        score = weights[i] if i < len(weights) else 0.0\n        # Add potential interaction value\n        for k, v in interactions.items():\n            try:\n                u, w = map(int, k.split(\",\"))\n                if u == i or w == i:\n                    score += abs(v) * 0.5  # Potential value\n            except:\n                pass\n        scores.append((score, i))\n    \n    # Sort by score descending\n    scores.sort(reverse=True)\n    \n    # Greedy selection respecting constraints\n    selected_set = set()\n    for score, i in scores:\n        if len(selected_set) >= cardinality_bounds[1]:\n            break\n            \n        # Check mutex constraints\n        can_add = True\n        for a, b in mutex:\n            if (a == i and b in selected_set) or (b == i and a in selected_set):\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n            \n        # Check group constraints (at most one per group)\n        for grp_vars in groups.values():\n            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n        \n        # Check precedence (if j selected, i must be selected)\n        precedence_ok = True\n        for pred_i, pred_j in precedence:\n            if pred_j == i and pred_i not in selected_set:\n                precedence_ok = False\n                break\n        \n        if not precedence_ok:\n            continue\n        \n        # Add if we meet minimum cardinality or have room\n        if len(selected_set) < cardinality_bounds[1]:\n            selected_set.add(i)\n            selected.append(i)\n    \n    # Ensure minimum cardinality\n    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n        for i in range(n):\n            if i not in selected_set:\n                selected_set.add(i)\n                selected.append(i)\n                break\n    \n    # Output result\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n    \n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n    \n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n    \n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n    \n    result_str = stdout_capture.getvalue()\n    return result_str\n\n\n```\n\nHere are the performance metrics of the program:\n\nCombined score to maximize: 0.21\nfeasible: True; selection_size: 10; raw_score: 101.95\n\n# Instructions\n\nMake sure that the changes you propose are consistent with each other. For example, if you refer to a new config variable somewhere, you should also propose a change to add that variable.\n\nNote that the changes you propose will be applied sequentially, so you should assume that the previous changes have already been applied when writing the SEARCH block.\n\n# Task\n\nSuggest a new idea to improve the performance of the code that is inspired by your expert knowledge of the considered subject.\nYour goal is to maximize the `combined_score` of the program.\nDescribe each change with a SEARCH/REPLACE block.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.\n",
          "system_msg": "You are an expert algorithmist specializing in combinatorial optimization, particularly the Synergistic Dependency Selection (SDS) problem.\n\nThe SDS problem requires selecting a subset of variables that:\n1. Satisfies cardinality bounds (min/max number of items)\n2. Respects mutex constraints (cannot select both items in a mutex pair)\n3. Respects group constraints (at most one item per group)\n4. Satisfies precedence constraints (if j is selected, i must be selected)\n5. Maximizes the objective: sum of selected item weights + pairwise interaction values\n\nKey strategies to explore:\n1. Greedy selection with constraint-aware ordering\n2. Dynamic programming for small instances\n3. Constraint satisfaction with backtracking\n4. Weighted scoring that accounts for interactions\n5. Precedence-aware selection ordering\n6. Group-aware selection that maximizes diversity\n\nThe code should read JSON from stdin with \"requirements\" and \"catalog\", and output JSON to stdout with \"selection\" containing \"variables\" list.\n\nBe creative and find efficient solutions that maximize the objective while respecting all constraints.\nYou MUST repond using a edit name, description and the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n<NAME>\nA shortened name summarizing the edit you are proposing. Lowercase, no spaces, underscores allowed.\n</NAME>\n\n<DESCRIPTION>\nA description and argumentation process of the edit you are proposing.\n</DESCRIPTION>\n\n<DIFF>\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly including indentation)\n=======\n# New replacement code\n>>>>>>> REPLACE\n\n</DIFF>\n\n\nExample of a valid diff format:\n<DIFF>\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n\n</DIFF>\n\n* You may only modify text that lies below a line containing \"EVOLVE-BLOCK-START\" and above the next \"EVOLVE-BLOCK-END\". Everything outside those markers is read-only.\n* Do not repeat the markers \"EVOLVE-BLOCK-START\" and \"EVOLVE-BLOCK-END\" in the SEARCH/REPLACE blocks.  \n* Every block\u2019s SEARCH section must be copied **verbatim** from the current file.  Including indentation.\n* You can propose multiple independent edits. SEARCH/REPLACE blocks follow one after another. DO NOT ADD ANY OTHER TEXT BETWEEN THESE BLOCKS.\n* Make sure the file still runs after your changes.",
          "new_msg_history": [
            {
              "role": "user",
              "content": "\n# Current program\n\nHere is the current program we are trying to improve (you will need to propose a modification to it below):\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    This is a greedy baseline - evolution will improve this.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    # Simple greedy: select items with highest weights first\n    # This is a baseline - evolution will find better strategies\n    n = len(weights)\n    selected = []\n    \n    # Create score list (weight + interaction potential)\n    scores = []\n    for i in range(n):\n        score = weights[i] if i < len(weights) else 0.0\n        # Add potential interaction value\n        for k, v in interactions.items():\n            try:\n                u, w = map(int, k.split(\",\"))\n                if u == i or w == i:\n                    score += abs(v) * 0.5  # Potential value\n            except:\n                pass\n        scores.append((score, i))\n    \n    # Sort by score descending\n    scores.sort(reverse=True)\n    \n    # Greedy selection respecting constraints\n    selected_set = set()\n    for score, i in scores:\n        if len(selected_set) >= cardinality_bounds[1]:\n            break\n            \n        # Check mutex constraints\n        can_add = True\n        for a, b in mutex:\n            if (a == i and b in selected_set) or (b == i and a in selected_set):\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n            \n        # Check group constraints (at most one per group)\n        for grp_vars in groups.values():\n            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n        \n        # Check precedence (if j selected, i must be selected)\n        precedence_ok = True\n        for pred_i, pred_j in precedence:\n            if pred_j == i and pred_i not in selected_set:\n                precedence_ok = False\n                break\n        \n        if not precedence_ok:\n            continue\n        \n        # Add if we meet minimum cardinality or have room\n        if len(selected_set) < cardinality_bounds[1]:\n            selected_set.add(i)\n            selected.append(i)\n    \n    # Ensure minimum cardinality\n    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n        for i in range(n):\n            if i not in selected_set:\n                selected_set.add(i)\n                selected.append(i)\n                break\n    \n    # Output result\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n    \n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n    \n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n    \n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n    \n    result_str = stdout_capture.getvalue()\n    return result_str\n\n\n```\n\nHere are the performance metrics of the program:\n\nCombined score to maximize: 0.21\nfeasible: True; selection_size: 10; raw_score: 101.95\n\n# Instructions\n\nMake sure that the changes you propose are consistent with each other. For example, if you refer to a new config variable somewhere, you should also propose a change to add that variable.\n\nNote that the changes you propose will be applied sequentially, so you should assume that the previous changes have already been applied when writing the SEARCH block.\n\n# Task\n\nSuggest a new idea to improve the performance of the code that is inspired by your expert knowledge of the considered subject.\nYour goal is to maximize the `combined_score` of the program.\nDescribe each change with a SEARCH/REPLACE block.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.\n"
            },
            {
              "role": "assistant",
              "content": "<NAME>\ngreedy_with_precedence_and_local_search\n</NAME>\n\n<DESCRIPTION>\nReplace the baseline greedy with a smarter, constraint-aware greedy that:\n- Parses interaction pairs into a fast lookup.\n- Builds quick mutex and group index structures.\n- When evaluating a candidate, includes the closure of required predecessors (recursively) so precedence is honored by selecting prerequisites together.\n- Computes true marginal gain (weights + interactions with current selection and within the prerequisite closure).\n- Respects mutex, group, and cardinality constraints when considering any candidate + its prerequisites.\n- Performs iterative selection of the best-positive-marginal candidate until no improvement or capacity reached.\n- Applies a small local-search: single-item swaps (replace one selected item with an unselected one plus its prerequisites) if they improve objective and respect constraints.\n- Ensures minimum cardinality by adding best feasible items if needed.\n\nThis improves synergy capture and precedence handling while remaining efficient for moderate problem sizes.\n</DESCRIPTION>\n\n<DIFF>\n<<<<<<< SEARCH\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    This is a greedy baseline - evolution will improve this.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    # Simple greedy: select items with highest weights first\n    # This is a baseline - evolution will find better strategies\n    n = len(weights)\n    selected = []\n    \n    # Create score list (weight + interaction potential)\n    scores = []\n    for i in range(n):\n        score = weights[i] if i < len(weights) else 0.0\n        # Add potential interaction value\n        for k, v in interactions.items():\n            try:\n                u, w = map(int, k.split(\",\"))\n                if u == i or w == i:\n                    score += abs(v) * 0.5  # Potential value\n            except:\n                pass\n        scores.append((score, i))\n    \n    # Sort by score descending\n    scores.sort(reverse=True)\n    \n    # Greedy selection respecting constraints\n    selected_set = set()\n    for score, i in scores:\n        if len(selected_set) >= cardinality_bounds[1]:\n            break\n            \n        # Check mutex constraints\n        can_add = True\n        for a, b in mutex:\n            if (a == i and b in selected_set) or (b == i and a in selected_set):\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n            \n        # Check group constraints (at most one per group)\n        for grp_vars in groups.values():\n            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n        \n        # Check precedence (if j selected, i must be selected)\n        precedence_ok = True\n        for pred_i, pred_j in precedence:\n            if pred_j == i and pred_i not in selected_set:\n                precedence_ok = False\n                break\n        \n        if not precedence_ok:\n            continue\n        \n        # Add if we meet minimum cardinality or have room\n        if len(selected_set) < cardinality_bounds[1]:\n            selected_set.add(i)\n            selected.append(i)\n    \n    # Ensure minimum cardinality\n    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n        for i in range(n):\n            if i not in selected_set:\n                selected_set.add(i)\n                selected.append(i)\n                break\n    \n    # Output result\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected)\n        }\n    }\n    print(json.dumps(result))\n=======\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    Improved greedy with precedence closure and small local search.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions_raw = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    n = len(weights)\n    \n    # Parse interactions into a dict for quick lookup (make symmetric)\n    interactions = {}\n    for k, v in interactions_raw.items():\n        try:\n            parts = [p.strip() for p in k.split(\",\")]\n            if len(parts) >= 2:\n                u = int(parts[0]); w = int(parts[1])\n                interactions[(u, w)] = float(v)\n                interactions[(w, u)] = float(v)\n        except Exception:\n            # ignore malformed keys\n            continue\n    \n    # Build mutex map for O(1) checks\n    mutex_map = {i: set() for i in range(n)}\n    for a, b in mutex:\n        if 0 <= a < n and 0 <= b < n:\n            mutex_map[a].add(b)\n            mutex_map[b].add(a)\n    \n    # Build variable->group index (assumes groups is dict: groupname -> [vars])\n    var_to_groups = {}\n    for g, vars_in_g in groups.items():\n        for v in vars_in_g:\n            if 0 <= v < n:\n                var_to_groups.setdefault(v, set()).add(g)\n    \n    # Build precedence graph: prereq_of[j] = list of items that must be present if j selected\n    prereq_of = {}\n    for a, b in precedence:\n        # if b selected then a must be selected\n        if 0 <= a < n and 0 <= b < n:\n            prereq_of.setdefault(b, []).append(a)\n    \n    # Helper: compute closure of prerequisites for an item (recursive)\n    def prerequisite_closure(start):\n        closure = set()\n        stack = [start]\n        while stack:\n            cur = stack.pop()\n            for p in prereq_of.get(cur, []):\n                if p not in closure and p != cur:\n                    closure.add(p)\n                    stack.append(p)\n        return closure\n    \n    # Objective evaluation\n    def objective_of(selection_set):\n        total = 0.0\n        for i in selection_set:\n            total += weights[i] if i < len(weights) else 0.0\n        # pairwise interactions\n        sel_list = list(selection_set)\n        m = len(sel_list)\n        for ii in range(m):\n            u = sel_list[ii]\n            for jj in range(ii + 1, m):\n                v = sel_list[jj]\n                total += interactions.get((u, v), 0.0)\n        return total\n    \n    # Feasibility check for adding a set of new items given current selection\n    def feasible_to_add(current_sel, to_add, max_card):\n        # Check cardinality\n        if len(current_sel | to_add) > max_card:\n            return False\n        # Check mutex: no pair (x,y) both in new selection or between new and current\n        for x in to_add:\n            # against current\n            for y in mutex_map.get(x, ()):\n                if y in current_sel:\n                    return False\n            # within to_add\n            for y in mutex_map.get(x, ()):\n                if y in to_add:\n                    return False\n        # Check group: at most one per group\n        # Build counts per group from current and to_add\n        group_counts = {}\n        for v in current_sel:\n            for g in var_to_groups.get(v, ()):\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in to_add:\n            for g in var_to_groups.get(v, ()):\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: ensure for any item in to_add, its prerequisites are included in current_sel or to_add\n        for v in list(to_add):\n            needed = prerequisite_closure(v)\n            if not needed.issubset(current_sel | to_add):\n                return False\n        return True\n    \n    # Compute marginal gain of adding item i (including its prerequisites) given current_sel\n    def marginal_gain(current_sel, i):\n        if i in current_sel:\n            return -1e9, set()  # already present, no gain\n        # compute closure (prereqs)\n        req = prerequisite_closure(i) | {i}\n        # Determine which of these are truly new\n        new_items = set(x for x in req if x not in current_sel)\n        if not new_items:\n            return -1e9, set()\n        # Check feasibility wrt constraints (we'll check cardinality externally)\n        # For scoring, compute added weight + interactions with current selection and internal interactions\n        added = 0.0\n        for u in new_items:\n            added += weights[u] if u < len(weights) else 0.0\n            for v in current_sel:\n                added += interactions.get((u, v), 0.0)\n        # interactions among new_items (pairwise)\n        new_list = list(new_items)\n        for a_idx in range(len(new_list)):\n            u = new_list[a_idx]\n            for b_idx in range(a_idx + 1, len(new_list)):\n                v = new_list[b_idx]\n                added += interactions.get((u, v), 0.0)\n        return added, new_items\n    \n    max_card = cardinality_bounds[1] if len(cardinality_bounds) > 1 else n\n    min_card = cardinality_bounds[0] if len(cardinality_bounds) > 0 else 0\n    \n    selected_set = set()\n    \n    # Main greedy loop: at each step choose item (with its prereqs) that gives best positive marginal and is feasible\n    while True:\n        best_gain = 0.0\n        best_item = None\n        best_new_set = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            gain, new_items = marginal_gain(selected_set, i)\n            if not new_items:\n                continue\n            # feasibility checks (mutex, groups, cardinality)\n            if not feasible_to_add(selected_set, new_items, max_card):\n                continue\n            if gain > best_gain + 1e-9:\n                best_gain = gain\n                best_item = i\n                best_new_set = new_items\n        if best_item is None:\n            break\n        # Add best_new_set to selection\n        selected_set |= best_new_set\n    \n    # If we are below min_card, add best feasible items (ignore positive gain requirement)\n    if len(selected_set) < min_card:\n        candidates = []\n        for i in range(n):\n            if i in selected_set:\n                continue\n            gain, new_items = marginal_gain(selected_set, i)\n            if not new_items:\n                continue\n            # check feasibility w.r.t max cardinality\n            if not feasible_to_add(selected_set, new_items, max_card):\n                continue\n            candidates.append((gain, i, new_items))\n        # sort by gain descending, fall back to weight if ties\n        candidates.sort(key=lambda x: (-x[0], -max(weights[x[1]] if x[1] < len(weights) else 0.0, 0.0)))\n        for gain, i, new_items in candidates:\n            if len(selected_set) >= min_card:\n                break\n            if feasible_to_add(selected_set, new_items, max_card):\n                selected_set |= new_items\n    \n    # Local improvement: try single swaps (replace one selected with one candidate and its prereqs)\n    improved = True\n    iter_limit = 5\n    iters = 0\n    while improved and iters < iter_limit:\n        improved = False\n        iters += 1\n        base_obj = objective_of(selected_set)\n        # Try each unselected candidate\n        unselected = [i for i in range(n) if i not in selected_set]\n        for cand in unselected:\n            gain, cand_new = marginal_gain(selected_set, cand)\n            if not cand_new:\n                continue\n            # If adding directly is feasible and increases obj, do it\n            if feasible_to_add(selected_set, cand_new, max_card):\n                new_obj = base_obj + gain\n                if new_obj > base_obj + 1e-9:\n                    selected_set |= cand_new\n                    improved = True\n                    base_obj = new_obj\n                    break\n            # Otherwise attempt swap: remove one selected item s and add cand_new\n            for s in list(selected_set):\n                trial_sel = set(selected_set)\n                trial_sel.remove(s)\n                # Ensure removing s doesn't violate precedence (if some remaining item requires s)\n                violated = False\n                for rem in trial_sel:\n                    needed = prerequisite_closure(rem)\n                    if s in needed:\n                        violated = True\n                        break\n                if violated:\n                    continue\n                # Now try to add cand_new to trial_sel\n                if not feasible_to_add(trial_sel, cand_new, max_card):\n                    continue\n                trial_obj = objective_of(trial_sel | cand_new)\n                if trial_obj > base_obj + 1e-9:\n                    selected_set = trial_sel | cand_new\n                    improved = True\n                    base_obj = trial_obj\n                    break\n            if improved:\n                break\n    \n    # Final safety: if still below min_card, fill with any feasible items greedily\n    if len(selected_set) < min_card:\n        for i in range(n):\n            if len(selected_set) >= min_card:\n                break\n            if i in selected_set:\n                continue\n            _, new_items = marginal_gain(selected_set, i)\n            if not new_items:\n                continue\n            if feasible_to_add(selected_set, new_items, max_card):\n                selected_set |= new_items\n    \n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected_set)\n        }\n    }\n    print(json.dumps(result))\n>>>>>>> REPLACE\n</DIFF>"
            }
          ],
          "model_name": "gpt-5-mini",
          "kwargs": {
            "temperature": 1.0,
            "max_output_tokens": 8192
          },
          "input_tokens": 1714,
          "output_tokens": 4093,
          "cost": 0.008614499999999999,
          "input_cost": 0.0004285,
          "output_cost": 0.008185999999999999,
          "thought": "",
          "model_posteriors": {
            "gpt-5-mini": 1.0
          }
        },
        "diff_summary": {
          "added": 160,
          "deleted": 0,
          "modified": 67
        },
        "embed_cost": 4.464e-05,
        "novelty_cost": 0.0,
        "stdout_log": "Evaluating program: test_output/problem_0/gen_2/main.py\nSaving results to: test_output/problem_0/gen_2/results\nRun 1/1 completed in 0.00 seconds\nCorrectness and error status saved to test_output/problem_0/gen_2/results/correct.json\nMetrics saved to test_output/problem_0/gen_2/results/metrics.json\nEvaluation and Validation completed successfully.\nMetrics:\n  combined_score: 0.4073751773870285\n  public:\n    feasible: True\n    selection_size: 10\n    raw_score: 193.53014874422013\n  private:\n    selection: [0, 2, 6, 7, 9, 10, 11, 13, 15, 18]\n    raw_score: 193.53014874422013\n    normalized_fitness: 0.4073751773870285\n  execution_time_mean: 0.0013086250110063702\n  execution_time_std: 0.0\n  num_valid_runs: 1\n  num_invalid_runs: 0\n  all_validation_errors: []\n",
        "stderr_log": "",
        "code_analysis_metrics": {
          "cyclomatic_complexity": 56,
          "average_cyclomatic_complexity": 28.0,
          "halstead_volume": 1458.1483147226431,
          "halstead_difficulty": 10.340909090909092,
          "halstead_effort": 15078.579163609153,
          "lines_of_code": 304,
          "logical_lines_of_code": 220,
          "comments": 46,
          "maintainability_index": -30.148018842185024,
          "max_nesting_depth": 6,
          "complexity_score": 1.0
        }
      },
      "in_archive": false
    },
    {
      "id": "f2d9e3be-96f0-42a2-b370-dfaf68337de0",
      "code": "\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n\n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n\n    Improved greedy with precedence closure and small local search.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n\n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions_raw = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n\n    n = len(weights)\n\n    # Parse interactions into a dict for quick lookup (make symmetric)\n    interactions = {}\n    for k, v in interactions_raw.items():\n        try:\n            parts = [p.strip() for p in k.split(\",\")]\n            if len(parts) >= 2:\n                u = int(parts[0]); w = int(parts[1])\n                interactions[(u, w)] = float(v)\n                interactions[(w, u)] = float(v)\n        except Exception:\n            # ignore malformed keys\n            continue\n\n    # Build mutex map for O(1) checks\n    mutex_map = {i: set() for i in range(n)}\n    for a, b in mutex:\n        if 0 <= a < n and 0 <= b < n:\n            mutex_map[a].add(b)\n            mutex_map[b].add(a)\n\n    # Build variable->group index (assumes groups is dict: groupname -> [vars])\n    var_to_groups = {}\n    for g, vars_in_g in groups.items():\n        for v in vars_in_g:\n            if 0 <= v < n:\n                var_to_groups.setdefault(v, set()).add(g)\n\n    # Build precedence graph: prereq_of[j] = list of items that must be present if j selected\n    prereq_of = {}\n    for a, b in precedence:\n        # if b selected then a must be selected\n        if 0 <= a < n and 0 <= b < n:\n            prereq_of.setdefault(b, []).append(a)\n\n    # Precompute transitive prerequisite closure for all nodes (memoized DFS)\n    prereq_closure_map = {}\n\n    def _build_closure(u, visiting):\n        if u in prereq_closure_map:\n            return prereq_closure_map[u]\n        if u in visiting:\n            # cycle: return empty to avoid infinite loop (cycles imply mutual prerequisites;\n            # we'll let feasibility checks handle such cases)\n            prereq_closure_map[u] = set()\n            return prereq_closure_map[u]\n        visiting.add(u)\n        closure = set()\n        for p in prereq_of.get(u, []):\n            closure.add(p)\n            closure |= _build_closure(p, visiting)\n        visiting.remove(u)\n        prereq_closure_map[u] = closure\n        return closure\n\n    for i in range(n):\n        _build_closure(i, set())\n\n    # Helper: compute closure of prerequisites for an item (use precomputed map)\n    def prerequisite_closure(start):\n        return prereq_closure_map.get(start, set())\n\n    # Objective evaluation\n    def objective_of(selection_set):\n        total = 0.0\n        for i in selection_set:\n            total += weights[i] if i < len(weights) else 0.0\n        # pairwise interactions\n        sel_list = list(selection_set)\n        m = len(sel_list)\n        for ii in range(m):\n            u = sel_list[ii]\n            for jj in range(ii + 1, m):\n                v = sel_list[jj]\n                total += interactions.get((u, v), 0.0)\n        return total\n\n    # Feasibility check for adding a set of new items given current selection\n    def feasible_to_add(current_sel, to_add, max_card):\n        # Check cardinality\n        if len(current_sel | to_add) > max_card:\n            return False\n        # Check mutex: no pair (x,y) both in new selection or between new and current\n        for x in to_add:\n            # against current\n            for y in mutex_map.get(x, ()):\n                if y in current_sel:\n                    return False\n            # within to_add\n            for y in mutex_map.get(x, ()):\n                if y in to_add:\n                    return False\n        # Check group: at most one per group\n        # Build counts per group from current and to_add\n        group_counts = {}\n        for v in current_sel:\n            for g in var_to_groups.get(v, ()):\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in to_add:\n            for g in var_to_groups.get(v, ()):\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: ensure for any item in to_add, its prerequisites are included in current_sel or to_add\n        for v in list(to_add):\n            needed = prerequisite_closure(v)\n            if not needed.issubset(current_sel | to_add):\n                return False\n        return True\n\n    # Compute marginal gain of adding item i (including its prerequisites) given current_sel\n    # Return: (normalized_score, true_added_value, new_items)\n    def marginal_gain(current_sel, i):\n        if i in current_sel:\n            return -1e9, -1e9, set()  # already present, no gain\n        # compute closure (prereqs) using precomputed map\n        req = prerequisite_closure(i) | {i}\n        # Determine which of these are truly new\n        new_items = set(x for x in req if x not in current_sel)\n        if not new_items:\n            return -1e9, -1e9, set()\n        # For scoring, compute added weight + interactions with current selection and internal interactions\n        added = 0.0\n        for u in new_items:\n            added += weights[u] if u < len(weights) else 0.0\n            for v in current_sel:\n                added += interactions.get((u, v), 0.0)\n        # interactions among new_items (pairwise)\n        new_list = list(new_items)\n        for a_idx in range(len(new_list)):\n            u = new_list[a_idx]\n            for b_idx in range(a_idx + 1, len(new_list)):\n                v = new_list[b_idx]\n                added += interactions.get((u, v), 0.0)\n        # Normalize score to penalize selections that require many prerequisites:\n        # Prefer compact high-value additions. Tunable factor.\n        size = max(1, len(new_items))\n        penalty = 1.0 + 0.4 * (size - 1)  # modest penalty per extra required item\n        normalized = added / penalty\n        return normalized, added, new_items\n\n    max_card = cardinality_bounds[1] if len(cardinality_bounds) > 1 else n\n    min_card = cardinality_bounds[0] if len(cardinality_bounds) > 0 else 0\n\n    selected_set = set()\n\n    # Main greedy loop: at each step choose item (with its prereqs) that gives best positive normalized marginal and is feasible\n    while True:\n        best_score = 0.0\n        best_item = None\n        best_new_set = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            score, added, new_items = marginal_gain(selected_set, i)\n            if not new_items:\n                continue\n            # feasibility checks (mutex, groups, cardinality)\n            if not feasible_to_add(selected_set, new_items, max_card):\n                continue\n            if score > best_score + 1e-9:\n                best_score = score\n                best_item = i\n                best_new_set = new_items\n        if best_item is None:\n            break\n        # Add best_new_set to selection\n        selected_set |= best_new_set\n\n    # If we are below min_card, add best feasible items (ignore positive normalized score requirement)\n    if len(selected_set) < min_card:\n        candidates = []\n        for i in range(n):\n            if i in selected_set:\n                continue\n            score, added, new_items = marginal_gain(selected_set, i)\n            if not new_items:\n                continue\n            # check feasibility w.r.t max cardinality\n            if not feasible_to_add(selected_set, new_items, max_card):\n                continue\n            candidates.append((score, added, i, new_items))\n        # sort by normalized score descending, tie-break by true added value\n        candidates.sort(key=lambda x: (-x[0], -x[1]))\n        for score, added, i, new_items in candidates:\n            if len(selected_set) >= min_card:\n                break\n            if feasible_to_add(selected_set, new_items, max_card):\n                selected_set |= new_items\n\n    # Local improvement: try single swaps (replace one selected with one candidate and its prereqs)\n    improved = True\n    iter_limit = 5\n    iters = 0\n    while improved and iters < iter_limit:\n        improved = False\n        iters += 1\n        base_obj = objective_of(selected_set)\n        # Try each unselected candidate\n        unselected = [i for i in range(n) if i not in selected_set]\n        for cand in unselected:\n            score, added, cand_new = marginal_gain(selected_set, cand)\n            if not cand_new:\n                continue\n            # If adding directly is feasible and increases obj, do it (use true added)\n            if feasible_to_add(selected_set, cand_new, max_card):\n                new_obj = base_obj + added\n                if new_obj > base_obj + 1e-9:\n                    selected_set |= cand_new\n                    improved = True\n                    base_obj = new_obj\n                    break\n            # Otherwise attempt swap: remove one selected item s and add cand_new\n            for s in list(selected_set):\n                trial_sel = set(selected_set)\n                trial_sel.remove(s)\n                # Ensure removing s doesn't violate precedence (if some remaining item requires s)\n                violated = False\n                for rem in trial_sel:\n                    needed = prerequisite_closure(rem)\n                    if s in needed:\n                        violated = True\n                        break\n                if violated:\n                    continue\n                # Now try to add cand_new to trial_sel\n                if not feasible_to_add(trial_sel, cand_new, max_card):\n                    continue\n                trial_obj = objective_of(trial_sel | cand_new)\n                if trial_obj > base_obj + 1e-9:\n                    selected_set = trial_sel | cand_new\n                    improved = True\n                    base_obj = trial_obj\n                    break\n            if improved:\n                break\n\n    # Final safety: if still below min_card, fill with any feasible items greedily (use true added)\n    if len(selected_set) < min_card:\n        for i in range(n):\n            if len(selected_set) >= min_card:\n                break\n            if i in selected_set:\n                continue\n            _, added, new_items = marginal_gain(selected_set, i)\n            if not new_items:\n                continue\n            if feasible_to_add(selected_set, new_items, max_card):\n                selected_set |= new_items\n\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected_set)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n\n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n\n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n\n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n\n    result_str = stdout_capture.getvalue()\n    return result_str",
      "language": "python",
      "parent_id": "549a6832-b200-4308-8069-96f8779b4d8c",
      "archive_inspiration_ids": [
        "aac66d0e-7541-4a5b-b733-00b0ef41adec"
      ],
      "top_k_inspiration_ids": [],
      "island_idx": 0,
      "generation": 3,
      "timestamp": 1764626915.996269,
      "code_diff": "--- a/original.py\n+++ b/original.py\n@@ -1,304 +1,324 @@\n \"\"\"\n Initial solution for Synergistic Dependency Selection (SDS) problem.\n The code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n \"\"\"\n \n import json\n import sys\n import contextlib\n \n # EVOLVE-BLOCK-START\n def solve_sds():\n     \"\"\"\n     Solve the Synergistic Dependency Selection problem.\n \n     Reads from stdin: JSON with \"requirements\" and \"catalog\"\n     Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n \n     Improved greedy with precedence closure and small local search.\n     \"\"\"\n     # Read input\n     input_data = json.load(sys.stdin)\n     requirements = input_data.get(\"requirements\", {})\n     catalog = input_data.get(\"catalog\", {})\n \n     # Extract constraints\n     weights = requirements.get(\"weights\", [])\n     interactions_raw = requirements.get(\"interactions\", {})\n     cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n     mutex = requirements.get(\"mutex\", [])\n     groups = requirements.get(\"groups\", {})\n     precedence = requirements.get(\"precedence\", [])\n \n     n = len(weights)\n \n     # Parse interactions into a dict for quick lookup (make symmetric)\n     interactions = {}\n     for k, v in interactions_raw.items():\n         try:\n             parts = [p.strip() for p in k.split(\",\")]\n             if len(parts) >= 2:\n                 u = int(parts[0]); w = int(parts[1])\n                 interactions[(u, w)] = float(v)\n                 interactions[(w, u)] = float(v)\n         except Exception:\n             # ignore malformed keys\n             continue\n \n     # Build mutex map for O(1) checks\n     mutex_map = {i: set() for i in range(n)}\n     for a, b in mutex:\n         if 0 <= a < n and 0 <= b < n:\n             mutex_map[a].add(b)\n             mutex_map[b].add(a)\n \n     # Build variable->group index (assumes groups is dict: groupname -> [vars])\n     var_to_groups = {}\n     for g, vars_in_g in groups.items():\n         for v in vars_in_g:\n             if 0 <= v < n:\n                 var_to_groups.setdefault(v, set()).add(g)\n \n     # Build precedence graph: prereq_of[j] = list of items that must be present if j selected\n     prereq_of = {}\n     for a, b in precedence:\n         # if b selected then a must be selected\n         if 0 <= a < n and 0 <= b < n:\n             prereq_of.setdefault(b, []).append(a)\n \n-    # Helper: compute closure of prerequisites for an item (recursive)\n+    # Precompute transitive prerequisite closure for all nodes (memoized DFS)\n+    prereq_closure_map = {}\n+\n+    def _build_closure(u, visiting):\n+        if u in prereq_closure_map:\n+            return prereq_closure_map[u]\n+        if u in visiting:\n+            # cycle: return empty to avoid infinite loop (cycles imply mutual prerequisites;\n+            # we'll let feasibility checks handle such cases)\n+            prereq_closure_map[u] = set()\n+            return prereq_closure_map[u]\n+        visiting.add(u)\n+        closure = set()\n+        for p in prereq_of.get(u, []):\n+            closure.add(p)\n+            closure |= _build_closure(p, visiting)\n+        visiting.remove(u)\n+        prereq_closure_map[u] = closure\n+        return closure\n+\n+    for i in range(n):\n+        _build_closure(i, set())\n+\n+    # Helper: compute closure of prerequisites for an item (use precomputed map)\n     def prerequisite_closure(start):\n-        closure = set()\n-        stack = [start]\n-        while stack:\n-            cur = stack.pop()\n-            for p in prereq_of.get(cur, []):\n-                if p not in closure and p != cur:\n-                    closure.add(p)\n-                    stack.append(p)\n-        return closure\n+        return prereq_closure_map.get(start, set())\n \n     # Objective evaluation\n     def objective_of(selection_set):\n         total = 0.0\n         for i in selection_set:\n             total += weights[i] if i < len(weights) else 0.0\n         # pairwise interactions\n         sel_list = list(selection_set)\n         m = len(sel_list)\n         for ii in range(m):\n             u = sel_list[ii]\n             for jj in range(ii + 1, m):\n                 v = sel_list[jj]\n                 total += interactions.get((u, v), 0.0)\n         return total\n \n     # Feasibility check for adding a set of new items given current selection\n     def feasible_to_add(current_sel, to_add, max_card):\n         # Check cardinality\n         if len(current_sel | to_add) > max_card:\n             return False\n         # Check mutex: no pair (x,y) both in new selection or between new and current\n         for x in to_add:\n             # against current\n             for y in mutex_map.get(x, ()):\n                 if y in current_sel:\n                     return False\n             # within to_add\n             for y in mutex_map.get(x, ()):\n                 if y in to_add:\n                     return False\n         # Check group: at most one per group\n         # Build counts per group from current and to_add\n         group_counts = {}\n         for v in current_sel:\n             for g in var_to_groups.get(v, ()):\n                 group_counts[g] = group_counts.get(g, 0) + 1\n         for v in to_add:\n             for g in var_to_groups.get(v, ()):\n                 group_counts[g] = group_counts.get(g, 0) + 1\n                 if group_counts[g] > 1:\n                     return False\n         # Precedence: ensure for any item in to_add, its prerequisites are included in current_sel or to_add\n         for v in list(to_add):\n             needed = prerequisite_closure(v)\n             if not needed.issubset(current_sel | to_add):\n                 return False\n         return True\n \n     # Compute marginal gain of adding item i (including its prerequisites) given current_sel\n+    # Return: (normalized_score, true_added_value, new_items)\n     def marginal_gain(current_sel, i):\n         if i in current_sel:\n-            return -1e9, set()  # already present, no gain\n-        # compute closure (prereqs)\n+            return -1e9, -1e9, set()  # already present, no gain\n+        # compute closure (prereqs) using precomputed map\n         req = prerequisite_closure(i) | {i}\n         # Determine which of these are truly new\n         new_items = set(x for x in req if x not in current_sel)\n         if not new_items:\n-            return -1e9, set()\n-        # Check feasibility wrt constraints (we'll check cardinality externally)\n+            return -1e9, -1e9, set()\n         # For scoring, compute added weight + interactions with current selection and internal interactions\n         added = 0.0\n         for u in new_items:\n             added += weights[u] if u < len(weights) else 0.0\n             for v in current_sel:\n                 added += interactions.get((u, v), 0.0)\n         # interactions among new_items (pairwise)\n         new_list = list(new_items)\n         for a_idx in range(len(new_list)):\n             u = new_list[a_idx]\n             for b_idx in range(a_idx + 1, len(new_list)):\n                 v = new_list[b_idx]\n                 added += interactions.get((u, v), 0.0)\n-        return added, new_items\n+        # Normalize score to penalize selections that require many prerequisites:\n+        # Prefer compact high-value additions. Tunable factor.\n+        size = max(1, len(new_items))\n+        penalty = 1.0 + 0.4 * (size - 1)  # modest penalty per extra required item\n+        normalized = added / penalty\n+        return normalized, added, new_items\n \n     max_card = cardinality_bounds[1] if len(cardinality_bounds) > 1 else n\n     min_card = cardinality_bounds[0] if len(cardinality_bounds) > 0 else 0\n \n     selected_set = set()\n \n-    # Main greedy loop: at each step choose item (with its prereqs) that gives best positive marginal and is feasible\n+    # Main greedy loop: at each step choose item (with its prereqs) that gives best positive normalized marginal and is feasible\n     while True:\n-        best_gain = 0.0\n+        best_score = 0.0\n         best_item = None\n         best_new_set = None\n         for i in range(n):\n             if i in selected_set:\n                 continue\n-            gain, new_items = marginal_gain(selected_set, i)\n+            score, added, new_items = marginal_gain(selected_set, i)\n             if not new_items:\n                 continue\n             # feasibility checks (mutex, groups, cardinality)\n             if not feasible_to_add(selected_set, new_items, max_card):\n                 continue\n-            if gain > best_gain + 1e-9:\n-                best_gain = gain\n+            if score > best_score + 1e-9:\n+                best_score = score\n                 best_item = i\n                 best_new_set = new_items\n         if best_item is None:\n             break\n         # Add best_new_set to selection\n         selected_set |= best_new_set\n \n-    # If we are below min_card, add best feasible items (ignore positive gain requirement)\n+    # If we are below min_card, add best feasible items (ignore positive normalized score requirement)\n     if len(selected_set) < min_card:\n         candidates = []\n         for i in range(n):\n             if i in selected_set:\n                 continue\n-            gain, new_items = marginal_gain(selected_set, i)\n+            score, added, new_items = marginal_gain(selected_set, i)\n             if not new_items:\n                 continue\n             # check feasibility w.r.t max cardinality\n             if not feasible_to_add(selected_set, new_items, max_card):\n                 continue\n-            candidates.append((gain, i, new_items))\n-        # sort by gain descending, fall back to weight if ties\n-        candidates.sort(key=lambda x: (-x[0], -max(weights[x[1]] if x[1] < len(weights) else 0.0, 0.0)))\n-        for gain, i, new_items in candidates:\n+            candidates.append((score, added, i, new_items))\n+        # sort by normalized score descending, tie-break by true added value\n+        candidates.sort(key=lambda x: (-x[0], -x[1]))\n+        for score, added, i, new_items in candidates:\n             if len(selected_set) >= min_card:\n                 break\n             if feasible_to_add(selected_set, new_items, max_card):\n                 selected_set |= new_items\n \n     # Local improvement: try single swaps (replace one selected with one candidate and its prereqs)\n     improved = True\n     iter_limit = 5\n     iters = 0\n     while improved and iters < iter_limit:\n         improved = False\n         iters += 1\n         base_obj = objective_of(selected_set)\n         # Try each unselected candidate\n         unselected = [i for i in range(n) if i not in selected_set]\n         for cand in unselected:\n-            gain, cand_new = marginal_gain(selected_set, cand)\n+            score, added, cand_new = marginal_gain(selected_set, cand)\n             if not cand_new:\n                 continue\n-            # If adding directly is feasible and increases obj, do it\n+            # If adding directly is feasible and increases obj, do it (use true added)\n             if feasible_to_add(selected_set, cand_new, max_card):\n-                new_obj = base_obj + gain\n+                new_obj = base_obj + added\n                 if new_obj > base_obj + 1e-9:\n                     selected_set |= cand_new\n                     improved = True\n                     base_obj = new_obj\n                     break\n             # Otherwise attempt swap: remove one selected item s and add cand_new\n             for s in list(selected_set):\n                 trial_sel = set(selected_set)\n                 trial_sel.remove(s)\n                 # Ensure removing s doesn't violate precedence (if some remaining item requires s)\n                 violated = False\n                 for rem in trial_sel:\n                     needed = prerequisite_closure(rem)\n                     if s in needed:\n                         violated = True\n                         break\n                 if violated:\n                     continue\n                 # Now try to add cand_new to trial_sel\n                 if not feasible_to_add(trial_sel, cand_new, max_card):\n                     continue\n                 trial_obj = objective_of(trial_sel | cand_new)\n                 if trial_obj > base_obj + 1e-9:\n                     selected_set = trial_sel | cand_new\n                     improved = True\n                     base_obj = trial_obj\n                     break\n             if improved:\n                 break\n \n-    # Final safety: if still below min_card, fill with any feasible items greedily\n+    # Final safety: if still below min_card, fill with any feasible items greedily (use true added)\n     if len(selected_set) < min_card:\n         for i in range(n):\n             if len(selected_set) >= min_card:\n                 break\n             if i in selected_set:\n                 continue\n-            _, new_items = marginal_gain(selected_set, i)\n+            _, added, new_items = marginal_gain(selected_set, i)\n             if not new_items:\n                 continue\n             if feasible_to_add(selected_set, new_items, max_card):\n                 selected_set |= new_items\n \n     result = {\n         \"selection\": {\n             \"variables\": sorted(selected_set)\n         }\n     }\n     print(json.dumps(result))\n # EVOLVE-BLOCK-END\n \n \n # This part remains fixed (not evolved)\n def run_sds(problem_data=None):\n     \"\"\"\n     Main function called by the evaluator.\n     Can accept problem_data as parameter or read from stdin.\n     Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n     \"\"\"\n     import sys\n     import json\n     import io\n \n     if problem_data is None:\n         # Read from stdin (for compatibility)\n         input_data = json.load(sys.stdin)\n     else:\n         # Use provided problem data\n         input_data = problem_data\n \n     # Capture stdout from solve_sds\n     stdout_capture = io.StringIO()\n     old_stdin = sys.stdin\n \n     try:\n         # Create mock stdin\n         sys.stdin = io.StringIO(json.dumps(input_data))\n         with contextlib.redirect_stdout(stdout_capture):\n             solve_sds()\n     finally:\n         sys.stdin = old_stdin\n \n     result_str = stdout_capture.getvalue()\n     return result_str",
      "combined_score": 0.4073751773870285,
      "public_metrics": {
        "feasible": true,
        "selection_size": 10,
        "raw_score": 193.53014874422013
      },
      "private_metrics": {
        "selection": [
          0,
          2,
          6,
          7,
          9,
          10,
          11,
          13,
          15,
          18
        ],
        "raw_score": 193.53014874422013,
        "normalized_fitness": 0.4073751773870285
      },
      "text_feedback": "",
      "correct": true,
      "children_count": 0,
      "complexity": 1.0,
      "embedding": [
        0.022112275,
        0.006794134,
        0.019229155,
        -0.0226889,
        0.014152357,
        0.020858744,
        0.037480555,
        0.015355746,
        -0.032842495,
        0.027753161,
        0.04542794,
        -0.062576234,
        -0.025659766,
        0.023553835,
        0.01692266,
        -0.038533524,
        0.046355553,
        0.00055821275,
        -0.011225364,
        0.010097187,
        0.05500491,
        0.022112275,
        0.034873214,
        0.019968739,
        0.0069320225,
        -0.004716408,
        0.039185356,
        0.09296181,
        0.03264193,
        -0.038633805,
        0.028379926,
        -0.009733663,
        -0.038633805,
        0.0057380353,
        -0.0043497505,
        0.027552597,
        -0.002701358,
        0.027602738,
        -0.04174256,
        -0.018614925,
        0.0006467433,
        -0.02474469,
        -0.026950901,
        -0.0009417147,
        0.00083046383,
        -0.012378612,
        0.008298371,
        -0.017098153,
        0.026299067,
        -0.019279296,
        -0.043547645,
        0.033644754,
        0.014804193,
        0.01444067,
        -0.019329438,
        -0.030611211,
        0.003578829,
        0.0061767707,
        -0.0021027972,
        0.004713274,
        0.040012687,
        -0.03098727,
        0.043923702,
        0.02030719,
        -0.011839594,
        0.014540952,
        0.009251053,
        0.007220335,
        -0.020269586,
        -0.011645297,
        -0.0553559,
        -0.0021921112,
        0.02110945,
        -0.029483033,
        0.00135773,
        0.032516576,
        0.034221377,
        0.04166735,
        0.009025418,
        -0.04457554,
        -0.04956459,
        -0.023766935,
        -0.0029583315,
        -0.025634695,
        -0.06463202,
        -0.074309275,
        -0.013989398,
        0.0149796875,
        -0.034672648,
        -0.06438132,
        -0.017837737,
        -0.018677602,
        -0.0676405,
        0.03680365,
        0.014352922,
        -0.03963663,
        0.03346926,
        -0.022601152,
        0.014240105,
        0.006675049,
        0.0050861994,
        -0.03429659,
        0.008260765,
        -0.037530698,
        0.014177428,
        0.019542538,
        0.02730189,
        0.042795524,
        0.013074322,
        -0.02314017,
        -0.037956897,
        0.031137694,
        0.013325027,
        0.045352727,
        0.028956551,
        -0.049765155,
        -0.041191008,
        -0.029583316,
        0.001474465,
        -0.01126297,
        -0.018351683,
        -0.015944906,
        0.00089705765,
        0.025521878,
        -0.02110945,
        0.031062482,
        0.02559709,
        -0.072203346,
        -0.022024527,
        0.0009189944,
        0.045678645,
        0.014127287,
        0.003400201,
        -0.050291635,
        -0.06513344,
        -0.014052075,
        -0.035374627,
        -0.01990606,
        -0.019078732,
        0.045778926,
        0.014728981,
        -0.0019116338,
        -0.0077280146,
        0.018414361,
        -0.03958649,
        -0.025897937,
        -0.0019649088,
        0.012961504,
        -0.0950176,
        0.038533524,
        0.046882033,
        -0.033394046,
        -0.0053055673,
        0.008091538,
        0.060219597,
        -0.064581886,
        -0.031187834,
        0.009558169,
        0.054252792,
        -0.030661352,
        -0.020883815,
        -0.005609548,
        -0.0018489573,
        -0.0044092927,
        0.039661698,
        -0.012190582,
        -0.037355203,
        0.036552943,
        -0.0371045,
        -0.028430067,
        -0.008298371,
        -0.07977467,
        -0.016759701,
        0.0061642355,
        0.0022203156,
        -0.008937671,
        0.0037355204,
        -0.023616511,
        0.015456029,
        -0.03961156,
        -0.041692417,
        -0.03221573,
        -0.018000696,
        -0.050091073,
        -0.01345038,
        -0.04668147,
        -0.025847794,
        -0.013061786,
        0.016910125,
        0.012152976,
        -0.0077405497,
        0.021648468,
        0.008824853,
        -0.01668449,
        -0.0003968207,
        -0.028831197,
        0.06568499,
        0.05460378,
        -0.0011783185,
        0.02228777,
        0.021924246,
        0.0011540314,
        0.034396872,
        -0.02415553,
        -0.013951792,
        -0.01713576,
        -0.04876233,
        -0.011557549,
        -0.01708562,
        -0.051444884,
        0.029583316,
        -0.03555012,
        -0.0016938328,
        0.05490463,
        0.04289581,
        0.010673811,
        -0.021761287,
        0.0060169455,
        -0.007790691,
        0.04720795,
        -0.023603976,
        0.018025765,
        0.011250434,
        0.021811428,
        0.0048856344,
        0.045904282,
        -0.016584206,
        -0.029132044,
        0.01449081,
        -0.041090723,
        -0.008843657,
        -0.00413665,
        0.0016750299,
        0.0322408,
        -0.005073664,
        -0.022676364,
        -0.024493983,
        0.027402174,
        0.0068317405,
        -0.009276125,
        0.03768112,
        -0.0061736368,
        0.014340387,
        -8.2997416e-05,
        0.011551282,
        -0.008398653,
        -0.040438887,
        0.0004273755,
        -0.0098151425,
        0.0014282411,
        0.018326614,
        -0.027853444,
        0.027026113,
        -0.02044508,
        -0.025484271,
        -0.03469772,
        -0.019718032,
        -0.016797306,
        -0.004296475,
        0.05164545,
        -0.06693852,
        -0.0006780816,
        0.013299957,
        -0.022137346,
        -0.042845666,
        0.017524354,
        0.016997872,
        -0.013162068,
        -0.0077656205,
        -0.0019304367,
        -0.018326614,
        0.026073432,
        -0.04289581,
        0.009370139,
        -0.04262003,
        -0.012297133,
        0.004120981,
        0.06428104,
        -0.01865253,
        -0.017323788,
        -0.06723937,
        0.007214067,
        0.040313534,
        -0.0037668587,
        0.0409403,
        0.007176461,
        -0.002574438,
        0.0062895883,
        0.003274848,
        0.030335434,
        0.0066813165,
        -0.021447904,
        0.028379926,
        -0.043497503,
        -0.02337834,
        -0.0318146,
        -0.0054622586,
        0.021209734,
        0.0067001195,
        -0.0021200331,
        0.080225945,
        0.015268,
        0.0057725073,
        -0.0033187214,
        -0.022538476,
        -0.019592678,
        0.035675474,
        -0.04560343,
        0.020332262,
        0.025697371,
        -0.01529307,
        0.000899408,
        0.012585444,
        -0.0018818624,
        -0.03585097,
        -0.022037063,
        0.0536511,
        -0.03552505,
        0.034472086,
        0.01815112,
        -0.025484271,
        0.004788486,
        0.033193484,
        0.0064682164,
        0.023014817,
        -0.05420265,
        -0.013412775,
        0.0018771617,
        0.007502379,
        -0.014992223,
        -0.036101673,
        0.01708562,
        0.04299609,
        0.037455488,
        -0.0018082175,
        -0.059367195,
        0.02973374,
        0.0076151965,
        0.021548185,
        0.0036070335,
        -0.02564723,
        0.0048072888,
        -0.029081903,
        -0.03936085,
        0.0064494135,
        -0.011707974,
        -0.03677858,
        0.07009742,
        0.054804347,
        -0.010962123,
        0.0136133395,
        -0.0008782547,
        -0.006562231,
        0.04788486,
        -0.019116338,
        -0.014603629,
        -0.02356637,
        0.0017236042,
        -0.025772583,
        -0.02108438,
        0.03101234,
        0.007051108,
        -0.011375788,
        0.011570085,
        -0.010617401,
        0.014428134,
        -0.039536346,
        0.019254226,
        -0.0013804503,
        -0.0068254727,
        0.04505188,
        0.034447014,
        -0.023202846,
        0.0055907452,
        -0.08649359,
        -0.005158277,
        0.003290517,
        0.037430417,
        0.021535652,
        0.045352727,
        -0.015581382,
        0.008473865,
        -0.016007582,
        -0.007941115,
        0.01884056,
        0.0031996362,
        -0.020495221,
        -0.020231979,
        -0.033193484,
        -0.022212557,
        0.034196306,
        -0.031263046,
        0.028730916,
        0.009376407,
        -0.012328471,
        0.020833675,
        0.00035510163,
        0.020557897,
        0.018865632,
        0.03961156,
        0.012046427,
        0.0054935967,
        -0.009551901,
        -0.04595442,
        -0.039310712,
        -0.0007482009,
        0.030861916,
        0.035750683,
        0.012786009,
        -0.021009168,
        0.039787054,
        0.01609533,
        0.0383831,
        -0.017198436,
        0.018702673,
        -0.0019868456,
        -0.024230741,
        0.052798696,
        0.019718032,
        0.061723832,
        -0.00058367505,
        -0.0112817725,
        0.028304715,
        -0.027502455,
        -0.021410298,
        0.020219443,
        0.04592935,
        -0.032742213,
        0.06723937,
        0.012717065,
        -0.013500522,
        0.035349555,
        0.05164545,
        0.006562231,
        0.013625875,
        0.03890958,
        0.043672998,
        0.018238867,
        0.025948077,
        -0.02928247,
        -0.012384879,
        0.0008531841,
        0.030360505,
        -0.004531512,
        -0.016346036,
        0.008524006,
        0.021573257,
        -0.018965913,
        0.02807908,
        0.021447904,
        0.010886911,
        -0.0036477733,
        0.025609626,
        -0.020984098,
        -0.008624288,
        0.0068630786,
        0.041617207,
        -0.023578905,
        0.04515216,
        -0.0060138116,
        0.05575703,
        0.057361547,
        -0.023453552,
        0.022362981,
        0.020557897,
        0.02888134,
        0.027076256,
        0.025271172,
        -0.029884163,
        0.0422189,
        0.025772583,
        -0.010843038,
        -0.050241496,
        -0.008649359,
        -0.02188664,
        -0.031112622,
        0.037806474,
        0.018865632,
        -0.0050830655,
        0.010792896,
        -0.0053306376,
        -0.010874376,
        0.0069320225,
        0.028379926,
        0.032040235,
        0.050542343,
        0.009996904,
        -0.033218555,
        -0.020758463,
        0.010473246,
        0.021999458,
        0.011407126,
        0.010767826,
        -0.013362633,
        -0.012861221,
        -0.03234108,
        -0.006010678,
        0.022513404,
        -0.032892637,
        -0.0014016036,
        0.030912058,
        -0.018878167,
        -0.04387356,
        0.05041699,
        0.0470826,
        -0.009896622,
        0.006819205,
        -0.02349116,
        -0.01115642,
        0.00625825,
        -0.025120748,
        0.026248924,
        -0.03214052,
        0.02938275,
        0.02682555,
        0.0018348551,
        -0.030836847,
        -0.040338606,
        -0.018765349,
        0.01881549,
        -0.0026355474,
        -0.033519402,
        -0.015004758,
        0.029307539,
        -0.0050642625,
        -0.022112275,
        0.012591712,
        -0.087145425,
        -0.02730189,
        -0.025697371,
        0.0035850967,
        -0.005434054,
        -0.049013037,
        0.08137919,
        -0.047809646,
        0.0016123534,
        -0.023629047,
        -0.025672302,
        -0.023503693,
        0.002933261,
        0.00011810606,
        -0.009326265,
        -0.028505279,
        -0.015995046,
        0.034321662,
        -0.04013804,
        0.05670971,
        0.006543428,
        -0.012403683,
        0.0009464154,
        -0.025609626,
        -0.023127634,
        -0.015468564,
        0.008335977,
        -0.0171859,
        0.007452238,
        -0.029006692,
        -0.021773823,
        -0.0099154245,
        -0.034572367,
        0.0049921847,
        -0.002018184,
        0.009645916,
        0.016183076,
        -0.016195612,
        -0.0073018144,
        0.0570607,
        0.031689245,
        -0.00816675,
        0.01446574,
        0.0066625136,
        -0.01593237,
        0.014703911,
        -0.060169455,
        0.051946297,
        0.024055246,
        -0.007753085,
        -0.03291771,
        -0.008536542,
        0.0019085,
        -0.016346036,
        -0.020846209,
        -0.0004704656,
        -0.0019179014,
        -0.07230363,
        0.016270824,
        -0.0156942,
        0.010404302,
        0.02167354,
        0.003616435,
        -0.0049733818,
        -0.008649359,
        0.028455138,
        0.016885053,
        -0.02167354,
        0.0014948349,
        -0.019504933,
        -0.005863388,
        -0.003976825,
        0.021410298,
        0.019730568,
        -0.046907105,
        0.02252594,
        0.010103455,
        -0.038057182,
        -0.010736487,
        0.05625844,
        0.014954617,
        0.016559135,
        0.02129748,
        -0.025208496,
        -0.030310363,
        0.006060819,
        -0.0056753587,
        -0.044074126,
        -0.0032043369,
        -0.025872866,
        0.040313534,
        0.01444067,
        -0.02122227,
        0.007226602,
        -0.011031067,
        -0.00016197962,
        0.026524702,
        0.049188532,
        -0.002356637,
        0.017048012,
        0.017737454,
        -0.0045597167,
        -0.0241806,
        -0.025634695,
        -0.004804155,
        -0.010128525,
        0.015380817,
        -0.020031415,
        0.0015481099,
        0.021849034,
        0.007452238,
        -0.009489224,
        0.02725175,
        0.02193678,
        0.0033187214,
        -0.0012253259,
        -0.036828723,
        0.031488683,
        0.016233217,
        -0.023315664,
        -0.00027479735,
        0.02543413,
        -0.008003791,
        -0.028354855,
        -0.00910063,
        0.010535923,
        -0.03015994,
        0.047734436,
        0.04061438,
        -0.0048166905,
        -0.019655356,
        -0.022037063,
        0.0039329515,
        -0.0046349284,
        -0.028655704,
        0.012366077,
        0.04923867,
        0.010893178,
        0.028455138,
        0.029508105,
        0.04424962,
        0.015443494,
        0.004766549,
        -0.042469606,
        -0.0115136765,
        0.020332262,
        -0.016371107,
        -0.0101159895,
        -0.01884056,
        0.02474469,
        -0.009833945,
        -0.03765605,
        0.032541648,
        -0.008429991,
        0.007859635,
        -0.018339148,
        0.00878098,
        0.018589854,
        -0.050592486,
        0.0074397023,
        0.006063953,
        0.014377993,
        0.014177428,
        0.0073268847,
        0.014904476,
        0.005687894,
        -0.021410298,
        0.031087551,
        0.026800478,
        0.0076026614,
        0.031187834,
        -0.030937128,
        -0.09897876,
        -0.0059668045,
        0.015969977,
        0.00568476,
        -0.0076026614,
        -0.020282121,
        -0.028831197,
        -0.013412775,
        0.017399002,
        0.024368629,
        0.003183967,
        -0.0014446937,
        0.019793244,
        -0.011150152,
        -0.0115136765,
        -0.0034534761,
        0.0057505704,
        0.03560026,
        0.015706735,
        0.036979146,
        -0.018639997,
        -0.052698415,
        -0.026349207,
        -0.017699849,
        0.0030084727,
        -0.056559287,
        -0.04053917,
        -0.00854281,
        0.031563893,
        0.0121153705,
        0.0036947806,
        0.0154810995,
        -0.0019743103,
        -0.03517406,
        0.022400588,
        -0.0017674777,
        -0.019993808,
        -0.02767795,
        0.00040152142,
        -0.015706735,
        0.028329786,
        -0.009244787,
        -0.00950176,
        0.027377103,
        0.013976864,
        -0.03063628,
        -0.006117228,
        -0.0001588458,
        0.027051184,
        -0.041516926,
        0.027953727,
        -0.041943125,
        0.009044222,
        -0.009225983,
        -0.0019367044,
        0.02349116,
        0.0054810615,
        0.025897937,
        -0.0024334157,
        -0.033519402,
        0.018878167,
        -0.008643092,
        -0.0067377253,
        -0.040188182,
        0.008524006,
        0.010109722,
        0.03023515,
        0.0010427806,
        -0.015117575,
        0.016007582,
        0.03304306,
        0.029558245,
        0.01531814,
        -0.00054332707,
        -0.00065967033,
        0.013500522,
        -0.012717065,
        -0.011457267,
        -0.04831106,
        0.012460091,
        0.020946492,
        0.019705497,
        0.003619569,
        -0.0058226483,
        0.02978388,
        0.013751227,
        -0.0024694547,
        0.003992494,
        0.0017659109,
        0.036728438,
        -0.042820595,
        -0.024005106,
        0.0059824735,
        -0.0026042094,
        0.031137694,
        -0.016346036,
        0.04512709,
        -0.03474786,
        -0.13447873,
        -0.0075713233,
        0.0021811428,
        -0.013600804,
        0.014189963,
        -0.014641235,
        0.022776647,
        0.013124462,
        -0.012309668,
        -0.016797306,
        -0.031939954,
        -0.020194374,
        0.014252639,
        0.024707083,
        0.007270476,
        -0.010278949,
        -0.013663481,
        0.0018661933,
        0.013500522,
        -0.031614035,
        -0.0069570933,
        0.017737454,
        -0.007283011,
        0.0053306376,
        -0.03883437,
        0.0033312568,
        0.0055531394,
        0.038734086,
        -0.0036947806,
        0.0058007115,
        0.0028893873,
        0.009157039,
        -0.00939521,
        0.05086826,
        -0.023741864,
        -0.001512071,
        0.0034064688,
        -0.012873757,
        -0.017524354,
        0.01486687,
        0.022087205,
        -0.009570704,
        0.028831197,
        -0.06157341,
        0.012309668,
        0.008079003,
        -0.014553487,
        -0.007696676,
        -0.0035286879,
        0.043748207,
        0.00087590434,
        0.021786356,
        -0.020808604,
        -0.034221377,
        -0.023152705,
        0.020670716,
        0.013838975,
        0.006969629,
        -0.016584206,
        0.020457614,
        -0.03063628,
        -0.020144232,
        0.04166735,
        -0.027828373,
        -0.023252988,
        0.005437188,
        -0.022952141,
        -0.025923008,
        -0.015456029,
        0.03023515,
        -0.014453204,
        0.0020980963,
        -0.018326614,
        -0.015593917,
        -0.04831106,
        0.038207605,
        0.0046443297,
        -0.003290517,
        -0.010103455,
        -0.0034472083,
        0.053450532,
        -0.011024799,
        0.00661864,
        0.02273904,
        0.0030319765,
        0.036201958,
        0.010184934,
        0.03635238,
        -0.01222192,
        0.049715012,
        -0.016885053,
        -0.015794482,
        0.013889116,
        0.0010506151,
        -0.02893148,
        0.0383831,
        0.009451618,
        -0.040814947,
        0.006775331,
        -0.012215653,
        0.015029829,
        0.059617903,
        0.002104364,
        -0.010567261,
        -0.0018395558,
        0.045202304,
        -0.05324997,
        0.013701087,
        -0.0097148605,
        0.019479861,
        0.007088714,
        0.012297133,
        -0.035474908,
        0.023403412,
        -0.0054904628,
        -0.021134522,
        0.0065747667,
        0.022262698,
        0.013149533,
        0.01638364,
        -0.009025418,
        0.043071304,
        -0.042269044,
        0.04262003,
        -0.02193678,
        0.023064958,
        0.0035161525,
        -0.003835803,
        -0.009765001,
        0.013274886,
        0.0126794595,
        -0.0037543233,
        -0.023516228,
        0.05966804,
        0.0035004835,
        0.02685062,
        0.030736564,
        -0.018188724,
        -0.025020465,
        0.013061786,
        0.017110689,
        0.012353541,
        -0.006280187,
        0.009407745,
        -0.022087205,
        0.0031996362,
        0.03758084,
        -0.017699849,
        -0.059868608,
        0.027201608,
        -0.012178048,
        -0.03630224,
        0.020394938,
        0.022701435,
        0.0051206714,
        0.046455834,
        -0.0066249077,
        -0.017035477,
        0.00051198876,
        -0.029884163,
        0.016220683,
        0.020520292,
        0.018351683,
        -0.027176537,
        0.043171585,
        0.022225093,
        0.004086509,
        -0.02444384,
        0.013149533,
        0.016007582,
        -0.038132392,
        -0.014428134,
        -0.028856268,
        -0.009733663,
        -0.0031918015,
        0.01673463,
        -0.014377993,
        0.015255464,
        0.02151058,
        0.043923702,
        0.0060012764,
        0.04339722,
        -0.011626494,
        0.004312144,
        0.021773823,
        -0.04675668,
        -0.022037063,
        -0.0019837117,
        0.0007587776,
        -0.009871552,
        0.028279644,
        0.019066196,
        -0.007377026,
        0.043647926,
        -0.00625825,
        0.02602329,
        -0.018564785,
        0.0071012494,
        0.04176763,
        -0.034873214,
        -0.0087496415,
        0.024318488,
        0.028229503,
        -0.05731141,
        0.012974039,
        0.045678645,
        0.020282121,
        0.00023229484,
        -0.035675474,
        0.005001586,
        0.0043622856,
        0.010147328,
        -0.01990606,
        -0.006819205,
        -0.013162068,
        0.026073432,
        0.017110689,
        -0.0007854151,
        -0.042945947,
        -0.021535652,
        -0.033719964,
        -0.0239675,
        0.038132392,
        -0.011507409,
        -0.0029740008,
        -0.0067063873,
        0.023766935,
        0.007859635,
        0.016534066,
        0.004465702,
        -0.00041679884,
        0.022701435,
        -0.015606453,
        -0.016559135,
        0.017699849,
        -0.021974387,
        -0.0017721785,
        0.0074020964,
        -0.0061955736,
        0.030561069,
        0.013011645,
        -0.017699849,
        0.014315316,
        -0.015518705,
        0.040012687,
        -0.024293417,
        0.025371455,
        0.012134174,
        0.017035477,
        -0.004312144,
        -0.025797654,
        -0.0048981695,
        0.009752466,
        -0.03504871,
        0.041817773,
        -0.033719964,
        0.022400588,
        0.04457554,
        0.004475103,
        -0.005148876,
        -0.007452238,
        -0.010911982,
        -0.011990017,
        -0.0053337715,
        -0.038759157,
        -0.013951792,
        -0.007038573,
        0.008975277,
        0.015744342,
        -0.009877819,
        0.009157039,
        0.020244515,
        -0.025033,
        0.007214067,
        -0.007828297,
        -0.021623397,
        -0.0055218013,
        -0.009934228,
        0.006781599,
        -0.029407822,
        -0.022964675,
        0.032541648,
        0.0013162069,
        0.04299609,
        0.018226331,
        -0.033293765,
        0.033419117,
        -0.023867218,
        0.033619683,
        -0.017486747,
        -0.002571304,
        0.014277711,
        -0.0059605367,
        -0.013350098,
        -0.008787247,
        -0.012127906,
        0.00846133,
        -0.031237977,
        0.010335358,
        -0.027402174,
        -0.011338182,
        0.022087205,
        0.020319726,
        -0.03555012,
        0.04216876,
        -0.0052460246,
        -0.047283165,
        0.0016045189,
        -0.008774713,
        -0.024970325,
        0.012566642,
        0.0052240877,
        0.011977483,
        0.015368282,
        0.011946144,
        0.001852091,
        0.0077969586,
        0.023403412,
        -0.0020824273,
        0.03417124,
        0.013951792,
        0.020119162,
        0.0006048284,
        -0.009765001,
        -0.024092853,
        0.011657832,
        0.012635586,
        0.00014288287,
        0.0125478385,
        -0.035675474,
        0.010623669,
        0.03482307,
        0.025722442,
        -0.020219443,
        -0.030009516,
        0.0014063043,
        -0.06488273,
        0.001160299,
        -0.005665957,
        -0.014791658,
        -0.020219443,
        -0.017825201,
        -0.0040050293,
        0.0032967848,
        -0.0073456876,
        0.0034284054,
        -0.012272062,
        0.0070573757,
        -0.007903509,
        0.02543413,
        0.08117862,
        0.018289007,
        -0.022826787,
        0.018853096,
        -0.00043207622,
        0.00235507,
        -0.015744342,
        0.01222192,
        0.012127906,
        -0.039862264,
        0.003829535,
        0.018326614,
        0.015969977,
        0.032992918,
        0.02730189,
        -0.018326614,
        -0.012102835,
        0.019091267,
        0.009758733,
        -0.014540952,
        0.007966185,
        0.013350098,
        0.009859016,
        0.023954965,
        0.008874995,
        0.0156942,
        0.024995394,
        -0.026248924,
        0.011137617,
        0.017825201,
        0.009765001,
        -0.014553487,
        -0.02690076,
        -0.0023535031,
        -0.01961775,
        0.0048072888,
        -0.014967152,
        0.012240724,
        -0.0159073,
        -0.051394742,
        -0.024506519,
        0.003829535,
        -0.02690076,
        0.018928308,
        0.05660943,
        0.017975625,
        -0.015706735,
        0.03143854,
        0.016007582,
        0.004531512,
        -0.0008061767,
        0.017248577,
        -0.024857506,
        -0.04424962,
        -0.007890973,
        -0.028279644,
        0.0038044646,
        0.020908887,
        0.012146709,
        3.547589e-05,
        -0.026223855,
        -0.028781056,
        0.012974039,
        0.04833613,
        0.02297721,
        -0.020545362,
        0.021347621,
        -0.006042016,
        -0.030485857,
        0.04720795,
        -0.030360505,
        -0.0057254997,
        -0.0035944982,
        0.006295856,
        -0.010510852,
        0.04587921,
        0.016596742,
        0.022638759,
        0.005434054,
        -0.012184314,
        -0.007283011,
        0.015142647,
        -0.037480555,
        -0.031739388,
        -0.016183076,
        0.0021341355,
        0.010473246,
        0.033243623,
        -0.025747513,
        0.018539714,
        -0.040990442,
        -0.01905366,
        -0.011946144,
        0.012372345,
        0.003817,
        -0.023403412,
        0.012497697,
        0.018502107,
        -0.03961156,
        -0.01758703,
        -0.0076214643,
        -0.011519943,
        0.030335434,
        -0.004315278,
        -0.067740776,
        0.02233791,
        -0.050793048,
        0.002030719,
        0.004011297,
        0.00019077165,
        0.010398034,
        0.0075086467,
        -0.02730189,
        0.018564785,
        -0.022851858,
        0.023102565,
        -0.0343718,
        -0.002934828,
        -0.00854281,
        -0.030611211,
        0.014616163,
        -0.015368282,
        0.004443765,
        -0.007427167,
        -0.007872171,
        0.0159073,
        -0.011739312,
        -0.012641854,
        -0.010278949,
        0.012272062,
        0.0141147515,
        -0.009827678,
        0.02933261,
        0.018050836,
        -0.0013310926,
        -0.022375517,
        -0.012334739,
        0.0016123534,
        -0.015255464,
        0.0120903,
        -0.032366153,
        -0.018451966,
        -0.035575192,
        0.031288117,
        -0.032967847,
        0.008618021,
        -0.021498045,
        -0.027452314,
        0.020495221,
        0.038608734,
        0.0057975776,
        -0.027552597,
        -0.0237544,
        -0.0015661295,
        -0.016107865,
        0.0013201241,
        0.034045883,
        -0.009652183,
        -0.006117228,
        -0.014365458,
        -0.0048292256,
        0.017850272,
        0.016358571,
        -0.02217495,
        0.003635238,
        0.0026371144,
        0.0019116338,
        0.012272062,
        0.021786356,
        0.0041836575,
        -0.0011046736,
        -0.027377103,
        0.030210081,
        -0.012798545,
        -0.011852129,
        0.044299763,
        0.02087128,
        -0.027527526,
        -0.016709559,
        0.01588223,
        0.000638517,
        0.015393352,
        0.012503965,
        -0.016885053,
        0.0072767437,
        -0.013124462,
        0.010586063,
        -0.014879405,
        -0.001745541,
        -0.0043936237,
        0.00587279,
        -0.020908887,
        -0.01177065,
        -0.02129748,
        0.026549771,
        0.019041127,
        -0.006295856,
        -0.041817773,
        -0.018477038,
        0.048285987,
        -0.005195883,
        0.0048354934,
        0.0044563003,
        0.0011626494,
        0.0038075983,
        -0.02122227,
        0.007157658,
        0.0064368783,
        0.025321312,
        -2.6931315e-07,
        0.061824117,
        -0.021284945,
        0.0063428637,
        0.0052240877,
        0.008599218,
        0.02257608,
        -0.010849305,
        0.0064306105,
        -0.008536542,
        0.0105484575,
        0.0024725886,
        -0.042369325,
        -0.012428753,
        -0.008874995,
        -0.049389094,
        0.015130111,
        0.015456029,
        -0.011125081,
        -0.0011657831,
        -0.0059824735,
        0.03549998,
        0.0031918015,
        -0.003400201,
        -0.004744612,
        0.0071012494,
        -0.0063773356,
        -0.04633048,
        0.049840365,
        0.024431307,
        -0.017160831,
        -0.039210428,
        0.001367915,
        0.015355746,
        0.006026347,
        0.009877819,
        0.035901107,
        0.01692266,
        0.014077146,
        -0.0007666121,
        -0.018915772,
        -0.002917592,
        -0.011733044,
        -0.011588888,
        -0.043647926,
        -0.013688551,
        -0.05335025,
        -0.0041961926,
        -0.027853444,
        0.0010592331,
        0.016007582,
        -0.016020117,
        0.0017267381,
        -0.027828373,
        0.0110812085,
        0.010510852,
        -0.019041127,
        -0.02770302,
        -0.011024799,
        -0.00060678704,
        -0.011024799,
        0.0021278677,
        0.013964328,
        -0.04003776,
        -0.017148295,
        0.010799164,
        0.011519943,
        0.007427167,
        -0.024055246,
        0.014265175,
        0.005919797,
        0.0570607,
        -0.0033155878,
        -0.042720314,
        0.005775641,
        0.010191201,
        0.019592678,
        -0.011845862,
        0.011112547,
        0.027652878,
        -0.0018489573,
        0.04462568,
        -0.0057975776,
        -0.0011015398,
        -0.02273904,
        -0.01046071,
        0.00021094565,
        0.028856268,
        -0.0062049753,
        0.036126744,
        0.0015136378,
        -0.032090377,
        0.007220335,
        0.017424071,
        -0.038157463,
        -0.009207181,
        -0.015581382,
        0.0083485115,
        0.010579796,
        -0.016997872,
        0.014804193,
        0.005186482,
        0.026574843,
        -0.025484271,
        -0.0012002552,
        -0.0055876113,
        0.020231979,
        0.01756196,
        0.009783804,
        -0.031588964,
        0.04297102,
        -0.026750337,
        0.018990984,
        0.022814251,
        -0.034848142,
        -0.012691994,
        -0.0038044646,
        0.0019555073,
        -0.0075274496,
        0.043723136,
        -0.005180214,
        0.040238325,
        -0.008079003,
        0.018702673,
        0.01342531,
        0.028755985,
        0.0037793939,
        0.0060514174,
        0.032842495,
        -0.0075337174,
        0.005399582,
        0.01385151,
        0.015581382,
        -0.008492668,
        0.011250434,
        -0.0047790846,
        0.03635238,
        0.00952683,
        -0.012146709,
        -0.00053353386,
        -0.0034284054,
        -0.016245753,
        -0.017850272,
        -0.010673811,
        -0.043622855,
        -0.01032909,
        -0.0012840851,
        -0.021773823,
        -0.024970325,
        -0.030460786,
        0.028003868,
        -0.037004214,
        -0.0039517544,
        -0.004681936,
        0.0028987888,
        0.03183967,
        0.009802607,
        -0.019780708,
        -0.0032529111,
        0.013663481,
        -0.030611211,
        0.03314334,
        0.024142994,
        0.012529036,
        0.021234803,
        -0.005869656,
        -0.00672519,
        -0.024945254,
        -0.0041523194,
        -0.011977483,
        -0.012541571,
        0.001529307,
        0.013437845,
        -0.0021090647,
        -0.020908887,
        0.01964282,
        -0.00305548,
        0.0018567918,
        -0.018301543,
        -0.010655007
      ],
      "embedding_pca_2d": [],
      "embedding_pca_3d": [],
      "embedding_cluster_id": null,
      "migration_history": [],
      "metadata": {
        "compute_time": 2.005859136581421,
        "patch_type": "diff",
        "api_costs": 0.013184999999999999,
        "num_applied": 1,
        "patch_name": "prereq_closure_and_normalized_marginal_gain",
        "patch_description": "Precompute transitive prerequisite closures for all variables to avoid repeated DFS and speed up feasibility and gain calculations. Change marginal_gain to return both the true added value and a normalized score that penalizes selections that require many prerequisite items (favoring compact high-value additions). Use the normalized score for greedy selection but the true added value for objective calculations and swaps. Update all call sites accordingly and improve candidate sorting when filling minimum cardinality. This focuses the greedy search on high-benefit, low-cost additions while keeping objective computations accurate.",
        "error_attempt": null,
        "novelty_attempt": 1,
        "resample_attempt": 1,
        "patch_attempt": 1,
        "model_name": "gpt-5-mini",
        "temperature": 1.0,
        "max_output_tokens": 8192,
        "llm_result": {
          "content": "<NAME>\nprereq_closure_and_normalized_marginal_gain\n</NAME>\n\n<DESCRIPTION>\nPrecompute transitive prerequisite closures for all variables to avoid repeated DFS and speed up feasibility and gain calculations. Change marginal_gain to return both the true added value and a normalized score that penalizes selections that require many prerequisite items (favoring compact high-value additions). Use the normalized score for greedy selection but the true added value for objective calculations and swaps. Update all call sites accordingly and improve candidate sorting when filling minimum cardinality. This focuses the greedy search on high-benefit, low-cost additions while keeping objective computations accurate.\n</DESCRIPTION>\n\n<DIFF>\n<<<<<<< SEARCH\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n\n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n\n    Improved greedy with precedence closure and small local search.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n\n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions_raw = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n\n    n = len(weights)\n\n    # Parse interactions into a dict for quick lookup (make symmetric)\n    interactions = {}\n    for k, v in interactions_raw.items():\n        try:\n            parts = [p.strip() for p in k.split(\",\")]\n            if len(parts) >= 2:\n                u = int(parts[0]); w = int(parts[1])\n                interactions[(u, w)] = float(v)\n                interactions[(w, u)] = float(v)\n        except Exception:\n            # ignore malformed keys\n            continue\n\n    # Build mutex map for O(1) checks\n    mutex_map = {i: set() for i in range(n)}\n    for a, b in mutex:\n        if 0 <= a < n and 0 <= b < n:\n            mutex_map[a].add(b)\n            mutex_map[b].add(a)\n\n    # Build variable->group index (assumes groups is dict: groupname -> [vars])\n    var_to_groups = {}\n    for g, vars_in_g in groups.items():\n        for v in vars_in_g:\n            if 0 <= v < n:\n                var_to_groups.setdefault(v, set()).add(g)\n\n    # Build precedence graph: prereq_of[j] = list of items that must be present if j selected\n    prereq_of = {}\n    for a, b in precedence:\n        # if b selected then a must be selected\n        if 0 <= a < n and 0 <= b < n:\n            prereq_of.setdefault(b, []).append(a)\n\n    # Helper: compute closure of prerequisites for an item (recursive)\n    def prerequisite_closure(start):\n        closure = set()\n        stack = [start]\n        while stack:\n            cur = stack.pop()\n            for p in prereq_of.get(cur, []):\n                if p not in closure and p != cur:\n                    closure.add(p)\n                    stack.append(p)\n        return closure\n\n    # Objective evaluation\n    def objective_of(selection_set):\n        total = 0.0\n        for i in selection_set:\n            total += weights[i] if i < len(weights) else 0.0\n        # pairwise interactions\n        sel_list = list(selection_set)\n        m = len(sel_list)\n        for ii in range(m):\n            u = sel_list[ii]\n            for jj in range(ii + 1, m):\n                v = sel_list[jj]\n                total += interactions.get((u, v), 0.0)\n        return total\n\n    # Feasibility check for adding a set of new items given current selection\n    def feasible_to_add(current_sel, to_add, max_card):\n        # Check cardinality\n        if len(current_sel | to_add) > max_card:\n            return False\n        # Check mutex: no pair (x,y) both in new selection or between new and current\n        for x in to_add:\n            # against current\n            for y in mutex_map.get(x, ()):\n                if y in current_sel:\n                    return False\n            # within to_add\n            for y in mutex_map.get(x, ()):\n                if y in to_add:\n                    return False\n        # Check group: at most one per group\n        # Build counts per group from current and to_add\n        group_counts = {}\n        for v in current_sel:\n            for g in var_to_groups.get(v, ()):\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in to_add:\n            for g in var_to_groups.get(v, ()):\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: ensure for any item in to_add, its prerequisites are included in current_sel or to_add\n        for v in list(to_add):\n            needed = prerequisite_closure(v)\n            if not needed.issubset(current_sel | to_add):\n                return False\n        return True\n\n    # Compute marginal gain of adding item i (including its prerequisites) given current_sel\n    def marginal_gain(current_sel, i):\n        if i in current_sel:\n            return -1e9, set()  # already present, no gain\n        # compute closure (prereqs)\n        req = prerequisite_closure(i) | {i}\n        # Determine which of these are truly new\n        new_items = set(x for x in req if x not in current_sel)\n        if not new_items:\n            return -1e9, set()\n        # Check feasibility wrt constraints (we'll check cardinality externally)\n        # For scoring, compute added weight + interactions with current selection and internal interactions\n        added = 0.0\n        for u in new_items:\n            added += weights[u] if u < len(weights) else 0.0\n            for v in current_sel:\n                added += interactions.get((u, v), 0.0)\n        # interactions among new_items (pairwise)\n        new_list = list(new_items)\n        for a_idx in range(len(new_list)):\n            u = new_list[a_idx]\n            for b_idx in range(a_idx + 1, len(new_list)):\n                v = new_list[b_idx]\n                added += interactions.get((u, v), 0.0)\n        return added, new_items\n\n    max_card = cardinality_bounds[1] if len(cardinality_bounds) > 1 else n\n    min_card = cardinality_bounds[0] if len(cardinality_bounds) > 0 else 0\n\n    selected_set = set()\n\n    # Main greedy loop: at each step choose item (with its prereqs) that gives best positive marginal and is feasible\n    while True:\n        best_gain = 0.0\n        best_item = None\n        best_new_set = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            gain, new_items = marginal_gain(selected_set, i)\n            if not new_items:\n                continue\n            # feasibility checks (mutex, groups, cardinality)\n            if not feasible_to_add(selected_set, new_items, max_card):\n                continue\n            if gain > best_gain + 1e-9:\n                best_gain = gain\n                best_item = i\n                best_new_set = new_items\n        if best_item is None:\n            break\n        # Add best_new_set to selection\n        selected_set |= best_new_set\n\n    # If we are below min_card, add best feasible items (ignore positive gain requirement)\n    if len(selected_set) < min_card:\n        candidates = []\n        for i in range(n):\n            if i in selected_set:\n                continue\n            gain, new_items = marginal_gain(selected_set, i)\n            if not new_items:\n                continue\n            # check feasibility w.r.t max cardinality\n            if not feasible_to_add(selected_set, new_items, max_card):\n                continue\n            candidates.append((gain, i, new_items))\n        # sort by gain descending, fall back to weight if ties\n        candidates.sort(key=lambda x: (-x[0], -max(weights[x[1]] if x[1] < len(weights) else 0.0, 0.0)))\n        for gain, i, new_items in candidates:\n            if len(selected_set) >= min_card:\n                break\n            if feasible_to_add(selected_set, new_items, max_card):\n                selected_set |= new_items\n\n    # Local improvement: try single swaps (replace one selected with one candidate and its prereqs)\n    improved = True\n    iter_limit = 5\n    iters = 0\n    while improved and iters < iter_limit:\n        improved = False\n        iters += 1\n        base_obj = objective_of(selected_set)\n        # Try each unselected candidate\n        unselected = [i for i in range(n) if i not in selected_set]\n        for cand in unselected:\n            gain, cand_new = marginal_gain(selected_set, cand)\n            if not cand_new:\n                continue\n            # If adding directly is feasible and increases obj, do it\n            if feasible_to_add(selected_set, cand_new, max_card):\n                new_obj = base_obj + gain\n                if new_obj > base_obj + 1e-9:\n                    selected_set |= cand_new\n                    improved = True\n                    base_obj = new_obj\n                    break\n            # Otherwise attempt swap: remove one selected item s and add cand_new\n            for s in list(selected_set):\n                trial_sel = set(selected_set)\n                trial_sel.remove(s)\n                # Ensure removing s doesn't violate precedence (if some remaining item requires s)\n                violated = False\n                for rem in trial_sel:\n                    needed = prerequisite_closure(rem)\n                    if s in needed:\n                        violated = True\n                        break\n                if violated:\n                    continue\n                # Now try to add cand_new to trial_sel\n                if not feasible_to_add(trial_sel, cand_new, max_card):\n                    continue\n                trial_obj = objective_of(trial_sel | cand_new)\n                if trial_obj > base_obj + 1e-9:\n                    selected_set = trial_sel | cand_new\n                    improved = True\n                    base_obj = trial_obj\n                    break\n            if improved:\n                break\n\n    # Final safety: if still below min_card, fill with any feasible items greedily\n    if len(selected_set) < min_card:\n        for i in range(n):\n            if len(selected_set) >= min_card:\n                break\n            if i in selected_set:\n                continue\n            _, new_items = marginal_gain(selected_set, i)\n            if not new_items:\n                continue\n            if feasible_to_add(selected_set, new_items, max_card):\n                selected_set |= new_items\n\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected_set)\n        }\n    }\n    print(json.dumps(result))\n=======\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n\n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n\n    Improved greedy with precedence closure and small local search.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n\n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions_raw = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n\n    n = len(weights)\n\n    # Parse interactions into a dict for quick lookup (make symmetric)\n    interactions = {}\n    for k, v in interactions_raw.items():\n        try:\n            parts = [p.strip() for p in k.split(\",\")]\n            if len(parts) >= 2:\n                u = int(parts[0]); w = int(parts[1])\n                interactions[(u, w)] = float(v)\n                interactions[(w, u)] = float(v)\n        except Exception:\n            # ignore malformed keys\n            continue\n\n    # Build mutex map for O(1) checks\n    mutex_map = {i: set() for i in range(n)}\n    for a, b in mutex:\n        if 0 <= a < n and 0 <= b < n:\n            mutex_map[a].add(b)\n            mutex_map[b].add(a)\n\n    # Build variable->group index (assumes groups is dict: groupname -> [vars])\n    var_to_groups = {}\n    for g, vars_in_g in groups.items():\n        for v in vars_in_g:\n            if 0 <= v < n:\n                var_to_groups.setdefault(v, set()).add(g)\n\n    # Build precedence graph: prereq_of[j] = list of items that must be present if j selected\n    prereq_of = {}\n    for a, b in precedence:\n        # if b selected then a must be selected\n        if 0 <= a < n and 0 <= b < n:\n            prereq_of.setdefault(b, []).append(a)\n\n    # Precompute transitive prerequisite closure for all nodes (memoized DFS)\n    prereq_closure_map = {}\n\n    def _build_closure(u, visiting):\n        if u in prereq_closure_map:\n            return prereq_closure_map[u]\n        if u in visiting:\n            # cycle: return empty to avoid infinite loop (cycles imply mutual prerequisites;\n            # we'll let feasibility checks handle such cases)\n            prereq_closure_map[u] = set()\n            return prereq_closure_map[u]\n        visiting.add(u)\n        closure = set()\n        for p in prereq_of.get(u, []):\n            closure.add(p)\n            closure |= _build_closure(p, visiting)\n        visiting.remove(u)\n        prereq_closure_map[u] = closure\n        return closure\n\n    for i in range(n):\n        _build_closure(i, set())\n\n    # Helper: compute closure of prerequisites for an item (use precomputed map)\n    def prerequisite_closure(start):\n        return prereq_closure_map.get(start, set())\n\n    # Objective evaluation\n    def objective_of(selection_set):\n        total = 0.0\n        for i in selection_set:\n            total += weights[i] if i < len(weights) else 0.0\n        # pairwise interactions\n        sel_list = list(selection_set)\n        m = len(sel_list)\n        for ii in range(m):\n            u = sel_list[ii]\n            for jj in range(ii + 1, m):\n                v = sel_list[jj]\n                total += interactions.get((u, v), 0.0)\n        return total\n\n    # Feasibility check for adding a set of new items given current selection\n    def feasible_to_add(current_sel, to_add, max_card):\n        # Check cardinality\n        if len(current_sel | to_add) > max_card:\n            return False\n        # Check mutex: no pair (x,y) both in new selection or between new and current\n        for x in to_add:\n            # against current\n            for y in mutex_map.get(x, ()):\n                if y in current_sel:\n                    return False\n            # within to_add\n            for y in mutex_map.get(x, ()):\n                if y in to_add:\n                    return False\n        # Check group: at most one per group\n        # Build counts per group from current and to_add\n        group_counts = {}\n        for v in current_sel:\n            for g in var_to_groups.get(v, ()):\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in to_add:\n            for g in var_to_groups.get(v, ()):\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: ensure for any item in to_add, its prerequisites are included in current_sel or to_add\n        for v in list(to_add):\n            needed = prerequisite_closure(v)\n            if not needed.issubset(current_sel | to_add):\n                return False\n        return True\n\n    # Compute marginal gain of adding item i (including its prerequisites) given current_sel\n    # Return: (normalized_score, true_added_value, new_items)\n    def marginal_gain(current_sel, i):\n        if i in current_sel:\n            return -1e9, -1e9, set()  # already present, no gain\n        # compute closure (prereqs) using precomputed map\n        req = prerequisite_closure(i) | {i}\n        # Determine which of these are truly new\n        new_items = set(x for x in req if x not in current_sel)\n        if not new_items:\n            return -1e9, -1e9, set()\n        # For scoring, compute added weight + interactions with current selection and internal interactions\n        added = 0.0\n        for u in new_items:\n            added += weights[u] if u < len(weights) else 0.0\n            for v in current_sel:\n                added += interactions.get((u, v), 0.0)\n        # interactions among new_items (pairwise)\n        new_list = list(new_items)\n        for a_idx in range(len(new_list)):\n            u = new_list[a_idx]\n            for b_idx in range(a_idx + 1, len(new_list)):\n                v = new_list[b_idx]\n                added += interactions.get((u, v), 0.0)\n        # Normalize score to penalize selections that require many prerequisites:\n        # Prefer compact high-value additions. Tunable factor.\n        size = max(1, len(new_items))\n        penalty = 1.0 + 0.4 * (size - 1)  # modest penalty per extra required item\n        normalized = added / penalty\n        return normalized, added, new_items\n\n    max_card = cardinality_bounds[1] if len(cardinality_bounds) > 1 else n\n    min_card = cardinality_bounds[0] if len(cardinality_bounds) > 0 else 0\n\n    selected_set = set()\n\n    # Main greedy loop: at each step choose item (with its prereqs) that gives best positive normalized marginal and is feasible\n    while True:\n        best_score = 0.0\n        best_item = None\n        best_new_set = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            score, added, new_items = marginal_gain(selected_set, i)\n            if not new_items:\n                continue\n            # feasibility checks (mutex, groups, cardinality)\n            if not feasible_to_add(selected_set, new_items, max_card):\n                continue\n            if score > best_score + 1e-9:\n                best_score = score\n                best_item = i\n                best_new_set = new_items\n        if best_item is None:\n            break\n        # Add best_new_set to selection\n        selected_set |= best_new_set\n\n    # If we are below min_card, add best feasible items (ignore positive normalized score requirement)\n    if len(selected_set) < min_card:\n        candidates = []\n        for i in range(n):\n            if i in selected_set:\n                continue\n            score, added, new_items = marginal_gain(selected_set, i)\n            if not new_items:\n                continue\n            # check feasibility w.r.t max cardinality\n            if not feasible_to_add(selected_set, new_items, max_card):\n                continue\n            candidates.append((score, added, i, new_items))\n        # sort by normalized score descending, tie-break by true added value\n        candidates.sort(key=lambda x: (-x[0], -x[1]))\n        for score, added, i, new_items in candidates:\n            if len(selected_set) >= min_card:\n                break\n            if feasible_to_add(selected_set, new_items, max_card):\n                selected_set |= new_items\n\n    # Local improvement: try single swaps (replace one selected with one candidate and its prereqs)\n    improved = True\n    iter_limit = 5\n    iters = 0\n    while improved and iters < iter_limit:\n        improved = False\n        iters += 1\n        base_obj = objective_of(selected_set)\n        # Try each unselected candidate\n        unselected = [i for i in range(n) if i not in selected_set]\n        for cand in unselected:\n            score, added, cand_new = marginal_gain(selected_set, cand)\n            if not cand_new:\n                continue\n            # If adding directly is feasible and increases obj, do it (use true added)\n            if feasible_to_add(selected_set, cand_new, max_card):\n                new_obj = base_obj + added\n                if new_obj > base_obj + 1e-9:\n                    selected_set |= cand_new\n                    improved = True\n                    base_obj = new_obj\n                    break\n            # Otherwise attempt swap: remove one selected item s and add cand_new\n            for s in list(selected_set):\n                trial_sel = set(selected_set)\n                trial_sel.remove(s)\n                # Ensure removing s doesn't violate precedence (if some remaining item requires s)\n                violated = False\n                for rem in trial_sel:\n                    needed = prerequisite_closure(rem)\n                    if s in needed:\n                        violated = True\n                        break\n                if violated:\n                    continue\n                # Now try to add cand_new to trial_sel\n                if not feasible_to_add(trial_sel, cand_new, max_card):\n                    continue\n                trial_obj = objective_of(trial_sel | cand_new)\n                if trial_obj > base_obj + 1e-9:\n                    selected_set = trial_sel | cand_new\n                    improved = True\n                    base_obj = trial_obj\n                    break\n            if improved:\n                break\n\n    # Final safety: if still below min_card, fill with any feasible items greedily (use true added)\n    if len(selected_set) < min_card:\n        for i in range(n):\n            if len(selected_set) >= min_card:\n                break\n            if i in selected_set:\n                continue\n            _, added, new_items = marginal_gain(selected_set, i)\n            if not new_items:\n                continue\n            if feasible_to_add(selected_set, new_items, max_card):\n                selected_set |= new_items\n\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected_set)\n        }\n    }\n    print(json.dumps(result))\n>>>>>>> REPLACE\n</DIFF>",
          "msg": "Here are the performance metrics of a set of prioviously implemented programs:\n\n# Prior programs\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    This is a greedy baseline - evolution will improve this.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    # Simple greedy: select items with highest weights first\n    # This is a baseline - evolution will find better strategies\n    n = len(weights)\n    selected = []\n    \n    # Create score list (weight + interaction potential)\n    scores = []\n    for i in range(n):\n        score = weights[i] if i < len(weights) else 0.0\n        # Add potential interaction value\n        for k, v in interactions.items():\n            try:\n                u, w = map(int, k.split(\",\"))\n                if u == i or w == i:\n                    score += abs(v) * 0.5  # Potential value\n            except:\n                pass\n        scores.append((score, i))\n    \n    # Sort by score descending\n    scores.sort(reverse=True)\n    \n    # Greedy selection respecting constraints\n    selected_set = set()\n    for score, i in scores:\n        if len(selected_set) >= cardinality_bounds[1]:\n            break\n            \n        # Check mutex constraints\n        can_add = True\n        for a, b in mutex:\n            if (a == i and b in selected_set) or (b == i and a in selected_set):\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n            \n        # Check group constraints (at most one per group)\n        for grp_vars in groups.values():\n            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n        \n        # Check precedence (if j selected, i must be selected)\n        precedence_ok = True\n        for pred_i, pred_j in precedence:\n            if pred_j == i and pred_i not in selected_set:\n                precedence_ok = False\n                break\n        \n        if not precedence_ok:\n            continue\n        \n        # Add if we meet minimum cardinality or have room\n        if len(selected_set) < cardinality_bounds[1]:\n            selected_set.add(i)\n            selected.append(i)\n    \n    # Ensure minimum cardinality\n    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n        for i in range(n):\n            if i not in selected_set:\n                selected_set.add(i)\n                selected.append(i)\n                break\n    \n    # Output result\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n    \n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n    \n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n    \n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n    \n    result_str = stdout_capture.getvalue()\n    return result_str\n\n\n```\n\nPerformance metrics:\nCombined score to maximize: 0.21\nfeasible: True; selection_size: 10; raw_score: 101.95\n\n\n# Current program\n\nHere is the current program we are trying to improve (you will need to propose a modification to it below):\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n\n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n\n    Improved greedy with precedence closure and small local search.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n\n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions_raw = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n\n    n = len(weights)\n\n    # Parse interactions into a dict for quick lookup (make symmetric)\n    interactions = {}\n    for k, v in interactions_raw.items():\n        try:\n            parts = [p.strip() for p in k.split(\",\")]\n            if len(parts) >= 2:\n                u = int(parts[0]); w = int(parts[1])\n                interactions[(u, w)] = float(v)\n                interactions[(w, u)] = float(v)\n        except Exception:\n            # ignore malformed keys\n            continue\n\n    # Build mutex map for O(1) checks\n    mutex_map = {i: set() for i in range(n)}\n    for a, b in mutex:\n        if 0 <= a < n and 0 <= b < n:\n            mutex_map[a].add(b)\n            mutex_map[b].add(a)\n\n    # Build variable->group index (assumes groups is dict: groupname -> [vars])\n    var_to_groups = {}\n    for g, vars_in_g in groups.items():\n        for v in vars_in_g:\n            if 0 <= v < n:\n                var_to_groups.setdefault(v, set()).add(g)\n\n    # Build precedence graph: prereq_of[j] = list of items that must be present if j selected\n    prereq_of = {}\n    for a, b in precedence:\n        # if b selected then a must be selected\n        if 0 <= a < n and 0 <= b < n:\n            prereq_of.setdefault(b, []).append(a)\n\n    # Helper: compute closure of prerequisites for an item (recursive)\n    def prerequisite_closure(start):\n        closure = set()\n        stack = [start]\n        while stack:\n            cur = stack.pop()\n            for p in prereq_of.get(cur, []):\n                if p not in closure and p != cur:\n                    closure.add(p)\n                    stack.append(p)\n        return closure\n\n    # Objective evaluation\n    def objective_of(selection_set):\n        total = 0.0\n        for i in selection_set:\n            total += weights[i] if i < len(weights) else 0.0\n        # pairwise interactions\n        sel_list = list(selection_set)\n        m = len(sel_list)\n        for ii in range(m):\n            u = sel_list[ii]\n            for jj in range(ii + 1, m):\n                v = sel_list[jj]\n                total += interactions.get((u, v), 0.0)\n        return total\n\n    # Feasibility check for adding a set of new items given current selection\n    def feasible_to_add(current_sel, to_add, max_card):\n        # Check cardinality\n        if len(current_sel | to_add) > max_card:\n            return False\n        # Check mutex: no pair (x,y) both in new selection or between new and current\n        for x in to_add:\n            # against current\n            for y in mutex_map.get(x, ()):\n                if y in current_sel:\n                    return False\n            # within to_add\n            for y in mutex_map.get(x, ()):\n                if y in to_add:\n                    return False\n        # Check group: at most one per group\n        # Build counts per group from current and to_add\n        group_counts = {}\n        for v in current_sel:\n            for g in var_to_groups.get(v, ()):\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in to_add:\n            for g in var_to_groups.get(v, ()):\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: ensure for any item in to_add, its prerequisites are included in current_sel or to_add\n        for v in list(to_add):\n            needed = prerequisite_closure(v)\n            if not needed.issubset(current_sel | to_add):\n                return False\n        return True\n\n    # Compute marginal gain of adding item i (including its prerequisites) given current_sel\n    def marginal_gain(current_sel, i):\n        if i in current_sel:\n            return -1e9, set()  # already present, no gain\n        # compute closure (prereqs)\n        req = prerequisite_closure(i) | {i}\n        # Determine which of these are truly new\n        new_items = set(x for x in req if x not in current_sel)\n        if not new_items:\n            return -1e9, set()\n        # Check feasibility wrt constraints (we'll check cardinality externally)\n        # For scoring, compute added weight + interactions with current selection and internal interactions\n        added = 0.0\n        for u in new_items:\n            added += weights[u] if u < len(weights) else 0.0\n            for v in current_sel:\n                added += interactions.get((u, v), 0.0)\n        # interactions among new_items (pairwise)\n        new_list = list(new_items)\n        for a_idx in range(len(new_list)):\n            u = new_list[a_idx]\n            for b_idx in range(a_idx + 1, len(new_list)):\n                v = new_list[b_idx]\n                added += interactions.get((u, v), 0.0)\n        return added, new_items\n\n    max_card = cardinality_bounds[1] if len(cardinality_bounds) > 1 else n\n    min_card = cardinality_bounds[0] if len(cardinality_bounds) > 0 else 0\n\n    selected_set = set()\n\n    # Main greedy loop: at each step choose item (with its prereqs) that gives best positive marginal and is feasible\n    while True:\n        best_gain = 0.0\n        best_item = None\n        best_new_set = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            gain, new_items = marginal_gain(selected_set, i)\n            if not new_items:\n                continue\n            # feasibility checks (mutex, groups, cardinality)\n            if not feasible_to_add(selected_set, new_items, max_card):\n                continue\n            if gain > best_gain + 1e-9:\n                best_gain = gain\n                best_item = i\n                best_new_set = new_items\n        if best_item is None:\n            break\n        # Add best_new_set to selection\n        selected_set |= best_new_set\n\n    # If we are below min_card, add best feasible items (ignore positive gain requirement)\n    if len(selected_set) < min_card:\n        candidates = []\n        for i in range(n):\n            if i in selected_set:\n                continue\n            gain, new_items = marginal_gain(selected_set, i)\n            if not new_items:\n                continue\n            # check feasibility w.r.t max cardinality\n            if not feasible_to_add(selected_set, new_items, max_card):\n                continue\n            candidates.append((gain, i, new_items))\n        # sort by gain descending, fall back to weight if ties\n        candidates.sort(key=lambda x: (-x[0], -max(weights[x[1]] if x[1] < len(weights) else 0.0, 0.0)))\n        for gain, i, new_items in candidates:\n            if len(selected_set) >= min_card:\n                break\n            if feasible_to_add(selected_set, new_items, max_card):\n                selected_set |= new_items\n\n    # Local improvement: try single swaps (replace one selected with one candidate and its prereqs)\n    improved = True\n    iter_limit = 5\n    iters = 0\n    while improved and iters < iter_limit:\n        improved = False\n        iters += 1\n        base_obj = objective_of(selected_set)\n        # Try each unselected candidate\n        unselected = [i for i in range(n) if i not in selected_set]\n        for cand in unselected:\n            gain, cand_new = marginal_gain(selected_set, cand)\n            if not cand_new:\n                continue\n            # If adding directly is feasible and increases obj, do it\n            if feasible_to_add(selected_set, cand_new, max_card):\n                new_obj = base_obj + gain\n                if new_obj > base_obj + 1e-9:\n                    selected_set |= cand_new\n                    improved = True\n                    base_obj = new_obj\n                    break\n            # Otherwise attempt swap: remove one selected item s and add cand_new\n            for s in list(selected_set):\n                trial_sel = set(selected_set)\n                trial_sel.remove(s)\n                # Ensure removing s doesn't violate precedence (if some remaining item requires s)\n                violated = False\n                for rem in trial_sel:\n                    needed = prerequisite_closure(rem)\n                    if s in needed:\n                        violated = True\n                        break\n                if violated:\n                    continue\n                # Now try to add cand_new to trial_sel\n                if not feasible_to_add(trial_sel, cand_new, max_card):\n                    continue\n                trial_obj = objective_of(trial_sel | cand_new)\n                if trial_obj > base_obj + 1e-9:\n                    selected_set = trial_sel | cand_new\n                    improved = True\n                    base_obj = trial_obj\n                    break\n            if improved:\n                break\n\n    # Final safety: if still below min_card, fill with any feasible items greedily\n    if len(selected_set) < min_card:\n        for i in range(n):\n            if len(selected_set) >= min_card:\n                break\n            if i in selected_set:\n                continue\n            _, new_items = marginal_gain(selected_set, i)\n            if not new_items:\n                continue\n            if feasible_to_add(selected_set, new_items, max_card):\n                selected_set |= new_items\n\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected_set)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n\n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n\n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n\n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n\n    result_str = stdout_capture.getvalue()\n    return result_str\n\n```\n\nHere are the performance metrics of the program:\n\nCombined score to maximize: 0.41\nfeasible: True; selection_size: 10; raw_score: 193.53\n\n# Instructions\n\nMake sure that the changes you propose are consistent with each other. For example, if you refer to a new config variable somewhere, you should also propose a change to add that variable.\n\nNote that the changes you propose will be applied sequentially, so you should assume that the previous changes have already been applied when writing the SEARCH block.\n\n# Task\n\nSuggest a new idea to improve the performance of the code that is inspired by your expert knowledge of the considered subject.\nYour goal is to maximize the `combined_score` of the program.\nDescribe each change with a SEARCH/REPLACE block.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.\n",
          "system_msg": "You are an expert algorithmist specializing in combinatorial optimization, particularly the Synergistic Dependency Selection (SDS) problem.\n\nThe SDS problem requires selecting a subset of variables that:\n1. Satisfies cardinality bounds (min/max number of items)\n2. Respects mutex constraints (cannot select both items in a mutex pair)\n3. Respects group constraints (at most one item per group)\n4. Satisfies precedence constraints (if j is selected, i must be selected)\n5. Maximizes the objective: sum of selected item weights + pairwise interaction values\n\nKey strategies to explore:\n1. Greedy selection with constraint-aware ordering\n2. Dynamic programming for small instances\n3. Constraint satisfaction with backtracking\n4. Weighted scoring that accounts for interactions\n5. Precedence-aware selection ordering\n6. Group-aware selection that maximizes diversity\n\nThe code should read JSON from stdin with \"requirements\" and \"catalog\", and output JSON to stdout with \"selection\" containing \"variables\" list.\n\nBe creative and find efficient solutions that maximize the objective while respecting all constraints.\nYou MUST repond using a edit name, description and the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n<NAME>\nA shortened name summarizing the edit you are proposing. Lowercase, no spaces, underscores allowed.\n</NAME>\n\n<DESCRIPTION>\nA description and argumentation process of the edit you are proposing.\n</DESCRIPTION>\n\n<DIFF>\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly including indentation)\n=======\n# New replacement code\n>>>>>>> REPLACE\n\n</DIFF>\n\n\nExample of a valid diff format:\n<DIFF>\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n\n</DIFF>\n\n* You may only modify text that lies below a line containing \"EVOLVE-BLOCK-START\" and above the next \"EVOLVE-BLOCK-END\". Everything outside those markers is read-only.\n* Do not repeat the markers \"EVOLVE-BLOCK-START\" and \"EVOLVE-BLOCK-END\" in the SEARCH/REPLACE blocks.  \n* Every block\u2019s SEARCH section must be copied **verbatim** from the current file.  Including indentation.\n* You can propose multiple independent edits. SEARCH/REPLACE blocks follow one after another. DO NOT ADD ANY OTHER TEXT BETWEEN THESE BLOCKS.\n* Make sure the file still runs after your changes.",
          "new_msg_history": [
            {
              "role": "user",
              "content": "Here are the performance metrics of a set of prioviously implemented programs:\n\n# Prior programs\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    This is a greedy baseline - evolution will improve this.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    # Simple greedy: select items with highest weights first\n    # This is a baseline - evolution will find better strategies\n    n = len(weights)\n    selected = []\n    \n    # Create score list (weight + interaction potential)\n    scores = []\n    for i in range(n):\n        score = weights[i] if i < len(weights) else 0.0\n        # Add potential interaction value\n        for k, v in interactions.items():\n            try:\n                u, w = map(int, k.split(\",\"))\n                if u == i or w == i:\n                    score += abs(v) * 0.5  # Potential value\n            except:\n                pass\n        scores.append((score, i))\n    \n    # Sort by score descending\n    scores.sort(reverse=True)\n    \n    # Greedy selection respecting constraints\n    selected_set = set()\n    for score, i in scores:\n        if len(selected_set) >= cardinality_bounds[1]:\n            break\n            \n        # Check mutex constraints\n        can_add = True\n        for a, b in mutex:\n            if (a == i and b in selected_set) or (b == i and a in selected_set):\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n            \n        # Check group constraints (at most one per group)\n        for grp_vars in groups.values():\n            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n        \n        # Check precedence (if j selected, i must be selected)\n        precedence_ok = True\n        for pred_i, pred_j in precedence:\n            if pred_j == i and pred_i not in selected_set:\n                precedence_ok = False\n                break\n        \n        if not precedence_ok:\n            continue\n        \n        # Add if we meet minimum cardinality or have room\n        if len(selected_set) < cardinality_bounds[1]:\n            selected_set.add(i)\n            selected.append(i)\n    \n    # Ensure minimum cardinality\n    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n        for i in range(n):\n            if i not in selected_set:\n                selected_set.add(i)\n                selected.append(i)\n                break\n    \n    # Output result\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n    \n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n    \n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n    \n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n    \n    result_str = stdout_capture.getvalue()\n    return result_str\n\n\n```\n\nPerformance metrics:\nCombined score to maximize: 0.21\nfeasible: True; selection_size: 10; raw_score: 101.95\n\n\n# Current program\n\nHere is the current program we are trying to improve (you will need to propose a modification to it below):\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n\n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n\n    Improved greedy with precedence closure and small local search.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n\n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions_raw = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n\n    n = len(weights)\n\n    # Parse interactions into a dict for quick lookup (make symmetric)\n    interactions = {}\n    for k, v in interactions_raw.items():\n        try:\n            parts = [p.strip() for p in k.split(\",\")]\n            if len(parts) >= 2:\n                u = int(parts[0]); w = int(parts[1])\n                interactions[(u, w)] = float(v)\n                interactions[(w, u)] = float(v)\n        except Exception:\n            # ignore malformed keys\n            continue\n\n    # Build mutex map for O(1) checks\n    mutex_map = {i: set() for i in range(n)}\n    for a, b in mutex:\n        if 0 <= a < n and 0 <= b < n:\n            mutex_map[a].add(b)\n            mutex_map[b].add(a)\n\n    # Build variable->group index (assumes groups is dict: groupname -> [vars])\n    var_to_groups = {}\n    for g, vars_in_g in groups.items():\n        for v in vars_in_g:\n            if 0 <= v < n:\n                var_to_groups.setdefault(v, set()).add(g)\n\n    # Build precedence graph: prereq_of[j] = list of items that must be present if j selected\n    prereq_of = {}\n    for a, b in precedence:\n        # if b selected then a must be selected\n        if 0 <= a < n and 0 <= b < n:\n            prereq_of.setdefault(b, []).append(a)\n\n    # Helper: compute closure of prerequisites for an item (recursive)\n    def prerequisite_closure(start):\n        closure = set()\n        stack = [start]\n        while stack:\n            cur = stack.pop()\n            for p in prereq_of.get(cur, []):\n                if p not in closure and p != cur:\n                    closure.add(p)\n                    stack.append(p)\n        return closure\n\n    # Objective evaluation\n    def objective_of(selection_set):\n        total = 0.0\n        for i in selection_set:\n            total += weights[i] if i < len(weights) else 0.0\n        # pairwise interactions\n        sel_list = list(selection_set)\n        m = len(sel_list)\n        for ii in range(m):\n            u = sel_list[ii]\n            for jj in range(ii + 1, m):\n                v = sel_list[jj]\n                total += interactions.get((u, v), 0.0)\n        return total\n\n    # Feasibility check for adding a set of new items given current selection\n    def feasible_to_add(current_sel, to_add, max_card):\n        # Check cardinality\n        if len(current_sel | to_add) > max_card:\n            return False\n        # Check mutex: no pair (x,y) both in new selection or between new and current\n        for x in to_add:\n            # against current\n            for y in mutex_map.get(x, ()):\n                if y in current_sel:\n                    return False\n            # within to_add\n            for y in mutex_map.get(x, ()):\n                if y in to_add:\n                    return False\n        # Check group: at most one per group\n        # Build counts per group from current and to_add\n        group_counts = {}\n        for v in current_sel:\n            for g in var_to_groups.get(v, ()):\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in to_add:\n            for g in var_to_groups.get(v, ()):\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: ensure for any item in to_add, its prerequisites are included in current_sel or to_add\n        for v in list(to_add):\n            needed = prerequisite_closure(v)\n            if not needed.issubset(current_sel | to_add):\n                return False\n        return True\n\n    # Compute marginal gain of adding item i (including its prerequisites) given current_sel\n    def marginal_gain(current_sel, i):\n        if i in current_sel:\n            return -1e9, set()  # already present, no gain\n        # compute closure (prereqs)\n        req = prerequisite_closure(i) | {i}\n        # Determine which of these are truly new\n        new_items = set(x for x in req if x not in current_sel)\n        if not new_items:\n            return -1e9, set()\n        # Check feasibility wrt constraints (we'll check cardinality externally)\n        # For scoring, compute added weight + interactions with current selection and internal interactions\n        added = 0.0\n        for u in new_items:\n            added += weights[u] if u < len(weights) else 0.0\n            for v in current_sel:\n                added += interactions.get((u, v), 0.0)\n        # interactions among new_items (pairwise)\n        new_list = list(new_items)\n        for a_idx in range(len(new_list)):\n            u = new_list[a_idx]\n            for b_idx in range(a_idx + 1, len(new_list)):\n                v = new_list[b_idx]\n                added += interactions.get((u, v), 0.0)\n        return added, new_items\n\n    max_card = cardinality_bounds[1] if len(cardinality_bounds) > 1 else n\n    min_card = cardinality_bounds[0] if len(cardinality_bounds) > 0 else 0\n\n    selected_set = set()\n\n    # Main greedy loop: at each step choose item (with its prereqs) that gives best positive marginal and is feasible\n    while True:\n        best_gain = 0.0\n        best_item = None\n        best_new_set = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            gain, new_items = marginal_gain(selected_set, i)\n            if not new_items:\n                continue\n            # feasibility checks (mutex, groups, cardinality)\n            if not feasible_to_add(selected_set, new_items, max_card):\n                continue\n            if gain > best_gain + 1e-9:\n                best_gain = gain\n                best_item = i\n                best_new_set = new_items\n        if best_item is None:\n            break\n        # Add best_new_set to selection\n        selected_set |= best_new_set\n\n    # If we are below min_card, add best feasible items (ignore positive gain requirement)\n    if len(selected_set) < min_card:\n        candidates = []\n        for i in range(n):\n            if i in selected_set:\n                continue\n            gain, new_items = marginal_gain(selected_set, i)\n            if not new_items:\n                continue\n            # check feasibility w.r.t max cardinality\n            if not feasible_to_add(selected_set, new_items, max_card):\n                continue\n            candidates.append((gain, i, new_items))\n        # sort by gain descending, fall back to weight if ties\n        candidates.sort(key=lambda x: (-x[0], -max(weights[x[1]] if x[1] < len(weights) else 0.0, 0.0)))\n        for gain, i, new_items in candidates:\n            if len(selected_set) >= min_card:\n                break\n            if feasible_to_add(selected_set, new_items, max_card):\n                selected_set |= new_items\n\n    # Local improvement: try single swaps (replace one selected with one candidate and its prereqs)\n    improved = True\n    iter_limit = 5\n    iters = 0\n    while improved and iters < iter_limit:\n        improved = False\n        iters += 1\n        base_obj = objective_of(selected_set)\n        # Try each unselected candidate\n        unselected = [i for i in range(n) if i not in selected_set]\n        for cand in unselected:\n            gain, cand_new = marginal_gain(selected_set, cand)\n            if not cand_new:\n                continue\n            # If adding directly is feasible and increases obj, do it\n            if feasible_to_add(selected_set, cand_new, max_card):\n                new_obj = base_obj + gain\n                if new_obj > base_obj + 1e-9:\n                    selected_set |= cand_new\n                    improved = True\n                    base_obj = new_obj\n                    break\n            # Otherwise attempt swap: remove one selected item s and add cand_new\n            for s in list(selected_set):\n                trial_sel = set(selected_set)\n                trial_sel.remove(s)\n                # Ensure removing s doesn't violate precedence (if some remaining item requires s)\n                violated = False\n                for rem in trial_sel:\n                    needed = prerequisite_closure(rem)\n                    if s in needed:\n                        violated = True\n                        break\n                if violated:\n                    continue\n                # Now try to add cand_new to trial_sel\n                if not feasible_to_add(trial_sel, cand_new, max_card):\n                    continue\n                trial_obj = objective_of(trial_sel | cand_new)\n                if trial_obj > base_obj + 1e-9:\n                    selected_set = trial_sel | cand_new\n                    improved = True\n                    base_obj = trial_obj\n                    break\n            if improved:\n                break\n\n    # Final safety: if still below min_card, fill with any feasible items greedily\n    if len(selected_set) < min_card:\n        for i in range(n):\n            if len(selected_set) >= min_card:\n                break\n            if i in selected_set:\n                continue\n            _, new_items = marginal_gain(selected_set, i)\n            if not new_items:\n                continue\n            if feasible_to_add(selected_set, new_items, max_card):\n                selected_set |= new_items\n\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected_set)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n\n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n\n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n\n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n\n    result_str = stdout_capture.getvalue()\n    return result_str\n\n```\n\nHere are the performance metrics of the program:\n\nCombined score to maximize: 0.41\nfeasible: True; selection_size: 10; raw_score: 193.53\n\n# Instructions\n\nMake sure that the changes you propose are consistent with each other. For example, if you refer to a new config variable somewhere, you should also propose a change to add that variable.\n\nNote that the changes you propose will be applied sequentially, so you should assume that the previous changes have already been applied when writing the SEARCH block.\n\n# Task\n\nSuggest a new idea to improve the performance of the code that is inspired by your expert knowledge of the considered subject.\nYour goal is to maximize the `combined_score` of the program.\nDescribe each change with a SEARCH/REPLACE block.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.\n"
            },
            {
              "role": "assistant",
              "content": "<NAME>\nprereq_closure_and_normalized_marginal_gain\n</NAME>\n\n<DESCRIPTION>\nPrecompute transitive prerequisite closures for all variables to avoid repeated DFS and speed up feasibility and gain calculations. Change marginal_gain to return both the true added value and a normalized score that penalizes selections that require many prerequisite items (favoring compact high-value additions). Use the normalized score for greedy selection but the true added value for objective calculations and swaps. Update all call sites accordingly and improve candidate sorting when filling minimum cardinality. This focuses the greedy search on high-benefit, low-cost additions while keeping objective computations accurate.\n</DESCRIPTION>\n\n<DIFF>\n<<<<<<< SEARCH\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n\n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n\n    Improved greedy with precedence closure and small local search.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n\n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions_raw = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n\n    n = len(weights)\n\n    # Parse interactions into a dict for quick lookup (make symmetric)\n    interactions = {}\n    for k, v in interactions_raw.items():\n        try:\n            parts = [p.strip() for p in k.split(\",\")]\n            if len(parts) >= 2:\n                u = int(parts[0]); w = int(parts[1])\n                interactions[(u, w)] = float(v)\n                interactions[(w, u)] = float(v)\n        except Exception:\n            # ignore malformed keys\n            continue\n\n    # Build mutex map for O(1) checks\n    mutex_map = {i: set() for i in range(n)}\n    for a, b in mutex:\n        if 0 <= a < n and 0 <= b < n:\n            mutex_map[a].add(b)\n            mutex_map[b].add(a)\n\n    # Build variable->group index (assumes groups is dict: groupname -> [vars])\n    var_to_groups = {}\n    for g, vars_in_g in groups.items():\n        for v in vars_in_g:\n            if 0 <= v < n:\n                var_to_groups.setdefault(v, set()).add(g)\n\n    # Build precedence graph: prereq_of[j] = list of items that must be present if j selected\n    prereq_of = {}\n    for a, b in precedence:\n        # if b selected then a must be selected\n        if 0 <= a < n and 0 <= b < n:\n            prereq_of.setdefault(b, []).append(a)\n\n    # Helper: compute closure of prerequisites for an item (recursive)\n    def prerequisite_closure(start):\n        closure = set()\n        stack = [start]\n        while stack:\n            cur = stack.pop()\n            for p in prereq_of.get(cur, []):\n                if p not in closure and p != cur:\n                    closure.add(p)\n                    stack.append(p)\n        return closure\n\n    # Objective evaluation\n    def objective_of(selection_set):\n        total = 0.0\n        for i in selection_set:\n            total += weights[i] if i < len(weights) else 0.0\n        # pairwise interactions\n        sel_list = list(selection_set)\n        m = len(sel_list)\n        for ii in range(m):\n            u = sel_list[ii]\n            for jj in range(ii + 1, m):\n                v = sel_list[jj]\n                total += interactions.get((u, v), 0.0)\n        return total\n\n    # Feasibility check for adding a set of new items given current selection\n    def feasible_to_add(current_sel, to_add, max_card):\n        # Check cardinality\n        if len(current_sel | to_add) > max_card:\n            return False\n        # Check mutex: no pair (x,y) both in new selection or between new and current\n        for x in to_add:\n            # against current\n            for y in mutex_map.get(x, ()):\n                if y in current_sel:\n                    return False\n            # within to_add\n            for y in mutex_map.get(x, ()):\n                if y in to_add:\n                    return False\n        # Check group: at most one per group\n        # Build counts per group from current and to_add\n        group_counts = {}\n        for v in current_sel:\n            for g in var_to_groups.get(v, ()):\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in to_add:\n            for g in var_to_groups.get(v, ()):\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: ensure for any item in to_add, its prerequisites are included in current_sel or to_add\n        for v in list(to_add):\n            needed = prerequisite_closure(v)\n            if not needed.issubset(current_sel | to_add):\n                return False\n        return True\n\n    # Compute marginal gain of adding item i (including its prerequisites) given current_sel\n    def marginal_gain(current_sel, i):\n        if i in current_sel:\n            return -1e9, set()  # already present, no gain\n        # compute closure (prereqs)\n        req = prerequisite_closure(i) | {i}\n        # Determine which of these are truly new\n        new_items = set(x for x in req if x not in current_sel)\n        if not new_items:\n            return -1e9, set()\n        # Check feasibility wrt constraints (we'll check cardinality externally)\n        # For scoring, compute added weight + interactions with current selection and internal interactions\n        added = 0.0\n        for u in new_items:\n            added += weights[u] if u < len(weights) else 0.0\n            for v in current_sel:\n                added += interactions.get((u, v), 0.0)\n        # interactions among new_items (pairwise)\n        new_list = list(new_items)\n        for a_idx in range(len(new_list)):\n            u = new_list[a_idx]\n            for b_idx in range(a_idx + 1, len(new_list)):\n                v = new_list[b_idx]\n                added += interactions.get((u, v), 0.0)\n        return added, new_items\n\n    max_card = cardinality_bounds[1] if len(cardinality_bounds) > 1 else n\n    min_card = cardinality_bounds[0] if len(cardinality_bounds) > 0 else 0\n\n    selected_set = set()\n\n    # Main greedy loop: at each step choose item (with its prereqs) that gives best positive marginal and is feasible\n    while True:\n        best_gain = 0.0\n        best_item = None\n        best_new_set = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            gain, new_items = marginal_gain(selected_set, i)\n            if not new_items:\n                continue\n            # feasibility checks (mutex, groups, cardinality)\n            if not feasible_to_add(selected_set, new_items, max_card):\n                continue\n            if gain > best_gain + 1e-9:\n                best_gain = gain\n                best_item = i\n                best_new_set = new_items\n        if best_item is None:\n            break\n        # Add best_new_set to selection\n        selected_set |= best_new_set\n\n    # If we are below min_card, add best feasible items (ignore positive gain requirement)\n    if len(selected_set) < min_card:\n        candidates = []\n        for i in range(n):\n            if i in selected_set:\n                continue\n            gain, new_items = marginal_gain(selected_set, i)\n            if not new_items:\n                continue\n            # check feasibility w.r.t max cardinality\n            if not feasible_to_add(selected_set, new_items, max_card):\n                continue\n            candidates.append((gain, i, new_items))\n        # sort by gain descending, fall back to weight if ties\n        candidates.sort(key=lambda x: (-x[0], -max(weights[x[1]] if x[1] < len(weights) else 0.0, 0.0)))\n        for gain, i, new_items in candidates:\n            if len(selected_set) >= min_card:\n                break\n            if feasible_to_add(selected_set, new_items, max_card):\n                selected_set |= new_items\n\n    # Local improvement: try single swaps (replace one selected with one candidate and its prereqs)\n    improved = True\n    iter_limit = 5\n    iters = 0\n    while improved and iters < iter_limit:\n        improved = False\n        iters += 1\n        base_obj = objective_of(selected_set)\n        # Try each unselected candidate\n        unselected = [i for i in range(n) if i not in selected_set]\n        for cand in unselected:\n            gain, cand_new = marginal_gain(selected_set, cand)\n            if not cand_new:\n                continue\n            # If adding directly is feasible and increases obj, do it\n            if feasible_to_add(selected_set, cand_new, max_card):\n                new_obj = base_obj + gain\n                if new_obj > base_obj + 1e-9:\n                    selected_set |= cand_new\n                    improved = True\n                    base_obj = new_obj\n                    break\n            # Otherwise attempt swap: remove one selected item s and add cand_new\n            for s in list(selected_set):\n                trial_sel = set(selected_set)\n                trial_sel.remove(s)\n                # Ensure removing s doesn't violate precedence (if some remaining item requires s)\n                violated = False\n                for rem in trial_sel:\n                    needed = prerequisite_closure(rem)\n                    if s in needed:\n                        violated = True\n                        break\n                if violated:\n                    continue\n                # Now try to add cand_new to trial_sel\n                if not feasible_to_add(trial_sel, cand_new, max_card):\n                    continue\n                trial_obj = objective_of(trial_sel | cand_new)\n                if trial_obj > base_obj + 1e-9:\n                    selected_set = trial_sel | cand_new\n                    improved = True\n                    base_obj = trial_obj\n                    break\n            if improved:\n                break\n\n    # Final safety: if still below min_card, fill with any feasible items greedily\n    if len(selected_set) < min_card:\n        for i in range(n):\n            if len(selected_set) >= min_card:\n                break\n            if i in selected_set:\n                continue\n            _, new_items = marginal_gain(selected_set, i)\n            if not new_items:\n                continue\n            if feasible_to_add(selected_set, new_items, max_card):\n                selected_set |= new_items\n\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected_set)\n        }\n    }\n    print(json.dumps(result))\n=======\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n\n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n\n    Improved greedy with precedence closure and small local search.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n\n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions_raw = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n\n    n = len(weights)\n\n    # Parse interactions into a dict for quick lookup (make symmetric)\n    interactions = {}\n    for k, v in interactions_raw.items():\n        try:\n            parts = [p.strip() for p in k.split(\",\")]\n            if len(parts) >= 2:\n                u = int(parts[0]); w = int(parts[1])\n                interactions[(u, w)] = float(v)\n                interactions[(w, u)] = float(v)\n        except Exception:\n            # ignore malformed keys\n            continue\n\n    # Build mutex map for O(1) checks\n    mutex_map = {i: set() for i in range(n)}\n    for a, b in mutex:\n        if 0 <= a < n and 0 <= b < n:\n            mutex_map[a].add(b)\n            mutex_map[b].add(a)\n\n    # Build variable->group index (assumes groups is dict: groupname -> [vars])\n    var_to_groups = {}\n    for g, vars_in_g in groups.items():\n        for v in vars_in_g:\n            if 0 <= v < n:\n                var_to_groups.setdefault(v, set()).add(g)\n\n    # Build precedence graph: prereq_of[j] = list of items that must be present if j selected\n    prereq_of = {}\n    for a, b in precedence:\n        # if b selected then a must be selected\n        if 0 <= a < n and 0 <= b < n:\n            prereq_of.setdefault(b, []).append(a)\n\n    # Precompute transitive prerequisite closure for all nodes (memoized DFS)\n    prereq_closure_map = {}\n\n    def _build_closure(u, visiting):\n        if u in prereq_closure_map:\n            return prereq_closure_map[u]\n        if u in visiting:\n            # cycle: return empty to avoid infinite loop (cycles imply mutual prerequisites;\n            # we'll let feasibility checks handle such cases)\n            prereq_closure_map[u] = set()\n            return prereq_closure_map[u]\n        visiting.add(u)\n        closure = set()\n        for p in prereq_of.get(u, []):\n            closure.add(p)\n            closure |= _build_closure(p, visiting)\n        visiting.remove(u)\n        prereq_closure_map[u] = closure\n        return closure\n\n    for i in range(n):\n        _build_closure(i, set())\n\n    # Helper: compute closure of prerequisites for an item (use precomputed map)\n    def prerequisite_closure(start):\n        return prereq_closure_map.get(start, set())\n\n    # Objective evaluation\n    def objective_of(selection_set):\n        total = 0.0\n        for i in selection_set:\n            total += weights[i] if i < len(weights) else 0.0\n        # pairwise interactions\n        sel_list = list(selection_set)\n        m = len(sel_list)\n        for ii in range(m):\n            u = sel_list[ii]\n            for jj in range(ii + 1, m):\n                v = sel_list[jj]\n                total += interactions.get((u, v), 0.0)\n        return total\n\n    # Feasibility check for adding a set of new items given current selection\n    def feasible_to_add(current_sel, to_add, max_card):\n        # Check cardinality\n        if len(current_sel | to_add) > max_card:\n            return False\n        # Check mutex: no pair (x,y) both in new selection or between new and current\n        for x in to_add:\n            # against current\n            for y in mutex_map.get(x, ()):\n                if y in current_sel:\n                    return False\n            # within to_add\n            for y in mutex_map.get(x, ()):\n                if y in to_add:\n                    return False\n        # Check group: at most one per group\n        # Build counts per group from current and to_add\n        group_counts = {}\n        for v in current_sel:\n            for g in var_to_groups.get(v, ()):\n                group_counts[g] = group_counts.get(g, 0) + 1\n        for v in to_add:\n            for g in var_to_groups.get(v, ()):\n                group_counts[g] = group_counts.get(g, 0) + 1\n                if group_counts[g] > 1:\n                    return False\n        # Precedence: ensure for any item in to_add, its prerequisites are included in current_sel or to_add\n        for v in list(to_add):\n            needed = prerequisite_closure(v)\n            if not needed.issubset(current_sel | to_add):\n                return False\n        return True\n\n    # Compute marginal gain of adding item i (including its prerequisites) given current_sel\n    # Return: (normalized_score, true_added_value, new_items)\n    def marginal_gain(current_sel, i):\n        if i in current_sel:\n            return -1e9, -1e9, set()  # already present, no gain\n        # compute closure (prereqs) using precomputed map\n        req = prerequisite_closure(i) | {i}\n        # Determine which of these are truly new\n        new_items = set(x for x in req if x not in current_sel)\n        if not new_items:\n            return -1e9, -1e9, set()\n        # For scoring, compute added weight + interactions with current selection and internal interactions\n        added = 0.0\n        for u in new_items:\n            added += weights[u] if u < len(weights) else 0.0\n            for v in current_sel:\n                added += interactions.get((u, v), 0.0)\n        # interactions among new_items (pairwise)\n        new_list = list(new_items)\n        for a_idx in range(len(new_list)):\n            u = new_list[a_idx]\n            for b_idx in range(a_idx + 1, len(new_list)):\n                v = new_list[b_idx]\n                added += interactions.get((u, v), 0.0)\n        # Normalize score to penalize selections that require many prerequisites:\n        # Prefer compact high-value additions. Tunable factor.\n        size = max(1, len(new_items))\n        penalty = 1.0 + 0.4 * (size - 1)  # modest penalty per extra required item\n        normalized = added / penalty\n        return normalized, added, new_items\n\n    max_card = cardinality_bounds[1] if len(cardinality_bounds) > 1 else n\n    min_card = cardinality_bounds[0] if len(cardinality_bounds) > 0 else 0\n\n    selected_set = set()\n\n    # Main greedy loop: at each step choose item (with its prereqs) that gives best positive normalized marginal and is feasible\n    while True:\n        best_score = 0.0\n        best_item = None\n        best_new_set = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            score, added, new_items = marginal_gain(selected_set, i)\n            if not new_items:\n                continue\n            # feasibility checks (mutex, groups, cardinality)\n            if not feasible_to_add(selected_set, new_items, max_card):\n                continue\n            if score > best_score + 1e-9:\n                best_score = score\n                best_item = i\n                best_new_set = new_items\n        if best_item is None:\n            break\n        # Add best_new_set to selection\n        selected_set |= best_new_set\n\n    # If we are below min_card, add best feasible items (ignore positive normalized score requirement)\n    if len(selected_set) < min_card:\n        candidates = []\n        for i in range(n):\n            if i in selected_set:\n                continue\n            score, added, new_items = marginal_gain(selected_set, i)\n            if not new_items:\n                continue\n            # check feasibility w.r.t max cardinality\n            if not feasible_to_add(selected_set, new_items, max_card):\n                continue\n            candidates.append((score, added, i, new_items))\n        # sort by normalized score descending, tie-break by true added value\n        candidates.sort(key=lambda x: (-x[0], -x[1]))\n        for score, added, i, new_items in candidates:\n            if len(selected_set) >= min_card:\n                break\n            if feasible_to_add(selected_set, new_items, max_card):\n                selected_set |= new_items\n\n    # Local improvement: try single swaps (replace one selected with one candidate and its prereqs)\n    improved = True\n    iter_limit = 5\n    iters = 0\n    while improved and iters < iter_limit:\n        improved = False\n        iters += 1\n        base_obj = objective_of(selected_set)\n        # Try each unselected candidate\n        unselected = [i for i in range(n) if i not in selected_set]\n        for cand in unselected:\n            score, added, cand_new = marginal_gain(selected_set, cand)\n            if not cand_new:\n                continue\n            # If adding directly is feasible and increases obj, do it (use true added)\n            if feasible_to_add(selected_set, cand_new, max_card):\n                new_obj = base_obj + added\n                if new_obj > base_obj + 1e-9:\n                    selected_set |= cand_new\n                    improved = True\n                    base_obj = new_obj\n                    break\n            # Otherwise attempt swap: remove one selected item s and add cand_new\n            for s in list(selected_set):\n                trial_sel = set(selected_set)\n                trial_sel.remove(s)\n                # Ensure removing s doesn't violate precedence (if some remaining item requires s)\n                violated = False\n                for rem in trial_sel:\n                    needed = prerequisite_closure(rem)\n                    if s in needed:\n                        violated = True\n                        break\n                if violated:\n                    continue\n                # Now try to add cand_new to trial_sel\n                if not feasible_to_add(trial_sel, cand_new, max_card):\n                    continue\n                trial_obj = objective_of(trial_sel | cand_new)\n                if trial_obj > base_obj + 1e-9:\n                    selected_set = trial_sel | cand_new\n                    improved = True\n                    base_obj = trial_obj\n                    break\n            if improved:\n                break\n\n    # Final safety: if still below min_card, fill with any feasible items greedily (use true added)\n    if len(selected_set) < min_card:\n        for i in range(n):\n            if len(selected_set) >= min_card:\n                break\n            if i in selected_set:\n                continue\n            _, added, new_items = marginal_gain(selected_set, i)\n            if not new_items:\n                continue\n            if feasible_to_add(selected_set, new_items, max_card):\n                selected_set |= new_items\n\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected_set)\n        }\n    }\n    print(json.dumps(result))\n>>>>>>> REPLACE\n</DIFF>"
            }
          ],
          "model_name": "gpt-5-mini",
          "kwargs": {
            "temperature": 1.0,
            "max_output_tokens": 8192
          },
          "input_tokens": 4260,
          "output_tokens": 6060,
          "cost": 0.013184999999999999,
          "input_cost": 0.001065,
          "output_cost": 0.012119999999999999,
          "thought": "",
          "model_posteriors": {
            "gpt-5-mini": 1.0
          }
        },
        "diff_summary": {
          "added": 20,
          "deleted": 0,
          "modified": 31
        },
        "embed_cost": 4.896e-05,
        "novelty_cost": 0.0,
        "stdout_log": "Evaluating program: test_output/problem_0/gen_3/main.py\nSaving results to: test_output/problem_0/gen_3/results\nRun 1/1 completed in 0.00 seconds\nCorrectness and error status saved to test_output/problem_0/gen_3/results/correct.json\nMetrics saved to test_output/problem_0/gen_3/results/metrics.json\nEvaluation and Validation completed successfully.\nMetrics:\n  combined_score: 0.4073751773870285\n  public:\n    feasible: True\n    selection_size: 10\n    raw_score: 193.53014874422013\n  private:\n    selection: [0, 2, 6, 7, 9, 10, 11, 13, 15, 18]\n    raw_score: 193.53014874422013\n    normalized_fitness: 0.4073751773870285\n  execution_time_mean: 0.0011102090065833181\n  execution_time_std: 0.0\n  num_valid_runs: 1\n  num_invalid_runs: 0\n  all_validation_errors: []\n",
        "stderr_log": "",
        "code_analysis_metrics": {
          "cyclomatic_complexity": 56,
          "average_cyclomatic_complexity": 28.0,
          "halstead_volume": 1564.020340845066,
          "halstead_difficulty": 12.065217391304348,
          "halstead_effort": 18870.245416717644,
          "lines_of_code": 324,
          "logical_lines_of_code": 232,
          "comments": 52,
          "maintainability_index": -32.16299656070643,
          "max_nesting_depth": 6,
          "complexity_score": 1.0
        }
      },
      "in_archive": false
    },
    {
      "id": "eb147a68-981c-469e-91a4-97e9a40b992d",
      "code": "\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n\n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n\n    Improved greedy with precedence-closure and small local search.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n\n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    raw_interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n\n    n = len(weights)\n\n    # Parse interactions into a symmetric dict for quick lookup\n    interactions = {}\n    for k, v in raw_interactions.items():\n        try:\n            u, w = map(int, k.split(\",\"))\n            interactions[(u, w)] = float(v)\n            interactions[(w, u)] = float(v)\n        except Exception:\n            # ignore malformed keys\n            continue\n\n    # Build precedence map: if (i, j) in precedence then selecting j requires i\n    pred_map = {}  # pred_map[j] = set([i,...])\n    for pair in precedence:\n        try:\n            i, j = pair\n            pred_map.setdefault(j, set()).add(i)\n        except Exception:\n            continue\n\n    # Compute transitive closure for a given item (its required predecessors)\n    def closure_of(item):\n        stack = [item]\n        closure = set()\n        while stack:\n            cur = stack.pop()\n            if cur in closure:\n                continue\n            closure.add(cur)\n            for p in pred_map.get(cur, ()):\n                if p not in closure:\n                    stack.append(p)\n        return closure\n\n    # Objective for a set (weights + interactions among all unordered pairs)\n    def objective_of(varset):\n        s = 0.0\n        for i in varset:\n            if 0 <= i < n:\n                s += weights[i]\n        # pairwise interactions (count each pair once)\n        seen = set()\n        for i in varset:\n            for j in varset:\n                if j <= i:\n                    continue\n                if (i, j) in interactions:\n                    s += interactions[(i, j)]\n        return s\n\n    # Check mutex and group feasibility for union selected U to_add\n    def feasible_union(selected_set, to_add):\n        union = set(selected_set) | set(to_add)\n        # cardinality upper bound\n        if len(union) > cardinality_bounds[1]:\n            return False\n        # mutex pairs\n        for a, b in mutex:\n            if a in union and b in union:\n                return False\n        # group constraints: at most one per group\n        for grp_vars in groups.values():\n            cnt = 0\n            for v in grp_vars:\n                if v in union:\n                    cnt += 1\n                    if cnt > 1:\n                        return False\n        # precedence: every selected element must have its preds in union\n        for j in list(union):\n            for p in pred_map.get(j, ()):\n                if p not in union:\n                    return False\n        return True\n\n    # Check if an item is removable (no selected item depends on it)\n    # i.e., no other selected has i in its transitive predecessors\n    # Precompute reverse closure check by scanning selected set when needed\n    def removable(selected_set, item):\n        for j in selected_set:\n            if j == item:\n                continue\n            # if item is in closure of j, cannot remove\n            if item in closure_of(j):\n                return False\n        return True\n\n    # Greedy selection using closure-aware delta objective\n    selected_set = set()\n    # Precompute candidate base scores to order attempts (weight + small interaction potential)\n    base_scores = []\n    for i in range(n):\n        score = weights[i]\n        # add half of absolute interactions as potential\n        for (u, v), val in interactions.items():\n            if u == i or v == i:\n                score += abs(val) * 0.25\n        base_scores.append((score, i))\n    base_scores.sort(reverse=True)\n    candidates = [i for _, i in base_scores]\n\n    # Iteratively add the best feasible closure that gives positive objective delta\n    improved = True\n    while improved:\n        improved = False\n        best_delta = 0.0\n        best_add = None\n        cur_obj = objective_of(selected_set)\n        for i in candidates:\n            if i in selected_set:\n                continue\n            cl = closure_of(i)\n            to_add = cl - selected_set\n            if not to_add:\n                continue\n            if not feasible_union(selected_set, to_add):\n                continue\n            new_obj = objective_of(selected_set | to_add)\n            delta = new_obj - cur_obj\n            if delta > best_delta + 1e-9:\n                best_delta = delta\n                best_add = to_add\n        if best_add:\n            selected_set |= set(best_add)\n            improved = True\n        # stop if hit upper bound\n        if len(selected_set) >= cardinality_bounds[1]:\n            break\n\n    # Local improvement: try beneficial removals and additions until no change\n    changed = True\n    while changed:\n        changed = False\n        cur_obj = objective_of(selected_set)\n        # Attempt removals\n        for i in list(selected_set):\n            if not removable(selected_set, i):\n                continue\n            new_set = set(selected_set)\n            new_set.remove(i)\n            if not feasible_union(set(), new_set):  # new_set should be self-consistent\n                continue\n            new_obj = objective_of(new_set)\n            if new_obj > cur_obj + 1e-9:\n                selected_set = new_set\n                changed = True\n                break\n        if changed:\n            continue\n        # Attempt any single-item addition (with closure) that improves objective\n        cur_obj = objective_of(selected_set)\n        best_delta = 0.0\n        best_add = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            cl = closure_of(i)\n            to_add = cl - selected_set\n            if not to_add:\n                continue\n            if not feasible_union(selected_set, to_add):\n                continue\n            new_obj = objective_of(selected_set | to_add)\n            delta = new_obj - cur_obj\n            if delta > best_delta + 1e-9:\n                best_delta = delta\n                best_add = to_add\n        if best_add:\n            selected_set |= set(best_add)\n            changed = True\n\n    # Ensure minimum cardinality: add best feasible candidates (even if delta <= 0) until min satisfied\n    while len(selected_set) < cardinality_bounds[0]:\n        best_choice = None\n        best_delta = None\n        cur_obj = objective_of(selected_set)\n        for i in range(n):\n            if i in selected_set:\n                continue\n            cl = closure_of(i)\n            to_add = cl - selected_set\n            if not to_add:\n                continue\n            if not feasible_union(selected_set, to_add):\n                continue\n            new_obj = objective_of(selected_set | to_add)\n            delta = new_obj - cur_obj\n            if best_choice is None or delta > best_delta:\n                best_choice = to_add\n                best_delta = delta\n        if best_choice:\n            selected_set |= set(best_choice)\n        else:\n            # No feasible addition to reach min (shouldn't happen in feasible instances), break to avoid infinite loop\n            break\n\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected_set)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n\n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n\n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n\n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n\n    result_str = stdout_capture.getvalue()\n    return result_str\n",
      "language": "python",
      "parent_id": "13a89a1d-a497-4121-b03c-1c796e067ee2",
      "archive_inspiration_ids": [],
      "top_k_inspiration_ids": [],
      "island_idx": 1,
      "generation": 4,
      "timestamp": 1764626991.0902,
      "code_diff": "--- a/original.py\n+++ b/original.py\n@@ -1,144 +1,271 @@\n \"\"\"\n Initial solution for Synergistic Dependency Selection (SDS) problem.\n The code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n \"\"\"\n \n import json\n import sys\n import contextlib\n \n # EVOLVE-BLOCK-START\n def solve_sds():\n     \"\"\"\n     Solve the Synergistic Dependency Selection problem.\n \n     Reads from stdin: JSON with \"requirements\" and \"catalog\"\n     Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n \n-    This is a greedy baseline - evolution will improve this.\n+    Improved greedy with precedence-closure and small local search.\n     \"\"\"\n     # Read input\n     input_data = json.load(sys.stdin)\n     requirements = input_data.get(\"requirements\", {})\n     catalog = input_data.get(\"catalog\", {})\n \n     # Extract constraints\n     weights = requirements.get(\"weights\", [])\n-    interactions = requirements.get(\"interactions\", {})\n+    raw_interactions = requirements.get(\"interactions\", {})\n     cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n     mutex = requirements.get(\"mutex\", [])\n     groups = requirements.get(\"groups\", {})\n     precedence = requirements.get(\"precedence\", [])\n \n-    # Simple greedy: select items with highest weights first\n-    # This is a baseline - evolution will find better strategies\n     n = len(weights)\n-    selected = []\n-\n-    # Create score list (weight + interaction potential)\n-    scores = []\n+\n+    # Parse interactions into a symmetric dict for quick lookup\n+    interactions = {}\n+    for k, v in raw_interactions.items():\n+        try:\n+            u, w = map(int, k.split(\",\"))\n+            interactions[(u, w)] = float(v)\n+            interactions[(w, u)] = float(v)\n+        except Exception:\n+            # ignore malformed keys\n+            continue\n+\n+    # Build precedence map: if (i, j) in precedence then selecting j requires i\n+    pred_map = {}  # pred_map[j] = set([i,...])\n+    for pair in precedence:\n+        try:\n+            i, j = pair\n+            pred_map.setdefault(j, set()).add(i)\n+        except Exception:\n+            continue\n+\n+    # Compute transitive closure for a given item (its required predecessors)\n+    def closure_of(item):\n+        stack = [item]\n+        closure = set()\n+        while stack:\n+            cur = stack.pop()\n+            if cur in closure:\n+                continue\n+            closure.add(cur)\n+            for p in pred_map.get(cur, ()):\n+                if p not in closure:\n+                    stack.append(p)\n+        return closure\n+\n+    # Objective for a set (weights + interactions among all unordered pairs)\n+    def objective_of(varset):\n+        s = 0.0\n+        for i in varset:\n+            if 0 <= i < n:\n+                s += weights[i]\n+        # pairwise interactions (count each pair once)\n+        seen = set()\n+        for i in varset:\n+            for j in varset:\n+                if j <= i:\n+                    continue\n+                if (i, j) in interactions:\n+                    s += interactions[(i, j)]\n+        return s\n+\n+    # Check mutex and group feasibility for union selected U to_add\n+    def feasible_union(selected_set, to_add):\n+        union = set(selected_set) | set(to_add)\n+        # cardinality upper bound\n+        if len(union) > cardinality_bounds[1]:\n+            return False\n+        # mutex pairs\n+        for a, b in mutex:\n+            if a in union and b in union:\n+                return False\n+        # group constraints: at most one per group\n+        for grp_vars in groups.values():\n+            cnt = 0\n+            for v in grp_vars:\n+                if v in union:\n+                    cnt += 1\n+                    if cnt > 1:\n+                        return False\n+        # precedence: every selected element must have its preds in union\n+        for j in list(union):\n+            for p in pred_map.get(j, ()):\n+                if p not in union:\n+                    return False\n+        return True\n+\n+    # Check if an item is removable (no selected item depends on it)\n+    # i.e., no other selected has i in its transitive predecessors\n+    # Precompute reverse closure check by scanning selected set when needed\n+    def removable(selected_set, item):\n+        for j in selected_set:\n+            if j == item:\n+                continue\n+            # if item is in closure of j, cannot remove\n+            if item in closure_of(j):\n+                return False\n+        return True\n+\n+    # Greedy selection using closure-aware delta objective\n+    selected_set = set()\n+    # Precompute candidate base scores to order attempts (weight + small interaction potential)\n+    base_scores = []\n     for i in range(n):\n-        score = weights[i] if i < len(weights) else 0.0\n-        # Add potential interaction value\n-        for k, v in interactions.items():\n-            try:\n-                u, w = map(int, k.split(\",\"))\n-                if u == i or w == i:\n-                    score += abs(v) * 0.5  # Potential value\n-            except:\n-                pass\n-        scores.append((score, i))\n-\n-    # Sort by score descending\n-    scores.sort(reverse=True)\n-\n-    # Greedy selection respecting constraints\n-    selected_set = set()\n-    for score, i in scores:\n+        score = weights[i]\n+        # add half of absolute interactions as potential\n+        for (u, v), val in interactions.items():\n+            if u == i or v == i:\n+                score += abs(val) * 0.25\n+        base_scores.append((score, i))\n+    base_scores.sort(reverse=True)\n+    candidates = [i for _, i in base_scores]\n+\n+    # Iteratively add the best feasible closure that gives positive objective delta\n+    improved = True\n+    while improved:\n+        improved = False\n+        best_delta = 0.0\n+        best_add = None\n+        cur_obj = objective_of(selected_set)\n+        for i in candidates:\n+            if i in selected_set:\n+                continue\n+            cl = closure_of(i)\n+            to_add = cl - selected_set\n+            if not to_add:\n+                continue\n+            if not feasible_union(selected_set, to_add):\n+                continue\n+            new_obj = objective_of(selected_set | to_add)\n+            delta = new_obj - cur_obj\n+            if delta > best_delta + 1e-9:\n+                best_delta = delta\n+                best_add = to_add\n+        if best_add:\n+            selected_set |= set(best_add)\n+            improved = True\n+        # stop if hit upper bound\n         if len(selected_set) >= cardinality_bounds[1]:\n             break\n \n-        # Check mutex constraints\n-        can_add = True\n-        for a, b in mutex:\n-            if (a == i and b in selected_set) or (b == i and a in selected_set):\n-                can_add = False\n+    # Local improvement: try beneficial removals and additions until no change\n+    changed = True\n+    while changed:\n+        changed = False\n+        cur_obj = objective_of(selected_set)\n+        # Attempt removals\n+        for i in list(selected_set):\n+            if not removable(selected_set, i):\n+                continue\n+            new_set = set(selected_set)\n+            new_set.remove(i)\n+            if not feasible_union(set(), new_set):  # new_set should be self-consistent\n+                continue\n+            new_obj = objective_of(new_set)\n+            if new_obj > cur_obj + 1e-9:\n+                selected_set = new_set\n+                changed = True\n                 break\n-\n-        if not can_add:\n+        if changed:\n             continue\n-\n-        # Check group constraints (at most one per group)\n-        for grp_vars in groups.values():\n-            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n-                can_add = False\n-                break\n-\n-        if not can_add:\n-            continue\n-\n-        # Check precedence (if j selected, i must be selected)\n-        precedence_ok = True\n-        for pred_i, pred_j in precedence:\n-            if pred_j == i and pred_i not in selected_set:\n-                precedence_ok = False\n-                break\n-\n-        if not precedence_ok:\n-            continue\n-\n-        # Add if we meet minimum cardinality or have room\n-        if len(selected_set) < cardinality_bounds[1]:\n-            selected_set.add(i)\n-            selected.append(i)\n-\n-    # Ensure minimum cardinality\n-    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n+        # Attempt any single-item addition (with closure) that improves objective\n+        cur_obj = objective_of(selected_set)\n+        best_delta = 0.0\n+        best_add = None\n         for i in range(n):\n-            if i not in selected_set:\n-                selected_set.add(i)\n-                selected.append(i)\n-                break\n-\n-    # Output result\n+            if i in selected_set:\n+                continue\n+            cl = closure_of(i)\n+            to_add = cl - selected_set\n+            if not to_add:\n+                continue\n+            if not feasible_union(selected_set, to_add):\n+                continue\n+            new_obj = objective_of(selected_set | to_add)\n+            delta = new_obj - cur_obj\n+            if delta > best_delta + 1e-9:\n+                best_delta = delta\n+                best_add = to_add\n+        if best_add:\n+            selected_set |= set(best_add)\n+            changed = True\n+\n+    # Ensure minimum cardinality: add best feasible candidates (even if delta <= 0) until min satisfied\n+    while len(selected_set) < cardinality_bounds[0]:\n+        best_choice = None\n+        best_delta = None\n+        cur_obj = objective_of(selected_set)\n+        for i in range(n):\n+            if i in selected_set:\n+                continue\n+            cl = closure_of(i)\n+            to_add = cl - selected_set\n+            if not to_add:\n+                continue\n+            if not feasible_union(selected_set, to_add):\n+                continue\n+            new_obj = objective_of(selected_set | to_add)\n+            delta = new_obj - cur_obj\n+            if best_choice is None or delta > best_delta:\n+                best_choice = to_add\n+                best_delta = delta\n+        if best_choice:\n+            selected_set |= set(best_choice)\n+        else:\n+            # No feasible addition to reach min (shouldn't happen in feasible instances), break to avoid infinite loop\n+            break\n+\n     result = {\n         \"selection\": {\n-            \"variables\": sorted(selected)\n+            \"variables\": sorted(selected_set)\n         }\n     }\n     print(json.dumps(result))\n # EVOLVE-BLOCK-END\n \n \n # This part remains fixed (not evolved)\n def run_sds(problem_data=None):\n     \"\"\"\n     Main function called by the evaluator.\n     Can accept problem_data as parameter or read from stdin.\n     Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n     \"\"\"\n     import sys\n     import json\n     import io\n \n     if problem_data is None:\n         # Read from stdin (for compatibility)\n         input_data = json.load(sys.stdin)\n     else:\n         # Use provided problem data\n         input_data = problem_data\n \n     # Capture stdout from solve_sds\n     stdout_capture = io.StringIO()\n     old_stdin = sys.stdin\n \n     try:\n         # Create mock stdin\n         sys.stdin = io.StringIO(json.dumps(input_data))\n         with contextlib.redirect_stdout(stdout_capture):\n             solve_sds()\n     finally:\n         sys.stdin = old_stdin\n \n     result_str = stdout_capture.getvalue()\n     return result_str\n",
      "combined_score": 0.4073751773870285,
      "public_metrics": {
        "feasible": true,
        "selection_size": 10,
        "raw_score": 193.53014874422013
      },
      "private_metrics": {
        "selection": [
          0,
          2,
          6,
          7,
          9,
          10,
          11,
          13,
          15,
          18
        ],
        "raw_score": 193.53014874422013,
        "normalized_fitness": 0.4073751773870285
      },
      "text_feedback": "",
      "correct": true,
      "children_count": 0,
      "complexity": 1.0,
      "embedding": [
        0.020979801,
        0.0037044752,
        0.021053156,
        -0.015465879,
        0.013790918,
        0.032227714,
        0.039930087,
        0.0064858883,
        -0.02259363,
        0.033523668,
        0.028706627,
        -0.06963924,
        -0.019634942,
        0.0145244775,
        0.0060090744,
        -0.0370203,
        0.03814509,
        0.0057584415,
        -0.011480206,
        -0.0060090744,
        0.042399738,
        0.03144525,
        0.043695692,
        0.037435986,
        0.005932662,
        -0.0059601706,
        0.04320665,
        0.09330876,
        0.024280818,
        -0.036335643,
        0.024170784,
        -0.012763934,
        -0.03442839,
        0.0030534412,
        -0.004997374,
        0.032081,
        0.0021594157,
        0.035088595,
        -0.053598743,
        -0.011724725,
        0.002266393,
        -0.03281456,
        -0.02948909,
        0.0032429441,
        -0.008209753,
        -0.012054827,
        0.0008130284,
        -0.008876069,
        0.023632841,
        -0.021089835,
        -0.038071737,
        0.024293045,
        0.017617652,
        -0.006369741,
        -0.01893806,
        -0.03667797,
        0.02049076,
        0.01714084,
        0.0021823393,
        -0.0096096285,
        0.024525337,
        -0.0444048,
        0.042032957,
        0.022398015,
        -0.010477674,
        0.01295955,
        0.016969675,
        0.0052969106,
        -0.028926695,
        -0.02073528,
        -0.04110378,
        -0.004945413,
        0.012501076,
        -0.023718422,
        0.0063636284,
        0.032643396,
        0.024977699,
        0.038585227,
        0.0053947186,
        -0.037802763,
        -0.049564168,
        -0.025112186,
        0.003401882,
        -0.02128545,
        -0.06548241,
        -0.06504227,
        -0.0040559727,
        0.02424414,
        -0.037240367,
        -0.05403888,
        -0.01199981,
        -0.0082831085,
        -0.06650939,
        0.019586038,
        0.009970295,
        -0.04357343,
        0.04095707,
        -0.022495823,
        0.015074647,
        -0.005715651,
        -0.007989685,
        -0.037827216,
        0.0029877266,
        -0.02381623,
        -0.0052235546,
        0.016187211,
        0.032741204,
        0.03865858,
        0.017984433,
        -0.01640728,
        -0.03677578,
        0.024354175,
        0.015258037,
        0.054234497,
        0.0314697,
        -0.05491915,
        -0.061129954,
        -0.026823824,
        0.0004286738,
        -0.012641675,
        -0.021798942,
        -0.018974738,
        0.0009528632,
        0.03565099,
        -0.02665266,
        0.033328053,
        0.028413203,
        -0.07570334,
        -0.02799752,
        0.006128278,
        0.052131627,
        0.01530694,
        -0.010557143,
        -0.04159282,
        -0.063477345,
        -0.02079641,
        -0.03415942,
        -0.020833088,
        -0.022165721,
        0.04834157,
        0.014976839,
        0.0036372324,
        0.0002351593,
        0.023229383,
        -0.05511477,
        -0.027557384,
        0.0013929988,
        0.01363198,
        -0.09653643,
        0.04636096,
        0.041421656,
        -0.033254694,
        0.0015970201,
        -0.00046000292,
        0.0542834,
        -0.05364765,
        -0.035944413,
        0.006718182,
        0.059271604,
        -0.03489298,
        -0.026554853,
        0.002708057,
        -0.0047742496,
        0.00082525436,
        0.04095707,
        -0.027801903,
        -0.036653522,
        0.040932618,
        -0.030369362,
        -0.02448866,
        -0.0093589965,
        -0.080740444,
        -0.010214816,
        0.010899471,
        0.0013662545,
        -0.017397584,
        -0.0036188932,
        -0.022556953,
        0.013167392,
        -0.036995847,
        -0.036849137,
        -0.029024502,
        -0.013766466,
        -0.05403888,
        -0.015600365,
        -0.04897732,
        -0.019048095,
        -0.018424569,
        0.0051135207,
        0.010966714,
        -0.010618273,
        0.023620615,
        0.013301878,
        -0.011724725,
        0.0072377864,
        -0.020368502,
        0.054870248,
        0.04997985,
        0.0045297295,
        0.009646307,
        0.021065382,
        0.008380917,
        0.036433455,
        -0.02799752,
        -0.02238579,
        -0.017825495,
        -0.05932051,
        -0.020710828,
        -0.01652954,
        -0.057804484,
        0.028926695,
        -0.028657723,
        0.0032368312,
        0.054625727,
        0.046849996,
        0.0025644016,
        -0.020637473,
        0.0014992121,
        -0.01104007,
        0.0333525,
        -0.02802197,
        0.011920341,
        0.009004442,
        0.015392522,
        0.0026133056,
        0.036971398,
        -0.027606288,
        -0.037289273,
        0.012727257,
        -0.0394655,
        -0.0073417076,
        -0.00789799,
        0.006219973,
        0.03357257,
        -0.006394193,
        -0.02665266,
        -0.03428168,
        0.026970536,
        0.01363198,
        -0.003554707,
        0.031298537,
        -0.012054827,
        0.009658533,
        0.0058195717,
        0.014915709,
        -0.0055047525,
        -0.035724346,
        -0.00054443866,
        0.000706433,
        -0.0062780464,
        0.013680884,
        -0.015893789,
        0.018644636,
        -0.029684706,
        -0.020478535,
        -0.031005112,
        -0.022324659,
        -0.016994128,
        -0.00095439143,
        0.054087784,
        -0.05971174,
        0.0016795455,
        0.017495394,
        -0.01808224,
        -0.04303549,
        0.008478724,
        0.016627347,
        -0.013815369,
        -0.0111012,
        0.0024727066,
        -0.004902622,
        0.027679643,
        -0.04477158,
        0.020234015,
        -0.04589637,
        -0.006207747,
        0.0015954918,
        0.05516367,
        -0.0253078,
        -0.013717562,
        -0.0666072,
        0.003444673,
        0.037582695,
        -0.0026622096,
        0.05614175,
        0.016077178,
        -0.0033927124,
        0.0064308713,
        2.4625103e-06,
        0.042522,
        0.00989694,
        -0.021676682,
        0.02640814,
        -0.036849137,
        -0.031689767,
        -0.020833088,
        0.0015954918,
        0.031934287,
        0.009432352,
        0.0050279386,
        0.07795292,
        0.007824634,
        -0.007806295,
        -0.009511821,
        -0.019952817,
        -0.020930896,
        0.034868527,
        -0.044575963,
        0.030271554,
        0.036066674,
        -0.023901813,
        0.0010735948,
        0.013216296,
        0.008148623,
        -0.03418387,
        -0.025576772,
        0.05897818,
        -0.03132299,
        0.020331822,
        0.009230623,
        -0.026114717,
        0.0031237407,
        0.035113048,
        -0.004120159,
        0.017617652,
        -0.058342427,
        -0.019219257,
        -0.011798081,
        0.0040498595,
        -0.0172631,
        -0.03342586,
        0.013864274,
        0.029464638,
        0.044111375,
        0.0023428055,
        -0.06631377,
        0.026750468,
        0.013595302,
        0.020576343,
        0.002665266,
        -0.032081,
        0.0046275374,
        -0.026848275,
        -0.050028756,
        0.00861321,
        -0.017507618,
        -0.030687237,
        0.074187316,
        0.053403128,
        -0.018559054,
        0.009903053,
        -0.014451121,
        -0.017727686,
        0.03599332,
        -0.013546398,
        -0.014341087,
        -0.015135777,
        -0.011706387,
        -0.023962943,
        -0.029806966,
        0.039343238,
        0.008515403,
        -0.0132529745,
        0.004844549,
        -0.014402217,
        0.017275326,
        -0.03677578,
        0.02485544,
        0.006054922,
        -0.015245811,
        0.047803625,
        0.018595733,
        -0.034624007,
        0.021481067,
        -0.06709624,
        -0.006595922,
        0.005046278,
        0.030002581,
        0.015808206,
        0.058293525,
        -0.01671293,
        0.016456183,
        -0.025087733,
        -0.016431732,
        0.015747076,
        -0.002782941,
        -0.028070875,
        -0.032887917,
        -0.01744649,
        -0.0166518,
        0.03516195,
        -0.021933427,
        0.032032095,
        0.00445943,
        -0.006828216,
        0.0148056755,
        0.00032207844,
        0.013839821,
        0.021921203,
        0.03614003,
        0.013460816,
        0.0065592444,
        -0.011382397,
        -0.042595353,
        -0.036849137,
        0.00066478824,
        0.033205792,
        0.029440187,
        0.008619323,
        -0.010905584,
        0.041788436,
        0.009768567,
        0.042081863,
        -0.014842353,
        0.01042877,
        0.006834329,
        -0.028119778,
        0.04418473,
        0.022153495,
        0.0678787,
        -0.0046153115,
        -0.00808138,
        0.031763125,
        -0.03393935,
        -0.008344239,
        0.030956209,
        0.04821931,
        -0.0314697,
        0.058146812,
        0.013852048,
        -0.009193945,
        0.033645928,
        0.054381207,
        -0.008075267,
        -0.0004802522,
        0.05575052,
        0.043377817,
        0.022239078,
        0.021212094,
        -0.024378626,
        -0.0023382208,
        0.017691009,
        0.024329722,
        -0.006791538,
        -0.005468074,
        0.022239078,
        0.026823824,
        -0.014646737,
        0.03565099,
        0.019928366,
        0.013155166,
        -0.016981902,
        0.019084772,
        -0.025026603,
        0.00020134679,
        0.019476004,
        0.042008504,
        -0.027728548,
        0.06401529,
        -0.003021348,
        0.053500935,
        0.058391333,
        -0.027043892,
        0.019573811,
        0.0017865229,
        0.02616362,
        0.03540647,
        0.009585177,
        -0.033914898,
        0.046189792,
        0.0151724545,
        0.0019760258,
        -0.04863499,
        -0.011712499,
        -0.018338986,
        -0.024745407,
        0.04543178,
        0.005465018,
        -0.009120589,
        0.01199981,
        -0.011871438,
        -0.021089835,
        0.0036341758,
        0.02738622,
        0.022911508,
        0.03936769,
        -0.0014663548,
        -0.030320458,
        -0.01667625,
        0.012464398,
        0.03577325,
        0.004844549,
        0.013277426,
        -0.01236659,
        -0.012421607,
        -0.02875553,
        -0.0047131195,
        0.021432161,
        -0.020930896,
        -0.004771193,
        0.027606288,
        -0.024892118,
        -0.04230193,
        0.054576825,
        0.0444048,
        -0.010141459,
        -0.0011866853,
        -0.032887917,
        -0.011199008,
        -1.2631932e-05,
        -0.013705336,
        0.020943122,
        -0.032887917,
        0.033156887,
        0.033988256,
        -0.0012936627,
        -0.03983228,
        -0.04834157,
        -0.015869336,
        0.0037044752,
        -0.01610163,
        -0.031249633,
        -0.02146884,
        0.020466309,
        -0.0112479115,
        -0.02516109,
        0.011382397,
        -0.07609457,
        -0.029635802,
        -0.007708487,
        0.011749177,
        -0.010862793,
        -0.05022437,
        0.077806205,
        -0.041739535,
        -0.0031329102,
        -0.0182045,
        -0.031005112,
        -0.030491622,
        0.010092556,
        -0.008313674,
        -0.021481067,
        -0.022899281,
        -0.013962082,
        0.03406161,
        -0.031347442,
        0.05022437,
        0.01132738,
        -0.006858781,
        0.0059051537,
        -0.026946085,
        -0.027092796,
        -0.010667177,
        0.011688047,
        -0.012947325,
        0.005675916,
        -0.035210855,
        -0.017715462,
        -0.0071888827,
        -0.043989114,
        0.006748747,
        0.000816849,
        0.021798942,
        0.018363439,
        -0.017605428,
        -0.0072377864,
        0.050664507,
        0.029293474,
        -0.02201901,
        0.010801663,
        0.008668227,
        -0.01430441,
        0.015221358,
        -0.049637523,
        0.041250493,
        0.02875553,
        -0.021884523,
        -0.028095327,
        -0.011296815,
        -0.0045175035,
        -0.011364059,
        -0.019744975,
        -0.005944888,
        -0.010679403,
        -0.062499266,
        0.0040315203,
        -0.023779552,
        -0.004150724,
        0.020979801,
        0.007904103,
        -0.0072561256,
        -0.005782894,
        0.030540526,
        0.015869336,
        -0.014768997,
        0.000706433,
        -0.0049606957,
        -0.011791969,
        -0.0009796076,
        0.019952817,
        0.023278287,
        -0.04303549,
        0.019170353,
        0.0128861945,
        -0.0431822,
        -0.021786716,
        0.060885433,
        0.01677406,
        0.017813269,
        0.024341948,
        -0.01838789,
        -0.032496683,
        0.013546398,
        0.0058317976,
        -0.040516935,
        0.006773199,
        -0.03369483,
        0.033523668,
        0.01138851,
        -0.020502986,
        0.019842783,
        -0.017055258,
        0.00615273,
        0.015282488,
        0.057804484,
        0.0049179047,
        0.017250873,
        0.010764985,
        -0.005642295,
        -0.019524908,
        -0.030075938,
        -0.0030259327,
        -0.00959129,
        0.004710063,
        -0.008008024,
        0.0030916475,
        0.0075495495,
        0.008154736,
        -0.00934677,
        0.025234446,
        0.016847415,
        0.005761498,
        -0.00068083487,
        -0.034844074,
        0.025870197,
        0.012018149,
        -0.022165721,
        -0.009083911,
        0.030760594,
        -0.008711019,
        -0.022679213,
        -0.0040315203,
        0.00802025,
        -0.015282488,
        0.051055737,
        0.04555404,
        -0.0010231626,
        -0.02326606,
        -0.018363439,
        0.005468074,
        0.0033804865,
        -0.022642536,
        0.02787526,
        0.044820484,
        0.017568748,
        0.014451121,
        0.03428168,
        0.03772941,
        0.009927505,
        0.017030805,
        -0.046556573,
        -0.0056392383,
        0.029586898,
        -0.008796601,
        -0.013375234,
        -0.023363868,
        0.028095327,
        -0.0023366925,
        -0.038071737,
        0.017593201,
        -0.0082280915,
        0.011437414,
        -0.007250013,
        0.015209133,
        0.013925403,
        -0.04513836,
        0.008032476,
        0.00651034,
        0.008753809,
        0.013595302,
        0.0072989166,
        0.004260758,
        -0.0023122404,
        -0.022129044,
        0.033474762,
        0.025381157,
        0.014108794,
        0.038805295,
        -0.025112186,
        -0.085044,
        -0.0033163,
        0.018546829,
        0.0014869862,
        -0.011082861,
        -0.011908115,
        -0.036653522,
        -0.021187643,
        0.014707867,
        0.020906445,
        0.0063086115,
        -0.0050829556,
        0.020466309,
        -0.010911697,
        -0.01169416,
        -0.0038542436,
        0.003469125,
        0.024537563,
        0.01561259,
        0.038585227,
        -0.01875467,
        -0.060396396,
        -0.028388752,
        -0.019072546,
        0.00867434,
        -0.064259805,
        -0.040688097,
        -0.0073111425,
        0.028706627,
        0.0006602035,
        0.0012806725,
        0.0025567603,
        -0.00869268,
        -0.03689804,
        0.023131575,
        0.0012928986,
        -0.020246241,
        -0.020502986,
        0.0025384214,
        -0.028706627,
        0.0271417,
        -0.0077573913,
        -0.0029739724,
        0.024219688,
        0.008093606,
        -0.026921632,
        -0.0024772915,
        0.0036280628,
        0.023742875,
        -0.02799752,
        0.032618944,
        -0.03587106,
        0.008276996,
        -0.0091328155,
        -0.0054069445,
        0.023901813,
        0.002278619,
        0.023278287,
        -0.0065164533,
        -0.028290942,
        0.017580975,
        -0.010086442,
        -0.017605428,
        -0.045749657,
        0.0093589965,
        0.018559054,
        0.023217157,
        -0.00056659826,
        -0.024989925,
        0.020478535,
        0.021212094,
        0.022874828,
        0.018901382,
        -0.007855199,
        0.013790918,
        0.007781843,
        -0.011950906,
        -0.004997374,
        -0.039098717,
        0.008698792,
        0.022899281,
        0.017544298,
        0.0070360578,
        -0.012177087,
        0.024843214,
        0.018656863,
        -0.005128803,
        0.0029693875,
        0.005348871,
        0.032252163,
        -0.039661113,
        -0.027728548,
        0.0050401646,
        0.0065714703,
        0.03516195,
        -0.017043032,
        0.05071341,
        -0.0333036,
        -0.11893444,
        -0.0064736623,
        -0.0074639674,
        -0.024097428,
        0.013790918,
        -0.009774679,
        0.026236977,
        0.019781653,
        -0.010746646,
        -0.009872488,
        -0.029073406,
        -0.028046424,
        0.0044808257,
        0.020710828,
        0.012519415,
        -0.012287121,
        -0.02110206,
        -0.006131334,
        0.015221358,
        -0.033376954,
        -0.013742014,
        0.011357945,
        -0.00082983915,
        0.00050394004,
        -0.05516367,
        0.0036464017,
        0.006638713,
        0.03481962,
        -0.0010606047,
        0.0083686905,
        -0.007708487,
        0.0039765034,
        -0.012922873,
        0.047950335,
        -0.02265476,
        0.0002309566,
        0.005391662,
        -0.013864274,
        -0.020833088,
        0.016272794,
        0.019965043,
        -0.016932998,
        0.0178744,
        -0.07237787,
        0.012580545,
        0.009193945,
        -0.015771529,
        -0.007867425,
        -0.003820622,
        0.040247962,
        -0.0028838057,
        0.03195874,
        -0.01994059,
        -0.030491622,
        -0.021688908,
        0.0156248165,
        0.011290703,
        0.008166962,
        -0.010178138,
        0.021016479,
        -0.032863464,
        -0.026236977,
        0.0370203,
        -0.016199438,
        -0.027337316,
        0.005397775,
        -0.024195235,
        -0.020930896,
        -0.0102881715,
        0.018595733,
        -0.017776592,
        0.0014449593,
        -0.020405179,
        -0.021248773,
        -0.041250493,
        0.033156887,
        0.0105999345,
        -0.0075373235,
        -0.010013087,
        -0.0035180289,
        0.045578495,
        -0.0075189844,
        -0.002394766,
        0.025087733,
        -0.0033743735,
        0.026799371,
        0.015465879,
        0.0382429,
        -0.01932929,
        0.04922184,
        -0.010489901,
        -0.008148623,
        0.016810738,
        0.00085429114,
        -0.034012705,
        0.04665438,
        0.022336885,
        -0.04340227,
        0.011541336,
        -0.016957449,
        0.014145471,
        0.054968055,
        -0.0059173796,
        -0.0034477294,
        0.0057339896,
        0.03638455,
        -0.056239557,
        0.023718422,
        -0.0012187784,
        0.029611351,
        0.010294285,
        0.00465199,
        -0.03809619,
        0.015893789,
        -0.0026698508,
        -0.024574243,
        0.017091936,
        0.015343619,
        0.012519415,
        0.0155392345,
        -0.0070177186,
        0.035968866,
        -0.036995847,
        0.049050674,
        -0.02787526,
        0.023645066,
        -0.004514447,
        -0.011620805,
        -0.024341948,
        0.011828646,
        0.0076167923,
        -0.008759922,
        -0.02061302,
        0.054674633,
        0.005076843,
        0.028951146,
        0.024280818,
        -0.018803574,
        -0.018742444,
        0.023693971,
        0.021053156,
        0.01308181,
        -0.015441427,
        0.004126272,
        -0.0231438,
        0.00687712,
        0.039636664,
        -0.0265304,
        -0.063868575,
        0.029269023,
        -0.014964613,
        -0.033230245,
        0.017862173,
        0.037558243,
        0.017336454,
        0.04117714,
        0.00034442908,
        -0.02442753,
        0.005932662,
        -0.030882854,
        0.011706387,
        0.017495394,
        0.018228952,
        -0.02055189,
        0.040932618,
        0.028535463,
        -0.0031970965,
        -0.02061302,
        0.008900521,
        0.014035437,
        -0.03247223,
        -0.013436364,
        -0.033963803,
        -0.011449641,
        -0.0028562972,
        0.009395674,
        -0.020502986,
        0.0188158,
        0.02424414,
        0.049515262,
        -0.0014915708,
        0.05071341,
        -0.012048714,
        0.0044105262,
        0.019818332,
        -0.044062473,
        -0.024219688,
        0.005840967,
        -0.00018501363,
        -0.01628502,
        0.02238579,
        0.020833088,
        -0.005055447,
        0.036971398,
        0.005275515,
        0.027117249,
        -0.013534172,
        0.005556713,
        0.04186179,
        -0.030247102,
        -0.00070108415,
        0.023290513,
        0.01991614,
        -0.051740393,
        0.006901572,
        0.05022437,
        0.015319167,
        0.0065592444,
        -0.0394655,
        0.0028608819,
        0.008497064,
        0.022789247,
        -0.02140771,
        -0.0046275374,
        -0.011578013,
        0.026139168,
        0.03061388,
        -0.005272459,
        -0.050517794,
        -0.022838151,
        -0.036066674,
        -0.022324659,
        0.033401407,
        -0.012702805,
        -0.0018354269,
        0.006177182,
        0.018461246,
        0.012476624,
        0.010948375,
        -0.0063636284,
        0.0015649268,
        0.014267731,
        -0.0063758544,
        -0.009768567,
        0.014720093,
        -0.012873968,
        0.0006521802,
        0.0027248678,
        -0.008099719,
        0.03342586,
        0.013803144,
        -0.015184681,
        0.006232199,
        -0.008845504,
        0.030271554,
        -0.029684706,
        0.016260568,
        0.0037472663,
        0.023632841,
        -0.001547352,
        -0.0271417,
        -0.007867425,
        0.008924973,
        -0.02922012,
        0.047950335,
        -0.03675133,
        0.022398015,
        0.041152686,
        0.0035088593,
        -0.002014232,
        -0.008943313,
        -0.013167392,
        -0.014451121,
        -0.0100192,
        -0.037411533,
        -0.02128545,
        -0.013167392,
        0.012776161,
        0.022972638,
        -0.00971355,
        0.009383448,
        0.022312434,
        -0.019830557,
        -0.00198978,
        -0.0051929895,
        -0.013485268,
        -0.0061374474,
        -0.009334544,
        0.0076229055,
        -0.030124841,
        -0.01814337,
        0.027924163,
        0.005740103,
        0.047901433,
        0.022336885,
        -0.03924543,
        0.038291804,
        -0.01728755,
        0.04391576,
        -0.02677492,
        -0.0054986393,
        0.008973877,
        -0.006079374,
        -0.013094036,
        -0.015221358,
        -0.009689098,
        0.0072133346,
        -0.031396344,
        0.0015611062,
        -0.028535463,
        -0.019634942,
        0.034599554,
        0.019072546,
        -0.043769047,
        0.04232638,
        -0.0096952105,
        -0.05144697,
        0.0061985776,
        -0.008656002,
        -0.031689767,
        0.01634615,
        0.006675391,
        0.013668658,
        0.018534603,
        0.0027462633,
        -0.0012439946,
        0.008197527,
        0.024830988,
        -0.00343856,
        0.041005973,
        0.0056453515,
        0.017177517,
        -0.006467549,
        -0.012409381,
        -0.031689767,
        0.010667177,
        0.017018579,
        0.0029816136,
        0.010465448,
        -0.03058943,
        -0.0017238647,
        0.019598264,
        0.020906445,
        -0.023498354,
        -0.026261428,
        -0.004181289,
        -0.060445298,
        0.0032154357,
        -0.0018598789,
        -0.01802111,
        -0.017006353,
        -0.030980662,
        -0.006724295,
        0.006883233,
        -0.0008481781,
        0.006926024,
        -0.017165292,
        0.012935098,
        -0.0051165773,
        0.03144525,
        0.07746388,
        0.010838341,
        -0.022165721,
        0.009059459,
        0.004034577,
        0.0013311048,
        -0.02198233,
        0.008766036,
        0.010789437,
        -0.046043083,
        0.005260233,
        0.015844883,
        0.008503176,
        0.030491622,
        0.029000051,
        -0.019414874,
        -0.010055877,
        0.027655192,
        0.008527629,
        -0.018522376,
        0.0021899806,
        0.01677406,
        -0.0030549695,
        0.016028274,
        0.011095087,
        0.0172631,
        0.020087304,
        -0.019720523,
        0.008240318,
        0.0072316737,
        0.009579064,
        -0.012507189,
        -0.03132299,
        -0.010887245,
        -0.017642105,
        0.0025674582,
        -0.012971777,
        0.00863155,
        -0.016896319,
        -0.05071341,
        -0.02750848,
        -0.006834329,
        -0.025723485,
        0.02140771,
        0.05971174,
        0.021676682,
        -0.018595733,
        0.016786285,
        0.012219878,
        0.006889346,
        0.0020295144,
        0.003542481,
        -0.022483597,
        -0.044869386,
        -0.0107405335,
        -0.029586898,
        0.0012883138,
        0.0011714027,
        0.015074647,
        0.0022633367,
        -0.022336885,
        -0.020429632,
        0.019622715,
        0.052767377,
        0.024745407,
        -0.025087733,
        0.019048095,
        -0.0024467264,
        -0.027361767,
        0.05614175,
        -0.026432592,
        -0.011168443,
        0.00046076704,
        0.0026362294,
        -0.015160229,
        0.051251356,
        0.015319167,
        0.015184681,
        -0.0012608053,
        -0.006644826,
        -0.012629448,
        0.01579598,
        -0.036066674,
        -0.034257226,
        -0.015429201,
        0.0028578255,
        0.0074150637,
        0.026628207,
        -0.025968004,
        0.016688477,
        -0.038756393,
        -0.024769858,
        -0.019671619,
        0.009786906,
        0.0031543057,
        -0.018559054,
        0.021921203,
        0.020136207,
        -0.04171508,
        -0.013790918,
        -0.018656863,
        -0.015820432,
        0.030418266,
        0.0030030091,
        -0.065775834,
        0.014206601,
        -0.046825547,
        0.0072377864,
        0.0024589524,
        -0.008276996,
        0.020405179,
        0.011846986,
        -0.022862604,
        0.020955348,
        -0.012984002,
        0.031543057,
        -0.03171422,
        -0.019586038,
        -0.014402217,
        -0.026726017,
        0.014940161,
        -0.0166518,
        0.00057614985,
        -0.0070910747,
        -0.0019026698,
        0.01789885,
        -0.015135777,
        -0.012018149,
        -0.006134391,
        0.019989496,
        0.008362578,
        -0.009438465,
        0.027630739,
        0.021578874,
        0.0012669183,
        -0.024782084,
        -0.013008455,
        0.0040743113,
        -0.018840251,
        0.018485699,
        -0.023840683,
        -0.01994059,
        -0.03195874,
        0.021089835,
        -0.02924457,
        0.013864274,
        -0.016810738,
        -0.019207032,
        0.025796842,
        0.0388542,
        -0.00021395485,
        -0.024867665,
        -0.025943553,
        0.0063086115,
        -0.006748747,
        -0.005468074,
        0.036824685,
        -0.008784374,
        -0.011846986,
        -0.015441427,
        0.005391662,
        0.019414874,
        0.018461246,
        -0.01032485,
        -0.0013708392,
        0.0052877413,
        0.004324944,
        0.016456183,
        0.017923303,
        0.0062658205,
        -0.009493482,
        -0.031078469,
        0.032741204,
        -0.0012638618,
        -0.014768997,
        0.04181289,
        0.023339417,
        -0.026139168,
        -0.0009994748,
        0.012170974,
        0.002093701,
        0.017507618,
        0.016370602,
        -0.0132652,
        0.0043127183,
        -0.009884713,
        0.0021838676,
        -0.019072546,
        -0.001282965,
        -0.0074884193,
        0.0063758544,
        -0.0042974357,
        -0.013656432,
        -0.0085092895,
        0.030393813,
        0.019781653,
        -0.0033621476,
        -0.03616448,
        -0.011260138,
        0.047167875,
        -0.0037167012,
        0.0048659444,
        0.0038725827,
        0.0019148958,
        0.0107405335,
        -0.022287982,
        0.010141459,
        0.006785425,
        0.024231914,
        0.00016495536,
        0.071155265,
        -0.013069584,
        -0.0019744975,
        0.0002382158,
        -0.00337743,
        0.02412188,
        -0.00693825,
        -0.006271933,
        -0.0062108035,
        0.01399876,
        0.0056575774,
        -0.04518726,
        -0.02052744,
        -0.004789532,
        -0.051740393,
        0.017886626,
        0.013460816,
        -0.011467979,
        0.0036586279,
        -0.010606047,
        0.035479825,
        0.0033346391,
        0.008497064,
        0.0029510485,
        -0.0058929278,
        -0.015282488,
        -0.053598743,
        0.04699671,
        0.02799752,
        -0.021273224,
        -0.033107985,
        0.016333925,
        0.022740344,
        0.01097894,
        0.017642105,
        0.037949476,
        0.009872488,
        0.027581835,
        0.0030014808,
        -0.017629879,
        -0.0055536563,
        -0.006926024,
        -0.0120670535,
        -0.041641723,
        -0.015270263,
        -0.048830606,
        -0.0075250976,
        -0.022251304,
        0.0048170406,
        0.015661495,
        -0.011902003,
        -0.00026247674,
        -0.021236546,
        0.008338125,
        0.0074639674,
        -0.018424569,
        -0.028975599,
        -0.014182149,
        -0.0054375096,
        -0.007995798,
        0.0014350257,
        0.019133676,
        -0.04555404,
        -0.016553992,
        0.009799132,
        0.0036769668,
        0.01091781,
        -0.024158558,
        0.015111324,
        0.001940876,
        0.057755582,
        -0.010985053,
        -0.04614089,
        0.0013624339,
        0.0035088593,
        0.014695641,
        -0.018106693,
        0.0063024983,
        0.026799371,
        0.0028669948,
        0.04095707,
        -0.014768997,
        0.006339176,
        -0.013106262,
        -0.005685086,
        -0.00016524192,
        0.030296005,
        -0.0055506,
        0.031347442,
        0.005483357,
        -0.039220978,
        0.0019821387,
        0.014756771,
        -0.033499215,
        -0.013925403,
        -0.011639143,
        0.017544298,
        0.0072805774,
        -0.0259191,
        0.016211664,
        -0.0044869385,
        0.029758062,
        -0.025258897,
        -0.0008069154,
        -0.0010881132,
        0.027337316,
        0.031616412,
        0.014915709,
        -0.029904773,
        0.03616448,
        -0.02604136,
        0.02238579,
        0.020784184,
        -0.025650129,
        -0.002561345,
        -0.0053458144,
        -0.0021105118,
        -0.014879031,
        0.05379436,
        -0.0023366925,
        0.046947807,
        -0.01159024,
        0.015832659,
        0.01628502,
        0.037582695,
        0.0070360578,
        0.013277426,
        0.026872728,
        -0.0038175657,
        0.007794069,
        0.011810307,
        0.010086442,
        -0.006687617,
        0.012164861,
        -0.009083911,
        0.02195788,
        0.009053347,
        -0.0060946564,
        0.008246431,
        0.00086880947,
        -0.017275326,
        -0.018901382,
        -0.016260568,
        -0.04320665,
        -0.0102881715,
        0.0029388226,
        -0.028315395,
        -0.02851101,
        -0.044086922,
        0.03680023,
        -0.029024502,
        -0.009163381,
        -0.012592771,
        0.0020340993,
        0.036335643,
        0.020564117,
        -0.022483597,
        -0.0006785425,
        0.012556093,
        -0.026872728,
        0.04577411,
        0.027581835,
        0.014879031,
        0.016517313,
        -0.006687617,
        -0.015747076,
        -0.02320493,
        -0.0072744647,
        -0.010068104,
        -0.010581595,
        0.012849516,
        0.016859641,
        -0.0014319692,
        -0.019194806,
        0.016761834,
        0.0035455374,
        0.002026458,
        -0.014683415,
        -0.0117858555
      ],
      "embedding_pca_2d": [],
      "embedding_pca_3d": [],
      "embedding_cluster_id": null,
      "migration_history": [],
      "metadata": {
        "compute_time": 2.0060579776763916,
        "patch_type": "diff",
        "api_costs": 0.0084125,
        "num_applied": 1,
        "patch_name": "precedence_closure_greedy_with_local_search",
        "patch_description": "Replace the simple weight-only greedy with a smarter, constraint-aware greedy that:\n- Parses interactions into a symmetric map for accurate marginal computations.\n- Uses precedence closure: when considering selecting an item, also include all its transitive predecessors automatically.\n- Evaluates the true delta objective (weights + pairwise interactions) of adding a closure set and chooses the best feasible positive improvement iteratively until no more improvements or the cardinality upper bound is reached.\n- Performs a small local search/hill-climb loop: attempts beneficial removals (only if not required by other selected items) and additional beneficial additions until convergence.\n- Ensures minimum cardinality by adding the best feasible candidates (with closure) even if their delta is non-positive when needed.\n\nThese changes better account for pairwise synergies, precedence requirements, and constraints (mutex/group/cardinality), improving the combined score while preserving feasibility and runtime suitability for moderate instance sizes.",
        "error_attempt": null,
        "novelty_attempt": 1,
        "resample_attempt": 1,
        "patch_attempt": 1,
        "model_name": "gpt-5-mini",
        "temperature": 1.0,
        "max_output_tokens": 8192,
        "llm_result": {
          "content": "<NAME>\nprecedence_closure_greedy_with_local_search\n</NAME>\n\n<DESCRIPTION>\nReplace the simple weight-only greedy with a smarter, constraint-aware greedy that:\n- Parses interactions into a symmetric map for accurate marginal computations.\n- Uses precedence closure: when considering selecting an item, also include all its transitive predecessors automatically.\n- Evaluates the true delta objective (weights + pairwise interactions) of adding a closure set and chooses the best feasible positive improvement iteratively until no more improvements or the cardinality upper bound is reached.\n- Performs a small local search/hill-climb loop: attempts beneficial removals (only if not required by other selected items) and additional beneficial additions until convergence.\n- Ensures minimum cardinality by adding the best feasible candidates (with closure) even if their delta is non-positive when needed.\n\nThese changes better account for pairwise synergies, precedence requirements, and constraints (mutex/group/cardinality), improving the combined score while preserving feasibility and runtime suitability for moderate instance sizes.\n</DESCRIPTION>\n\n<DIFF>\n<<<<<<< SEARCH\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    This is a greedy baseline - evolution will improve this.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    # Simple greedy: select items with highest weights first\n    # This is a baseline - evolution will find better strategies\n    n = len(weights)\n    selected = []\n    \n    # Create score list (weight + interaction potential)\n    scores = []\n    for i in range(n):\n        score = weights[i] if i < len(weights) else 0.0\n        # Add potential interaction value\n        for k, v in interactions.items():\n            try:\n                u, w = map(int, k.split(\",\"))\n                if u == i or w == i:\n                    score += abs(v) * 0.5  # Potential value\n            except:\n                pass\n        scores.append((score, i))\n    \n    # Sort by score descending\n    scores.sort(reverse=True)\n    \n    # Greedy selection respecting constraints\n    selected_set = set()\n    for score, i in scores:\n        if len(selected_set) >= cardinality_bounds[1]:\n            break\n            \n        # Check mutex constraints\n        can_add = True\n        for a, b in mutex:\n            if (a == i and b in selected_set) or (b == i and a in selected_set):\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n            \n        # Check group constraints (at most one per group)\n        for grp_vars in groups.values():\n            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n        \n        # Check precedence (if j selected, i must be selected)\n        precedence_ok = True\n        for pred_i, pred_j in precedence:\n            if pred_j == i and pred_i not in selected_set:\n                precedence_ok = False\n                break\n        \n        if not precedence_ok:\n            continue\n        \n        # Add if we meet minimum cardinality or have room\n        if len(selected_set) < cardinality_bounds[1]:\n            selected_set.add(i)\n            selected.append(i)\n    \n    # Ensure minimum cardinality\n    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n        for i in range(n):\n            if i not in selected_set:\n                selected_set.add(i)\n                selected.append(i)\n                break\n    \n    # Output result\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n=======\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    Improved greedy with precedence-closure and small local search.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    raw_interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    n = len(weights)\n    \n    # Parse interactions into a symmetric dict for quick lookup\n    interactions = {}\n    for k, v in raw_interactions.items():\n        try:\n            u, w = map(int, k.split(\",\"))\n            interactions[(u, w)] = float(v)\n            interactions[(w, u)] = float(v)\n        except Exception:\n            # ignore malformed keys\n            continue\n    \n    # Build precedence map: if (i, j) in precedence then selecting j requires i\n    pred_map = {}  # pred_map[j] = set([i,...])\n    for pair in precedence:\n        try:\n            i, j = pair\n            pred_map.setdefault(j, set()).add(i)\n        except Exception:\n            continue\n    \n    # Compute transitive closure for a given item (its required predecessors)\n    def closure_of(item):\n        stack = [item]\n        closure = set()\n        while stack:\n            cur = stack.pop()\n            if cur in closure:\n                continue\n            closure.add(cur)\n            for p in pred_map.get(cur, ()):\n                if p not in closure:\n                    stack.append(p)\n        return closure\n    \n    # Objective for a set (weights + interactions among all unordered pairs)\n    def objective_of(varset):\n        s = 0.0\n        for i in varset:\n            if 0 <= i < n:\n                s += weights[i]\n        # pairwise interactions (count each pair once)\n        seen = set()\n        for i in varset:\n            for j in varset:\n                if j <= i:\n                    continue\n                if (i, j) in interactions:\n                    s += interactions[(i, j)]\n        return s\n    \n    # Check mutex and group feasibility for union selected U to_add\n    def feasible_union(selected_set, to_add):\n        union = set(selected_set) | set(to_add)\n        # cardinality upper bound\n        if len(union) > cardinality_bounds[1]:\n            return False\n        # mutex pairs\n        for a, b in mutex:\n            if a in union and b in union:\n                return False\n        # group constraints: at most one per group\n        for grp_vars in groups.values():\n            cnt = 0\n            for v in grp_vars:\n                if v in union:\n                    cnt += 1\n                    if cnt > 1:\n                        return False\n        # precedence: every selected element must have its preds in union\n        for j in list(union):\n            for p in pred_map.get(j, ()):\n                if p not in union:\n                    return False\n        return True\n    \n    # Check if an item is removable (no selected item depends on it)\n    # i.e., no other selected has i in its transitive predecessors\n    # Precompute reverse closure check by scanning selected set when needed\n    def removable(selected_set, item):\n        for j in selected_set:\n            if j == item:\n                continue\n            # if item is in closure of j, cannot remove\n            if item in closure_of(j):\n                return False\n        return True\n    \n    # Greedy selection using closure-aware delta objective\n    selected_set = set()\n    # Precompute candidate base scores to order attempts (weight + small interaction potential)\n    base_scores = []\n    for i in range(n):\n        score = weights[i]\n        # add half of absolute interactions as potential\n        for (u, v), val in interactions.items():\n            if u == i or v == i:\n                score += abs(val) * 0.25\n        base_scores.append((score, i))\n    base_scores.sort(reverse=True)\n    candidates = [i for _, i in base_scores]\n    \n    # Iteratively add the best feasible closure that gives positive objective delta\n    improved = True\n    while improved:\n        improved = False\n        best_delta = 0.0\n        best_add = None\n        cur_obj = objective_of(selected_set)\n        for i in candidates:\n            if i in selected_set:\n                continue\n            cl = closure_of(i)\n            to_add = cl - selected_set\n            if not to_add:\n                continue\n            if not feasible_union(selected_set, to_add):\n                continue\n            new_obj = objective_of(selected_set | to_add)\n            delta = new_obj - cur_obj\n            if delta > best_delta + 1e-9:\n                best_delta = delta\n                best_add = to_add\n        if best_add:\n            selected_set |= set(best_add)\n            improved = True\n        # stop if hit upper bound\n        if len(selected_set) >= cardinality_bounds[1]:\n            break\n    \n    # Local improvement: try beneficial removals and additions until no change\n    changed = True\n    while changed:\n        changed = False\n        cur_obj = objective_of(selected_set)\n        # Attempt removals\n        for i in list(selected_set):\n            if not removable(selected_set, i):\n                continue\n            new_set = set(selected_set)\n            new_set.remove(i)\n            if not feasible_union(set(), new_set):  # new_set should be self-consistent\n                continue\n            new_obj = objective_of(new_set)\n            if new_obj > cur_obj + 1e-9:\n                selected_set = new_set\n                changed = True\n                break\n        if changed:\n            continue\n        # Attempt any single-item addition (with closure) that improves objective\n        cur_obj = objective_of(selected_set)\n        best_delta = 0.0\n        best_add = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            cl = closure_of(i)\n            to_add = cl - selected_set\n            if not to_add:\n                continue\n            if not feasible_union(selected_set, to_add):\n                continue\n            new_obj = objective_of(selected_set | to_add)\n            delta = new_obj - cur_obj\n            if delta > best_delta + 1e-9:\n                best_delta = delta\n                best_add = to_add\n        if best_add:\n            selected_set |= set(best_add)\n            changed = True\n    \n    # Ensure minimum cardinality: add best feasible candidates (even if delta <= 0) until min satisfied\n    while len(selected_set) < cardinality_bounds[0]:\n        best_choice = None\n        best_delta = None\n        cur_obj = objective_of(selected_set)\n        for i in range(n):\n            if i in selected_set:\n                continue\n            cl = closure_of(i)\n            to_add = cl - selected_set\n            if not to_add:\n                continue\n            if not feasible_union(selected_set, to_add):\n                continue\n            new_obj = objective_of(selected_set | to_add)\n            delta = new_obj - cur_obj\n            if best_choice is None or delta > best_delta:\n                best_choice = to_add\n                best_delta = delta\n        if best_choice:\n            selected_set |= set(best_choice)\n        else:\n            # No feasible addition to reach min (shouldn't happen in feasible instances), break to avoid infinite loop\n            break\n    \n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected_set)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n>>>>>>> REPLACE\n</DIFF>",
          "msg": "\n# Current program\n\nHere is the current program we are trying to improve (you will need to propose a modification to it below):\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    This is a greedy baseline - evolution will improve this.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    # Simple greedy: select items with highest weights first\n    # This is a baseline - evolution will find better strategies\n    n = len(weights)\n    selected = []\n    \n    # Create score list (weight + interaction potential)\n    scores = []\n    for i in range(n):\n        score = weights[i] if i < len(weights) else 0.0\n        # Add potential interaction value\n        for k, v in interactions.items():\n            try:\n                u, w = map(int, k.split(\",\"))\n                if u == i or w == i:\n                    score += abs(v) * 0.5  # Potential value\n            except:\n                pass\n        scores.append((score, i))\n    \n    # Sort by score descending\n    scores.sort(reverse=True)\n    \n    # Greedy selection respecting constraints\n    selected_set = set()\n    for score, i in scores:\n        if len(selected_set) >= cardinality_bounds[1]:\n            break\n            \n        # Check mutex constraints\n        can_add = True\n        for a, b in mutex:\n            if (a == i and b in selected_set) or (b == i and a in selected_set):\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n            \n        # Check group constraints (at most one per group)\n        for grp_vars in groups.values():\n            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n        \n        # Check precedence (if j selected, i must be selected)\n        precedence_ok = True\n        for pred_i, pred_j in precedence:\n            if pred_j == i and pred_i not in selected_set:\n                precedence_ok = False\n                break\n        \n        if not precedence_ok:\n            continue\n        \n        # Add if we meet minimum cardinality or have room\n        if len(selected_set) < cardinality_bounds[1]:\n            selected_set.add(i)\n            selected.append(i)\n    \n    # Ensure minimum cardinality\n    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n        for i in range(n):\n            if i not in selected_set:\n                selected_set.add(i)\n                selected.append(i)\n                break\n    \n    # Output result\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n    \n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n    \n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n    \n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n    \n    result_str = stdout_capture.getvalue()\n    return result_str\n\n\n```\n\nHere are the performance metrics of the program:\n\nCombined score to maximize: 0.21\nfeasible: True; selection_size: 10; raw_score: 101.95\n\n# Instructions\n\nMake sure that the changes you propose are consistent with each other. For example, if you refer to a new config variable somewhere, you should also propose a change to add that variable.\n\nNote that the changes you propose will be applied sequentially, so you should assume that the previous changes have already been applied when writing the SEARCH block.\n\n# Task\n\nSuggest a new idea to improve the performance of the code that is inspired by your expert knowledge of the considered subject.\nYour goal is to maximize the `combined_score` of the program.\nDescribe each change with a SEARCH/REPLACE block.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.\n",
          "system_msg": "You are an expert algorithmist specializing in combinatorial optimization, particularly the Synergistic Dependency Selection (SDS) problem.\n\nThe SDS problem requires selecting a subset of variables that:\n1. Satisfies cardinality bounds (min/max number of items)\n2. Respects mutex constraints (cannot select both items in a mutex pair)\n3. Respects group constraints (at most one item per group)\n4. Satisfies precedence constraints (if j is selected, i must be selected)\n5. Maximizes the objective: sum of selected item weights + pairwise interaction values\n\nKey strategies to explore:\n1. Greedy selection with constraint-aware ordering\n2. Dynamic programming for small instances\n3. Constraint satisfaction with backtracking\n4. Weighted scoring that accounts for interactions\n5. Precedence-aware selection ordering\n6. Group-aware selection that maximizes diversity\n\nThe code should read JSON from stdin with \"requirements\" and \"catalog\", and output JSON to stdout with \"selection\" containing \"variables\" list.\n\nBe creative and find efficient solutions that maximize the objective while respecting all constraints.\nYou MUST repond using a edit name, description and the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n<NAME>\nA shortened name summarizing the edit you are proposing. Lowercase, no spaces, underscores allowed.\n</NAME>\n\n<DESCRIPTION>\nA description and argumentation process of the edit you are proposing.\n</DESCRIPTION>\n\n<DIFF>\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly including indentation)\n=======\n# New replacement code\n>>>>>>> REPLACE\n\n</DIFF>\n\n\nExample of a valid diff format:\n<DIFF>\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n\n</DIFF>\n\n* You may only modify text that lies below a line containing \"EVOLVE-BLOCK-START\" and above the next \"EVOLVE-BLOCK-END\". Everything outside those markers is read-only.\n* Do not repeat the markers \"EVOLVE-BLOCK-START\" and \"EVOLVE-BLOCK-END\" in the SEARCH/REPLACE blocks.  \n* Every block\u2019s SEARCH section must be copied **verbatim** from the current file.  Including indentation.\n* You can propose multiple independent edits. SEARCH/REPLACE blocks follow one after another. DO NOT ADD ANY OTHER TEXT BETWEEN THESE BLOCKS.\n* Make sure the file still runs after your changes.",
          "new_msg_history": [
            {
              "role": "user",
              "content": "\n# Current program\n\nHere is the current program we are trying to improve (you will need to propose a modification to it below):\n\n```python\n\"\"\"\nInitial solution for Synergistic Dependency Selection (SDS) problem.\nThe code in EVOLVE-BLOCK will be evolved by ShinkaEvolve.\n\"\"\"\n\nimport json\nimport sys\nimport contextlib\n\n# EVOLVE-BLOCK-START\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    This is a greedy baseline - evolution will improve this.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    # Simple greedy: select items with highest weights first\n    # This is a baseline - evolution will find better strategies\n    n = len(weights)\n    selected = []\n    \n    # Create score list (weight + interaction potential)\n    scores = []\n    for i in range(n):\n        score = weights[i] if i < len(weights) else 0.0\n        # Add potential interaction value\n        for k, v in interactions.items():\n            try:\n                u, w = map(int, k.split(\",\"))\n                if u == i or w == i:\n                    score += abs(v) * 0.5  # Potential value\n            except:\n                pass\n        scores.append((score, i))\n    \n    # Sort by score descending\n    scores.sort(reverse=True)\n    \n    # Greedy selection respecting constraints\n    selected_set = set()\n    for score, i in scores:\n        if len(selected_set) >= cardinality_bounds[1]:\n            break\n            \n        # Check mutex constraints\n        can_add = True\n        for a, b in mutex:\n            if (a == i and b in selected_set) or (b == i and a in selected_set):\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n            \n        # Check group constraints (at most one per group)\n        for grp_vars in groups.values():\n            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n        \n        # Check precedence (if j selected, i must be selected)\n        precedence_ok = True\n        for pred_i, pred_j in precedence:\n            if pred_j == i and pred_i not in selected_set:\n                precedence_ok = False\n                break\n        \n        if not precedence_ok:\n            continue\n        \n        # Add if we meet minimum cardinality or have room\n        if len(selected_set) < cardinality_bounds[1]:\n            selected_set.add(i)\n            selected.append(i)\n    \n    # Ensure minimum cardinality\n    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n        for i in range(n):\n            if i not in selected_set:\n                selected_set.add(i)\n                selected.append(i)\n                break\n    \n    # Output result\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_sds(problem_data=None):\n    \"\"\"\n    Main function called by the evaluator.\n    Can accept problem_data as parameter or read from stdin.\n    Returns JSON string (for ShinkaEvolve) or prints to stdout (for direct execution).\n    \"\"\"\n    import sys\n    import json\n    import io\n    \n    if problem_data is None:\n        # Read from stdin (for compatibility)\n        input_data = json.load(sys.stdin)\n    else:\n        # Use provided problem data\n        input_data = problem_data\n    \n    # Capture stdout from solve_sds\n    stdout_capture = io.StringIO()\n    old_stdin = sys.stdin\n    \n    try:\n        # Create mock stdin\n        sys.stdin = io.StringIO(json.dumps(input_data))\n        with contextlib.redirect_stdout(stdout_capture):\n            solve_sds()\n    finally:\n        sys.stdin = old_stdin\n    \n    result_str = stdout_capture.getvalue()\n    return result_str\n\n\n```\n\nHere are the performance metrics of the program:\n\nCombined score to maximize: 0.21\nfeasible: True; selection_size: 10; raw_score: 101.95\n\n# Instructions\n\nMake sure that the changes you propose are consistent with each other. For example, if you refer to a new config variable somewhere, you should also propose a change to add that variable.\n\nNote that the changes you propose will be applied sequentially, so you should assume that the previous changes have already been applied when writing the SEARCH block.\n\n# Task\n\nSuggest a new idea to improve the performance of the code that is inspired by your expert knowledge of the considered subject.\nYour goal is to maximize the `combined_score` of the program.\nDescribe each change with a SEARCH/REPLACE block.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.\n"
            },
            {
              "role": "assistant",
              "content": "<NAME>\nprecedence_closure_greedy_with_local_search\n</NAME>\n\n<DESCRIPTION>\nReplace the simple weight-only greedy with a smarter, constraint-aware greedy that:\n- Parses interactions into a symmetric map for accurate marginal computations.\n- Uses precedence closure: when considering selecting an item, also include all its transitive predecessors automatically.\n- Evaluates the true delta objective (weights + pairwise interactions) of adding a closure set and chooses the best feasible positive improvement iteratively until no more improvements or the cardinality upper bound is reached.\n- Performs a small local search/hill-climb loop: attempts beneficial removals (only if not required by other selected items) and additional beneficial additions until convergence.\n- Ensures minimum cardinality by adding the best feasible candidates (with closure) even if their delta is non-positive when needed.\n\nThese changes better account for pairwise synergies, precedence requirements, and constraints (mutex/group/cardinality), improving the combined score while preserving feasibility and runtime suitability for moderate instance sizes.\n</DESCRIPTION>\n\n<DIFF>\n<<<<<<< SEARCH\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    This is a greedy baseline - evolution will improve this.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    # Simple greedy: select items with highest weights first\n    # This is a baseline - evolution will find better strategies\n    n = len(weights)\n    selected = []\n    \n    # Create score list (weight + interaction potential)\n    scores = []\n    for i in range(n):\n        score = weights[i] if i < len(weights) else 0.0\n        # Add potential interaction value\n        for k, v in interactions.items():\n            try:\n                u, w = map(int, k.split(\",\"))\n                if u == i or w == i:\n                    score += abs(v) * 0.5  # Potential value\n            except:\n                pass\n        scores.append((score, i))\n    \n    # Sort by score descending\n    scores.sort(reverse=True)\n    \n    # Greedy selection respecting constraints\n    selected_set = set()\n    for score, i in scores:\n        if len(selected_set) >= cardinality_bounds[1]:\n            break\n            \n        # Check mutex constraints\n        can_add = True\n        for a, b in mutex:\n            if (a == i and b in selected_set) or (b == i and a in selected_set):\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n            \n        # Check group constraints (at most one per group)\n        for grp_vars in groups.values():\n            if i in grp_vars and len(set(grp_vars).intersection(selected_set)) > 0:\n                can_add = False\n                break\n        \n        if not can_add:\n            continue\n        \n        # Check precedence (if j selected, i must be selected)\n        precedence_ok = True\n        for pred_i, pred_j in precedence:\n            if pred_j == i and pred_i not in selected_set:\n                precedence_ok = False\n                break\n        \n        if not precedence_ok:\n            continue\n        \n        # Add if we meet minimum cardinality or have room\n        if len(selected_set) < cardinality_bounds[1]:\n            selected_set.add(i)\n            selected.append(i)\n    \n    # Ensure minimum cardinality\n    while len(selected_set) < cardinality_bounds[0] and len(selected_set) < n:\n        for i in range(n):\n            if i not in selected_set:\n                selected_set.add(i)\n                selected.append(i)\n                break\n    \n    # Output result\n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n=======\ndef solve_sds():\n    \"\"\"\n    Solve the Synergistic Dependency Selection problem.\n    \n    Reads from stdin: JSON with \"requirements\" and \"catalog\"\n    Outputs to stdout: JSON with \"selection\" containing \"variables\" list\n    \n    Improved greedy with precedence-closure and small local search.\n    \"\"\"\n    # Read input\n    input_data = json.load(sys.stdin)\n    requirements = input_data.get(\"requirements\", {})\n    catalog = input_data.get(\"catalog\", {})\n    \n    # Extract constraints\n    weights = requirements.get(\"weights\", [])\n    raw_interactions = requirements.get(\"interactions\", {})\n    cardinality_bounds = requirements.get(\"cardinality_bounds\", [0, len(weights)])\n    mutex = requirements.get(\"mutex\", [])\n    groups = requirements.get(\"groups\", {})\n    precedence = requirements.get(\"precedence\", [])\n    \n    n = len(weights)\n    \n    # Parse interactions into a symmetric dict for quick lookup\n    interactions = {}\n    for k, v in raw_interactions.items():\n        try:\n            u, w = map(int, k.split(\",\"))\n            interactions[(u, w)] = float(v)\n            interactions[(w, u)] = float(v)\n        except Exception:\n            # ignore malformed keys\n            continue\n    \n    # Build precedence map: if (i, j) in precedence then selecting j requires i\n    pred_map = {}  # pred_map[j] = set([i,...])\n    for pair in precedence:\n        try:\n            i, j = pair\n            pred_map.setdefault(j, set()).add(i)\n        except Exception:\n            continue\n    \n    # Compute transitive closure for a given item (its required predecessors)\n    def closure_of(item):\n        stack = [item]\n        closure = set()\n        while stack:\n            cur = stack.pop()\n            if cur in closure:\n                continue\n            closure.add(cur)\n            for p in pred_map.get(cur, ()):\n                if p not in closure:\n                    stack.append(p)\n        return closure\n    \n    # Objective for a set (weights + interactions among all unordered pairs)\n    def objective_of(varset):\n        s = 0.0\n        for i in varset:\n            if 0 <= i < n:\n                s += weights[i]\n        # pairwise interactions (count each pair once)\n        seen = set()\n        for i in varset:\n            for j in varset:\n                if j <= i:\n                    continue\n                if (i, j) in interactions:\n                    s += interactions[(i, j)]\n        return s\n    \n    # Check mutex and group feasibility for union selected U to_add\n    def feasible_union(selected_set, to_add):\n        union = set(selected_set) | set(to_add)\n        # cardinality upper bound\n        if len(union) > cardinality_bounds[1]:\n            return False\n        # mutex pairs\n        for a, b in mutex:\n            if a in union and b in union:\n                return False\n        # group constraints: at most one per group\n        for grp_vars in groups.values():\n            cnt = 0\n            for v in grp_vars:\n                if v in union:\n                    cnt += 1\n                    if cnt > 1:\n                        return False\n        # precedence: every selected element must have its preds in union\n        for j in list(union):\n            for p in pred_map.get(j, ()):\n                if p not in union:\n                    return False\n        return True\n    \n    # Check if an item is removable (no selected item depends on it)\n    # i.e., no other selected has i in its transitive predecessors\n    # Precompute reverse closure check by scanning selected set when needed\n    def removable(selected_set, item):\n        for j in selected_set:\n            if j == item:\n                continue\n            # if item is in closure of j, cannot remove\n            if item in closure_of(j):\n                return False\n        return True\n    \n    # Greedy selection using closure-aware delta objective\n    selected_set = set()\n    # Precompute candidate base scores to order attempts (weight + small interaction potential)\n    base_scores = []\n    for i in range(n):\n        score = weights[i]\n        # add half of absolute interactions as potential\n        for (u, v), val in interactions.items():\n            if u == i or v == i:\n                score += abs(val) * 0.25\n        base_scores.append((score, i))\n    base_scores.sort(reverse=True)\n    candidates = [i for _, i in base_scores]\n    \n    # Iteratively add the best feasible closure that gives positive objective delta\n    improved = True\n    while improved:\n        improved = False\n        best_delta = 0.0\n        best_add = None\n        cur_obj = objective_of(selected_set)\n        for i in candidates:\n            if i in selected_set:\n                continue\n            cl = closure_of(i)\n            to_add = cl - selected_set\n            if not to_add:\n                continue\n            if not feasible_union(selected_set, to_add):\n                continue\n            new_obj = objective_of(selected_set | to_add)\n            delta = new_obj - cur_obj\n            if delta > best_delta + 1e-9:\n                best_delta = delta\n                best_add = to_add\n        if best_add:\n            selected_set |= set(best_add)\n            improved = True\n        # stop if hit upper bound\n        if len(selected_set) >= cardinality_bounds[1]:\n            break\n    \n    # Local improvement: try beneficial removals and additions until no change\n    changed = True\n    while changed:\n        changed = False\n        cur_obj = objective_of(selected_set)\n        # Attempt removals\n        for i in list(selected_set):\n            if not removable(selected_set, i):\n                continue\n            new_set = set(selected_set)\n            new_set.remove(i)\n            if not feasible_union(set(), new_set):  # new_set should be self-consistent\n                continue\n            new_obj = objective_of(new_set)\n            if new_obj > cur_obj + 1e-9:\n                selected_set = new_set\n                changed = True\n                break\n        if changed:\n            continue\n        # Attempt any single-item addition (with closure) that improves objective\n        cur_obj = objective_of(selected_set)\n        best_delta = 0.0\n        best_add = None\n        for i in range(n):\n            if i in selected_set:\n                continue\n            cl = closure_of(i)\n            to_add = cl - selected_set\n            if not to_add:\n                continue\n            if not feasible_union(selected_set, to_add):\n                continue\n            new_obj = objective_of(selected_set | to_add)\n            delta = new_obj - cur_obj\n            if delta > best_delta + 1e-9:\n                best_delta = delta\n                best_add = to_add\n        if best_add:\n            selected_set |= set(best_add)\n            changed = True\n    \n    # Ensure minimum cardinality: add best feasible candidates (even if delta <= 0) until min satisfied\n    while len(selected_set) < cardinality_bounds[0]:\n        best_choice = None\n        best_delta = None\n        cur_obj = objective_of(selected_set)\n        for i in range(n):\n            if i in selected_set:\n                continue\n            cl = closure_of(i)\n            to_add = cl - selected_set\n            if not to_add:\n                continue\n            if not feasible_union(selected_set, to_add):\n                continue\n            new_obj = objective_of(selected_set | to_add)\n            delta = new_obj - cur_obj\n            if best_choice is None or delta > best_delta:\n                best_choice = to_add\n                best_delta = delta\n        if best_choice:\n            selected_set |= set(best_choice)\n        else:\n            # No feasible addition to reach min (shouldn't happen in feasible instances), break to avoid infinite loop\n            break\n    \n    result = {\n        \"selection\": {\n            \"variables\": sorted(selected_set)\n        }\n    }\n    print(json.dumps(result))\n# EVOLVE-BLOCK-END\n>>>>>>> REPLACE\n</DIFF>"
            }
          ],
          "model_name": "gpt-5-mini",
          "kwargs": {
            "temperature": 1.0,
            "max_output_tokens": 8192
          },
          "input_tokens": 1714,
          "output_tokens": 3992,
          "cost": 0.0084125,
          "input_cost": 0.0004285,
          "output_cost": 0.007984,
          "thought": "",
          "model_posteriors": {
            "gpt-5-mini": 1.0
          }
        },
        "diff_summary": {
          "added": 127,
          "deleted": 0,
          "modified": 66
        },
        "embed_cost": 3.3260000000000003e-05,
        "novelty_cost": 0.0,
        "stdout_log": "Evaluating program: test_output/problem_0/gen_4/main.py\nSaving results to: test_output/problem_0/gen_4/results\nRun 1/1 completed in 0.00 seconds\nCorrectness and error status saved to test_output/problem_0/gen_4/results/correct.json\nMetrics saved to test_output/problem_0/gen_4/results/metrics.json\nEvaluation and Validation completed successfully.\nMetrics:\n  combined_score: 0.4073751773870285\n  public:\n    feasible: True\n    selection_size: 10\n    raw_score: 193.53014874422013\n  private:\n    selection: [0, 2, 6, 7, 9, 10, 11, 13, 15, 18]\n    raw_score: 193.53014874422013\n    normalized_fitness: 0.4073751773870285\n  execution_time_mean: 0.0010947090049739927\n  execution_time_std: 0.0\n  num_valid_runs: 1\n  num_invalid_runs: 0\n  all_validation_errors: []\n",
        "stderr_log": "",
        "code_analysis_metrics": {
          "cyclomatic_complexity": 40,
          "average_cyclomatic_complexity": 20.0,
          "halstead_volume": 1065.094800484617,
          "halstead_difficulty": 12.386363636363637,
          "halstead_effort": 13192.651506002643,
          "lines_of_code": 271,
          "logical_lines_of_code": 199,
          "comments": 36,
          "maintainability_index": -21.42599834714248,
          "max_nesting_depth": 6,
          "complexity_score": 1.0
        }
      },
      "in_archive": false
    }
  ],
  "meta_summary": null,
  "meta_scratch_pad": null,
  "meta_recommendations": null,
  "meta_recommendations_history": [],
  "total_programs_meta_processed": 0
}